{"version":3,"file":"144.0.36.1.1695910659174.js","mappings":"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","sources":["webpack:///../../node_modules/buffer/index.js"],"sourcesContent":["/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n"],"names":["base64","ieee754","customInspectSymbol","Symbol","exports","Buffer","SlowBuffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","kMaxLength","TYPED_ARRAY_SUPPORT","typedArraySupport","console","error","arr","Uint8Array","proto","foo","Object","setPrototypeOf","prototype","e","defineProperty","enumerable","get","isBuffer","this","undefined","buffer","byteOffset","createBuffer","length","RangeError","buf","arg","encodingOrOffset","TypeError","allocUnsafe","from","poolSize","value","fromString","ArrayBuffer","isView","fromArrayView","isInstance","fromArrayBuffer","SharedArrayBuffer","valueOf","b","fromObject","toPrimitive","assertSize","size","alloc","fill","encoding","checked","allocUnsafeSlow","string","isEncoding","byteLength","actual","write","slice","fromArrayLike","array","i","arrayView","copy","obj","len","numberIsNaN","type","Array","isArray","data","toString","_isBuffer","compare","a","offset","x","y","Math","min","String","toLowerCase","concat","list","pos","set","call","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","m","swap16","swap32","swap64","apply","toLocaleString","equals","inspect","str","max","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","indexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","includes","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","isFinite","Error","toJSON","_arr","fromByteArray","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","push","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","fromCharCode","ret","out","hexSliceLookupTable","bytes","newBuf","subarray","checkOffset","ext","readUintLE","readUIntLE","noAssert","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","BigInt","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","checkInt","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","checkIEEE754","writeFloat","littleEndian","writeFloatLE","writeFloatBE","writeDouble","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","code","charCodeAt","errors","E","sym","getMessage","Base","NodeError","constructor","super","writable","configurable","name","stack","message","range","input","msg","received","isInteger","abs","addNumericalSeparator","checkBounds","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","INVALID_BASE64_RE","base64clean","split","units","Infinity","leadSurrogate","byteArray","c","toByteArray","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined"],"sourceRoot":""}