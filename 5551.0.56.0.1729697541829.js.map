{"version":3,"file":"5551.0.56.0.1729697541829.js","mappings":"qRAAA,0tC","sources":["webpack:///../../libs/remix-ws-templates/src/templates/rln/circuits/utils.circom"],"sourcesContent":["export default \"pragma circom 2.1.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\ninclude \\\"circomlib/circuits/mux1.circom\\\";\\ninclude \\\"circomlib/circuits/bitify.circom\\\";\\ninclude \\\"circomlib/circuits/comparators.circom\\\";\\n\\ntemplate MerkleTreeInclusionProof(DEPTH) {\\n    signal input leaf;\\n    signal input pathIndex[DEPTH];\\n    signal input pathElements[DEPTH];\\n\\n    signal output root;\\n\\n    signal mux[DEPTH][2];\\n    signal levelHashes[DEPTH + 1];\\n    \\n    levelHashes[0] <== leaf;\\n    for (var i = 0; i < DEPTH; i++) {\\n        pathIndex[i] * (pathIndex[i] - 1) === 0;\\n\\n        mux[i] <== MultiMux1(2)(\\n            [\\n                [levelHashes[i], pathElements[i]], \\n                [pathElements[i], levelHashes[i]]\\n            ], \\n            pathIndex[i]\\n        );\\n\\n        levelHashes[i + 1] <== Poseidon(2)([mux[i][0], mux[i][1]]);\\n    }\\n\\n    root <== levelHashes[DEPTH];\\n}\\n\\ntemplate RangeCheck(LIMIT_BIT_SIZE) {\\n    assert(LIMIT_BIT_SIZE < 253);\\n\\n    signal input messageId;\\n    signal input limit;\\n\\n    signal bitCheck[LIMIT_BIT_SIZE] <== Num2Bits(LIMIT_BIT_SIZE)(messageId);\\n    signal rangeCheck <== LessThan(LIMIT_BIT_SIZE)([messageId, limit]);\\n    rangeCheck === 1;\\n}\";"],"names":[],"sourceRoot":""}