"use strict";(self["webpackChunk"]=self["webpackChunk"]||[]).push([[2933],{62933:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__);__webpack_require__.d(__webpack_exports__,{default:()=>__WEBPACK_DEFAULT_EXPORT__});const __WEBPACK_DEFAULT_EXPORT__="/*\n    This file is part of web3.js.\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.d.ts\n * @author Josh Stevens <joshstevens19@hotmail.co.uk>\n * @author Prince Sinha <sinhaprince013@gmail.com>\n * @date 2018\n */\n\nimport * as net from 'net';\nimport {\n    HttpProviderBase,\n    HttpProviderOptions,\n    IpcProviderBase,\n    WebsocketProviderBase,\n    WebsocketProviderOptions,\n    JsonRpcPayload,\n    JsonRpcResponse\n} from 'web3-core-helpers';\nimport { Method } from 'web3-core-method';\nimport BN = require('bn.js');\nimport BigNumber from 'bignumber.js';\n\nexport interface SignedTransaction {\n    messageHash?: string;\n    r: string;\n    s: string;\n    v: string;\n    rawTransaction?: string;\n    transactionHash?: string;\n}\n\nexport interface Extension {\n    property?: string,\n    methods: Method[]\n}\n\nexport interface Providers {\n    HttpProvider: new (\n        host: string,\n        options?: HttpProviderOptions\n    ) => HttpProvider;\n    WebsocketProvider: new (\n        host: string,\n        options?: WebsocketProviderOptions\n    ) => WebsocketProvider;\n    IpcProvider: new (path: string, net: any) => IpcProvider;\n}\n\nexport interface PromiEvent<T> extends Promise<T> {\n    once(\n        type: 'sending',\n        handler: (payload: object) => void\n    ): PromiEvent<T>;\n\n    once(\n        type: 'sent',\n        handler: (payload: object) => void\n    ): PromiEvent<T>;\n\n    once(\n        type: 'transactionHash',\n        handler: (transactionHash: string) => void\n    ): PromiEvent<T>;\n\n    once(\n        type: 'receipt',\n        handler: (receipt: TransactionReceipt) => void\n    ): PromiEvent<T>;\n\n    once(\n        type: 'confirmation',\n        handler: (confirmationNumber: number, receipt: TransactionReceipt, latestBlockHash?: string) => void\n    ): PromiEvent<T>;\n\n    once(type: 'error', handler: (error: Error) => void): PromiEvent<T>;\n\n    once(\n        type: 'error' | 'confirmation' | 'receipt' | 'transactionHash' | 'sent' | 'sending',\n        handler: (error: Error | TransactionReceipt | string | object) => void\n    ): PromiEvent<T>;\n\n    on(\n        type: 'sending',\n        handler: (payload: object) => void\n    ): PromiEvent<T>;\n\n    on(\n        type: 'sent',\n        handler: (payload: object) => void\n    ): PromiEvent<T>;\n\n    on(\n        type: 'transactionHash',\n        handler: (receipt: string) => void\n    ): PromiEvent<T>;\n\n    on(\n        type: 'receipt',\n        handler: (receipt: TransactionReceipt) => void\n    ): PromiEvent<T>;\n\n    on(\n        type: 'confirmation',\n        handler: (confNumber: number, receipt: TransactionReceipt, latestBlockHash?: string) => void\n    ): PromiEvent<T>;\n\n    on(type: 'error', handler: (error: Error) => void): PromiEvent<T>;\n\n    on(\n        type: 'error' | 'confirmation' | 'receipt' | 'transactionHash' | 'sent' | 'sending',\n        handler: (error: Error | TransactionReceipt | string | object) => void\n    ): PromiEvent<T>;\n}\n\nexport interface Transaction {\n    hash: string;\n    nonce: number;\n    blockHash: string | null;\n    blockNumber: number | null;\n    transactionIndex: number | null;\n    from: string;\n    to: string | null;\n    value: string;\n    gasPrice: string;\n    maxPriorityFeePerGas?: number | string | BN;\n    maxFeePerGas?: number | string | BN;\n    gas: number;\n    input: string;\n}\n\nexport interface TransactionConfig {\n    from?: string | number;\n    to?: string;\n    value?: number | string | BN;\n    gas?: number | string;\n    gasPrice?: number | string | BN;\n    maxPriorityFeePerGas?: number | string | BN;\n    maxFeePerGas?: number | string | BN;\n    data?: string;\n    nonce?: number;\n    chainId?: number;\n    common?: Common;\n    chain?: string;\n    hardfork?: string;\n}\n\nexport type chain =\n    | 'mainnet'\n    | 'goerli'\n    | 'kovan'\n    | 'rinkeby'\n    | 'ropsten';\n\nexport type hardfork =\n    | 'chainstart'\n    | 'homestead'\n    | 'dao'\n    | 'tangerineWhistle'\n    | 'spuriousDragon'\n    | 'byzantium'\n    | 'constantinople'\n    | 'petersburg'\n    | 'istanbul';\n\nexport interface Common {\n    customChain: CustomChainParams;\n    baseChain?: chain;\n    hardfork?: hardfork;\n}\n\nexport interface CustomChainParams {\n    name?: string;\n    networkId: number;\n    chainId: number;\n}\n\nexport interface RLPEncodedTransaction {\n    raw: string;\n    tx: {\n        nonce: string;\n        gasPrice: string;\n        gas: string;\n        to: string;\n        value: string;\n        input: string;\n        r: string;\n        s: string;\n        v: string;\n        hash: string;\n    };\n}\n\nexport interface TransactionReceipt {\n    status: boolean;\n    transactionHash: string;\n    transactionIndex: number;\n    blockHash: string;\n    blockNumber: number;\n    from: string;\n    to: string;\n    contractAddress?: string;\n    cumulativeGasUsed: number;\n    gasUsed: number;\n    effectiveGasPrice: number;\n    logs: Log[];\n    logsBloom: string;\n    events?: {\n        [eventName: string]: EventLog;\n    };\n}\n\nexport interface EventLog {\n    event: string;\n    address: string;\n    returnValues: any;\n    logIndex: number;\n    transactionIndex: number;\n    transactionHash: string;\n    blockHash: string;\n    blockNumber: number;\n    raw?: {data: string; topics: any[]};\n}\n\nexport interface Log {\n    address: string;\n    data: string;\n    topics: string[];\n    logIndex: number;\n    transactionIndex: number;\n    transactionHash: string;\n    blockHash: string;\n    blockNumber: number;\n}\n\n// had to move `web3-net` due to other modules in `1.x` not referencing\n\nexport class NetworkBase {\n    constructor();\n    constructor(provider: provider);\n    constructor(provider: provider, net: net.Socket);\n\n    readonly givenProvider: any;\n    readonly currentProvider: provider;\n    static readonly givenProvider: any;\n    static readonly providers: Providers;\n    BatchRequest: new () => BatchRequest;\n\n    setProvider(provider: provider): boolean;\n\n    extend(extension: Extension): any;\n\n    getNetworkType(\n        callback?: (error: Error, returnValue: string) => void\n    ): Promise<string>;\n\n    getId(callback?: (error: Error, id: number) => void): Promise<number>;\n\n    isListening(\n        callback?: (error: Error, listening: boolean) => void\n    ): Promise<boolean>;\n\n    getPeerCount(\n        callback?: (error: Error, peerCount: number) => void\n    ): Promise<number>;\n}\n\n// had to move accounts from web3-eth-accounts due to other modules in 1.x not referencing\n\nexport class AccountsBase {\n    constructor();\n    constructor(provider: provider);\n    constructor(provider: provider, net: net.Socket);\n\n    readonly givenProvider: any;\n    readonly currentProvider: provider;\n\n    setProvider(provider: provider): boolean;\n\n    create(entropy?: string): Account;\n\n    privateKeyToAccount(privateKey: string, ignoreLength?: boolean): Account;\n\n    signTransaction(\n        transactionConfig: TransactionConfig,\n        privateKey: string,\n        callback?: (error: Error, signedTransaction: SignedTransaction) => void\n    ): Promise<SignedTransaction>;\n\n    recoverTransaction(signature: string): string;\n\n    hashMessage(message: string): string;\n\n    sign(data: string, privateKey: string): Sign;\n\n    recover(signatureObject: SignatureObject): string;\n    recover(message: string, signature: string, preFixed?: boolean): string;\n    recover(\n        message: string,\n        v: string,\n        r: string,\n        s: string,\n        preFixed?: boolean\n    ): string;\n\n    encrypt(privateKey: string, password: string): EncryptedKeystoreV3Json;\n\n    decrypt(keystoreJsonV3: EncryptedKeystoreV3Json, password: string): Account;\n\n    wallet: WalletBase;\n}\n\nexport class WalletBase {\n    constructor(accounts: AccountsBase);\n\n    length: number;\n    defaultKeyName: string;\n\n    [key: number]: Account;\n\n    create(numberOfAccounts: number, entropy?: string): WalletBase;\n\n    add(account: string | AddAccount): AddedAccount;\n\n    remove(account: string | number): boolean;\n\n    clear(): WalletBase;\n\n    encrypt(password: string): EncryptedKeystoreV3Json[];\n\n    decrypt(\n        keystoreArray: EncryptedKeystoreV3Json[],\n        password: string\n    ): WalletBase;\n\n    save(password: string, keyName?: string): boolean;\n\n    load(password: string, keyName?: string): WalletBase;\n}\n\nexport interface AddAccount {\n    address: string;\n    privateKey: string;\n}\n\nexport interface AddedAccount extends Account {\n    index: number;\n}\n\nexport interface Account {\n    address: string;\n    privateKey: string;\n    signTransaction: (\n        transactionConfig: TransactionConfig,\n        callback?: (signTransaction: SignedTransaction) => void\n    ) => Promise<SignedTransaction>;\n    sign: (data: string) => Sign;\n    encrypt: (password: string) => EncryptedKeystoreV3Json;\n}\n\nexport interface EncryptedKeystoreV3Json {\n    version: number;\n    id: string;\n    address: string;\n    crypto: {\n        ciphertext: string;\n        cipherparams: {iv: string};\n        cipher: string;\n        kdf: string;\n        kdfparams: {\n            dklen: number;\n            salt: string;\n            n: number;\n            r: number;\n            p: number;\n        };\n        mac: string;\n    };\n}\n\nexport interface Sign extends SignedTransaction {\n    message: string;\n    signature: string;\n}\n\nexport interface SignatureObject {\n    messageHash: string;\n    r: string;\n    s: string;\n    v: string;\n}\n\n// put all the `web3-provider` typings in here so we can get to them everywhere as this module does not exist in 1.x\n\nexport class BatchRequest {\n    constructor();\n\n    add(method: Method): void;\n\n    execute(): void;\n}\n\nexport class HttpProvider extends HttpProviderBase {\n    constructor(host: string, options?: HttpProviderOptions);\n}\n\nexport class IpcProvider extends IpcProviderBase {\n    constructor(path: string, net: net.Server);\n}\n\nexport class WebsocketProvider extends WebsocketProviderBase {\n    constructor(host: string, options?: WebsocketProviderOptions);\n}\n\nexport interface PastLogsOptions extends LogsOptions {\n    toBlock?: BlockNumber;\n}\n\nexport interface LogsOptions {\n    fromBlock?: BlockNumber;\n    address?: string | string[];\n    topics?: Array<string | string[] | null>;\n}\n\nexport type BlockNumber = string | number | BN | BigNumber | 'latest' | 'pending' | 'earliest' | 'genesis' | 'finalized' | 'safe';\n\nexport interface RequestArguments {\n    method: string;\n    params?: any;\n    [key: string]: any;\n}\n\nexport interface AbstractProvider {\n    sendAsync(payload: JsonRpcPayload, callback?: (error: Error | null, result?: JsonRpcResponse) => Promise<unknown> | void): void;\n    send?(payload: JsonRpcPayload, callback: (error: Error | null, result?: JsonRpcResponse) => unknown): void;\n    request?(args: RequestArguments): Promise<any>;\n    connected?: boolean;\n  }\n\nexport type provider =\n    | HttpProvider\n    | IpcProvider\n    | WebsocketProvider\n    | AbstractProvider\n    | string\n    | null;\n"}}]);