(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],Array(1112).concat([
/* 1112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _udapp = __webpack_require__(1645);

var _remixEngine = __webpack_require__(2103);

var _remixAppManager = __webpack_require__(2104);

var _themeModule = __webpack_require__(490);

var _networkModule = __webpack_require__(2105);

var _web3Provider = __webpack_require__(2106);

var _compileAndRun = __webpack_require__(2107);

var _sidePanel = __webpack_require__(2108);

var _hiddenPanel = __webpack_require__(2111);

var _verticalIcons = __webpack_require__(2112);

var _landingPage = __webpack_require__(2127);

var _mainPanel = __webpack_require__(2156);

var _permissionHandlerPlugin = __webpack_require__(2157);

var _remixAstwalker = __webpack_require__(1180);

var _corePlugin = __webpack_require__(1253);

var _walkthroughService = __webpack_require__(2253);

var _registry = _interopRequireDefault(__webpack_require__(315));

var _config = __webpack_require__(2255);

var _storage = __webpack_require__(2256);

var _layout = __webpack_require__(2257);

var _notification = __webpack_require__(2258);

var _blockchain = __webpack_require__(2259);

var _hardhatProvider = __webpack_require__(2439);

var _ganacheProvider = __webpack_require__(2440);

var _foundryProvider = __webpack_require__(2441);

var _externalHttpProvider = __webpack_require__(2442);

var _injectedOptimismProvider = __webpack_require__(2443);

var _injectedArbitrumOneProvider = __webpack_require__(2444);

var _remixLib = __webpack_require__(311);

var _search = __webpack_require__(2445);

var isElectron = __webpack_require__(1300);

var remixLib = __webpack_require__(311);

var Storage = remixLib.Storage;

var RemixDProvider = __webpack_require__(2469);

var Config = __webpack_require__(501);

var FileManager = __webpack_require__(2470);

var FileProvider = __webpack_require__(1362);

var DGitProvider = __webpack_require__(2471);

var WorkspaceFileProvider = __webpack_require__(2490);

var PluginManagerComponent = __webpack_require__(2491);

var CompileTab = __webpack_require__(2504);

var SettingsTab = __webpack_require__(2520);

var AnalysisTab = __webpack_require__(2534);

var _require = __webpack_require__(2571),
    DebuggerTab = _require.DebuggerTab;

var TestTab = __webpack_require__(2641);

var FilePanel = __webpack_require__(2759);

var Editor = __webpack_require__(2843);

var Terminal = __webpack_require__(2857);

var _require2 = __webpack_require__(2896),
    TabProxy = _require2.TabProxy;

var AppComponent = /*#__PURE__*/function () {
  function AppComponent() {
    (0, _classCallCheck2["default"])(this, AppComponent);
    this.appManager = new _remixAppManager.RemixAppManager({});
    this.queryParams = new _remixLib.QueryParams();
    this._components = {}; // setup storage

    var configStorage = new Storage('config-v0.8:'); // load app config

    var config = new Config(configStorage);

    _registry["default"].getInstance().put({
      api: config,
      name: 'config'
    }); // load file system


    this._components.filesProviders = {};
    this._components.filesProviders.browser = new FileProvider('browser');

    _registry["default"].getInstance().put({
      api: this._components.filesProviders.browser,
      name: 'fileproviders/browser'
    });

    this._components.filesProviders.localhost = new RemixDProvider(this.appManager);

    _registry["default"].getInstance().put({
      api: this._components.filesProviders.localhost,
      name: 'fileproviders/localhost'
    });

    this._components.filesProviders.workspace = new WorkspaceFileProvider();

    _registry["default"].getInstance().put({
      api: this._components.filesProviders.workspace,
      name: 'fileproviders/workspace'
    });

    _registry["default"].getInstance().put({
      api: this._components.filesProviders,
      name: 'fileproviders'
    });
  }

  (0, _createClass2["default"])(AppComponent, [{
    key: "run",
    value: function () {
      var _run = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var appManager, pluginLoader, matomoDomains, hosts, editor, fileManager, dGitProvider, storagePlugin, search, contentImport, blockchain, compilerMetadataGenerator, compilersArtefacts, fetchAndCompile, networkModule, web3Provider, hardhatProvider, ganacheProvider, foundryProvider, externalHttpProvider, injected0ptimismProvider, injectedArbitrumOneProvider, offsetToLineColumnConverter, compileAndRun, terminal, contextualListener, configPlugin, permissionHandler, appPanel, tabProxy, pluginManagerComponent, filePanel, landingPage, openZeppelinProxy, linkLibraries, deployLibraries, compileTab, run, analysis, debug, test;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // APP_MANAGER
                appManager = this.appManager;
                pluginLoader = this.appManager.pluginLoader;
                this.panels = {};
                this.workspace = pluginLoader.get();
                this.engine = new _remixEngine.RemixEngine();
                this.engine.register(appManager);
                matomoDomains = {
                  'remix-alpha.ethereum.org': 27,
                  'remix-beta.ethereum.org': 25,
                  'remix.ethereum.org': 23
                };
                this.showMatamo = matomoDomains[window.location.hostname] && !_registry["default"].getInstance().get('config').api.exists('settings/matomo-analytics');
                this.walkthroughService = new _walkthroughService.WalkthroughService(appManager, this.showMatamo);
                hosts = ['127.0.0.1:8080', '192.168.0.101:8080', 'localhost:8080']; // workaround for Electron support

                if (!isElectron() && !hosts.includes(window.location.host)) {
                  // Oops! Accidentally trigger refresh or bookmark.
                  window.onbeforeunload = function () {
                    return 'Are you sure you want to leave?';
                  };
                } // SERVICES
                // ----------------- gist service ---------------------------------


                this.gistHandler = new _corePlugin.GistHandler(); // ----------------- theme service ---------------------------------

                this.themeModule = new _themeModule.ThemeModule();

                _registry["default"].getInstance().put({
                  api: this.themeModule,
                  name: 'themeModule'
                }); // ----------------- editor service ----------------------------


                editor = new Editor(); // wrapper around ace editor

                _registry["default"].getInstance().put({
                  api: editor,
                  name: 'editor'
                });

                editor.event.register('requiringToSaveCurrentfile', function () {
                  return fileManager.saveCurrentFile();
                }); // ----------------- fileManager service ----------------------------

                fileManager = new FileManager(editor, appManager);

                _registry["default"].getInstance().put({
                  api: fileManager,
                  name: 'filemanager'
                }); // ----------------- dGit provider ---------------------------------


                dGitProvider = new DGitProvider(); // ----------------- Storage plugin ---------------------------------

                storagePlugin = new _storage.StoragePlugin(); //----- search

                search = new _search.SearchPlugin(); // ----------------- import content service ------------------------

                contentImport = new _corePlugin.CompilerImports();
                blockchain = new _blockchain.Blockchain(_registry["default"].getInstance().get('config').api); // ----------------- compilation metadata generation service ---------

                compilerMetadataGenerator = new _corePlugin.CompilerMetadata(); // ----------------- compilation result service (can keep track of compilation results) ----------------------------

                compilersArtefacts = new _corePlugin.CompilerArtefacts(); // store all the compilation results (key represent a compiler name)

                _registry["default"].getInstance().put({
                  api: compilersArtefacts,
                  name: 'compilersartefacts'
                }); // service which fetch contract artifacts from sourve-verify, put artifacts in remix and compile it


                fetchAndCompile = new _corePlugin.FetchAndCompile(); // ----------------- network service (resolve network id / name) -----

                networkModule = new _networkModule.NetworkModule(blockchain); // ----------------- represent the current selected web3 provider ----

                web3Provider = new _web3Provider.Web3ProviderModule(blockchain);
                hardhatProvider = new _hardhatProvider.HardhatProvider(blockchain);
                ganacheProvider = new _ganacheProvider.GanacheProvider(blockchain);
                foundryProvider = new _foundryProvider.FoundryProvider(blockchain);
                externalHttpProvider = new _externalHttpProvider.ExternalHttpProvider(blockchain);
                injected0ptimismProvider = new _injectedOptimismProvider.Injected0ptimismProvider(blockchain);
                injectedArbitrumOneProvider = new _injectedArbitrumOneProvider.InjectedArbitrumOneProvider(blockchain); // ----------------- convert offset to line/column service -----------

                offsetToLineColumnConverter = new _corePlugin.OffsetToLineColumnConverter();

                _registry["default"].getInstance().put({
                  api: offsetToLineColumnConverter,
                  name: 'offsettolinecolumnconverter'
                }); // ----------------- run script after each compilation results -----------


                compileAndRun = new _compileAndRun.CompileAndRun(); // -------------------Terminal----------------------------------------

                (0, _udapp.makeUdapp)(blockchain, compilersArtefacts, function (domEl) {
                  return terminal.logHtml(domEl);
                });
                terminal = new Terminal({
                  appManager: appManager,
                  blockchain: blockchain
                }, {
                  getPosition: function getPosition(event) {
                    var limitUp = 36;
                    var limitDown = 20;
                    var height = window.innerHeight;
                    var newpos = event.pageY < limitUp ? limitUp : event.pageY;
                    newpos = newpos < height - limitDown ? newpos : height - limitDown;
                    return height - newpos;
                  }
                });
                contextualListener = new _corePlugin.EditorContextListener(new _remixAstwalker.AstWalker());
                this.notification = new _notification.NotificationPlugin();
                configPlugin = new _config.ConfigPlugin();
                this.layout = new _layout.Layout();
                permissionHandler = new _permissionHandlerPlugin.PermissionHandlerPlugin();
                this.engine.register([permissionHandler, this.layout, this.notification, this.gistHandler, configPlugin, blockchain, contentImport, this.themeModule, editor, fileManager, compilerMetadataGenerator, compilersArtefacts, networkModule, offsetToLineColumnConverter, contextualListener, terminal, web3Provider, compileAndRun, fetchAndCompile, dGitProvider, storagePlugin, hardhatProvider, ganacheProvider, foundryProvider, externalHttpProvider, injected0ptimismProvider, injectedArbitrumOneProvider, this.walkthroughService, search]); // LAYOUT & SYSTEM VIEWS

                appPanel = new _mainPanel.MainPanel();

                _registry["default"].getInstance().put({
                  api: this.mainview,
                  name: 'mainview'
                });

                tabProxy = new TabProxy(fileManager, editor);
                this.engine.register([appPanel, tabProxy]); // those views depend on app_manager

                this.menuicons = new _verticalIcons.VerticalIcons();
                this.sidePanel = new _sidePanel.SidePanel();
                this.hiddenPanel = new _hiddenPanel.HiddenPanel();
                pluginManagerComponent = new PluginManagerComponent(appManager, this.engine);
                filePanel = new FilePanel(appManager);
                landingPage = new _landingPage.LandingPage(appManager, this.menuicons, fileManager, filePanel, contentImport);
                this.settings = new SettingsTab(_registry["default"].getInstance().get('config').api, editor, appManager);
                this.engine.register([this.menuicons, landingPage, this.hiddenPanel, this.sidePanel, filePanel, pluginManagerComponent, this.settings]); // CONTENT VIEWS & DEFAULT PLUGINS

                openZeppelinProxy = new _corePlugin.OpenZeppelinProxy(blockchain);
                linkLibraries = new _corePlugin.LinkLibraries(blockchain);
                deployLibraries = new _corePlugin.DeployLibraries(blockchain);
                compileTab = new CompileTab(_registry["default"].getInstance().get('config').api, _registry["default"].getInstance().get('filemanager').api);
                run = new _udapp.RunTab(blockchain, _registry["default"].getInstance().get('config').api, _registry["default"].getInstance().get('filemanager').api, _registry["default"].getInstance().get('editor').api, filePanel, _registry["default"].getInstance().get('compilersartefacts').api, networkModule, _registry["default"].getInstance().get('fileproviders/browser').api);
                analysis = new AnalysisTab();
                debug = new DebuggerTab();
                test = new TestTab(_registry["default"].getInstance().get('filemanager').api, _registry["default"].getInstance().get('offsettolinecolumnconverter').api, filePanel, compileTab, appManager, contentImport);
                this.engine.register([compileTab, run, debug, analysis, test, filePanel.remixdHandle, filePanel.gitHandle, filePanel.hardhatHandle, filePanel.truffleHandle, filePanel.slitherHandle, linkLibraries, deployLibraries, openZeppelinProxy, run.recorder]);
                this.layout.panels = {
                  tabs: {
                    plugin: tabProxy,
                    active: true
                  },
                  editor: {
                    plugin: editor,
                    active: true
                  },
                  main: {
                    plugin: appPanel,
                    active: false
                  },
                  terminal: {
                    plugin: terminal,
                    active: true,
                    minimized: false
                  }
                };

              case 69:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function run() {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }, {
    key: "activate",
    value: function () {
      var _activate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var _this = this;

        var queryParams, params;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                queryParams = new _remixLib.QueryParams();
                params = queryParams.get();

                if (isElectron()) {
                  this.appManager.activatePlugin('remixd');
                }

                _context4.prev = 3;
                _context4.t0 = this.engine;
                _context4.next = 7;
                return this.appManager.registeredPlugins();

              case 7:
                _context4.t1 = _context4.sent;

                _context4.t0.register.call(_context4.t0, _context4.t1);

                _context4.next = 14;
                break;

              case 11:
                _context4.prev = 11;
                _context4.t2 = _context4["catch"](3);
                console.log("couldn't register iframe plugins", _context4.t2.message);

              case 14:
                _context4.next = 16;
                return this.appManager.activatePlugin(['layout']);

              case 16:
                _context4.next = 18;
                return this.appManager.activatePlugin(['notification']);

              case 18:
                _context4.next = 20;
                return this.appManager.activatePlugin(['editor']);

              case 20:
                _context4.next = 22;
                return this.appManager.activatePlugin(['permissionhandler', 'theme', 'fileManager', 'compilerMetadata', 'compilerArtefacts', 'network', 'web3Provider', 'offsetToLineColumnConverter']);

              case 22:
                _context4.next = 24;
                return this.appManager.activatePlugin(['mainPanel', 'menuicons', 'tabs']);

              case 24:
                _context4.next = 26;
                return this.appManager.activatePlugin(['sidePanel']);

              case 26:
                _context4.next = 28;
                return this.appManager.activatePlugin(['home']);

              case 28:
                _context4.next = 30;
                return this.appManager.activatePlugin(['settings', 'config']);

              case 30:
                _context4.next = 32;
                return this.appManager.activatePlugin(['hiddenPanel', 'pluginManager', 'contextualListener', 'terminal', 'blockchain', 'fetchAndCompile', 'contentImport', 'gistHandler']);

              case 32:
                _context4.next = 34;
                return this.appManager.activatePlugin(['settings']);

              case 34:
                _context4.next = 36;
                return this.appManager.activatePlugin(['walkthrough', 'storage', 'search', 'compileAndRun', 'recorder']);

              case 36:
                this.appManager.on('filePanel', 'workspaceInitializationCompleted', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
                  return _regenerator["default"].wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this.appManager.registerContextMenuItems();

                        case 2:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })));
                _context4.next = 39;
                return this.appManager.activatePlugin(['filePanel']);

              case 39:
                // Set workspace after initial activation
                this.appManager.on('editor', 'editorMounted', function () {
                  if (Array.isArray(_this.workspace)) {
                    _this.appManager.activatePlugin(_this.workspace).then( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
                      var callDetails, _this$appManager;

                      return _regenerator["default"].wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              _context3.prev = 0;

                              if (!params.deactivate) {
                                _context3.next = 4;
                                break;
                              }

                              _context3.next = 4;
                              return _this.appManager.deactivatePlugin(params.deactivate.split(','));

                            case 4:
                              _context3.next = 9;
                              break;

                            case 6:
                              _context3.prev = 6;
                              _context3.t0 = _context3["catch"](0);
                              console.log(_context3.t0);

                            case 9:
                              if (params.code && (!params.activate || params.activate.split(',').includes('solidity'))) {
                                // if code is given in url we focus on solidity plugin
                                _this.menuicons.select('solidity');
                              } else {
                                // If plugins are loaded from the URL params, we focus on the last one.
                                if (_this.appManager.pluginLoader.current === 'queryParams' && _this.workspace.length > 0) {
                                  _this.menuicons.select(_this.workspace[_this.workspace.length - 1]);
                                }
                              }

                              if (params.call) {
                                callDetails = params.call.split('//');

                                if (callDetails.length > 1) {
                                  _this.appManager.call('notification', 'toast', "initiating ".concat(callDetails[0], " ...")); // @todo(remove the timeout when activatePlugin is on 0.3.0)


                                  (_this$appManager = _this.appManager).call.apply(_this$appManager, (0, _toConsumableArray2["default"])(callDetails))["catch"](console.error);
                                }
                              }

                            case 11:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3, null, [[0, 6]]);
                    })))["catch"](console.error);
                  }
                }); // activate solidity plugin

                this.appManager.activatePlugin(['solidity', 'udapp', 'deploy-libraries', 'link-libraries', 'openzeppelin-proxy']); // Load and start the service who manager layout and frame

              case 41:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 11]]);
      }));

      function activate() {
        return _activate.apply(this, arguments);
      }

      return activate;
    }()
  }]);
  return AppComponent;
}();

var _default = AppComponent;
exports["default"] = _default;

/***/ }),
/* 1113 */,
/* 1114 */,
/* 1115 */,
/* 1116 */,
/* 1117 */,
/* 1118 */,
/* 1119 */,
/* 1120 */,
/* 1121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiHelper = __webpack_require__(1656);

Object.keys(_remixUiHelper).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiHelper[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiHelper[key];
    }
  });
});

var _helperComponents = __webpack_require__(1657);

Object.keys(_helperComponents).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _helperComponents[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _helperComponents[key];
    }
  });
});

var _PluginViewWrapper = __webpack_require__(1658);

Object.keys(_PluginViewWrapper).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PluginViewWrapper[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PluginViewWrapper[key];
    }
  });
});

var _customDropdown = __webpack_require__(1659);

Object.keys(_customDropdown).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _customDropdown[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _customDropdown[key];
    }
  });
});

/***/ }),
/* 1122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLowLevelCall = exports.isTransfer = exports.isStateVariable = exports.isWriteOnStateVariable = exports.isLocalCall = exports.isLocalCallGraphRelevantNode = exports.isLibraryCall = exports.isSuperLocalCall = exports.isThisLocalCall = exports.isBlockBlockHashAccess = exports.isBlockTimestampAccess = exports.isNowAccess = exports.isTxOriginAccess = exports.isEffect = exports.isInteraction = exports.hasFunctionBody = exports.isSubScopeWithTopLevelUnAssignedBinOp = exports.isMappingIndexAccess = exports.isDynamicArrayLengthAccess = exports.isDynamicArrayAccess = exports.isVariableTurnedIntoGetter = exports.isSpecialVariableAccess = exports.isAbiNamespaceCall = exports.isDeleteFromDynamicArray = exports.isDeleteOfDynamicArray = exports.getCompilerVersion = exports.getMethodParamsSplittedTypeDesc = exports.getUnAssignedTopLevelBinOps = exports.getFunctionDefinitionReturnParameterPart = exports.getFunctionOrModifierDefinitionParameterPart = exports.getStateVariableDeclarationsFromContractNode = exports.getFullQuallyfiedFuncDefinitionIdent = exports.getFullQualifiedFunctionCallIdent = exports.getLibraryCallMemberName = exports.getLibraryCallContractName = exports.getFunctionCallTypeParameterType = exports.getFunctionDefinitionName = exports.getExternalDirectCallMemberName = exports.getThisLocalCallContractName = exports.getExternalDirectCallContractName = exports.getInheritsFromName = exports.getLocalCallName = exports.getDeclaredVariableType = exports.getDeclaredVariableName = exports.getEffectedVariableName = exports.getContractName = exports.getFunctionCallType = exports.getSuperLocalCallName = exports.getThisLocalCallName = exports.getType = void 0;
exports.helpers = exports.specialVariables = exports.lowLevelCallTypes = exports.basicFunctionTypes = exports.basicTypes = exports.nodeTypes = exports.isStatement = exports.isConstructor = exports.isPayableFunction = exports.isConstantFunction = exports.isStorageVariableDeclaration = exports.isDeleteUnaryOperation = exports.isLoop = exports.isBytesLengthCheck = exports.isStringToBytesConversion = exports.isIntDivision = exports.isRequireCall = exports.isAssertCall = exports.isSelfdestructCall = exports.isBuiltinFunctionCall = exports.isMinusMinusUnaryOperation = exports.isPlusPlusUnaryOperation = exports.isCallToNonConstLocalFunction = exports.isLibrary = exports.isFullyImplementedContract = exports.isExternalDirectCall = exports.isLLSend04 = exports.isLLSend = exports.isLLDelegatecall04 = exports.isLLDelegatecall = exports.isLLCallcode = exports.isLLCall04 = exports.isLLCall = void 0;

const remix_lib_1 = __webpack_require__(311);

const nodeTypes = {
  SOURCEUNIT: 'SourceUnit',
  PRAGMADIRECTIVE: 'PragmaDirective',
  IMPORTDIRECTIVE: 'ImportDirective',
  CONTRACTDEFINITION: 'ContractDefinition',
  INHERITANCESPECIFIER: 'InheritanceSpecifier',
  USINGFORDIRECTIVE: 'UsingForDirective',
  STRUCTDEFINITION: 'StructDefinition',
  ENUMDEFINITION: 'EnumDefinition',
  ENUMVALUE: 'EnumValue',
  PARAMETERLIST: 'ParameterList',
  OVERRIDESPECIFIER: 'OverrideSpecifier',
  FUNCTIONDEFINITION: 'FunctionDefinition',
  VARIABLEDECLARATION: 'VariableDeclaration',
  MODIFIERDEFINITION: 'ModifierDefinition',
  MODIFIERINVOCATION: 'ModifierInvocation',
  EVENTDEFINITION: 'EventDefinition',
  ELEMENTARYTYPENAME: 'ElementaryTypeName',
  USERDEFINEDTYPENAME: 'UserDefinedTypeName',
  FUNCTIONTYPENAME: 'FunctionTypeName',
  MAPPING: 'Mapping',
  ARRAYTYPENAME: 'ArrayTypeName',
  INLINEASSEMBLY: 'InlineAssembly',
  BLOCK: 'Block',
  PLACEHOLDERSTATEMENT: 'PlaceholderStatement',
  IFSTATEMENT: 'IfStatement',
  TRYCATCHCLAUSE: 'TryCatchClause',
  TRYSTATEMENT: 'TryStatement',
  WHILESTATEMENT: 'WhileStatement',
  DOWHILESTATEMENT: 'DoWhileStatement',
  FORSTATEMENT: 'ForStatement',
  CONTINUE: 'Continue',
  BREAK: 'Break',
  RETURN: 'Return',
  THROW: 'Throw',
  EMITSTATEMENT: 'EmitStatement',
  VARIABLEDECLARATIONSTATEMENT: 'VariableDeclarationStatement',
  EXPRESSIONSTATEMENT: 'ExpressionStatement',
  CONDITIONAL: 'Conditional',
  ASSIGNMENT: 'Assignment',
  TUPLEEXPRESSION: 'TupleExpression',
  UNARYOPERATION: 'UnaryOperation',
  BINARYOPERATION: 'BinaryOperation',
  FUNCTIONCALL: 'FunctionCall',
  FUNCTIONCALLOPTIONS: 'FunctionCallOptions',
  NEWEXPRESSION: 'NewExpression',
  MEMBERACCESS: 'MemberAccess',
  INDEXACCESS: 'IndexAccess',
  INDEXRANGEACCESS: 'IndexRangeAccess',
  ELEMENTARYTYPENAMEEXPRESSION: 'ElementaryTypeNameExpression',
  LITERAL: 'Literal',
  IDENTIFIER: 'Identifier',
  STRUCTUREDDOCUMENTATION: 'StructuredDocumentation'
};
exports.nodeTypes = nodeTypes;
const basicTypes = {
  UINT: 'uint256',
  BOOL: 'bool',
  ADDRESS: 'address',
  PAYABLE_ADDRESS: 'address payable',
  BYTES32: 'bytes32',
  STRING_MEM: 'string memory',
  BYTES_MEM: 'bytes memory',
  BYTES4: 'bytes4'
};
exports.basicTypes = basicTypes;
const basicRegex = {
  CONTRACTTYPE: '^contract ',
  FUNCTIONTYPE: '^function \\(',
  EXTERNALFUNCTIONTYPE: '^function \\(.*\\).* external',
  CONSTANTFUNCTIONTYPE: '^function \\(.*\\).* (view|pure)',
  REFTYPE: '(storage)|(mapping\\()|(\\[\\])',
  FUNCTIONSIGNATURE: '^function \\(([^\\(]*)\\)',
  LIBRARYTYPE: '^type\\(library (.*)\\)'
};
const basicFunctionTypes = {
  SEND: buildFunctionSignature([basicTypes.UINT], [basicTypes.BOOL], false),
  'CALL-0.4': buildFunctionSignature([], [basicTypes.BOOL], true),
  CALL: buildFunctionSignature([basicTypes.BYTES_MEM], [basicTypes.BOOL, basicTypes.BYTES_MEM], true),
  'DELEGATECALL-0.4': buildFunctionSignature([], [basicTypes.BOOL], false),
  DELEGATECALL: buildFunctionSignature([basicTypes.BYTES_MEM], [basicTypes.BOOL, basicTypes.BYTES_MEM], false),
  TRANSFER: buildFunctionSignature([basicTypes.UINT], [], false)
};
exports.basicFunctionTypes = basicFunctionTypes;
const builtinFunctions = {
  'keccak256()': true,
  'sha3()': true,
  'sha256()': true,
  'ripemd160()': true,
  'ecrecover(bytes32,uint8,bytes32,bytes32)': true,
  'addmod(uint256,uint256,uint256)': true,
  'mulmod(uint256,uint256,uint256)': true,
  'selfdestruct(address)': true,
  'selfdestruct(address payable)': true,
  'revert()': true,
  'revert(string memory)': true,
  'assert(bool)': true,
  'require(bool)': true,
  'require(bool,string memory)': true,
  'gasleft()': true,
  'blockhash(uint256)': true,
  'address(address)': true
};
const lowLevelCallTypes = {
  'CALL-0.4': {
    ident: 'call',
    type: basicFunctionTypes['CALL-0.4']
  },
  CALL: {
    ident: 'call',
    type: basicFunctionTypes.CALL
  },
  CALLCODE: {
    ident: 'callcode',
    type: basicFunctionTypes['CALL-0.4']
  },
  'DELEGATECALL-0.4': {
    ident: 'delegatecall',
    type: basicFunctionTypes['DELEGATECALL-0.4']
  },
  DELEGATECALL: {
    ident: 'delegatecall',
    type: basicFunctionTypes.DELEGATECALL
  },
  SEND: {
    ident: 'send',
    type: basicFunctionTypes.SEND
  },
  TRANSFER: {
    ident: 'transfer',
    type: basicFunctionTypes.TRANSFER
  }
};
exports.lowLevelCallTypes = lowLevelCallTypes;
const specialVariables = {
  BLOCKTIMESTAMP: {
    obj: 'block',
    member: 'timestamp',
    type: basicTypes.UINT
  },
  BLOCKHASH: {
    obj: 'block',
    member: 'blockhash',
    type: buildFunctionSignature([basicTypes.UINT], [basicTypes.BYTES32], false, 'view')
  }
};
exports.specialVariables = specialVariables;
const abiNamespace = {
  ENCODE: {
    obj: 'abi',
    member: 'encode',
    type: buildFunctionSignature([], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODEPACKED: {
    obj: 'abi',
    member: 'encodePacked',
    type: buildFunctionSignature([], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODE_SELECT: {
    obj: 'abi',
    member: 'encodeWithSelector',
    type: buildFunctionSignature([basicTypes.BYTES4], [basicTypes.BYTES_MEM], false, 'pure')
  },
  ENCODE_SIG: {
    obj: 'abi',
    member: 'encodeWithSignature',
    type: buildFunctionSignature([basicTypes.STRING_MEM], [basicTypes.BYTES_MEM], false, 'pure')
  }
}; // #################### Trivial Getters
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function getType(node) {
  return node.typeDescriptions.typeString;
}

exports.getType = getType; // #################### Complex Getters

/**
 * Returns the type parameter of function call AST nodes. Throws if not a function call node
 * @func {ASTNode} Function call node
 * @return {string} type of function call
 */

function getFunctionCallType(func) {
  return getType(func.expression);
}

exports.getFunctionCallType = getFunctionCallType;
/**
 * Get the variable name written to by a effect node, except for inline assembly because there is no information to find out where we write to. Trows if not a effect node or is inlineassmbly.
 * Example: x = 10; => x
 * @effectNode {ASTNode} Assignmnet node
 * @return {string} variable name written to
 */

function getEffectedVariableName(effectNode) {
  if (!isEffect(effectNode)) throw new Error('staticAnalysisCommon.js: not an effect Node');

  if (effectNode.nodeType === 'Assignment' || effectNode.nodeType === 'UnaryOperation') {
    const IdentNode = findFirstSubNodeLTR(effectNode, exactMatch(nodeTypes.IDENTIFIER));
    return IdentNode.name;
  } else throw new Error('staticAnalysisCommon.js: wrong node type');
}

exports.getEffectedVariableName = getEffectedVariableName;
/**
 * Returns the identifier of a local call, Throws on wrong node.
 * Example: f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getLocalCallName(localCallNode) {
  if (!isLocalCall(localCallNode) && !isAbiNamespaceCall(localCallNode)) throw new Error('staticAnalysisCommon.js: not a local call Node');
  return localCallNode.expression.name;
}

exports.getLocalCallName = getLocalCallName;
/**
 * Returns the identifier of a this local call, Throws on wrong node.
 * Example: this.f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getThisLocalCallName(thisLocalCallNode) {
  if (!isThisLocalCall(thisLocalCallNode.expression)) throw new Error('staticAnalysisCommon.js: not a this local call Node');
  return thisLocalCallNode.expression.memberName;
}

exports.getThisLocalCallName = getThisLocalCallName;
/**
 * Returns the identifier of a super local call, Throws on wrong node.
 * Example: super.f(103) => f
 * @localCallNode {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getSuperLocalCallName(superLocalCallNode) {
  if (!isSuperLocalCall(superLocalCallNode.expression)) throw new Error('staticAnalysisCommon.js: not a super local call Node');
  return superLocalCallNode.expression.memberName;
}

exports.getSuperLocalCallName = getSuperLocalCallName;
/**
 * Returns the contract type of a external direct call, Throws on wrong node.
 * Example:
 *  foo x = foo(0xdeadbeef...);
 *  x.f(103) => foo
 * @extDirectCall {ASTNode} Function call node
 * @return {string} name of the contract the function is defined in
 */

function getExternalDirectCallContractName(extDirectCall) {
  if (!isExternalDirectCall(extDirectCall)) throw new Error('staticAnalysisCommon.js: not an external direct call Node');
  return extDirectCall.expression.expression.typeDescriptions.typeString.replace(new RegExp(basicRegex.CONTRACTTYPE), '');
}

exports.getExternalDirectCallContractName = getExternalDirectCallContractName;
/**
 * Returns the name of the contract of a this local call (current contract), Throws on wrong node.
 * Example:
 * Contract foo {
 *    ...
 *    this.f(103) => foo
 *    ...
 * @thisLocalCall {ASTNode} Function call node
 * @return {string} name of the contract the function is defined in
 */

function getThisLocalCallContractName(thisLocalCall) {
  if (!isThisLocalCall(thisLocalCall.expression)) throw new Error('staticAnalysisCommon.js: not a this local call Node');
  return thisLocalCall.expression.expression.typeDescriptions.typeString.replace(new RegExp(basicRegex.CONTRACTTYPE), '');
}

exports.getThisLocalCallContractName = getThisLocalCallContractName;
/**
 * Returns the function identifier of a external direct call, Throws on wrong node.
 * Example:
 *  foo x = foo(0xdeadbeef...);
 *  x.f(103) => f
 * @extDirectCall {ASTNode} Function call node
 * @return {string} name of the function called
 */

function getExternalDirectCallMemberName(extDirectCall) {
  if (!isExternalDirectCall(extDirectCall)) throw new Error('staticAnalysisCommon.js: not an external direct call Node');
  return extDirectCall.expression.memberName;
}

exports.getExternalDirectCallMemberName = getExternalDirectCallMemberName;
/**
 * Returns the name of a contract, Throws on wrong node.
 * Example:
 *   Contract foo { => foo
 * @contract {ASTNode} Contract Definition node
 * @return {string} name of a contract defined
 */

function getContractName(contract) {
  if (!nodeType(contract, exactMatch(nodeTypes.CONTRACTDEFINITION))) throw new Error('staticAnalysisCommon.js: not a ContractDefinition Node');
  return contract.name;
}

exports.getContractName = getContractName;
/**
 * Returns the name of a function definition, Throws on wrong node.
 * Example:
 *   func foo(uint bla) { => foo
 * @funcDef {ASTNode} Function Definition node
 * @return {string} name of a function defined
 */

function getFunctionDefinitionName(funcDef) {
  if (!nodeType(funcDef, exactMatch(nodeTypes.FUNCTIONDEFINITION))) throw new Error('staticAnalysisCommon.js: not a FunctionDefinition Node');
  return funcDef.name;
}

exports.getFunctionDefinitionName = getFunctionDefinitionName;
/**
 * Returns the identifier of an inheritance specifier, Throws on wrong node.
 * Example:
 *   contract KingOfTheEtherThrone is b { => b
 * @func {ASTNode} Inheritance specifier
 * @return {string} name of contract inherited from
 */

function getInheritsFromName(inheritsNode) {
  if (!nodeType(inheritsNode, exactMatch(nodeTypes.INHERITANCESPECIFIER))) throw new Error('staticAnalysisCommon.js: not an InheritanceSpecifier Node');
  return inheritsNode.baseName.name;
}

exports.getInheritsFromName = getInheritsFromName;
/**
 * Returns the identifier of a variable definition, Throws on wrong node.
 * Example:
 *   var x = 10; => x
 * @varDeclNode {ASTNode} Variable declaration node
 * @return {string} variable name
 */

function getDeclaredVariableName(varDeclNode) {
  if (!nodeType(varDeclNode, exactMatch(nodeTypes.VARIABLEDECLARATION))) throw new Error('staticAnalysisCommon.js: not a VariableDeclaration Node');
  return varDeclNode.name;
}

exports.getDeclaredVariableName = getDeclaredVariableName;
/**
 * Returns the type of a variable definition, Throws on wrong node.
 * Example:
 *   var x = 10; => x
 * @varDeclNode {ASTNode} Variable declaration node
 * @return {string} variable type
 */

function getDeclaredVariableType(varDeclNode) {
  return varDeclNode.typeName.name;
}

exports.getDeclaredVariableType = getDeclaredVariableType;
/**
 * Returns state variable declaration nodes for a contract, Throws on wrong node.
 * Example:
 * contract foo {
 *     ...
 *   var y = true;
 *   var x = 10; => [y,x]
 * @contractNode {ASTNode} Contract Definition node
 * @return {list variable declaration} state variable node list
 */

function getStateVariableDeclarationsFromContractNode(contractNode) {
  return contractNode.nodes.filter(el => el.nodeType === 'VariableDeclaration');
}

exports.getStateVariableDeclarationsFromContractNode = getStateVariableDeclarationsFromContractNode;
/**
 * Returns parameter node for a function or modifier definition, Throws on wrong node.
 * Example:
 * function bar(uint a, uint b) => uint a, uint b
 * @funcNode {ASTNode} Contract Definition node
 * @return {parameterlist node} parameterlist node
 */

function getFunctionOrModifierDefinitionParameterPart(funcNode) {
  if (!nodeTypeIn(funcNode, [exactMatch(nodeTypes.FUNCTIONDEFINITION), exactMatch(nodeTypes.MODIFIERDEFINITION)])) throw new Error('staticAnalysisCommon.js: not a FunctionDefinition or ModifierDefinition Node');
  return funcNode.parameters;
}

exports.getFunctionOrModifierDefinitionParameterPart = getFunctionOrModifierDefinitionParameterPart;
/**
 * Returns return parameter node for a function or modifier definition, Throws on wrong node.
 * Example:
 * function bar(uint a, uint b) returns (bool a, bool b) => bool a, bool b
 * @funcNode {ASTNode} Contract Definition node
 * @return {parameterlist node} parameterlist node
 */

function getFunctionDefinitionReturnParameterPart(funcNode) {
  return funcNode.returnParameters;
}

exports.getFunctionDefinitionReturnParameterPart = getFunctionDefinitionReturnParameterPart;
/**
 * Extracts the parameter types for a function type signature
 * Example:
 * function(uint a, uint b) returns (bool) => uint a, uint b
 * @func {ASTNode} function call node
 * @return {string} parameter signature
 */

function getFunctionCallTypeParameterType(func) {
  const type = getFunctionCallType(func);

  if (type.startsWith('function (')) {
    let paramTypes = '';
    let openPar = 1;

    for (let x = 10; x < type.length; x++) {
      const c = type.charAt(x);
      if (c === '(') openPar++;else if (c === ')') openPar--;
      if (openPar === 0) return paramTypes;
      paramTypes += c;
    }
  } else {
    throw new Error('staticAnalysisCommon.js: cannot extract parameter types from function call');
  }
}

exports.getFunctionCallTypeParameterType = getFunctionCallTypeParameterType;
/**
 * Returns the name of the library called, Throws on wrong node.
 * Example:
 *  library set{...}
 *  contract foo {
 *    ...
 *    function () { set.union() => set}
 * @funcCall {ASTNode} function call node
 * @return {string} name of the lib defined
 */

function getLibraryCallContractName(node) {
  if (!isLibraryCall(node.expression)) throw new Error('staticAnalysisCommon.js: not a library call Node');
  const types = new RegExp(basicRegex.LIBRARYTYPE).exec(node.expression.expression.typeDescriptions.typeString);

  if (types) {
    return types[1];
  }
}

exports.getLibraryCallContractName = getLibraryCallContractName;
/**
 * Returns the name of the function of a library call, Throws on wrong node.
 * Example:
 *  library set{...}
 *  contract foo {
 *    ...
 *    function () { set.union() => uinion}
 * @func {ASTNode} function call node
 * @return {string} name of function called on the library
 */

function getLibraryCallMemberName(funcCall) {
  if (!isLibraryCall(funcCall.expression)) throw new Error('staticAnalysisCommon.js: not a library call Node');
  return funcCall.expression.memberName;
}

exports.getLibraryCallMemberName = getLibraryCallMemberName;
/**
 * Returns full qualified name for a function call, Throws on wrong node.
 * Example:
 *  contract foo {
 *    ...
 *    function bar(uint b) { }
 *    function baz() {
 *      bar(10) => foo.bar(uint)
 * @func {ASTNode} function call node
 * @func {ASTNode} contract defintion
 * @return {string} full qualified identifier for the function call
 */

function getFullQualifiedFunctionCallIdent(contract, func) {
  if (isLocalCall(func)) return getContractName(contract) + '.' + getLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isThisLocalCall(func.expression)) return getThisLocalCallContractName(func) + '.' + getThisLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isSuperLocalCall(func.expression)) return getContractName(contract) + '.' + getSuperLocalCallName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isExternalDirectCall(func)) return getExternalDirectCallContractName(func) + '.' + getExternalDirectCallMemberName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else if (isLibraryCall(func.expression)) return getLibraryCallContractName(func) + '.' + getLibraryCallMemberName(func) + '(' + getFunctionCallTypeParameterType(func) + ')';else throw new Error('staticAnalysisCommon.js: Can not get function name from non function call node');
}

exports.getFullQualifiedFunctionCallIdent = getFullQualifiedFunctionCallIdent;

function getFullQuallyfiedFuncDefinitionIdent(contract, func, paramTypes) {
  return getContractName(contract) + '.' + getFunctionDefinitionName(func) + '(' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')';
}

exports.getFullQuallyfiedFuncDefinitionIdent = getFullQuallyfiedFuncDefinitionIdent;

function getUnAssignedTopLevelBinOps(subScope) {
  let result = [];
  if (subScope && subScope.nodeType === 'Block') result = subScope.statements.filter(isBinaryOpInExpression); // for 'without braces' loops
  else if (subScope && subScope.nodeType && subScope.nodeType !== 'Block' && isSubScopeStatement(subScope)) {
    if (subScope.nodeType === 'IfStatement') {
      if (subScope.trueBody && subScope.trueBody.nodeType === 'ExpressionStatement' && isBinaryOpInExpression(subScope.trueBody)) {
        result.push(subScope.trueBody);
      }

      if (subScope.falseBody && subScope.falseBody.nodeType === 'ExpressionStatement' && isBinaryOpInExpression(subScope.falseBody)) {
        result.push(subScope.falseBody);
      }
    } else {
      if (subScope.body && subScope.body.nodeType === 'ExpressionStatement' && isBinaryOpInExpression(subScope.body)) {
        result.push(subScope.body);
      }
    }
  }
  return result;
}

exports.getUnAssignedTopLevelBinOps = getUnAssignedTopLevelBinOps; // #################### Trivial Node Identification
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function isStatement(node) {
  return nodeType(node, 'Statement$') || node.nodeType === 'Block' || node.nodeType === 'Return';
}

exports.isStatement = isStatement; // #################### Complex Node Identification

/**
 * True if function defintion has function body
 * @funcNode {ASTNode} function defintion node
 * @return {bool}
 */

function hasFunctionBody(funcNode) {
  return funcNode.body !== null;
}

exports.hasFunctionBody = hasFunctionBody;
/**
 * True if node is a delete instruction of a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDeleteOfDynamicArray(node) {
  return isDeleteUnaryOperation(node) && isDynamicArrayAccess(node.subExpression);
}

exports.isDeleteOfDynamicArray = isDeleteOfDynamicArray;
/**
 * True if node is node is a ref to a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDynamicArrayAccess(node) {
  return getType(node).endsWith('[] storage ref') || typeDescription(node, 'bytes storage ref') || typeDescription(node, 'string storage ref');
}

exports.isDynamicArrayAccess = isDynamicArrayAccess;
/**
 * True if node accesses 'length' member of dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDynamicArrayLengthAccess(node) {
  return node.memberName === 'length' && // accessing 'length' member
  node.expression.typeDescriptions.typeString.indexOf('[]') !== -1; // member is accessed from dynamic array, notice [] without any number
}

exports.isDynamicArrayLengthAccess = isDynamicArrayLengthAccess;
/**
 * True if node is a delete instruction for an element from a dynamic array
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isDeleteFromDynamicArray(node) {
  return isDeleteUnaryOperation(node) && node.subExpression.nodeType === 'IndexAccess';
}

exports.isDeleteFromDynamicArray = isDeleteFromDynamicArray;
/**
 * True if node is the access of a mapping index
 * @node {ASTNode} node to check for
 * @return {bool}
 */

function isMappingIndexAccess(node) {
  return node.typeDescriptions.typeString.startsWith('mapping');
}

exports.isMappingIndexAccess = isMappingIndexAccess;
/**
 * True if call to code within the current contracts context including (delegate) library call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLocalCallGraphRelevantNode(node) {
  return (isLocalCall(node) || isSuperLocalCall(node.expression) || isLibraryCall(node.expression)) && !isBuiltinFunctionCall(node);
}

exports.isLocalCallGraphRelevantNode = isLocalCallGraphRelevantNode;
/**
 * True if is builtin function like assert, sha3, erecover, ...
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBuiltinFunctionCall(node) {
  return node.nodeType === 'FunctionCall' && isLocalCall(node) && builtinFunctions[getLocalCallName(node) + '(' + getFunctionCallTypeParameterType(node) + ')'] === true || isAbiNamespaceCall(node);
}

exports.isBuiltinFunctionCall = isBuiltinFunctionCall;
/**
 * True if is builtin function like assert, sha3, erecover, ...
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isAbiNamespaceCall(node) {
  return Object.keys(abiNamespace).some(key => Object.prototype.hasOwnProperty.call(abiNamespace, key) && node.expression && isSpecialVariableAccess(node.expression, abiNamespace[key]));
}

exports.isAbiNamespaceCall = isAbiNamespaceCall;
/**
 * True if node is a call to selfdestruct
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSelfdestructCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'selfdestruct';
}

exports.isSelfdestructCall = isSelfdestructCall;
/**
 * True if node is a call to builtin assert(bool)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isAssertCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'assert';
}

exports.isAssertCall = isAssertCall;
/**
 * True if node is a call to builtin require(bool)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isRequireCall(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'require';
}

exports.isRequireCall = isRequireCall;
/**
 * True if is storage variable declaration
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isStorageVariableDeclaration(node) {
  return node.storageLocation === 'storage' && new RegExp(basicRegex.REFTYPE).test(node.typeDescriptions.typeIdentifier);
}

exports.isStorageVariableDeclaration = isStorageVariableDeclaration;
/**
 * True if is interaction with external contract (change in context, no delegate calls) (send, call of other contracts)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isInteraction(node) {
  return isLLCall(node.expression) || isLLSend(node.expression) || isExternalDirectCall(node) || isTransfer(node.expression) || isLLCall04(node.expression) || isLLSend04(node.expression) || // to cover case of address.call.value.gas , See: inheritance.sol
  node.expression && node.expression.expression && isLLCall(node.expression.expression) || node.expression && node.expression.expression && isLLCall04(node.expression.expression);
}

exports.isInteraction = isInteraction;
/**
 * True if node changes state of a variable or is inline assembly (does not include check if it is a global state change, on a state variable)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isEffect(node) {
  return node.nodeType === 'Assignment' || node.nodeType === 'UnaryOperation' && (isPlusPlusUnaryOperation(node) || isMinusMinusUnaryOperation(node)) || node.nodeType === 'InlineAssembly';
}

exports.isEffect = isEffect;
/**
 * True if node changes state of a variable or is inline assembly (Checks if variable is a state variable via provided list)
 * @node {ASTNode} some AstNode
 * @node {list Variable declaration} state variable declaration currently in scope
 * @return {bool}
 */

function isWriteOnStateVariable(effectNode, stateVariables) {
  return effectNode.nodeType === 'InlineAssembly' || isEffect(effectNode) && isStateVariable(getEffectedVariableName(effectNode), stateVariables);
}

exports.isWriteOnStateVariable = isWriteOnStateVariable;
/**
 * True if there is a variable with name, name in stateVariables
 * @node {ASTNode} some AstNode
 * @node {list Variable declaration} state variable declaration currently in scope
 * @return {bool}
 */

function isStateVariable(name, stateVariables) {
  return stateVariables.some(item => item.stateVariable && name === getDeclaredVariableName(item));
}

exports.isStateVariable = isStateVariable;
/**
 * True if is function defintion that is flaged as constant
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isConstantFunction(node) {
  return node.stateMutability === 'view' || node.stateMutability === 'pure';
}

exports.isConstantFunction = isConstantFunction;
/**
* True if variable decalaration is converted into a getter method
 * @node {ASTNode} variable declaration AstNode
 * @return {bool}
 */

function isVariableTurnedIntoGetter(varDeclNode) {
  return varDeclNode.stateVariable && varDeclNode.visibility === 'public';
}

exports.isVariableTurnedIntoGetter = isVariableTurnedIntoGetter;
/**
 * True if is function defintion has payable modifier
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isPayableFunction(node) {
  return node.stateMutability === 'payable';
}

exports.isPayableFunction = isPayableFunction;
/**
 * True if is constructor
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isConstructor(node) {
  return node.kind === 'constructor';
}

exports.isConstructor = isConstructor;
/**
 * True if node is integer division that truncates (not only int literals since those yield a rational value)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isIntDivision(node) {
  return operator(node, exactMatch(remix_lib_1.util.escapeRegExp('/'))) && typeDescription(node.rightExpression, remix_lib_1.util.escapeRegExp('int'));
}

exports.isIntDivision = isIntDivision;
/**
 * True if is block / SubScope has top level binops (e.g. that are not assigned to anything, most of the time confused compare instead of assign)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSubScopeWithTopLevelUnAssignedBinOp(node) {
  if (node.nodeType === 'Block') return node.statements.some(isBinaryOpInExpression); // for 'without braces' loops
  else if (node && node.nodeType && isSubScopeStatement(node)) {
    if (node.nodeType === 'IfStatement') {
      return node.trueBody && node.trueBody.nodeType === 'ExpressionStatement' && isBinaryOpInExpression(node.trueBody) || node.falseBody && node.falseBody.nodeType === 'ExpressionStatement' && isBinaryOpInExpression(node.falseBody);
    } else {
      return node.body && node.body.nodeType === 'ExpressionStatement' && isBinaryOpInExpression(node.body);
    }
  }
}

exports.isSubScopeWithTopLevelUnAssignedBinOp = isSubScopeWithTopLevelUnAssignedBinOp;

function isSubScopeStatement(node) {
  if (node.nodeType === 'IfStatement') {
    return node.trueBody && node.trueBody.nodeType && !nodeType(node.trueBody, exactMatch(nodeTypes.BLOCK)) || node.falseBody && node.falseBody.nodeType && !nodeType(node.falseBody, exactMatch(nodeTypes.BLOCK));
  } else {
    return node.body && node.body.nodeType && !nodeType(node.body, exactMatch(nodeTypes.BLOCK));
  }
}
/**
 * True if binary operation inside of expression statement
 * @node {ASTNode} some AstNode
 * @return {bool}
 */


function isBinaryOpInExpression(node) {
  return node.nodeType === 'ExpressionStatement' && node.expression.nodeType === 'BinaryOperation';
}
/**
 * True if unary increment operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */


function isPlusPlusUnaryOperation(node) {
  return node.operator === '++';
}

exports.isPlusPlusUnaryOperation = isPlusPlusUnaryOperation;
/**
 * True if unary delete operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isDeleteUnaryOperation(node) {
  return node.operator === 'delete';
}

exports.isDeleteUnaryOperation = isDeleteUnaryOperation;
/**
 * True if unary decrement operation
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isMinusMinusUnaryOperation(node) {
  return node.operator === '--';
}

exports.isMinusMinusUnaryOperation = isMinusMinusUnaryOperation;
/**
 * True if all functions on a contract are implemented
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isFullyImplementedContract(node) {
  return node.fullyImplemented === true;
}

exports.isFullyImplementedContract = isFullyImplementedContract;
/**
 * True if it is a library contract defintion
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLibrary(node) {
  return node.contractKind === 'library';
}

exports.isLibrary = isLibrary;
/**
 * True if it is a local call to non const function
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isCallToNonConstLocalFunction(node) {
  return isLocalCall(node) && !expressionTypeDescription(node, basicRegex.CONSTANTFUNCTIONTYPE);
}

exports.isCallToNonConstLocalFunction = isCallToNonConstLocalFunction;
/**
 * True if it is a call to a library
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLibraryCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, undefined, basicRegex.LIBRARYTYPE, undefined);
}

exports.isLibraryCall = isLibraryCall;
/**
 * True if it is an external call via defined interface (not low level call)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isExternalDirectCall(node) {
  return isMemberAccess(node.expression, basicRegex.EXTERNALFUNCTIONTYPE, undefined, basicRegex.CONTRACTTYPE, undefined) && !isThisLocalCall(node.expression) && !isSuperLocalCall(node.expression);
}

exports.isExternalDirectCall = isExternalDirectCall;
/**
 * True if access to block.timestamp via now alias
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isNowAccess(node) {
  return node.name === 'now' && typeDescription(node, exactMatch(basicTypes.UINT));
}

exports.isNowAccess = isNowAccess;
/**
 * True if access to block.timestamp via now alias
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isTxOriginAccess(node) {
  return isMemberAccess(node, 'address', 'tx', 'tx', 'origin');
}

exports.isTxOriginAccess = isTxOriginAccess;
/**
 * True if access to block.timestamp
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBlockTimestampAccess(node) {
  return isSpecialVariableAccess(node, specialVariables.BLOCKTIMESTAMP);
}

exports.isBlockTimestampAccess = isBlockTimestampAccess;
/**
 * True if access to block.blockhash
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isBlockBlockHashAccess(node) {
  return isBuiltinFunctionCall(node) && getLocalCallName(node) === 'blockhash' || isSpecialVariableAccess(node.expression, specialVariables.BLOCKHASH);
}

exports.isBlockBlockHashAccess = isBlockBlockHashAccess;
/**
 * True if call to local function via this keyword
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isThisLocalCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, exactMatch('this'), basicRegex.CONTRACTTYPE, undefined);
}

exports.isThisLocalCall = isThisLocalCall;
/**
 * True if access to local function via super keyword
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isSuperLocalCall(node) {
  return isMemberAccess(node, basicRegex.FUNCTIONTYPE, exactMatch('super'), basicRegex.CONTRACTTYPE, undefined);
}

exports.isSuperLocalCall = isSuperLocalCall;
/**
 * True if call to local function
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLocalCall(node) {
  return node.nodeType === 'FunctionCall' && node.kind === 'functionCall' && node.expression.nodeType === 'Identifier' && expressionTypeDescription(node, basicRegex.FUNCTIONTYPE) && !expressionTypeDescription(node, basicRegex.EXTERNALFUNCTIONTYPE);
}

exports.isLocalCall = isLocalCall;
/**
 * True if low level call (send, call, delegatecall, callcode)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLowLevelCall(node) {
  return isLLCall(node) || isLLDelegatecall(node) || isLLSend(node) || isLLSend04(node) || isLLCallcode(node) || isLLCall04(node) || isLLDelegatecall04(node);
}

exports.isLowLevelCall = isLowLevelCall;
/**
 * True if low level send (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLSend04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.SEND.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.SEND.ident));
}

exports.isLLSend04 = isLLSend04;
/**
 * True if low level send (solidity >= 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLSend(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.SEND.type)), undefined, exactMatch(basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.SEND.ident));
}

exports.isLLSend = isLLSend;
/**
 * True if low level call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCall(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALL.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.CALL.ident)) || isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALL.type)), undefined, exactMatch(basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.CALL.ident));
}

exports.isLLCall = isLLCall;
/**
 * True if low level payable call (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCall04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes['CALL-0.4'].type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes['CALL-0.4'].ident));
}

exports.isLLCall04 = isLLCall04;
/**
 * True if low level callcode
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLCallcode(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.CALLCODE.type)), undefined, exactMatch(basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.CALLCODE.ident));
}

exports.isLLCallcode = isLLCallcode;
/**
 * True if low level delegatecall
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLDelegatecall(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.DELEGATECALL.type)), undefined, matches(basicTypes.PAYABLE_ADDRESS, basicTypes.ADDRESS), exactMatch(lowLevelCallTypes.DELEGATECALL.ident));
}

exports.isLLDelegatecall = isLLDelegatecall;
/**
 * True if low level delegatecall (solidity < 0.5)
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isLLDelegatecall04(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes['DELEGATECALL-0.4'].type)), undefined, matches(basicTypes.PAYABLE_ADDRESS, basicTypes.ADDRESS), exactMatch(lowLevelCallTypes['DELEGATECALL-0.4'].ident));
}

exports.isLLDelegatecall04 = isLLDelegatecall04;
/**
 * True if transfer call
 * @node {ASTNode} some AstNode
 * @return {bool}
 */

function isTransfer(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(lowLevelCallTypes.TRANSFER.type)), undefined, matches(basicTypes.ADDRESS, basicTypes.PAYABLE_ADDRESS), exactMatch(lowLevelCallTypes.TRANSFER.ident));
}

exports.isTransfer = isTransfer;

function isStringToBytesConversion(node) {
  return isExplicitCast(node, remix_lib_1.util.escapeRegExp('string *'), remix_lib_1.util.escapeRegExp('bytes'));
}

exports.isStringToBytesConversion = isStringToBytesConversion;

function isExplicitCast(node, castFromType, castToType) {
  return node.kind === 'typeConversion' && nodeType(node.expression, exactMatch(nodeTypes.ELEMENTARYTYPENAMEEXPRESSION)) && node.expression.typeName === castToType && nodeType(node.arguments[0], exactMatch(nodeTypes.IDENTIFIER)) && typeDescription(node.arguments[0], castFromType);
}

function isBytesLengthCheck(node) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(basicTypes.UINT)), undefined, remix_lib_1.util.escapeRegExp('bytes *'), 'length');
}

exports.isBytesLengthCheck = isBytesLengthCheck;
/**
 * True if it is a loop
 * @node {ASTNode} some AstNode
 * @return {bool}
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function isLoop(node) {
  return nodeType(node, exactMatch(nodeTypes.FORSTATEMENT)) || nodeType(node, exactMatch(nodeTypes.WHILESTATEMENT)) || nodeType(node, exactMatch(nodeTypes.DOWHILESTATEMENT));
}

exports.isLoop = isLoop; // #################### Complex Node Identification - Private

function isMemberAccess(node, retType, accessor, accessorType, memberName) {
  if (node && nodeType(node, exactMatch('MemberAccess'))) {
    const nodeTypeDef = typeDescription(node, retType);
    const nodeMemName = memName(node, memberName);
    const nodeExpMemName = memName(node.expression, accessor);
    const nodeExpTypeDef = expressionTypeDescription(node, accessorType);
    return nodeTypeDef && nodeMemName && nodeExpTypeDef && nodeExpMemName;
  } else return false;
}

function isSpecialVariableAccess(node, varType) {
  return isMemberAccess(node, exactMatch(remix_lib_1.util.escapeRegExp(varType.type)), varType.obj, varType.obj, varType.member);
}

exports.isSpecialVariableAccess = isSpecialVariableAccess; // #################### Node Identification Primitives
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function expressionTypeDescription(node, typeRegex) {
  return new RegExp(typeRegex).test(node.expression.typeDescriptions.typeString);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function typeDescription(node, typeRegex) {
  return new RegExp(typeRegex).test(node.typeDescriptions.typeString);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function nodeType(node, typeRegex) {
  return new RegExp(typeRegex).test(node.nodeType);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function nodeTypeIn(node, typeRegex) {
  return typeRegex.some(typeRegex => nodeType(node, typeRegex));
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function memName(node, memNameRegex) {
  return node && !memNameRegex || new RegExp(memNameRegex).test(node.name) || new RegExp(memNameRegex).test(node.memberName);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function operator(node, opRegex) {
  return new RegExp(opRegex).test(node.operator);
} // #################### Helpers


function exactMatch(regexStr) {
  return '^' + regexStr + '$';
}

function matches(...fnArgs) {
  const args = [];

  for (let k = 0; k < fnArgs.length; k++) {
    args.push(fnArgs[k]);
  }

  return '(' + args.join('|') + ')';
}
/**
 * Finds first node of a certain type under a specific node.
 * @node {AstNode} node to start form
 * @type {String} Type the ast node should have
 * @return {AstNode} null or node found
 * Note: developed keeping identifier node search in mind to get first identifier node from left in subscope
 */


function findFirstSubNodeLTR(node, type) {
  if (node.nodeType && nodeType(node, type)) {
    return node;
  } else if (node.nodeType && nodeType(node, exactMatch('Assignment'))) {
    return findFirstSubNodeLTR(node.leftHandSide, type);
  } else if (node.nodeType && nodeType(node, exactMatch('MemberAccess'))) {
    return findFirstSubNodeLTR(node.expression, type);
  } else if (node.nodeType && nodeType(node, exactMatch('IndexAccess'))) {
    return findFirstSubNodeLTR(node.baseExpression, type);
  } else if (node.nodeType && nodeType(node, exactMatch('UnaryOperation'))) {
    return findFirstSubNodeLTR(node.subExpression, type);
  }
}
/**
 * Builds a function signature as used in the AST of the solc-json AST
 * @param {Array} paramTypes
 *  list of parameter type names
 * @param {Array} returnTypes
 *  list of return type names
 * @return {Boolean} isPayable
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


function buildFunctionSignature(paramTypes, returnTypes, isPayable, additionalMods) {
  return 'function (' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')' + (isPayable ? ' payable' : '') + (additionalMods ? ' ' + additionalMods : '') + (returnTypes.length ? ' returns (' + remix_lib_1.util.concatWithSeperator(returnTypes, ',') + ')' : '');
}

function buildAbiSignature(funName, paramTypes) {
  return funName + '(' + remix_lib_1.util.concatWithSeperator(paramTypes, ',') + ')';
} // To create the method signature similar to contract.evm.gasEstimates.external object
// For address payable, return address


function getMethodParamsSplittedTypeDesc(node, contracts) {
  return node.parameters.parameters.map((varNode, varIndex) => {
    let finalTypeString;
    const typeString = varNode.typeDescriptions.typeString;

    if (typeString.includes('struct')) {
      const fnName = node.name;

      for (const filename in contracts) {
        for (const contractName in contracts[filename]) {
          const methodABI = contracts[filename][contractName].abi.find(e => {
            var _a;

            return e.name === fnName && ((_a = e.inputs) === null || _a === void 0 ? void 0 : _a.length) && e.inputs[varIndex]['type'].includes('tuple') && e.inputs[varIndex]['internalType'] === typeString;
          });

          if (methodABI && methodABI.inputs) {
            const inputs = methodABI.inputs[varIndex];
            const typeStr = getTypeStringFromComponents(inputs['components']);
            finalTypeString = typeStr + inputs['type'].replace('tuple', '');
          }
        }
      }
    } else {
      finalTypeString = typeString.split(' ')[0];
    }

    return finalTypeString;
  });
}

exports.getMethodParamsSplittedTypeDesc = getMethodParamsSplittedTypeDesc;

function getTypeStringFromComponents(components) {
  let typeString = '(';

  for (let i = 0; i < components.length; i++) {
    const param = components[i];

    if (param.type.includes('tuple') && param.components && param.components.length > 0) {
      typeString = typeString + getTypeStringFromComponents(param.components);
      typeString = typeString + param.type.replace('tuple', '');
    } else {
      typeString = typeString + param.type;
    }

    if (i !== components.length - 1) {
      typeString = typeString + ',';
    }
  }

  typeString = typeString + ')';
  return typeString;
}
/**
 * Get compiler version from compiler contract object
 * This is used to redirect the user to specific version of Solidity documentation
 * @param contractFiles compiled contract object
 */


function getCompilerVersion(contractFiles) {
  let version = 'latest';
  const fileNames = Object.keys(contractFiles);
  const contracts = contractFiles[fileNames[0]];
  const contractNames = Object.keys(contracts);
  const contract = contracts[contractNames[0]]; // For some compiler/contract,  metadata is ""

  if (contract && contract.metadata) {
    const metadata = JSON.parse(contract.metadata);
    const compilerVersion = metadata.compiler.version;

    if (!compilerVersion.includes('nightly')) {
      version = 'v' + compilerVersion.split('+commit')[0];
    }
  }

  return version;
}

exports.getCompilerVersion = getCompilerVersion;
const helpers = {
  expressionTypeDescription,
  nodeType,
  memName,
  operator,
  buildFunctionSignature,
  buildAbiSignature
};
exports.helpers = helpers;

/***/ }),
/* 1123 */,
/* 1124 */,
/* 1125 */,
/* 1126 */,
/* 1127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  SECURITY: {
    displayName: 'Security',
    id: 'SEC'
  },
  GAS: {
    displayName: 'Gas & Economy',
    id: 'GAS'
  },
  MISC: {
    displayName: 'Miscellaneous',
    id: 'MISC'
  },
  ERC: {
    displayName: 'ERC',
    id: 'ERC'
  }
};

/***/ }),
/* 1128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
  * Should be used to categorize different modules, main reason is to give users feedback if the modules
  * Produce exact results or have false positives and negatives in them
  * A further category could be approximate if some form of approximation is used
*/

exports.default = {
  EXACT: {
    hasFalsePositives: false,
    hasFalseNegatives: false,
    id: 'EXACT'
  },
  HEURISTIC: {
    hasFalsePositives: true,
    hasFalseNegatives: true,
    id: 'HEURI'
  }
};

/***/ }),
/* 1129 */,
/* 1130 */,
/* 1131 */,
/* 1132 */,
/* 1133 */,
/* 1134 */,
/* 1135 */,
/* 1136 */,
/* 1137 */,
/* 1138 */,
/* 1139 */,
/* 1140 */,
/* 1141 */,
/* 1142 */,
/* 1143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeHex = exports.extractLocationFromAstVariable = exports.extractLocation = exports.removeLocation = exports.sub = exports.add = exports.toBN = exports.extractHexValue = exports.extractHexByteSlice = exports.readFromStorage = exports.decodeIntFromHex = void 0;

const tslib_1 = __webpack_require__(23);

const ethereumjs_util_1 = __webpack_require__(34);

function decodeIntFromHex(value, byteLength, signed) {
  let bigNumber = new ethereumjs_util_1.BN(value, 16);

  if (signed) {
    bigNumber = bigNumber.fromTwos(8 * byteLength);
  }

  return bigNumber.toString(10);
}

exports.decodeIntFromHex = decodeIntFromHex;

function readFromStorage(slot, storageResolver) {
  const hexSlot = '0x' + normalizeHex((0, ethereumjs_util_1.bufferToHex)(slot));
  return new Promise((resolve, reject) => {
    storageResolver.storageSlot(hexSlot, (error, slot) => {
      if (error) {
        return reject(error);
      }

      if (!slot) {
        slot = {
          key: slot,
          value: ''
        };
      }

      return resolve(normalizeHex(slot.value));
    });
  });
}

exports.readFromStorage = readFromStorage;
/**
 * @returns a hex encoded byte slice of length @arg byteLength from inside @arg slotValue.
 *
 * @param {String} slotValue  - hex encoded value to extract the byte slice from
 * @param {Int} byteLength  - Length of the byte slice to extract
 * @param {Int} offsetFromLSB  - byte distance from the right end slot value to the right end of the byte slice
 */

function extractHexByteSlice(slotValue, byteLength, offsetFromLSB) {
  const offset = slotValue.length - 2 * offsetFromLSB - 2 * byteLength;
  return slotValue.substr(offset, 2 * byteLength);
}

exports.extractHexByteSlice = extractHexByteSlice;
/**
 * @returns a hex encoded storage content at the given @arg location. it does not have Ox prefix but always has the full length.
 *
 * @param {Object} location  - object containing the slot and offset of the data to extract.
 * @param {Object} storageResolver  - storage resolver
 * @param {Int} byteLength  - Length of the byte slice to extract
 */

function extractHexValue(location, storageResolver, byteLength) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    let slotvalue;

    try {
      slotvalue = yield readFromStorage(location.slot, storageResolver);
    } catch (e) {
      return '';
    }

    return extractHexByteSlice(slotvalue, byteLength, location.offset);
  });
}

exports.extractHexValue = extractHexValue;

function toBN(value) {
  if (value instanceof ethereumjs_util_1.BN) {
    return value;
  } else if (value.match && value.match(/^(0x)?([a-f0-9]*)$/)) {
    value = (0, ethereumjs_util_1.unpadHexString)(value);
    value = new ethereumjs_util_1.BN(value === '' ? '0' : value, 16);
  } else if (!isNaN(value)) {
    value = new ethereumjs_util_1.BN(value);
  }

  return value;
}

exports.toBN = toBN;

function add(value1, value2) {
  return toBN(value1).add(toBN(value2));
}

exports.add = add;

function sub(value1, value2) {
  return toBN(value1).sub(toBN(value2));
}

exports.sub = sub;

function removeLocation(type) {
  return type.replace(/( storage ref| storage pointer| memory| calldata)/g, '');
}

exports.removeLocation = removeLocation;

function extractLocation(type) {
  const match = type.match(/( storage ref| storage pointer| memory| calldata)?$/);

  if (match[1] !== '') {
    return match[1].trim();
  }

  return null;
}

exports.extractLocation = extractLocation;

function extractLocationFromAstVariable(node) {
  if (node.storageLocation !== 'default') {
    return node.storageLocation;
  } else if (node.stateVariable) {
    return 'storage';
  }

  return 'default'; // local variables => storage, function parameters & return values => memory, state => storage
}

exports.extractLocationFromAstVariable = extractLocationFromAstVariable;

function normalizeHex(hex) {
  hex = hex.replace('0x', '');

  if (hex.length < 64) {
    return new Array(64 - hex.length + 1).join('0') + hex;
  }

  return hex;
}

exports.normalizeHex = normalizeHex;

/***/ }),
/* 1144 */,
/* 1145 */,
/* 1146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isContractCreation = exports.contractCreationToken = exports.isCallToPrecompiledContract = exports.newContextStorage = exports.isSHA3Instruction = exports.isSSTOREInstruction = exports.isRevertInstruction = exports.isStopInstruction = exports.isJumpDestInstruction = exports.isReturnInstruction = exports.isCreateInstruction = exports.isCallInstruction = exports.resolveCalledAddress = void 0;

const remix_lib_1 = __webpack_require__(311);

const {
  ui
} = remix_lib_1.helpers; // vmTraceIndex has to point to a CALL, CODECALL, ...

function resolveCalledAddress(vmTraceIndex, trace) {
  const step = trace[vmTraceIndex];

  if (isCreateInstruction(step)) {
    return contractCreationToken(vmTraceIndex);
  } else if (isCallInstruction(step)) {
    const stack = step.stack; // callcode, delegatecall, ...

    return ui.normalizeHexAddress(stack[stack.length - 2]);
  }

  return undefined;
}

exports.resolveCalledAddress = resolveCalledAddress;

function isCallInstruction(step) {
  return ['CALL', 'STATICCALL', 'CALLCODE', 'CREATE', 'DELEGATECALL', 'CREATE2'].includes(step.op);
}

exports.isCallInstruction = isCallInstruction;

function isCreateInstruction(step) {
  return step.op === 'CREATE' || step.op === 'CREATE2';
}

exports.isCreateInstruction = isCreateInstruction;

function isReturnInstruction(step) {
  return step.op === 'RETURN';
}

exports.isReturnInstruction = isReturnInstruction;

function isJumpDestInstruction(step) {
  return step.op === 'JUMPDEST';
}

exports.isJumpDestInstruction = isJumpDestInstruction;

function isStopInstruction(step) {
  return step.op === 'STOP';
}

exports.isStopInstruction = isStopInstruction;

function isRevertInstruction(step) {
  return step.op === 'REVERT';
}

exports.isRevertInstruction = isRevertInstruction;

function isSSTOREInstruction(step) {
  return step.op === 'SSTORE';
}

exports.isSSTOREInstruction = isSSTOREInstruction;

function isSHA3Instruction(step) {
  return step.op === 'SHA3';
}

exports.isSHA3Instruction = isSHA3Instruction;

function newContextStorage(step) {
  return step.op === 'CREATE' || step.op === 'CALL' || step.op === 'CREATE2';
}

exports.newContextStorage = newContextStorage;

function isCallToPrecompiledContract(index, trace) {
  // if stack empty => this is not a precompiled contract
  const step = trace[index];

  if (isCallInstruction(step)) {
    return index + 1 < trace.length && trace[index + 1].stack.length !== 0;
  }

  return false;
}

exports.isCallToPrecompiledContract = isCallToPrecompiledContract;

function contractCreationToken(index) {
  return '(Contract Creation - Step ' + index + ')';
}

exports.contractCreationToken = contractCreationToken;

function isContractCreation(address) {
  return address.indexOf('(Contract Creation - Step') !== -1;
}

exports.isContractCreation = isContractCreation;

/***/ }),
/* 1147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchProvider = exports.SearchContext = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _SearchHelper = __webpack_require__(2448);

var _Reducer = __webpack_require__(2449);

var _types = __webpack_require__(1580);

var _filePathFilter = __webpack_require__(2450);

var _lodash = __webpack_require__(1361);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SearchContext = /*#__PURE__*/(0, _react.createContext)(null);
exports.SearchContext = SearchContext;

const SearchProvider = ({
  children: _children = [],
  reducer: _reducer = _Reducer.SearchReducer,
  initialState: _initialState = _types.SearchingInitialState,
  plugin: _plugin = undefined
} = {}) => {
  const [state, dispatch] = (0, _react.useReducer)(_reducer, _initialState);
  const [files, setFiles] = (0, _react.useState)([]);
  const clearSearchingTimeout = (0, _react.useRef)(null);
  const value = {
    state,
    setFind: value => {
      _plugin.cancel('fileManager');

      dispatch({
        type: 'SET_FIND',
        payload: value
      });
    },
    setReplace: value => {
      dispatch({
        type: 'SET_REPLACE',
        payload: value
      });
    },
    setReplaceEnabled: value => {
      dispatch({
        type: 'SET_REPLACE_ENABLED',
        payload: value
      });
    },
    setInclude: value => {
      dispatch({
        type: 'SET_INCLUDE',
        payload: value
      });
    },

    setExclude(value) {
      dispatch({
        type: 'SET_EXCLUDE',
        payload: value
      });
    },

    setCaseSensitive(value) {
      dispatch({
        type: 'SET_CASE_SENSITIVE',
        payload: value
      });
    },

    setWholeWord(value) {
      dispatch({
        type: 'SET_WHOLE_WORD',
        payload: value
      });
    },

    setRegex(value) {
      dispatch({
        type: 'SET_REGEX',
        payload: value
      });
    },

    setSearchResults(value) {
      dispatch({
        type: 'SET_SEARCH_RESULTS',
        payload: value
      });
    },

    reloadFile: async file => {
      dispatch({
        type: 'RELOAD_FILE',
        payload: file
      });
    },
    toggleUseRegex: () => {
      dispatch({
        type: 'TOGGLE_USE_REGEX',
        payload: undefined
      });
    },
    toggleCaseSensitive: () => {
      dispatch({
        type: 'TOGGLE_CASE_SENSITIVE',
        payload: undefined
      });
    },
    toggleMatchWholeWord: () => {
      dispatch({
        type: 'TOGGLE_MATCH_WHOLE_WORD',
        payload: undefined
      });
    },
    setReplaceWithoutConfirmation: value => {
      dispatch({
        type: 'SET_REPLACE_WITHOUT_CONFIRMATION',
        payload: value
      });
    },
    disableForceReload: file => {
      dispatch({
        type: 'DISABLE_FORCE_RELOAD',
        payload: file
      });
    },
    setCurrentFile: file => {
      dispatch({
        type: 'SET_CURRENT_FILE',
        payload: file
      });
    },
    setCurrentWorkspace: workspace => {
      dispatch({
        type: 'SET_CURRENT_WORKSPACE',
        payload: workspace
      });
    },
    updateCount: (count, file) => {
      dispatch({
        type: 'UPDATE_COUNT',
        payload: {
          count,
          file
        }
      });
    },

    setSearching(file) {
      dispatch({
        type: 'SET_SEARCHING',
        payload: file
      });
    },

    startSearch: () => {
      dispatch({
        type: 'START_SEARCH',
        payload: undefined
      });
    },

    setRun(value) {
      dispatch({
        type: 'SET_RUN',
        payload: value
      });
    },

    findText: async path => {
      if (!_plugin) return;

      try {
        if (state.find.length < 1) return;
        value.setSearching(path);
        const text = await _plugin.call('fileManager', 'readFile', path);
        const result = (0, _SearchHelper.findLinesInStringWithMatch)(text, createRegExFromFind());
        clearTimeout(clearSearchingTimeout.current);
        clearSearchingTimeout.current = setTimeout(() => value.setSearching(null), 500);
        return result;
      } catch (e) {
        console.log(e);
        value.setSearching(null); // do nothing
      }
    },
    hightLightInPath: async (result, line) => {
      await _plugin.call('editor', 'discardHighlight');
      await _plugin.call('editor', 'highlight', line.position, result.path);
      await _plugin.call('editor', 'revealRange', line.position.start.line, line.position.start.column, line.position.end.line, line.position.end.column);
    },
    replaceText: async (result, line) => {
      try {
        await _plugin.call('editor', 'discardHighlight');
        await _plugin.call('editor', 'highlight', line.position, result.path);
        const content = await _plugin.call('fileManager', 'readFile', result.path);
        const replaced = (0, _SearchHelper.replaceTextInLine)(content, line, state.replace);
        await _plugin.call('fileManager', 'setFile', result.path, replaced);
        setUndoState(content, replaced, result.path);
      } catch (e) {
        throw new Error(e);
      }
    },
    replaceAllInFile: async result => {
      await _plugin.call('editor', 'discardHighlight');
      const content = await _plugin.call('fileManager', 'readFile', result.path);
      const replaced = (0, _SearchHelper.replaceAllInFile)(content, createRegExFromFind(), state.replace);
      await _plugin.call('fileManager', 'setFile', result.path, replaced);
      await _plugin.call('fileManager', 'open', result.path);
      setUndoState(content, replaced, result.path);
    },
    setUndoEnabled: (path, workspace, content) => {
      dispatch({
        type: 'SET_UNDO_ENABLED',
        payload: {
          path,
          workspace,
          content
        }
      });
    },
    undoReplace: async buffer => {
      const content = await _plugin.call('fileManager', 'readFile', buffer.path);

      if (buffer.newContent !== content) {
        throw new Error('Can not undo replace, file has been changed.');
      }

      await _plugin.call('fileManager', 'setFile', buffer.path, buffer.oldContent);
      await _plugin.call('fileManager', 'open', buffer.path);
    },
    clearUndo: () => {
      dispatch({
        type: 'CLEAR_UNDO',
        payload: undefined
      });
    },
    clearStats: () => {
      _plugin.call('editor', 'discardHighlight');

      dispatch({
        type: 'CLEAR_STATS',
        payload: undefined
      });
    },
    cancelSearch: async (clearResults = true) => {
      _plugin.cancel('fileManager');

      if (clearResults) value.clearStats();
      value.setRun(false);
    },
    setClipped: value => {
      dispatch({
        type: 'SET_CLIPPED',
        payload: value
      });
    }
  };

  const reloadStateForFile = async file => {
    await value.reloadFile(file);
  };

  (0, _react.useEffect)(() => {
    _plugin.on('filePanel', 'setWorkspace', async workspace => {
      value.setSearchResults(null);
      value.clearUndo();
      value.setCurrentWorkspace(workspace.name);
      setFiles(await (0, _SearchHelper.getDirectory)('/', _plugin));
    });

    _plugin.on('fileManager', 'fileSaved', async file => {
      await reloadStateForFile(file);
      await checkUndoState(file);
    });

    _plugin.on('fileManager', 'rootFolderChanged', async file => {
      const workspace = await _plugin.call('filePanel', 'getCurrentWorkspace');
      if (workspace) value.setCurrentWorkspace(workspace.name);
      setFiles(await (0, _SearchHelper.getDirectory)('/', _plugin));
    });

    _plugin.on('fileManager', 'fileAdded', async file => {
      setFiles(await (0, _SearchHelper.getDirectory)('/', _plugin));
      await reloadStateForFile(file);
    });

    _plugin.on('fileManager', 'currentFileChanged', async file => {
      value.setCurrentFile(file);
      await checkUndoState(file);
    });

    async function fetchWorkspace() {
      try {
        const workspace = await _plugin.call('filePanel', 'getCurrentWorkspace');
        if (workspace) value.setCurrentWorkspace(workspace.name);
        setFiles(await (0, _SearchHelper.getDirectory)('/', _plugin));
      } catch (e) {
        console.log(e);
      }
    }

    setTimeout(async () => {
      await fetchWorkspace();
    }, 500);
    return () => {
      _plugin.off('fileManager', 'fileChanged');

      _plugin.off('filePanel', 'setWorkspace');
    };
  }, []); //*.sol, **/*.txt, contracts/*

  const setGlobalExpression = paths => {
    const results = [];
    paths.split(',').forEach(path => {
      path = path.trim();
      if (path.startsWith('*.')) path = path.replace(/(\*\.)/g, '**/*.');
      if (path.endsWith('/*') && !path.endsWith('/**/*')) path = path.replace(/(\*)/g, '**/*.*');
      results.push(path);
    });
    return results;
  };

  const checkUndoState = async path => {
    if (!_plugin) return;

    try {
      const content = await _plugin.call('fileManager', 'readFile', path);
      const workspace = await _plugin.call('filePanel', 'getCurrentWorkspace');
      value.setUndoEnabled(path, workspace.name, content);
    } catch (e) {
      console.log(e);
    }
  };

  const setUndoState = async (oldContent, newContent, path) => {
    const workspace = await _plugin.call('filePanel', 'getCurrentWorkspace');
    const undo = {
      oldContent,
      newContent,
      path,
      workspace: workspace.name
    };
    dispatch({
      type: 'SET_UNDO',
      payload: undo
    });
  };

  const createRegExFromFind = () => {
    let flags = 'g';
    let find = state.find;
    if (!state.casesensitive) flags += 'i';
    if (!state.useRegExp) find = (0, _lodash.escapeRegExp)(find);
    if (state.matchWord) find = `\\b${find}\\b`;
    const re = new RegExp(find, flags);
    return re;
  };

  (0, _react.useEffect)(() => {
    if (state.count > 500) {
      value.setClipped(true);
      value.cancelSearch(false);
    }
  }, [state.count]);
  (0, _react.useEffect)(() => {
    if (state.find) {
      (async () => {
        try {
          const pathFilter = {};

          if (state.include) {
            pathFilter.include = setGlobalExpression(state.include);
          }

          if (state.exclude) {
            pathFilter.exclude = setGlobalExpression(state.exclude);
          }

          const filteredFiles = files.filter((0, _filePathFilter.filePathFilter)(pathFilter)).map(file => {
            const r = {
              filename: file,
              lines: [],
              path: file,
              timeStamp: Date.now(),
              forceReload: false,
              count: 0
            };
            return r;
          });
          value.setSearchResults(filteredFiles);
        } catch (e) {
          console.log(e);
        }
      })();
    }
  }, [state.timeStamp]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(SearchContext.Provider, {
      value: value,
      children: _children
    })
  });
};

exports.SearchProvider = SearchProvider;

/***/ }),
/* 1148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DropdownPanel = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _treeView = __webpack_require__(1187);

var _clipboard = __webpack_require__(1154);

var _calldata = __webpack_require__(2584);

__webpack_require__(2585);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const DropdownPanel = props => {
  const [calldataObj, dispatch] = (0, _react.useReducer)(_calldata.reducer, _calldata.initialState);
  const {
    dropdownName,
    dropdownMessage,
    calldata,
    header,
    loading,
    extractFunc,
    formatSelfFunc,
    registerEvent,
    triggerEvent,
    loadMoreEvent,
    loadMoreCompletedEvent,
    headStyle,
    bodyStyle,
    hexHighlight
  } = props;

  const extractDataDefault = (item, parent) => {
    const ret = {};

    if (item instanceof Array) {
      ret.children = item.map((item, index) => {
        return {
          key: index,
          value: item
        };
      });
      ret.self = 'Array';
      ret.isNode = true;
      ret.isLeaf = false;
    } else if (item instanceof Object) {
      ret.children = Object.keys(item).map(key => {
        return {
          key: key,
          value: item[key]
        };
      });
      ret.self = 'Object';
      ret.isNode = true;
      ret.isLeaf = false;
    } else {
      ret.self = item;
      ret.children = null;
      ret.isNode = false;
      ret.isLeaf = true;
    }

    return ret;
  };

  const formatSelfDefault = (key, data) => {
    let value;

    if (hexHighlight && typeof data.self === 'string') {
      const isHex = data.self.startsWith('0x') || hexHighlight;

      if (isHex) {
        const regex = /^(0+)(.*)/g;
        const split = regex.exec(data.self.replace('0x', ''));

        if (split && split[1]) {
          value = /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              className: "m-0 label_value",
              children: "0x"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              className: "m-0 label_value",
              children: split[1]
            }), split[2] && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              className: "m-0 label_value font-weight-bold text-dark",
              children: split[2]
            })]
          });
        } else value = /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "m-0 label_value",
            children: "0x"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "m-0 label_value font-weight-bold text-dark",
            children: data.self.replace('0x', '')
          })]
        });
      } else value = /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "m-0 label_value",
        children: data.self
      });
    } else value = /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      className: "m-0 label_value",
      children: data.self
    });

    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "d-flex mr-1 flex-row label_item",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
        className: "small font-weight-bold mb-0 pr-1 label_key",
        children: [key, ":"]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "m-0 label_value",
        children: value
      })]
    });
  };

  const [state, setState] = (0, _react.useState)({
    header: '',
    toggleDropdown: false,
    message: {
      innerText: 'No data available.',
      display: 'block'
    },
    dropdownContent: {
      innerText: '',
      display: 'none'
    },
    title: {
      innerText: '',
      display: 'none'
    },
    copiableContent: '',
    updating: false,
    expandPath: [],
    data: null
  });
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent(loadMoreCompletedEvent, updatedCalldata => {
      dispatch({
        type: 'UPDATE_CALLDATA_SUCCESS',
        payload: updatedCalldata
      });
    });
  }, []);
  (0, _react.useEffect)(() => {
    dispatch({
      type: 'FETCH_CALLDATA_SUCCESS',
      payload: calldata
    });
  }, [calldata]);
  (0, _react.useEffect)(() => {
    update(calldata);
  }, [calldataObj.calldata]);
  (0, _react.useEffect)(() => {
    message(dropdownMessage);
  }, [dropdownMessage]);
  (0, _react.useEffect)(() => {
    if (loading && !state.updating) setLoading();
  }, [loading]);

  const handleToggle = () => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        toggleDropdown: !prevState.toggleDropdown
      });
    });
  };

  const handleExpand = keyPath => {
    if (!state.expandPath.includes(keyPath)) {
      state.expandPath.push(keyPath);
    } else {
      state.expandPath = state.expandPath.filter(path => !path.startsWith(keyPath));
    }
  };

  const message = message => {
    if (message === state.message.innerText) return;
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        message: {
          innerText: message,
          display: message ? 'block' : ''
        },
        updating: false
      });
    });
  };

  const setLoading = () => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        message: {
          innerText: '',
          display: 'none'
        },
        dropdownContent: _objectSpread(_objectSpread({}, prevState.dropdownContent), {}, {
          display: 'none'
        }),
        copiableContent: '',
        updating: true
      });
    });
  };

  const update = function update(calldata) {
    let isEmpty = !calldata;
    if (calldata && Array.isArray(calldata) && calldata.length === 0) isEmpty = true;else if (calldata && Object.keys(calldata).length === 0 && calldata.constructor === Object) isEmpty = true;
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        dropdownContent: _objectSpread(_objectSpread({}, prevState.dropdownContent), {}, {
          display: 'block'
        }),
        copiableContent: JSON.stringify(calldata, null, '\t'),
        message: {
          innerText: isEmpty ? 'No data available' : '',
          display: isEmpty ? 'block' : 'none'
        },
        updating: false,
        toggleDropdown: !isEmpty,
        data: calldata
      });
    });
  };

  const renderData = (item, parent, key, keyPath) => {
    const data = extractFunc ? extractFunc(item, parent) : extractDataDefault(item, parent);
    const children = (data.children || []).map(child => {
      return renderData(child.value, data, child.key, keyPath + '/' + child.key);
    });

    if (children && children.length > 0) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: `treeViewItem${key}`,
        label: formatSelfFunc ? formatSelfFunc(key, data) : formatSelfDefault(key, data),
        onClick: () => handleExpand(keyPath),
        expand: state.expandPath.includes(keyPath),
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_treeView.TreeView, {
          id: `treeView${key}`,
          children: [children, data.hasNext && /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
            id: 'treeViewLoadMore',
            "data-id": 'treeViewLoadMore',
            className: "cursor_pointer",
            label: "Load more",
            onClick: () => {
              triggerEvent(loadMoreEvent, [data.cursor]);
            }
          })]
        }, keyPath)
      }, keyPath);
    } else {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: key.toString(),
        label: formatSelfFunc ? formatSelfFunc(key, data) : formatSelfDefault(key, data),
        onClick: () => handleExpand(keyPath),
        expand: state.expandPath.includes(keyPath)
      }, keyPath);
    }
  };

  const uniquePanelName = dropdownName.split(' ').join('');
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "border rounded px-1 mt-1 bg-light",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "py-0 px-1 title",
      style: headStyle,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: state.toggleDropdown ? 'icon fas fa-caret-down' : 'icon fas fa-caret-right',
        onClick: handleToggle
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "name",
        "data-id": `dropdownPanel${uniquePanelName}`,
        onClick: handleToggle,
        children: dropdownName
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "nameDetail",
        onClick: handleToggle,
        children: header
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
        content: state.copiableContent,
        "data-id": `dropdownPanelCopyToClipboard${uniquePanelName}`
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "dropdownpanel",
      style: {
        display: state.toggleDropdown ? 'block' : 'none'
      },
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: "refresh fas fa-sync",
        style: {
          display: state.updating ? 'inline-block' : 'none'
        },
        "aria-hidden": "true"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "dropdowncontent",
        style: _objectSpread({
          display: state.dropdownContent.display
        }, bodyStyle),
        children: state.data && /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
          id: "treeView",
          children: Object.keys(state.data).map(innerkey => renderData(state.data[innerkey], state.data, innerkey, innerkey))
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "dropdownrawcontent",
        hidden: true,
        children: state.copiableContent
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "message",
        style: {
          display: state.message.display
        },
        children: state.message.innerText
      })]
    })]
  });
};

exports.DropdownPanel = DropdownPanel;
var _default = DropdownPanel;
exports.default = _default;

/***/ }),
/* 1149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.helper = exports.urlFromVersion = exports.canUseWorker = exports.baseURLWasm = exports.baseURLBin = exports.pathToURL = exports.promisedMiniXhr = exports.CompilerAbstract = exports.getValidLanguage = exports.CompilerInput = exports.compile = exports.Compiler = void 0;

const tslib_1 = __webpack_require__(23);

var compiler_1 = __webpack_require__(1403);

Object.defineProperty(exports, "Compiler", {
  enumerable: true,
  get: function () {
    return compiler_1.Compiler;
  }
});

var compiler_helpers_1 = __webpack_require__(1723);

Object.defineProperty(exports, "compile", {
  enumerable: true,
  get: function () {
    return compiler_helpers_1.compile;
  }
});

var compiler_input_1 = __webpack_require__(1407);

Object.defineProperty(exports, "CompilerInput", {
  enumerable: true,
  get: function () {
    return compiler_input_1.default;
  }
});
Object.defineProperty(exports, "getValidLanguage", {
  enumerable: true,
  get: function () {
    return compiler_input_1.getValidLanguage;
  }
});

var compiler_abstract_1 = __webpack_require__(1421);

Object.defineProperty(exports, "CompilerAbstract", {
  enumerable: true,
  get: function () {
    return compiler_abstract_1.CompilerAbstract;
  }
});
(0, tslib_1.__exportStar)(__webpack_require__(1408), exports);

var compiler_utils_1 = __webpack_require__(1420);

Object.defineProperty(exports, "promisedMiniXhr", {
  enumerable: true,
  get: function () {
    return compiler_utils_1.promisedMiniXhr;
  }
});
Object.defineProperty(exports, "pathToURL", {
  enumerable: true,
  get: function () {
    return compiler_utils_1.pathToURL;
  }
});
Object.defineProperty(exports, "baseURLBin", {
  enumerable: true,
  get: function () {
    return compiler_utils_1.baseURLBin;
  }
});
Object.defineProperty(exports, "baseURLWasm", {
  enumerable: true,
  get: function () {
    return compiler_utils_1.baseURLWasm;
  }
});
Object.defineProperty(exports, "canUseWorker", {
  enumerable: true,
  get: function () {
    return compiler_utils_1.canUseWorker;
  }
});
Object.defineProperty(exports, "urlFromVersion", {
  enumerable: true,
  get: function () {
    return compiler_utils_1.urlFromVersion;
  }
});

var helper_1 = __webpack_require__(1279);

Object.defineProperty(exports, "helper", {
  enumerable: true,
  get: function () {
    return helper_1.default;
  }
});

/***/ }),
/* 1150 */,
/* 1151 */,
/* 1152 */,
/* 1153 */,
/* 1154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _copyToClipboard = __webpack_require__(1650);

Object.keys(_copyToClipboard).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _copyToClipboard[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _copyToClipboard[key];
    }
  });
});

/***/ }),
/* 1155 */,
/* 1156 */,
/* 1157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventManager = void 0;

class EventManager {
  constructor() {
    this.registered = {};
    this.anonymous = {};
  }
  /*
    * Unregister a listener.
    * Note that if obj is a function. the unregistration will be applied to the dummy obj {}.
    *
    * @param {String} eventName  - the event name
    * @param {Object or Func} obj - object that will listen on this event
    * @param {Func} func         - function of the listeners that will be executed
  */


  unregister(eventName, obj, func) {
    if (!this.registered[eventName]) {
      return;
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    for (const reg in this.registered[eventName]) {
      if (this.registered[eventName][reg].obj === obj && this.registered[eventName][reg].func === func) {
        this.registered[eventName].splice(reg, 1);
      }
    }
  }
  /*
    * Register a new listener.
    * Note that if obj is a function, the function registration will be associated with the dummy object {}
    *
    * @param {String} eventName  - the event name
    * @param {Object or Func} obj - object that will listen on this event
    * @param {Func} func         - function of the listeners that will be executed
  */


  register(eventName, obj, func) {
    if (!this.registered[eventName]) {
      this.registered[eventName] = [];
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    this.registered[eventName].push({
      obj: obj,
      func: func
    });
  }
  /*
    * trigger event.
    * Every listener have their associated function executed
    *
    * @param {String} eventName  - the event name
    * @param {Array}j - argument that will be passed to the executed function.
  */


  trigger(eventName, args) {
    if (!this.registered[eventName]) {
      return;
    }

    for (const listener in this.registered[eventName]) {
      const l = this.registered[eventName][listener];
      if (l.func) l.func.apply(l.obj === this.anonymous ? {} : l.obj, args);
    }
  }

}

exports.EventManager = EventManager;

/***/ }),
/* 1158 */,
/* 1159 */,
/* 1160 */,
/* 1161 */,
/* 1162 */,
/* 1163 */,
/* 1164 */,
/* 1165 */,
/* 1166 */,
/* 1167 */,
/* 1168 */,
/* 1169 */,
/* 1170 */,
/* 1171 */,
/* 1172 */,
/* 1173 */,
/* 1174 */,
/* 1175 */,
/* 1176 */,
/* 1177 */,
/* 1178 */,
/* 1179 */,
/* 1180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

(0, tslib_1.__exportStar)(__webpack_require__(2163), exports);
(0, tslib_1.__exportStar)(__webpack_require__(1510), exports);
(0, tslib_1.__exportStar)(__webpack_require__(2164), exports);

/***/ }),
/* 1181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValueType = void 0;

const tslib_1 = __webpack_require__(23);

const util_1 = __webpack_require__(1143);

class ValueType {
  constructor(storageSlots, storageBytes, typeName) {
    this.storageSlots = storageSlots;
    this.storageBytes = storageBytes;
    this.typeName = typeName;
    this.basicType = 'ValueType';
  }

  decodeValue(input) {
    throw new Error('This method is abstract');
  }
  /**
    * decode the type with the @arg location from the storage
    *
    * @param {Object} location - containing offset and slot
    * @param {Object} storageResolver  - resolve storage queries
    * @return {Object} - decoded value
    */


  decodeFromStorage(location, storageResolver) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        const value = yield (0, util_1.extractHexValue)(location, storageResolver, this.storageBytes);
        return {
          value: this.decodeValue(value),
          type: this.typeName
        };
      } catch (e) {
        console.log(e);
        return {
          error: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }
    });
  }
  /**
    * decode the type from the stack
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @param {Array} stack - stack
    * @param {String} - memory
    * @return {Object} - decoded value
    */


  decodeFromStack(stackDepth, stack, memory, storageResolver, calldata, cursor, variableDetails) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      let value;

      if (stackDepth >= stack.length) {
        value = this.decodeValue('');
      } else {
        value = this.decodeValue(stack[stack.length - 1 - stackDepth].replace('0x', ''));
      }

      return {
        value,
        type: this.typeName
      };
    });
  }
  /**
    * decode the type with the @arg offset location from the memory
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @return {String} - memory
    * @return {Object} - decoded value
    */


  decodeFromMemory(offset, memory) {
    const value = memory.substr(2 * offset, 64);
    return {
      value: this.decodeValue(value),
      type: this.typeName
    };
  }

}

exports.ValueType = ValueType;

/***/ }),
/* 1182 */,
/* 1183 */,
/* 1184 */,
/* 1185 */,
/* 1186 */,
/* 1187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _treeViewItem = __webpack_require__(1662);

Object.keys(_treeViewItem).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _treeViewItem[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _treeViewItem[key];
    }
  });
});

var _remixUiTreeView = __webpack_require__(1665);

Object.keys(_remixUiTreeView).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiTreeView[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiTreeView[key];
    }
  });
});

/***/ }),
/* 1188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTxFeeContent = exports.setSendValue = exports.setSendUnit = exports.setSelectedAccount = exports.setRecorderCount = exports.setProxyEnvAddress = exports.setPersonalMode = exports.setPathToScenario = exports.setPassphrase = exports.setNetworkName = exports.setMaxPriorityFee = exports.setMaxFee = exports.setMatchPassphrase = exports.setLoadType = exports.setIpfsCheckedState = exports.setGasPriceStatus = exports.setGasPrice = exports.setGasLimit = exports.setExternalEndpoint = exports.setExecutionEnvironment = exports.setDeployOptions = exports.setDecodedResponse = exports.setCurrentFile = exports.setCurrentContract = exports.setConfirmSettings = exports.setBaseFeePerGas = exports.resetUdapp = exports.removeProvider = exports.removeExistingInstance = exports.removeDeployOption = exports.hidePopUp = exports.hideNotification = exports.fetchContractListSuccess = exports.fetchContractListRequest = exports.fetchContractListFailed = exports.fetchAccountsListSuccess = exports.fetchAccountsListRequest = exports.fetchAccountsListFailed = exports.displayPopUp = exports.displayNotification = exports.clearRecorderCount = exports.clearAllInstances = exports.addProvider = exports.addNewInstance = exports.addDeployOption = void 0;

var _constants = __webpack_require__(1401);

const fetchAccountsListRequest = () => {
  return {
    type: _constants.FETCH_ACCOUNTS_LIST_REQUEST,
    payload: null
  };
};

exports.fetchAccountsListRequest = fetchAccountsListRequest;

const fetchAccountsListSuccess = accounts => {
  return {
    type: _constants.FETCH_ACCOUNTS_LIST_SUCCESS,
    payload: accounts
  };
};

exports.fetchAccountsListSuccess = fetchAccountsListSuccess;

const fetchAccountsListFailed = error => {
  return {
    type: _constants.FETCH_ACCOUNTS_LIST_FAILED,
    payload: error
  };
};

exports.fetchAccountsListFailed = fetchAccountsListFailed;

const setSendValue = value => {
  return {
    type: _constants.SET_SEND_VALUE,
    payload: value
  };
};

exports.setSendValue = setSendValue;

const setSelectedAccount = account => {
  return {
    type: _constants.SET_SELECTED_ACCOUNT,
    payload: account
  };
};

exports.setSelectedAccount = setSelectedAccount;

const setSendUnit = unit => {
  return {
    type: _constants.SET_SEND_UNIT,
    payload: unit
  };
};

exports.setSendUnit = setSendUnit;

const setGasLimit = gasLimit => {
  return {
    type: _constants.SET_GAS_LIMIT,
    payload: gasLimit
  };
};

exports.setGasLimit = setGasLimit;

const setExecutionEnvironment = executionEnvironment => {
  return {
    type: _constants.SET_EXECUTION_ENVIRONMENT,
    payload: executionEnvironment
  };
};

exports.setExecutionEnvironment = setExecutionEnvironment;

const setPersonalMode = mode => {
  return {
    type: _constants.SET_PERSONAL_MODE,
    payload: mode
  };
};

exports.setPersonalMode = setPersonalMode;

const setNetworkName = networkName => {
  return {
    type: _constants.SET_NETWORK_NAME,
    payload: networkName
  };
};

exports.setNetworkName = setNetworkName;

const addProvider = provider => {
  return {
    type: _constants.ADD_PROVIDER,
    payload: provider
  };
};

exports.addProvider = addProvider;

const removeProvider = provider => {
  return {
    type: _constants.REMOVE_PROVIDER,
    payload: provider
  };
};

exports.removeProvider = removeProvider;

const displayNotification = (title, message, labelOk, labelCancel, actionOk, actionCancel) => {
  return {
    type: _constants.DISPLAY_NOTIFICATION,
    payload: {
      title,
      message,
      labelOk,
      labelCancel,
      actionOk,
      actionCancel
    }
  };
};

exports.displayNotification = displayNotification;

const hideNotification = () => {
  return {
    type: _constants.HIDE_NOTIFICATION
  };
};

exports.hideNotification = hideNotification;

const setExternalEndpoint = endpoint => {
  return {
    type: _constants.SET_EXTERNAL_WEB3_ENDPOINT,
    payload: endpoint
  };
};

exports.setExternalEndpoint = setExternalEndpoint;

const displayPopUp = message => {
  return {
    type: _constants.DISPLAY_POPUP_MESSAGE,
    payload: message
  };
};

exports.displayPopUp = displayPopUp;

const hidePopUp = () => {
  return {
    type: _constants.HIDE_POPUP_MESSAGE
  };
};

exports.hidePopUp = hidePopUp;

const setPassphrase = passphrase => {
  return {
    type: _constants.SET_PASSPHRASE,
    payload: passphrase
  };
};

exports.setPassphrase = setPassphrase;

const setMatchPassphrase = passphrase => {
  return {
    type: _constants.SET_MATCH_PASSPHRASE,
    payload: passphrase
  };
};

exports.setMatchPassphrase = setMatchPassphrase;

const fetchContractListRequest = () => {
  return {
    type: _constants.FETCH_CONTRACT_LIST_REQUEST
  };
};

exports.fetchContractListRequest = fetchContractListRequest;

const fetchContractListSuccess = contracts => {
  return {
    type: _constants.FETCH_CONTRACT_LIST_SUCCESS,
    payload: contracts
  };
};

exports.fetchContractListSuccess = fetchContractListSuccess;

const fetchContractListFailed = error => {
  return {
    type: _constants.FETCH_CONTRACT_LIST_FAILED,
    payload: error
  };
};

exports.fetchContractListFailed = fetchContractListFailed;

const setLoadType = type => {
  return {
    type: _constants.SET_LOAD_TYPE,
    payload: type
  };
};

exports.setLoadType = setLoadType;

const setCurrentFile = file => {
  return {
    type: _constants.SET_CURRENT_FILE,
    payload: file
  };
};

exports.setCurrentFile = setCurrentFile;

const setIpfsCheckedState = state => {
  return {
    type: _constants.SET_IPFS_CHECKED_STATE,
    payload: state
  };
};

exports.setIpfsCheckedState = setIpfsCheckedState;

const setGasPriceStatus = status => {
  return {
    type: _constants.SET_GAS_PRICE_STATUS,
    payload: status
  };
};

exports.setGasPriceStatus = setGasPriceStatus;

const setConfirmSettings = confirmation => {
  return {
    type: _constants.SET_CONFIRM_SETTINGS,
    payload: confirmation
  };
};

exports.setConfirmSettings = setConfirmSettings;

const setMaxFee = fee => {
  return {
    type: _constants.SET_MAX_FEE,
    payload: fee
  };
};

exports.setMaxFee = setMaxFee;

const setMaxPriorityFee = fee => {
  return {
    type: _constants.SET_MAX_PRIORITY_FEE,
    payload: fee
  };
};

exports.setMaxPriorityFee = setMaxPriorityFee;

const setBaseFeePerGas = baseFee => {
  return {
    type: _constants.SET_BASE_FEE_PER_GAS,
    payload: baseFee
  };
};

exports.setBaseFeePerGas = setBaseFeePerGas;

const setGasPrice = price => {
  return {
    type: _constants.SET_GAS_PRICE,
    payload: price
  };
};

exports.setGasPrice = setGasPrice;

const setTxFeeContent = content => {
  return {
    type: _constants.SET_TX_FEE_CONTENT,
    payload: content
  };
};

exports.setTxFeeContent = setTxFeeContent;

const addNewInstance = instance => {
  return {
    type: _constants.ADD_INSTANCE,
    payload: instance
  };
};

exports.addNewInstance = addNewInstance;

const removeExistingInstance = index => {
  return {
    type: _constants.REMOVE_INSTANCE,
    payload: index
  };
};

exports.removeExistingInstance = removeExistingInstance;

const clearAllInstances = () => {
  return {
    type: _constants.CLEAR_INSTANCES
  };
};

exports.clearAllInstances = clearAllInstances;

const setDecodedResponse = (instanceIndex, response, funcIndex) => {
  return {
    type: _constants.SET_DECODED_RESPONSE,
    payload: {
      instanceIndex,
      funcIndex,
      response
    }
  };
};

exports.setDecodedResponse = setDecodedResponse;

const setPathToScenario = path => {
  return {
    type: _constants.SET_PATH_TO_SCENARIO,
    payload: path
  };
};

exports.setPathToScenario = setPathToScenario;

const setRecorderCount = count => {
  return {
    type: _constants.SET_RECORDER_COUNT,
    payload: count
  };
};

exports.setRecorderCount = setRecorderCount;

const clearRecorderCount = () => {
  return {
    type: _constants.CLEAR_RECORDER_COUNT
  };
};

exports.clearRecorderCount = clearRecorderCount;

const resetUdapp = () => {
  return {
    type: _constants.RESET_STATE
  };
};

exports.resetUdapp = resetUdapp;

const addDeployOption = deployOption => {
  return {
    payload: deployOption,
    type: _constants.ADD_DEPLOY_OPTION
  };
};

exports.addDeployOption = addDeployOption;

const removeDeployOption = file => {
  return {
    payload: file,
    type: _constants.REMOVE_DEPLOY_OPTION
  };
};

exports.removeDeployOption = removeDeployOption;

const setDeployOptions = deployOptions => {
  return {
    payload: deployOptions,
    type: _constants.SET_DEPLOY_OPTIONS
  };
};

exports.setDeployOptions = setDeployOptions;

const setCurrentContract = contractName => {
  return {
    payload: contractName,
    type: _constants.SET_CURRENT_CONTRACT
  };
};

exports.setCurrentContract = setCurrentContract;

const setProxyEnvAddress = key => {
  return {
    payload: key,
    type: _constants.SET_PROXY_ENV_ADDRESS
  };
};

exports.setProxyEnvAddress = setProxyEnvAddress;

/***/ }),
/* 1189 */,
/* 1190 */,
/* 1191 */,
/* 1192 */,
/* 1193 */,
/* 1194 */,
/* 1195 */,
/* 1196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var remixLib = __webpack_require__(311);

var EventManager = remixLib.EventManager;
module.exports = EventManager;

/***/ }),
/* 1197 */,
/* 1198 */,
/* 1199 */,
/* 1200 */,
/* 1201 */,
/* 1202 */,
/* 1203 */,
/* 1204 */,
/* 1205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const staticAnalysisCommon_1 = __webpack_require__(1122);

const remix_astwalker_1 = __webpack_require__(1180);

class abstractAstView {
  constructor() {
    this.contracts = [];
    this.currentContractIndex = -1;
    this.currentFunctionIndex = -1;
    this.currentModifierIndex = -1;
    this.isFunctionNotModifier = false;
    /*
      file1: contract c{}
      file2: import "file1" as x; contract c{}
      therefore we have two contracts with the same name c. At the moment this is not handled because alias name "x" is not
      available in the current AST implementation thus can not be resolved.
      Additionally the fullQuallified function names e.g. [contractName].[functionName](param1Type, param2Type, ... ) must be prefixed to
      fully support this and when inheritance is resolved it must include alias resolving e.g x.c = file1.c
    */

    this.multipleContractsWithSameName = false;
  }
  /**
  * Builds a higher level AST view. I creates a list with each contract as an object in it.
  * Example contractsOut:
  *
  * {
  *  "node": {},                     // actual AST Node of the contract
  *  "functions": [
  *    {
  *      "node": {},                // actual AST Node of the function
  *      "relevantNodes": [],       // AST nodes in the function that are relevant for the anlysis of this function
  *      "modifierInvocations": [], // Modifier invocation AST nodes that are applied on this function
  *      "localVariables": [],      // Local variable declaration nodes
  *      "parameters": []           // Parameter types of the function in order of definition
  *      "returns": []              // list of return vars as { type: ... , name: ... }
  *    }
  *  ],
  *  "modifiers": [],              // Modifiers definded by the contract, format similar to functions
  *  "inheritsFrom": [],           // Names of contract this one inherits from in order of definition
  *  "stateVariables": []          // AST nodes of all State variables
  * }
  *
  * @relevantNodeFilter {ASTNode -> bool} function that selects relevant ast nodes for analysis on function level.
  * @contractsOut {list} return list for high level AST view
  * @return {ASTNode -> void} returns a function that can be used as visit function for static analysis modules, to build up a higher level AST view for further analysis.
  */
  // eslint-disable-next-line camelcase


  build_visit(relevantNodeFilter) {
    return node => {
      if (node.nodeType === 'ContractDefinition') {
        this.setCurrentContract({
          node: node,
          functions: [],
          relevantNodes: [],
          modifiers: [],
          inheritsFrom: [],
          stateVariables: (0, staticAnalysisCommon_1.getStateVariableDeclarationsFromContractNode)(node)
        });
      } else if (node.nodeType === 'InheritanceSpecifier') {
        const currentContract = this.getCurrentContract();
        const inheritsFromName = (0, staticAnalysisCommon_1.getInheritsFromName)(node);
        currentContract.inheritsFrom.push(inheritsFromName);
      } else if (node.nodeType === 'FunctionDefinition') {
        this.setCurrentFunction({
          node: node,
          relevantNodes: [],
          modifierInvocations: [],
          localVariables: this.getLocalVariables(node),
          parameters: this.getLocalParameters(node),
          returns: this.getReturnParameters(node)
        }); // push back relevant nodes to their the current fn if any

        this.getCurrentContract().relevantNodes.map(item => {
          if (item.referencedDeclaration === node.id) {
            this.getCurrentFunction().relevantNodes.push(item.node);
          }
        });
      } else if (node.nodeType === 'ModifierDefinition') {
        this.setCurrentModifier({
          node: node,
          relevantNodes: [],
          localVariables: this.getLocalVariables(node),
          parameters: this.getLocalParameters(node)
        });
      } else if (node.nodeType === 'ModifierInvocation') {
        if (!this.isFunctionNotModifier) throw new Error('abstractAstView.js: Found modifier invocation outside of function scope.');
        this.getCurrentFunction().modifierInvocations.push(node);
      } else if (relevantNodeFilter(node)) {
        let scope = this.isFunctionNotModifier ? this.getCurrentFunction() : this.getCurrentModifier();

        if (scope) {
          scope.relevantNodes.push(node);
        } else {
          scope = this.getCurrentContract(); // if we are not in a function scope, add the node to the contract scope

          if (scope && node.referencedDeclaration) {
            scope.relevantNodes.push({
              referencedDeclaration: node.referencedDeclaration,
              node: node
            });
          }
        }
      }
    };
  } // eslint-disable-next-line camelcase


  build_report(wrap) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return compilationResult => {
      const solVersion = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResult.contracts);
      this.resolveStateVariablesInHierarchy(this.contracts);
      return wrap(this.contracts, this.multipleContractsWithSameName, solVersion);
    };
  }

  resolveStateVariablesInHierarchy(contracts) {
    contracts.map(c => {
      this.resolveStateVariablesInHierarchyForContract(c, contracts);
    });
  }

  resolveStateVariablesInHierarchyForContract(currentContract, contracts) {
    currentContract.inheritsFrom.map(inheritsFromName => {
      // add variables from inherited contracts
      const inheritsFrom = contracts.find(contract => (0, staticAnalysisCommon_1.getContractName)(contract.node) === inheritsFromName);

      if (inheritsFrom) {
        currentContract.stateVariables = currentContract.stateVariables.concat(inheritsFrom.stateVariables);
      } else {
        console.log('abstractAstView.js: could not find contract defintion inherited from ' + inheritsFromName);
      }
    });
  }

  setCurrentContract(contract) {
    const name = (0, staticAnalysisCommon_1.getContractName)(contract.node);

    if (this.contracts.map(c => (0, staticAnalysisCommon_1.getContractName)(c.node)).filter(n => n === name).length > 0) {
      console.log('abstractAstView.js: two or more contracts with the same name dectected, import aliases not supported at the moment');
      this.multipleContractsWithSameName = true;
    }

    this.currentContractIndex = this.contracts.push(contract) - 1;
  }

  setCurrentFunction(func) {
    this.isFunctionNotModifier = true;
    this.currentFunctionIndex = this.getCurrentContract().functions.push(func) - 1;
  }

  setCurrentModifier(modi) {
    this.isFunctionNotModifier = false;
    this.currentModifierIndex = this.getCurrentContract().modifiers.push(modi) - 1;
  }

  getCurrentContract() {
    return this.contracts[this.currentContractIndex];
  }

  getCurrentFunction() {
    return this.getCurrentContract().functions[this.currentFunctionIndex];
  }

  getCurrentModifier() {
    return this.getCurrentContract().modifiers[this.currentModifierIndex];
  }

  getLocalParameters(funcNode) {
    return (0, staticAnalysisCommon_1.getFunctionOrModifierDefinitionParameterPart)(funcNode).parameters.map(staticAnalysisCommon_1.getType);
  }

  getReturnParameters(funcNode) {
    return this.getLocalVariables((0, staticAnalysisCommon_1.getFunctionDefinitionReturnParameterPart)(funcNode)).map(n => {
      return {
        type: (0, staticAnalysisCommon_1.getType)(n),
        name: (0, staticAnalysisCommon_1.getDeclaredVariableName)(n)
      };
    });
  }

  getLocalVariables(funcNode) {
    const locals = [];
    new remix_astwalker_1.AstWalker().walkFull(funcNode, node => {
      if (node.nodeType === 'VariableDeclaration') locals.push(node);
      return true;
    });
    return locals;
  }

}

exports.default = abstractAstView;

/***/ }),
/* 1206 */,
/* 1207 */,
/* 1208 */,
/* 1209 */,
/* 1210 */,
/* 1211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateTxFeeContent = exports.updateScenarioPath = exports.updateMaxPriorityFee = exports.updateMaxFee = exports.updateGasPriceStatus = exports.updateGasPrice = exports.updateConfirmSettings = exports.updateBaseFeePerGas = exports.setUnit = exports.setSendTransactionValue = exports.setSelectedContract = exports.setPassphrasePrompt = exports.setNetworkNameFromProvider = exports.setMatchPassphrasePrompt = exports.setGasFee = exports.setExecEnv = exports.setAccount = exports.removeInstance = exports.removeExternalProvider = exports.clearPopUp = exports.clearInstances = exports.addInstance = exports.addExternalProvider = void 0;

var _payload = __webpack_require__(1188);

const setAccount = (dispatch, account) => {
  dispatch((0, _payload.setSelectedAccount)(account));
};

exports.setAccount = setAccount;

const setUnit = (dispatch, unit) => {
  dispatch((0, _payload.setSendUnit)(unit));
};

exports.setUnit = setUnit;

const setGasFee = (dispatch, value) => {
  dispatch((0, _payload.setGasLimit)(value));
};

exports.setGasFee = setGasFee;

const setExecEnv = (dispatch, env) => {
  dispatch((0, _payload.setExecutionEnvironment)(env));
};

exports.setExecEnv = setExecEnv;

const setNetworkNameFromProvider = (dispatch, networkName) => {
  dispatch((0, _payload.setNetworkName)(networkName));
};

exports.setNetworkNameFromProvider = setNetworkNameFromProvider;

const addExternalProvider = (dispatch, network) => {
  dispatch((0, _payload.addProvider)(network));
};

exports.addExternalProvider = addExternalProvider;

const removeExternalProvider = (dispatch, name) => {
  dispatch((0, _payload.removeProvider)(name));
};

exports.removeExternalProvider = removeExternalProvider;

const clearPopUp = async dispatch => {
  dispatch((0, _payload.hidePopUp)());
};

exports.clearPopUp = clearPopUp;

const setPassphrasePrompt = (dispatch, passphrase) => {
  dispatch((0, _payload.setPassphrase)(passphrase));
};

exports.setPassphrasePrompt = setPassphrasePrompt;

const setMatchPassphrasePrompt = (dispatch, passphrase) => {
  dispatch((0, _payload.setMatchPassphrase)(passphrase));
};

exports.setMatchPassphrasePrompt = setMatchPassphrasePrompt;

const updateGasPriceStatus = (dispatch, status) => {
  dispatch((0, _payload.setGasPriceStatus)(status));
};

exports.updateGasPriceStatus = updateGasPriceStatus;

const updateConfirmSettings = (dispatch, confirmation) => {
  dispatch((0, _payload.setConfirmSettings)(confirmation));
};

exports.updateConfirmSettings = updateConfirmSettings;

const updateMaxFee = (dispatch, fee) => {
  dispatch((0, _payload.setMaxFee)(fee));
};

exports.updateMaxFee = updateMaxFee;

const updateMaxPriorityFee = (dispatch, fee) => {
  dispatch((0, _payload.setMaxPriorityFee)(fee));
};

exports.updateMaxPriorityFee = updateMaxPriorityFee;

const updateBaseFeePerGas = (dispatch, baseFee) => {
  dispatch((0, _payload.setBaseFeePerGas)(baseFee));
};

exports.updateBaseFeePerGas = updateBaseFeePerGas;

const updateGasPrice = (dispatch, price) => {
  dispatch((0, _payload.setGasPrice)(price));
};

exports.updateGasPrice = updateGasPrice;

const updateTxFeeContent = (dispatch, content) => {
  dispatch((0, _payload.setTxFeeContent)(content));
};

exports.updateTxFeeContent = updateTxFeeContent;

const addInstance = (dispatch, instance) => {
  instance.decodedResponse = {};
  dispatch((0, _payload.addNewInstance)(instance));
};

exports.addInstance = addInstance;

const removeInstance = (dispatch, index) => {
  dispatch((0, _payload.removeExistingInstance)(index));
};

exports.removeInstance = removeInstance;

const clearInstances = dispatch => {
  dispatch((0, _payload.clearAllInstances)());
  dispatch((0, _payload.clearRecorderCount)());
};

exports.clearInstances = clearInstances;

const setSelectedContract = (dispatch, contractName) => {
  dispatch((0, _payload.setCurrentContract)(contractName));
};

exports.setSelectedContract = setSelectedContract;

const updateScenarioPath = (dispatch, path) => {
  dispatch((0, _payload.setPathToScenario)(path));
};

exports.updateScenarioPath = updateScenarioPath;

const setSendTransactionValue = (dispatch, value) => {
  dispatch((0, _payload.setSendValue)(value));
};

exports.setSendTransactionValue = setSendTransactionValue;

/***/ }),
/* 1212 */,
/* 1213 */,
/* 1214 */,
/* 1215 */,
/* 1216 */,
/* 1217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(23);

const init = (0, tslib_1.__importStar)(__webpack_require__(2166));

const Ethdebugger_1 = __webpack_require__(1511);

const debugger_1 = __webpack_require__(1519);

const cmdline_1 = __webpack_require__(2196);

const storageViewer_1 = __webpack_require__(1218);

const storageResolver_1 = __webpack_require__(1327);

const SolidityDecoder = (0, tslib_1.__importStar)(__webpack_require__(1513));

const breakpointManager_1 = __webpack_require__(1520);

const sourceMappingDecoder = (0, tslib_1.__importStar)(__webpack_require__(1328));
const traceHelper = (0, tslib_1.__importStar)(__webpack_require__(1146));
module.exports = {
  init,
  traceHelper,
  sourceMappingDecoder,
  EthDebugger: Ethdebugger_1.Ethdebugger,
  TransactionDebugger: debugger_1.Debugger,

  /**
   * constructor
   *
   * @param {Object} _debugger - type of EthDebugger
   * @return {Function} _locationToRowConverter - function implemented by editor which return a column/line position for a char source location
   */
  BreakpointManager: breakpointManager_1.BreakpointManager,
  SolidityDecoder,
  storage: {
    StorageViewer: storageViewer_1.StorageViewer,
    StorageResolver: storageResolver_1.StorageResolver
  },
  CmdLine: cmdline_1.CmdLine
};

/***/ }),
/* 1218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageViewer = void 0;

const tslib_1 = __webpack_require__(23);

const remix_lib_1 = __webpack_require__(311);

const mappingPreimages_1 = __webpack_require__(1512);
/**
   * easier access to the storage resolver
   * Basically one instance is created foreach execution step and foreach component that need it.
   * (TODO: one instance need to be shared over all the components)
   */


class StorageViewer {
  constructor(_context, _storageResolver, _traceManager) {
    this.context = _context;
    this.storageResolver = _storageResolver;
    this.web3 = this.storageResolver.web3;
    this.initialMappingsLocationPromise = null;
    this.currentMappingsLocationPromise = null;
    this.storageChanges = _traceManager.accumulateStorageChanges(this.context.stepIndex, this.context.address, {});
  }
  /**
    * return the storage for the current context (address and vm trace index)
    * by default now returns the range 0 => 1000
    *
    * @param {Function} - callback - contains a map: [hashedKey] = {key, hashedKey, value}
    */


  storageRange() {
    return new Promise((resolve, reject) => {
      this.storageResolver.storageRange(this.context.tx, this.context.stepIndex, this.context.address).then(storage => {
        resolve(Object.assign({}, storage, this.storageChanges));
      }).catch(reject);
    });
  }
  /**
    * return a slot value for the current context (address and vm trace index)
    * @param {String} - slot - slot key (not hashed key!)
    * @param {Function} - callback - {key, hashedKey, value} -
    */


  storageSlot(slot, callback) {
    const hashed = remix_lib_1.util.sha3_256(slot);

    if (this.storageChanges[hashed]) {
      return callback(null, this.storageChanges[hashed]);
    }

    this.storageResolver.storageSlot(hashed, this.context.tx, this.context.stepIndex, this.context.address).then(storage => {
      callback(null, storage);
    }).catch(callback);
  }
  /**
    * return True if the storage at @arg address is complete
    *
    * @param {String} address  - contract address
    * @return {Bool} - return True if the storage at @arg address is complete
    */


  isComplete(address) {
    return this.storageResolver.isComplete(address);
  }
  /**
    * return all the possible mappings locations for the current context (cached) do not return state changes during the current transaction
    *
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  initialMappingsLocation(corrections) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (!this.initialMappingsLocationPromise) {
        this.initialMappingsLocationPromise = this.storageResolver.initialPreimagesMappings(this.context.tx, this.context.stepIndex, this.context.address, corrections);
      }

      return this.initialMappingsLocationPromise;
    });
  }
  /**
    * return all the possible mappings locations for the current context (cached) and current mapping slot. returns state changes during the current transaction
    *
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  mappingsLocation(corrections) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (!this.currentMappingsLocationPromise) {
        this.currentMappingsLocationPromise = new Promise((resolve, reject) => {
          const mappingsLocationChanges = this.extractMappingsLocationChanges(this.storageChanges, corrections);
          return resolve(mappingsLocationChanges);
        });
      }

      return this.currentMappingsLocationPromise;
    });
  }
  /**
    * retrieve mapping location changes from the storage changes.
    * @param {Map} storageChanges
    * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
    */


  extractMappingsLocationChanges(storageChanges, corrections) {
    if (this.mappingsLocationChanges) {
      return this.mappingsLocationChanges;
    }

    const mappings = (0, mappingPreimages_1.decodeMappingsKeys)(this.web3, storageChanges, corrections);
    this.mappingsLocationChanges = mappings;
    return this.mappingsLocationChanges;
  }

}

exports.StorageViewer = StorageViewer;

/***/ }),
/* 1219 */,
/* 1220 */,
/* 1221 */,
/* 1222 */,
/* 1223 */,
/* 1224 */,
/* 1225 */,
/* 1226 */,
/* 1227 */,
/* 1228 */,
/* 1229 */,
/* 1230 */,
/* 1231 */,
/* 1232 */,
/* 1233 */,
/* 1234 */,
/* 1235 */,
/* 1236 */,
/* 1237 */,
/* 1238 */,
/* 1239 */,
/* 1240 */,
/* 1241 */,
/* 1242 */,
/* 1243 */,
/* 1244 */,
/* 1245 */,
/* 1246 */,
/* 1247 */,
/* 1248 */,
/* 1249 */,
/* 1250 */,
/* 1251 */,
/* 1252 */,
/* 1253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  OffsetToLineColumnConverter: true,
  CompilerMetadata: true,
  FetchAndCompile: true,
  CompilerImports: true,
  CompilerArtefacts: true,
  EditorContextListener: true,
  GistHandler: true,
  LinkLibraries: true,
  DeployLibraries: true,
  OpenZeppelinProxy: true,
  fetchContractFromEtherscan: true
};
Object.defineProperty(exports, "CompilerArtefacts", {
  enumerable: true,
  get: function () {
    return _compilerArtefacts.CompilerArtefacts;
  }
});
Object.defineProperty(exports, "CompilerImports", {
  enumerable: true,
  get: function () {
    return _compilerContentImports.CompilerImports;
  }
});
Object.defineProperty(exports, "CompilerMetadata", {
  enumerable: true,
  get: function () {
    return _compilerMetadata.CompilerMetadata;
  }
});
Object.defineProperty(exports, "DeployLibraries", {
  enumerable: true,
  get: function () {
    return _linkLibraries.DeployLibraries;
  }
});
Object.defineProperty(exports, "EditorContextListener", {
  enumerable: true,
  get: function () {
    return _editorContextListener.EditorContextListener;
  }
});
Object.defineProperty(exports, "FetchAndCompile", {
  enumerable: true,
  get: function () {
    return _compilerFetchAndCompile.FetchAndCompile;
  }
});
Object.defineProperty(exports, "GistHandler", {
  enumerable: true,
  get: function () {
    return _gistHandler.GistHandler;
  }
});
Object.defineProperty(exports, "LinkLibraries", {
  enumerable: true,
  get: function () {
    return _linkLibraries.LinkLibraries;
  }
});
Object.defineProperty(exports, "OffsetToLineColumnConverter", {
  enumerable: true,
  get: function () {
    return _offsetLineToColumnConverter.OffsetToLineColumnConverter;
  }
});
Object.defineProperty(exports, "OpenZeppelinProxy", {
  enumerable: true,
  get: function () {
    return _openzeppelinProxy.OpenZeppelinProxy;
  }
});
Object.defineProperty(exports, "fetchContractFromEtherscan", {
  enumerable: true,
  get: function () {
    return _fetchEtherscan.fetchContractFromEtherscan;
  }
});

var _offsetLineToColumnConverter = __webpack_require__(2165);

var _compilerMetadata = __webpack_require__(2197);

var _compilerFetchAndCompile = __webpack_require__(2198);

var _compilerContentImports = __webpack_require__(2200);

var _compilerArtefacts = __webpack_require__(2246);

var _editorContextListener = __webpack_require__(2247);

var _gistHandler = __webpack_require__(2248);

var _contract = __webpack_require__(2249);

Object.keys(_contract).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _contract[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _contract[key];
    }
  });
});

var _linkLibraries = __webpack_require__(2250);

var _openzeppelinProxy = __webpack_require__(2251);

var _fetchEtherscan = __webpack_require__(1521);

/***/ }),
/* 1254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RefType = void 0;

const tslib_1 = __webpack_require__(23);

const ethers_1 = __webpack_require__(140);

const util_1 = __webpack_require__(1143);

class RefType {
  constructor(storageSlots, storageBytes, typeName, location) {
    this.location = location;
    this.storageSlots = storageSlots;
    this.storageBytes = storageBytes;
    this.typeName = typeName;
    this.basicType = 'RefType';
  }

  decodeFromStorage(input1, input2) {
    throw new Error('This method is abstract');
  }

  decodeFromMemoryInternal(input1, input2, input3) {
    throw new Error('This method is abstract');
  }
  /**
    * decode the type from the stack
    *
    * @param {Int} stackDepth - position of the type in the stack
    * @param {Array} stack - stack
    * @param {String} - memory
    * @param {Object} - storageResolver
    * @return {Object} decoded value
    */


  decodeFromStack(stackDepth, stack, memory, storageResolver, calldata, cursor, variableDetails) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (stack.length - 1 < stackDepth) {
        return {
          error: '<decoding failed - stack underflow ' + stackDepth + '>',
          type: this.typeName
        };
      }

      let offset = stack[stack.length - 1 - stackDepth];

      if (this.isInStorage()) {
        offset = (0, util_1.toBN)(offset);

        try {
          return yield this.decodeFromStorage({
            offset: 0,
            slot: offset
          }, storageResolver);
        } catch (e) {
          console.log(e);
          return {
            error: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }
      } else if (this.isInMemory()) {
        offset = parseInt(offset, 16);
        return this.decodeFromMemoryInternal(offset, memory, cursor);
      } else if (this.isInCallData()) {
        return this._decodeFromCallData(variableDetails, calldata);
      } else {
        return {
          error: '<decoding failed - no decoder for ' + this.location + '>',
          type: this.typeName
        };
      }
    });
  }

  _decodeFromCallData(variableDetails, calldata) {
    calldata = calldata.length > 0 ? calldata[0] : '0x';
    const ethersAbi = new ethers_1.ethers.utils.Interface(variableDetails.abi);
    const fnSign = calldata.substr(0, 10);
    const decodedData = ethersAbi.decodeFunctionData(ethersAbi.getFunction(fnSign), calldata);
    const decodedValue = decodedData[variableDetails.name];
    const isArray = Array.isArray(decodedValue);

    if (isArray) {
      return this._decodeCallDataArray(decodedValue, this);
    }

    return {
      length: isArray ? '0x' + decodedValue.length.toString(16) : undefined,
      value: decodedValue,
      type: this.typeName
    };
  }

  _decodeCallDataArray(value, type) {
    const isArray = Array.isArray(value);

    if (isArray) {
      value = value.map(el => {
        return this._decodeCallDataArray(el, this.underlyingType);
      });
      return {
        length: value.length.toString(16),
        value: value,
        type: type.typeName
      };
    } else {
      return {
        value: value.toString(),
        type: type.underlyingType && type.underlyingType.typeName || type.typeName
      };
    }
  }
  /**
    * decode the type from the memory
    *
    * @param {Int} offset - position of the ref of the type in memory
    * @param {String} memory - memory
    * @return {Object} decoded value
    */


  decodeFromMemory(offset, memory) {
    offset = memory.substr(2 * offset, 64);
    offset = parseInt(offset, 16);
    return this.decodeFromMemoryInternal(offset, memory);
  }
  /**
    * current type defined in storage
    *
    * @return {Bool} - return true if the type is defined in the storage
    */


  isInStorage() {
    return this.location.indexOf('storage') === 0;
  }
  /**
    * current type defined in memory
    *
    * @return {Bool} - return true if the type is defined in the memory
    */


  isInMemory() {
    return this.location.indexOf('memory') === 0;
  }
  /**
    * current type defined in storage
    *
    * @return {Bool} - return true if the type is defined in the storage
    */


  isInCallData() {
    return this.location.indexOf('calldata') === 0;
  }

}

exports.RefType = RefType;

/***/ }),
/* 1255 */,
/* 1256 */,
/* 1257 */,
/* 1258 */,
/* 1259 */,
/* 1260 */,
/* 1261 */,
/* 1262 */,
/* 1263 */,
/* 1264 */,
/* 1265 */,
/* 1266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractProvider = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engine = __webpack_require__(477);

var _app = __webpack_require__(483);

var _ethers = __webpack_require__(140);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AbstractProvider = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(AbstractProvider, _Plugin);

  var _super = _createSuper(AbstractProvider);

  function AbstractProvider(profile, blockchain, defaultUrl) {
    var _this;

    (0, _classCallCheck2["default"])(this, AbstractProvider);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "provider", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "blocked", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "blockchain", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "defaultUrl", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "connected", void 0);
    _this.defaultUrl = defaultUrl;
    _this.provider = null;
    _this.blocked = false; // used to block any call when trying to recover after a failed connection.

    _this.connected = false;
    _this.blockchain = blockchain;
    return _this;
  }

  (0, _createClass2["default"])(AbstractProvider, [{
    key: "onDeactivation",
    value: function onDeactivation() {
      this.provider = null;
      this.blocked = false;
    }
  }, {
    key: "sendAsync",
    value: function sendAsync(data) {
      var _this2 = this;

      return new Promise( /*#__PURE__*/function () {
        var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(resolve, reject) {
          var value, result;
          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!_this2.blocked) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return", reject(new Error('provider unable to connect')));

                case 2:
                  if (_this2.provider) {
                    _context.next = 31;
                    break;
                  }

                  _context.prev = 3;
                  _context.next = 6;
                  return function () {
                    return new Promise(function (resolve, reject) {
                      var modalContent = {
                        id: _this2.profile.name,
                        title: _this2.profile.displayName,
                        message: _this2.body(),
                        modalType: _app.ModalTypes.prompt,
                        okLabel: 'OK',
                        cancelLabel: 'Cancel',
                        validationFn: function validationFn(value) {
                          if (!value) return {
                            valid: false,
                            message: "value is empty"
                          };

                          if (value.startsWith('https://') || value.startsWith('http://')) {
                            return {
                              valid: true,
                              message: ''
                            };
                          } else {
                            return {
                              valid: false,
                              message: 'the provided value should contain the protocol ( e.g starts with http:// or https:// )'
                            };
                          }
                        },
                        okFn: function okFn(value) {
                          setTimeout(function () {
                            return resolve(value);
                          }, 0);
                        },
                        cancelFn: function cancelFn() {
                          setTimeout(function () {
                            return reject(new Error('Canceled'));
                          }, 0);
                        },
                        hideFn: function hideFn() {
                          setTimeout(function () {
                            return reject(new Error('Hide'));
                          }, 0);
                        },
                        defaultValue: _this2.defaultUrl
                      };

                      _this2.call('notification', 'modal', modalContent);
                    });
                  }();

                case 6:
                  value = _context.sent;
                  _context.next = 15;
                  break;

                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](3);
                  // the modal has been canceled/hide
                  result = data.method === 'net_listening' ? 'canceled' : [];
                  resolve({
                    jsonrpc: '2.0',
                    result: result,
                    id: data.id
                  });

                  _this2.switchAway(false);

                  return _context.abrupt("return");

                case 15:
                  _this2.provider = new _ethers.ethers.providers.JsonRpcProvider(value);
                  _context.prev = 16;
                  setTimeout(function () {
                    if (!_this2.connected) {
                      _this2.switchAway(true);

                      reject('Unable to connect');
                    }
                  }, 2000);
                  _context.next = 20;
                  return _this2.provider.ready;

                case 20:
                  _this2.connected = true;
                  _context.next = 28;
                  break;

                case 23:
                  _context.prev = 23;
                  _context.t1 = _context["catch"](16);

                  _this2.switchAway(true);

                  reject('Unable to connect');
                  return _context.abrupt("return");

                case 28:
                  _this2.sendAsyncInternal(data, resolve, reject);

                  _context.next = 32;
                  break;

                case 31:
                  _this2.sendAsyncInternal(data, resolve, reject);

                case 32:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[3, 9], [16, 23]]);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "switchAway",
    value: function () {
      var _switchAway = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(showError) {
        var _this3 = this;

        var modalContent;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.provider = null;
                this.blocked = true;
                this.connected = false;

                if (showError) {
                  modalContent = {
                    id: this.profile.name,
                    title: this.profile.displayName,
                    message: "Error while connecting to the provider, provider not connected"
                  };
                  this.call('notification', 'alert', modalContent);
                }

                _context2.next = 6;
                return this.call('udapp', 'setEnvironmentMode', {
                  context: 'vm',
                  fork: 'london'
                });

              case 6:
                setTimeout(function (_) {
                  _this3.blocked = false;
                }, 1000); // we wait 1 second for letting remix to switch to vm        

                return _context2.abrupt("return");

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function switchAway(_x3) {
        return _switchAway.apply(this, arguments);
      }

      return switchAway;
    }()
  }, {
    key: "sendAsyncInternal",
    value: function () {
      var _sendAsyncInternal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(data, resolve, reject) {
        var result, _result;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.provider) {
                  _context3.next = 16;
                  break;
                }

                if (!(this.blockchain.getProvider() !== this.profile.displayName && data.method !== 'net_listening')) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", reject(new Error('Environment Updated !!')));

              case 3:
                _context3.prev = 3;
                _context3.next = 6;
                return this.provider.send(data.method, data.params);

              case 6:
                result = _context3.sent;
                resolve({
                  jsonrpc: '2.0',
                  result: result,
                  id: data.id
                });
                _context3.next = 14;
                break;

              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](3);

                if (_context3.t0 && _context3.t0.message && _context3.t0.message.includes('net_version') && _context3.t0.message.includes('SERVER_ERROR')) {
                  this.switchAway(true);
                }

                reject(_context3.t0);

              case 14:
                _context3.next = 18;
                break;

              case 16:
                _result = data.method === 'net_listening' ? 'canceled' : [];
                resolve({
                  jsonrpc: '2.0',
                  result: _result,
                  id: data.id
                });

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[3, 10]]);
      }));

      function sendAsyncInternal(_x4, _x5, _x6) {
        return _sendAsyncInternal.apply(this, arguments);
      }

      return sendAsyncInternal;
    }()
  }]);
  return AbstractProvider;
}(_engine.Plugin);

exports.AbstractProvider = AbstractProvider;

/***/ }),
/* 1267 */,
/* 1268 */,
/* 1269 */,
/* 1270 */,
/* 1271 */,
/* 1272 */,
/* 1273 */,
/* 1274 */,
/* 1275 */,
/* 1276 */,
/* 1277 */,
/* 1278 */,
/* 1279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * @dev Get contract obj of given contract name from last compilation result.
   * @param name contract name
   * @param contracts 'contracts' object from last compilation result
   */
  getContract: (contractName, contracts) => {
    for (const file in contracts) {
      if (contracts[file][contractName]) {
        return {
          object: contracts[file][contractName],
          file: file
        };
      }
    }

    return null;
  },

  /**
   * @dev call the given callback for all contracts from last compilation result, stop visiting when cb return true
   * @param contracts - 'contracts' object from last compilation result
   * @param cb    - callback
   */
  visitContracts: (contracts, cb) => {
    for (const file in contracts) {
      for (const name in contracts[file]) {
        const param = {
          name: name,
          object: contracts[file][name],
          file: file
        };
        if (cb(param)) return;
      }
    }
  },
  // ^ e.g:
  // browser/gm.sol: Warning: Source file does not specify required compiler version! Consider adding "pragma solidity ^0.6.12
  // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/introspection/IERC1820Registry.sol:3:1: ParserError: Source file requires different compiler version (current compiler is 0.7.4+commit.3f05b770.Emscripten.clang) - note that nightly builds are considered to be strictly less than the released version
  getPositionDetails: msg => {
    const result = {}; // To handle some compiler warning without location like SPDX license warning etc

    if (!msg.includes(':')) return {
      errLine: -1,
      errCol: -1,
      errFile: ''
    };
    if (msg.includes('-->')) msg = msg.split('-->')[1].trim(); // extract line / column

    let pos = msg.match(/^(.*?):([0-9]*?):([0-9]*?)?/);
    result.errLine = pos ? parseInt(pos[2]) - 1 : -1;
    result.errCol = pos ? parseInt(pos[3]) : -1; // extract file

    pos = msg.match(/^(https:.*?|http:.*?|.*?):/);
    result.errFile = pos ? pos[1] : msg;
    return result;
  }
};

/***/ }),
/* 1280 */,
/* 1281 */,
/* 1282 */,
/* 1283 */,
/* 1284 */,
/* 1285 */,
/* 1286 */,
/* 1287 */,
/* 1288 */,
/* 1289 */,
/* 1290 */,
/* 1291 */,
/* 1292 */,
/* 1293 */,
/* 1294 */,
/* 1295 */,
/* 1296 */,
/* 1297 */,
/* 1298 */,
/* 1299 */,
/* 1300 */,
/* 1301 */,
/* 1302 */,
/* 1303 */,
/* 1304 */,
/* 1305 */,
/* 1306 */,
/* 1307 */,
/* 1308 */,
/* 1309 */,
/* 1310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _typeof2 = _interopRequireDefault(__webpack_require__(219));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var async = __webpack_require__(222);

var ethJSUtil = __webpack_require__(34);

module.exports = {
  shortenAddress: function shortenAddress(address, etherBalance) {
    var len = address.length;
    return address.slice(0, 5) + '...' + address.slice(len - 5, len) + (etherBalance ? ' (' + etherBalance.toString() + ' ether)' : '');
  },
  addressToString: function addressToString(address) {
    if (!address) return null;

    if (typeof address !== 'string') {
      address = address.toString('hex');
    }

    if (address.indexOf('0x') === -1) {
      address = '0x' + address;
    }

    return ethJSUtil.toChecksumAddress(address);
  },
  shortenHexData: function shortenHexData(data) {
    if (!data) return '';
    if (data.length < 5) return data;
    var len = data.length;
    return data.slice(0, 5) + '...' + data.slice(len - 5, len);
  },
  createNonClashingNameWithPrefix: function createNonClashingNameWithPrefix(name, fileProvider, prefix, cb) {
    if (!name) name = 'Undefined';
    var counter = '';
    var ext = 'sol';
    var reg = /(.*)\.([^.]+)/g;
    var split = reg.exec(name);

    if (split) {
      name = split[1];
      ext = split[2];
    }

    var exist = true;
    async.whilst(function () {
      return exist;
    }, function (callback) {
      fileProvider.exists(name + counter + prefix + '.' + ext).then(function (currentExist) {
        exist = currentExist;
        if (exist) counter = (counter | 0) + 1;
        callback();
      })["catch"](function (error) {
        if (error) console.log(error);
      });
    }, function (error) {
      cb(error, name + counter + prefix + '.' + ext);
    });
  },
  createNonClashingName: function createNonClashingName(name, fileProvider, cb) {
    this.createNonClashingNameWithPrefix(name, fileProvider, '', cb);
  },
  createNonClashingNameAsync: function createNonClashingNameAsync(name, fileManager) {
    var _arguments = arguments;
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
      var prefix, counter, ext, reg, split, exist, isDuplicate;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              prefix = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : '';
              if (!name) name = 'Undefined';
              counter = '';
              ext = 'sol';
              reg = /(.*)\.([^.]+)/g;
              split = reg.exec(name);

              if (split) {
                name = split[1];
                ext = split[2];
              }

              exist = true;

            case 8:
              _context.next = 10;
              return fileManager.exists(name + counter + prefix + '.' + ext);

            case 10:
              isDuplicate = _context.sent;
              if (isDuplicate) counter = (counter | 0) + 1;else exist = false;

            case 12:
              if (exist) {
                _context.next = 8;
                break;
              }

            case 13:
              return _context.abrupt("return", name + counter + prefix + '.' + ext);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  createNonClashingDirNameAsync: function createNonClashingDirNameAsync(name, fileManager) {
    return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
      var counter, exist, isDuplicate;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!name) name = 'Undefined';
              counter = '';
              exist = true;

            case 3:
              _context2.next = 5;
              return fileManager.exists(name + counter);

            case 5:
              isDuplicate = _context2.sent;
              if (isDuplicate) counter = (counter | 0) + 1;else exist = false;

            case 7:
              if (exist) {
                _context2.next = 3;
                break;
              }

            case 8:
              return _context2.abrupt("return", name + counter);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  },
  checkSpecialChars: function checkSpecialChars(name) {
    return name.match(/[:*?"<>\\'|]/) != null;
  },
  checkSlash: function checkSlash(name) {
    return name.match(/\//) != null;
  },
  isHexadecimal: function isHexadecimal(value) {
    return /^[0-9a-fA-F]+$/.test(value) && value.length % 2 === 0;
  },
  is0XPrefixed: function is0XPrefixed(value) {
    return value.substr(0, 2) === '0x';
  },
  isNumeric: function isNumeric(value) {
    return /^\+?(0|[1-9]\d*)$/.test(value);
  },
  isValidHash: function isValidHash(hash) {
    // 0x prefixed, hexadecimal, 64digit
    var hexValue = hash.slice(2, hash.length);
    return this.is0XPrefixed(hash) && /^[0-9a-fA-F]{64}$/.test(hexValue);
  },
  removeTrailingSlashes: function removeTrailingSlashes(text) {
    // Remove single or consecutive trailing slashes
    return text.replace(/\/+$/g, '');
  },
  removeMultipleSlashes: function removeMultipleSlashes(text) {
    // Replace consecutive slashes with '/'
    return text.replace(/\/+/g, '/');
  },
  find: find,
  joinPath: function joinPath() {
    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
      paths[_key] = arguments[_key];
    }

    paths = paths.filter(function (value) {
      return value !== '';
    }).map(function (path) {
      return path.replace(/^\/|\/$/g, '');
    }); // remove first and last slash)

    if (paths.length === 1) return paths[0];
    return paths.join('/');
  },
  extractNameFromKey: function extractNameFromKey(key) {
    var keyPath = key.split('/');
    return keyPath[keyPath.length - 1];
  }
};

function findDeep(object, fn) {
  var found = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    "break": false,
    value: undefined
  };
  if ((0, _typeof2["default"])(object) !== 'object' || object === null) return;

  for (var i in object) {
    if (found["break"]) break;
    var el = object[i];
    if (el && el.innerText !== undefined && el.innerText !== null) el = el.innerText;

    if (fn(el, i, object)) {
      found.value = el;
      found["break"] = true;
      break;
    } else {
      findDeep(el, fn, found);
    }
  }

  return found.value;
}

function find(args, query) {
  query = query.trim();
  var isMatch = !!findDeep(args, function check(value, key) {
    if (value === undefined || value === null) return false;
    if (typeof value === 'function') return false;
    if ((0, _typeof2["default"])(value) === 'object') return false;
    var contains = String(value).indexOf(query.trim()) !== -1;
    return contains;
  });
  return isMatch;
}

/***/ }),
/* 1311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractPanel = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _events = __webpack_require__(40);

var _engineWeb = __webpack_require__(1133);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var EventManager = __webpack_require__(1196);

var AbstractPanel = /*#__PURE__*/function (_HostPlugin) {
  (0, _inherits2["default"])(AbstractPanel, _HostPlugin);

  var _super = _createSuper(AbstractPanel);

  function AbstractPanel(profile) {
    var _this;

    (0, _classCallCheck2["default"])(this, AbstractPanel);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "events", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "event", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "plugins", {});
    _this.events = new _events.EventEmitter();
    _this.event = new EventManager();
    return _this;
  }

  (0, _createClass2["default"])(AbstractPanel, [{
    key: "currentFocus",
    value: function currentFocus() {
      return Object.values(this.plugins).find(function (plugin) {
        return plugin.active;
      }).profile.name;
    }
  }, {
    key: "addView",
    value: function addView(profile, view) {
      if (this.plugins[profile.name]) throw new Error("Plugin ".concat(profile.name, " already rendered"));
      this.plugins[profile.name] = {
        profile: profile,
        view: view,
        active: false,
        "class": 'plugItIn active'
      };
    }
  }, {
    key: "removeView",
    value: function removeView(profile) {
      this.emit('pluginDisabled', profile.name);
      this.call('menuicons', 'unlinkContent', profile);
      this.remove(profile.name);
    }
    /**
     * Remove a plugin from the panel
     * @param {String} name The name of the plugin to remove
     */

  }, {
    key: "remove",
    value: function remove(name) {
      delete this.plugins[name];
    }
    /**
     * Display the content of this specific plugin
     * @param {String} name The name of the plugin to display the content
     */

  }, {
    key: "showContent",
    value: function showContent(name) {
      if (!this.plugins[name]) throw new Error("Plugin ".concat(name, " is not yet activated"));
      Object.values(this.plugins).forEach(function (plugin) {
        plugin.active = false;
      });
      this.plugins[name].active = true;
    }
  }, {
    key: "focus",
    value: function focus(name) {
      this.showContent(name);
    }
  }]);
  return AbstractPanel;
}(_engineWeb.HostPlugin);

exports.AbstractPanel = AbstractPanel;

/***/ }),
/* 1312 */,
/* 1313 */,
/* 1314 */,
/* 1315 */,
/* 1316 */,
/* 1317 */,
/* 1318 */,
/* 1319 */,
/* 1320 */,
/* 1321 */,
/* 1322 */,
/* 1323 */,
/* 1324 */,
/* 1325 */,
/* 1326 */,
/* 1327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageResolver = void 0;

const tslib_1 = __webpack_require__(23);

const traceHelper_1 = __webpack_require__(1146);

const mappingPreimages_1 = __webpack_require__(1512);
/**
  * Basically one instance is created for one debugging session.
  * (TODO: one instance need to be shared over all the components)
  */


class StorageResolver {
  constructor(options) {
    this.storageByAddress = {};
    this.preimagesMappingByAddress = {};
    this.maxSize = 100;
    this.web3 = options.web3;
    this.zeroSlot = '0x0000000000000000000000000000000000000000000000000000000000000000';
  }
  /**
   * returns the storage for the given context (address and vm trace index)
   * returns the range 0x0 => this.maxSize
   *
   * @param {Object} - tx - transaction
   * @param {Int} - stepIndex - Index of the stop in the vm trace
   * @param {String} - address - lookup address
   * @param {Function} - callback - contains a map: [hashedKey] = {key, hashedKey, value}
   */


  storageRange(tx, stepIndex, address) {
    return this.storageRangeInternal(this, this.zeroSlot, tx, stepIndex, address);
  }
  /**
   * compute the mappgings type locations for the current address (cached for a debugging session)
   * note: that only retrieve the first 100 items.
   *
   * @param {Object} tx
   * @param {Int} stepIndex
   * @param {Object} address  - storage
   * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
   * @return {Function} - callback
   */


  initialPreimagesMappings(tx, stepIndex, address, corrections) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (this.preimagesMappingByAddress[address]) {
        return this.preimagesMappingByAddress[address];
      }

      const storage = yield this.storageRange(tx, stepIndex, address);
      const mappings = (0, mappingPreimages_1.decodeMappingsKeys)(this.web3, storage, corrections);
      this.preimagesMappingByAddress[address] = mappings;
      return mappings;
    });
  }
  /**
   * return a slot value for the given context (address and vm trace index)
   *
   * @param {String} - slot - slot key
   * @param {Object} - tx - transaction
   * @param {Int} - stepIndex - Index of the stop in the vm trace
   * @param {String} - address - lookup address
   * @param {Function} - callback - {key, hashedKey, value} -
   */


  storageSlot(slot, tx, stepIndex, address) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const storage = yield this.storageRangeInternal(this, slot, tx, stepIndex, address);
      return storage[slot] !== undefined ? storage[slot] : null;
    });
  }
  /**
   * return True if the storage at @arg address is complete
   *
   * @param {String} address  - contract address
   * @return {Bool} - return True if the storage at @arg address is complete
   */


  isComplete(address) {
    return this.storageByAddress[address] && this.storageByAddress[address].complete;
  }
  /**
   * retrieve the storage and ensure at least @arg slot is cached.
   * - If @arg slot is already cached, the storage will be returned from the cache
   *   even if the next 1000 items are not in the cache.
   * - If @arg slot is not cached, the corresponding value will be resolved and the next 1000 slots.
   */


  storageRangeInternal(self, slotKey, tx, stepIndex, address) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const cached = this.fromCache(self, address);

      if (cached && cached.storage[slotKey]) {
        // we have the current slot in the cache and maybe the next 1000...
        return cached.storage;
      }

      const result = yield this.storageRangeWeb3Call(tx, address, slotKey, self.maxSize);
      const [storage, nextKey] = result;

      if (!storage[slotKey] && slotKey !== self.zeroSlot) {
        // we don't cache the zero slot (could lead to inconsistency)
        storage[slotKey] = {
          key: slotKey,
          value: self.zeroSlot
        };
      }

      self.toCache(self, address, storage);

      if (slotKey === self.zeroSlot && !nextKey) {
        // only working if keys are sorted !!
        self.storageByAddress[address].complete = true;
      }

      return storage;
    });
  }
  /**
   * retrieve the storage from the cache. if @arg slot is defined, return only the desired slot, if not return the entire known storage
   *
   * @param {String} address  - contract address
   * @return {String} - either the entire known storage or a single value
   */


  fromCache(self, address) {
    if (!self.storageByAddress[address]) {
      return null;
    }

    return self.storageByAddress[address];
  }
  /**
   * store the result of `storageRangeAtInternal`
   *
   * @param {String} address  - contract address
   * @param {Object} storage  - result of `storageRangeAtInternal`, contains {key, hashedKey, value}
   */


  toCache(self, address, storage) {
    if (!self.storageByAddress[address]) {
      self.storageByAddress[address] = {};
    }

    self.storageByAddress[address].storage = Object.assign(self.storageByAddress[address].storage || {}, storage);
  }

  storageRangeWeb3Call(tx, address, start, maxSize) {
    return new Promise((resolve, reject) => {
      if ((0, traceHelper_1.isContractCreation)(address)) {
        resolve([{}, null]);
      } else {
        this.web3.debug.storageRangeAt(tx.blockHash, tx.transactionIndex, address, start, maxSize, (error, result) => {
          if (error) {
            reject(error);
          } else if (result.storage) {
            resolve([result.storage, result.nextKey]);
          } else {
            reject(new Error('the storage has not been provided'));
          }
        });
      }
    });
  }

}

exports.StorageResolver = StorageResolver;

/***/ }),
/* 1328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.atIndex = exports.nodesAtPosition = exports.findNodeAtInstructionIndex = exports.convertOffsetToLineColumn = exports.getLinebreakPositions = exports.decompressAll = exports.decode = void 0;

const remix_astwalker_1 = __webpack_require__(1180);

const remix_lib_1 = __webpack_require__(311);
/**
 * Decompress the source mapping given by solc-bin.js
 * s:l:f:j
 */

/**
 * Decode the given @arg value
 *
 * @param {string} value      - source location to decode ( should be start:length:file )
 * @return {Object} returns the decompressed source mapping {start, length, file}
 */


function decode(value) {
  if (value) {
    value = value.split(':');
    return {
      start: parseInt(value[0]),
      length: parseInt(value[1]),
      file: parseInt(value[2])
    };
  }
}

exports.decode = decode;
/**
 * Decode the source mapping for the given compressed mapping
 *
 * @param {String} mapping     - compressed source mapping given by solc-bin
 * @return {Array} returns the decompressed source mapping. Array of {start, length, file, jump}
 */

function decompressAll(mapping) {
  const map = mapping.split(';');
  const ret = [];

  for (const k in map) {
    const compressed = map[k].split(':');
    const sourceMap = {
      start: compressed[0] ? parseInt(compressed[0]) : ret[ret.length - 1].start,
      length: compressed[1] ? parseInt(compressed[1]) : ret[ret.length - 1].length,
      file: compressed[2] ? parseInt(compressed[2]) : ret[ret.length - 1].file,
      jump: compressed[3] ? compressed[3] : ret[ret.length - 1].jump
    };
    ret.push(sourceMap);
  }

  return ret;
}

exports.decompressAll = decompressAll;
/**
  * Retrieve line/column position of each source char
  *
  * @param {String} source - contract source code
  * @return {Array} returns an array containing offset of line breaks
  */

function getLinebreakPositions(source) {
  const ret = [];

  for (let pos = source.indexOf('\n'); pos >= 0; pos = source.indexOf('\n', pos + 1)) {
    ret.push(pos);
  }

  return ret;
}

exports.getLinebreakPositions = getLinebreakPositions;
/**
 * Retrieve the line/column position for the given source mapping
 *
 * @param {Object} sourceLocation - object containing attributes {source} and {length}
 * @param {Array} lineBreakPositions - array returned by the function 'getLinebreakPositions'
 * @return {Object} returns an object {start: {line, column}, end: {line, column}} (line/column count start at 0)
 */

function convertOffsetToLineColumn(sourceLocation, lineBreakPositions) {
  if (sourceLocation.start >= 0 && sourceLocation.length >= 0) {
    return {
      start: convertFromCharPosition(sourceLocation.start, lineBreakPositions),
      end: convertFromCharPosition(sourceLocation.start + sourceLocation.length, lineBreakPositions)
    };
  }

  return {
    start: null,
    end: null
  };
}

exports.convertOffsetToLineColumn = convertOffsetToLineColumn;

function convertFromCharPosition(pos, lineBreakPositions) {
  let line = remix_lib_1.util.findLowerBound(pos, lineBreakPositions);

  if (lineBreakPositions[line] !== pos) {
    line = line + 1;
  }

  const beginColumn = line === 0 ? 0 : lineBreakPositions[line - 1] + 1;
  const column = pos - beginColumn;
  return {
    line,
    column
  };
}

function sourceLocationFromAstNode(astNode) {
  if (astNode.src) {
    const split = astNode.src.split(':');
    return {
      start: parseInt(split[0]),
      length: parseInt(split[1]),
      file: parseInt(split[2])
    };
  }

  return null;
}
/**
 * Retrieve the first @arg astNodeType that include the source map at arg instIndex
 *
 * @param {String} astNodeType - node type that include the source map instIndex
 * @param {String} instIndex - instruction index used to retrieve the source map
 * @param {String} sourceMap - source map given by the compilation result
 * @param {Object} ast - ast given by the compilation result
 */


function findNodeAtInstructionIndex(astNodeType, instIndex, sourceMap, ast) {
  const sourceLocation = atIndex(instIndex, sourceMap);
  return findNodeAtSourceLocation(astNodeType, sourceLocation, ast);
}

exports.findNodeAtInstructionIndex = findNodeAtInstructionIndex;

function findNodeAtSourceLocation(astNodeType, sourceLocation, ast) {
  const astWalker = new remix_astwalker_1.AstWalker();
  let found = null;

  const callback = function (node) {
    const nodeLocation = sourceLocationFromAstNode(node);

    if (!nodeLocation) {
      return;
    }

    if (nodeLocation.start <= sourceLocation.start && nodeLocation.start + nodeLocation.length >= sourceLocation.start + sourceLocation.length) {
      if (astNodeType === node.nodeType) {
        found = node;
      }
    }
  };

  astWalker.walkFull(ast.ast, callback);
  return found;
}
/**
 * get a list of nodes that are at the given @arg position
 *
 * @param {String} astNodeType      - type of node to return
 * @param {Int} position     - cursor position
 * @return {Object} ast object given by the compiler
 */


function nodesAtPosition(astNodeType, position, ast) {
  const astWalker = new remix_astwalker_1.AstWalker();
  const found = [];

  const callback = function (node) {
    const nodeLocation = sourceLocationFromAstNode(node);

    if (!nodeLocation) {
      return;
    }

    if (nodeLocation.start <= position && nodeLocation.start + nodeLocation.length >= position) {
      if (!astNodeType || astNodeType === node.nodeType) {
        found.push(node);
      }
    }
  };

  astWalker.walkFull(ast.ast, callback);
  return found;
}

exports.nodesAtPosition = nodesAtPosition;
/**
 * starts with the given @arg index and move backward until it can find all the values for start, length, file, jump
 * if `file === -1` then the value of the sourcemap should be taken from the previous step,
 * because some steps are internal subroutine for the compiler and doesn't link to any high level code.
 *
 * Solidity source maps format is
 *  - start:length:file:jump
 *  - jump can be 'i', 'o' or '-' (jump 'in' or 'out' of a function)
 *  - if no value is specified ( e.g "5:2" - no mention of 'file' and 'jump' ), actual values are the one of the step before
 *  - if the file (3rd value) has -1, the source maps should be discarded
 *
 *  @param Int index - index in the bytecode to decode source mapping from
 *  @param Array mapping - source maps returned by the compiler. e.g 121:3741:0:-:0;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;121:3741:0;;;;;;;
 *  @return Object { start, length, file, jump }
 */

function atIndex(index, mapping) {
  const ret = {};
  const map = mapping.split(';');

  if (index >= map.length) {
    index = map.length - 1;
  }

  for (let k = index; k >= 0; k--) {
    let current = map[k];

    if (!current.length) {
      continue;
    }

    current = current.split(':');

    if (ret['start'] === undefined && current[0] && current[0] !== '-1' && current[0].length) {
      ret['start'] = parseInt(current[0]);
    }

    if (ret['length'] === undefined && current[1] && current[1] !== '-1' && current[1].length) {
      ret['length'] = parseInt(current[1]);
    }

    if (ret['file'] === undefined && current[2] && current[2].length) {
      ret['file'] = parseInt(current[2]);
    }

    if (ret['jump'] === undefined && current[3] && current[3].length) {
      ret['jump'] = current[3];
    }

    if (ret['start'] !== undefined && ret['length'] !== undefined && ret['file'] !== undefined && ret['jump'] !== undefined) {
      break;
    }
  }

  return ret;
}

exports.atIndex = atIndex;

/***/ }),
/* 1329 */,
/* 1330 */,
/* 1331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.solidityState = exports.extractStateVariables = exports.decodeState = void 0;

const tslib_1 = __webpack_require__(23);

const astHelper_1 = __webpack_require__(1514);

const decodeInfo_1 = __webpack_require__(1515);
/**
  * decode the contract state storage
  *
  * @param {Array} storage location  - location of all state variables
  * @param {Object} storageResolver  - resolve storage queries
  * @return {Map} - decoded state variable
  */


function decodeState(stateVars, storageResolver) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    const ret = {};

    for (const k in stateVars) {
      const stateVar = stateVars[k];

      try {
        const decoded = yield stateVar.type.decodeFromStorage(stateVar.storagelocation, storageResolver);
        decoded.constant = stateVar.constant;
        decoded.immutable = stateVar.immutable;

        if (decoded.constant) {
          decoded.value = '<constant>';
        }

        if (decoded.immutable) {
          decoded.value = '<immutable>';
        }

        ret[stateVar.name] = decoded;
      } catch (e) {
        console.log(e);
        ret[stateVar.name] = {
          error: '<decoding failed - ' + e.message + '>'
        };
      }
    }

    return ret;
  });
}

exports.decodeState = decodeState;
/**
  * return all storage location variables of the given @arg contractName
  *
  * @param {String} contractName  - name of the contract
  * @param {Object} sourcesList  - sources list
  * @return {Object} - return the location of all contract variables in the storage
  */

function extractStateVariables(contractName, sourcesList) {
  const states = (0, astHelper_1.extractStatesDefinitions)(sourcesList, null);

  if (!states[contractName]) {
    return [];
  }

  const types = states[contractName].stateVariables;
  const offsets = (0, decodeInfo_1.computeOffsets)(types, states, contractName, 'storage');

  if (!offsets) {
    return []; // TODO should maybe return an error
  }

  return offsets.typesOffsets;
}

exports.extractStateVariables = extractStateVariables;
/**
  * return the state of the given @a contractName as a json object
  *
  * @param {Object} storageResolver  - resolve storage queries
  * @param {astList} astList  - AST nodes of all the sources
  * @param {String} contractName  - contract for which state var should be resolved
  * @return {Map} - return the state of the contract
  */

function solidityState(storageResolver, astList, contractName) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    const stateVars = extractStateVariables(contractName, astList);

    try {
      return yield decodeState(stateVars, storageResolver);
    } catch (e) {
      return {
        error: '<decoding failed - ' + e.message + '>'
      };
    }
  });
}

exports.solidityState = solidityState;

/***/ }),
/* 1332 */,
/* 1333 */,
/* 1334 */,
/* 1335 */,
/* 1336 */,
/* 1337 */,
/* 1338 */,
/* 1339 */,
/* 1340 */,
/* 1341 */,
/* 1342 */,
/* 1343 */,
/* 1344 */,
/* 1345 */,
/* 1346 */,
/* 1347 */,
/* 1348 */,
/* 1349 */,
/* 1350 */,
/* 1351 */,
/* 1352 */,
/* 1353 */,
/* 1354 */,
/* 1355 */,
/* 1356 */,
/* 1357 */,
/* 1358 */,
/* 1359 */,
/* 1360 */,
/* 1361 */,
/* 1362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _corePlugin = __webpack_require__(1253);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var EventManager = __webpack_require__(40);

var remixLib = __webpack_require__(311);

var pathModule = __webpack_require__(1124);

var Storage = remixLib.Storage;

var FileProvider = /*#__PURE__*/function () {
  function FileProvider(name) {
    (0, _classCallCheck2["default"])(this, FileProvider);
    this.event = new EventManager();
    this.type = name;
    this.providerExternalsStorage = new Storage('providerExternals:');
    this.externalFolders = [this.type + '/swarm', this.type + '/ipfs', this.type + '/github', this.type + '/gists', this.type + '/https'];
    this.reverseKey = this.type + '-reverse-';
  }

  (0, _createClass2["default"])(FileProvider, [{
    key: "addNormalizedName",
    value: function addNormalizedName(path, url) {
      if (this.type) path = this.type + '/' + path;
      this.providerExternalsStorage.set(path, url);
      this.providerExternalsStorage.set(this.reverseKey + url, path);
    }
  }, {
    key: "removeNormalizedName",
    value: function removeNormalizedName(path) {
      var value = this.providerExternalsStorage.get(path);
      this.providerExternalsStorage.remove(path);
      this.providerExternalsStorage.remove(this.reverseKey + value);
    }
  }, {
    key: "normalizedNameExists",
    value: function normalizedNameExists(path) {
      return this.providerExternalsStorage.exists(path);
    }
  }, {
    key: "getNormalizedName",
    value: function getNormalizedName(path) {
      return this.providerExternalsStorage.get(path);
    }
  }, {
    key: "getPathFromUrl",
    value: function getPathFromUrl(url) {
      return this.providerExternalsStorage.get(this.reverseKey + url);
    }
  }, {
    key: "getUrlFromPath",
    value: function getUrlFromPath(path) {
      if (!path.startsWith(this.type)) path = this.type + '/' + path;
      return this.providerExternalsStorage.get(path);
    }
  }, {
    key: "isExternalFolder",
    value: function isExternalFolder(path) {
      return this.externalFolders.includes(path);
    }
  }, {
    key: "discardChanges",
    value: function () {
      var _discardChanges = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(path, toastCb, modalCb) {
        var _this = this;

        var compilerImport;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.remove(path);
                compilerImport = new _corePlugin.CompilerImports();
                this.providerExternalsStorage.keys().map(function (value) {
                  if (value.indexOf(path) === 0) {
                    compilerImport["import"](_this.getNormalizedName(value), true, function (loadingMsg) {
                      toastCb(loadingMsg);
                    }, /*#__PURE__*/function () {
                      var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(error, content, cleanUrl, type, url) {
                        return _regenerator["default"].wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                if (!error) {
                                  _context.next = 4;
                                  break;
                                }

                                modalCb(error);
                                _context.next = 6;
                                break;

                              case 4:
                                _context.next = 6;
                                return _this.addExternal(type + '/' + cleanUrl, content, url);

                              case 6:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x4, _x5, _x6, _x7, _x8) {
                        return _ref.apply(this, arguments);
                      };
                    }());
                  }
                });

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function discardChanges(_x, _x2, _x3) {
        return _discardChanges.apply(this, arguments);
      }

      return discardChanges;
    }()
  }, {
    key: "exists",
    value: function () {
      var _exists2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(path) {
        var ret;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._exists(path);

              case 2:
                ret = _context3.sent;
                return _context3.abrupt("return", ret);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function exists(_x9) {
        return _exists2.apply(this, arguments);
      }

      return exists;
    }()
  }, {
    key: "_exists",
    value: function () {
      var _exists3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(path) {
        var unprefixedpath;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

                unprefixedpath = this.removePrefix(path);

                if (!(path === this.type)) {
                  _context4.next = 6;
                  break;
                }

                _context4.t0 = true;
                _context4.next = 9;
                break;

              case 6:
                _context4.next = 8;
                return window.remixFileSystem.exists(unprefixedpath);

              case 8:
                _context4.t0 = _context4.sent;

              case 9:
                return _context4.abrupt("return", _context4.t0);

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _exists(_x10) {
        return _exists3.apply(this, arguments);
      }

      return _exists;
    }()
  }, {
    key: "init",
    value: function init(cb) {
      cb();
    }
  }, {
    key: "get",
    value: function () {
      var _get = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(path, cb) {
        var unprefixedpath, content;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cb = cb || function () {
                  /* do nothing. */
                };

                path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

                unprefixedpath = this.removePrefix(path);
                _context5.prev = 3;
                _context5.next = 6;
                return window.remixFileSystem.readFile(unprefixedpath, 'utf8');

              case 6:
                content = _context5.sent;
                if (cb) cb(null, content);
                return _context5.abrupt("return", content);

              case 11:
                _context5.prev = 11;
                _context5.t0 = _context5["catch"](3);
                if (cb) cb(_context5.t0, null);
                throw new Error(_context5.t0);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 11]]);
      }));

      function get(_x11, _x12) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(path, content, cb) {
        var unprefixedpath, exists;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                cb = cb || function () {
                  /* do nothing. */
                };

                unprefixedpath = this.removePrefix(path);
                _context6.next = 4;
                return window.remixFileSystem.exists(unprefixedpath);

              case 4:
                exists = _context6.sent;
                _context6.t0 = exists;

                if (!_context6.t0) {
                  _context6.next = 12;
                  break;
                }

                _context6.next = 9;
                return window.remixFileSystem.readFile(unprefixedpath, 'utf8');

              case 9:
                _context6.t1 = _context6.sent;
                _context6.t2 = content;
                _context6.t0 = _context6.t1 === _context6.t2;

              case 12:
                if (!_context6.t0) {
                  _context6.next = 15;
                  break;
                }

                if (cb) cb();
                return _context6.abrupt("return", null);

              case 15:
                _context6.next = 17;
                return this.createDir(path.substr(0, path.lastIndexOf('/')));

              case 17:
                _context6.prev = 17;
                _context6.next = 20;
                return window.remixFileSystem.writeFile(unprefixedpath, content, 'utf8');

              case 20:
                _context6.next = 26;
                break;

              case 22:
                _context6.prev = 22;
                _context6.t3 = _context6["catch"](17);
                if (cb) cb(_context6.t3);
                return _context6.abrupt("return", false);

              case 26:
                if (!exists) {
                  this.event.emit('fileAdded', this._normalizePath(unprefixedpath), false);
                } else {
                  this.event.emit('fileChanged', this._normalizePath(unprefixedpath));
                }

                if (cb) cb();
                return _context6.abrupt("return", true);

              case 29:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[17, 22]]);
      }));

      function set(_x13, _x14, _x15) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "createDir",
    value: function () {
      var _createDir = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(path, cb) {
        var unprefixedpath, paths, currentCheck, _iterator, _step, value;

        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                unprefixedpath = this.removePrefix(path);
                paths = unprefixedpath.split('/');
                if (paths.length && paths[0] === '') paths.shift();
                currentCheck = '';
                _iterator = _createForOfIteratorHelper(paths);
                _context7.prev = 5;

                _iterator.s();

              case 7:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 24;
                  break;
                }

                value = _step.value;
                currentCheck = currentCheck + '/' + value;
                _context7.next = 12;
                return window.remixFileSystem.exists(currentCheck);

              case 12:
                if (_context7.sent) {
                  _context7.next = 22;
                  break;
                }

                _context7.prev = 13;
                _context7.next = 16;
                return window.remixFileSystem.mkdir(currentCheck);

              case 16:
                this.event.emit('folderAdded', this._normalizePath(currentCheck));
                _context7.next = 22;
                break;

              case 19:
                _context7.prev = 19;
                _context7.t0 = _context7["catch"](13);
                console.log(_context7.t0);

              case 22:
                _context7.next = 7;
                break;

              case 24:
                _context7.next = 29;
                break;

              case 26:
                _context7.prev = 26;
                _context7.t1 = _context7["catch"](5);

                _iterator.e(_context7.t1);

              case 29:
                _context7.prev = 29;

                _iterator.f();

                return _context7.finish(29);

              case 32:
                if (cb) cb();

              case 33:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[5, 26, 29, 32], [13, 19]]);
      }));

      function createDir(_x16, _x17) {
        return _createDir.apply(this, arguments);
      }

      return createDir;
    }() // this will not add a folder as readonly but keep the original url to be able to restore it later

  }, {
    key: "addExternal",
    value: function () {
      var _addExternal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(path, content, url) {
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (url) this.addNormalizedName(path, url);
                _context8.next = 3;
                return this.set(path, content);

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function addExternal(_x18, _x19, _x20) {
        return _addExternal.apply(this, arguments);
      }

      return addExternal;
    }()
  }, {
    key: "isReadOnly",
    value: function isReadOnly(path) {
      return false;
    }
  }, {
    key: "isDirectory",
    value: function () {
      var _isDirectory = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(path) {
        var unprefixedpath;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                unprefixedpath = this.removePrefix(path);

                if (!(path === this.type)) {
                  _context9.next = 5;
                  break;
                }

                _context9.t0 = true;
                _context9.next = 8;
                break;

              case 5:
                _context9.next = 7;
                return window.remixFileSystem.stat(unprefixedpath);

              case 7:
                _context9.t0 = _context9.sent.isDirectory();

              case 8:
                return _context9.abrupt("return", _context9.t0);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function isDirectory(_x21) {
        return _isDirectory.apply(this, arguments);
      }

      return isDirectory;
    }()
  }, {
    key: "isFile",
    value: function () {
      var _isFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(path) {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                path = this.getPathFromUrl(path) || path; // ensure we actually use the normalized path from here

                path = this.removePrefix(path);
                _context10.next = 4;
                return window.remixFileSystem.stat(path);

              case 4:
                return _context10.abrupt("return", _context10.sent.isFile());

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function isFile(_x22) {
        return _isFile.apply(this, arguments);
      }

      return isFile;
    }()
    /**
     * Removes the folder recursively
     * @param {*} path is the folder to be removed
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(path) {
        var stat, items, _iterator2, _step2, item, curPath;

        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                path = this.removePrefix(path);
                _context11.next = 3;
                return window.remixFileSystem.exists(path);

              case 3:
                if (!_context11.sent) {
                  _context11.next = 54;
                  break;
                }

                _context11.next = 6;
                return window.remixFileSystem.stat(path);

              case 6:
                stat = _context11.sent;
                _context11.prev = 7;

                if (stat.isDirectory()) {
                  _context11.next = 12;
                  break;
                }

                return _context11.abrupt("return", this.removeFile(path));

              case 12:
                _context11.next = 14;
                return window.remixFileSystem.readdir(path);

              case 14:
                items = _context11.sent;

                if (!(items.length !== 0)) {
                  _context11.next = 45;
                  break;
                }

                _iterator2 = _createForOfIteratorHelper(items);
                _context11.prev = 17;

                _iterator2.s();

              case 19:
                if ((_step2 = _iterator2.n()).done) {
                  _context11.next = 33;
                  break;
                }

                item = _step2.value;
                curPath = "".concat(path).concat(path.endsWith('/') ? '' : '/').concat(item);
                _context11.next = 24;
                return window.remixFileSystem.stat(curPath);

              case 24:
                if (!_context11.sent.isDirectory()) {
                  _context11.next = 29;
                  break;
                }

                _context11.next = 27;
                return this.remove(curPath);

              case 27:
                _context11.next = 31;
                break;

              case 29:
                _context11.next = 31;
                return this.removeFile(curPath);

              case 31:
                _context11.next = 19;
                break;

              case 33:
                _context11.next = 38;
                break;

              case 35:
                _context11.prev = 35;
                _context11.t0 = _context11["catch"](17);

                _iterator2.e(_context11.t0);

              case 38:
                _context11.prev = 38;

                _iterator2.f();

                return _context11.finish(38);

              case 41:
                _context11.next = 43;
                return window.remixFileSystem.rmdir(path);

              case 43:
                _context11.next = 47;
                break;

              case 45:
                _context11.next = 47;
                return window.remixFileSystem.rmdir(path);

              case 47:
                this.event.emit('fileRemoved', this._normalizePath(path));

              case 48:
                _context11.next = 54;
                break;

              case 50:
                _context11.prev = 50;
                _context11.t1 = _context11["catch"](7);
                console.log(_context11.t1);
                return _context11.abrupt("return", false);

              case 54:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[7, 50], [17, 35, 38, 41]]);
      }));

      function remove(_x23) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * copy the folder recursively (internal use)
     * @param {string} path is the folder to be copied over
     * @param {Function} visitFile is a function called for each visited files
     * @param {Function} visitFolder is a function called for each visited folders
     */

  }, {
    key: "_copyFolderToJsonInternal",
    value: function () {
      var _copyFolderToJsonInternal2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(path, visitFile, visitFolder) {
        var json, items, _iterator3, _step3, item, file, curPath;

        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                visitFile = visitFile || function () {
                  /* do nothing. */
                };

                visitFolder = visitFolder || function () {
                  /* do nothing. */
                };

                json = {};
                path = this.removePrefix(path);
                _context12.next = 6;
                return window.remixFileSystem.exists(path);

              case 6:
                if (!_context12.sent) {
                  _context12.next = 49;
                  break;
                }

                _context12.prev = 7;
                _context12.next = 10;
                return window.remixFileSystem.readdir(path);

              case 10:
                items = _context12.sent;
                visitFolder({
                  path: path
                });

                if (!(items.length !== 0)) {
                  _context12.next = 43;
                  break;
                }

                _iterator3 = _createForOfIteratorHelper(items);
                _context12.prev = 14;

                _iterator3.s();

              case 16:
                if ((_step3 = _iterator3.n()).done) {
                  _context12.next = 35;
                  break;
                }

                item = _step3.value;
                file = {};
                curPath = "".concat(path).concat(path.endsWith('/') ? '' : '/').concat(item);
                _context12.next = 22;
                return window.remixFileSystem.stat(curPath);

              case 22:
                if (!_context12.sent.isDirectory()) {
                  _context12.next = 28;
                  break;
                }

                _context12.next = 25;
                return this._copyFolderToJsonInternal(curPath, visitFile, visitFolder);

              case 25:
                file.children = _context12.sent;
                _context12.next = 32;
                break;

              case 28:
                _context12.next = 30;
                return window.remixFileSystem.readFile(curPath, 'utf8');

              case 30:
                file.content = _context12.sent;
                visitFile({
                  path: curPath,
                  content: file.content
                });

              case 32:
                json[curPath] = file;

              case 33:
                _context12.next = 16;
                break;

              case 35:
                _context12.next = 40;
                break;

              case 37:
                _context12.prev = 37;
                _context12.t0 = _context12["catch"](14);

                _iterator3.e(_context12.t0);

              case 40:
                _context12.prev = 40;

                _iterator3.f();

                return _context12.finish(40);

              case 43:
                _context12.next = 49;
                break;

              case 45:
                _context12.prev = 45;
                _context12.t1 = _context12["catch"](7);
                console.log(_context12.t1);
                throw new Error(_context12.t1);

              case 49:
                return _context12.abrupt("return", json);

              case 50:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[7, 45], [14, 37, 40, 43]]);
      }));

      function _copyFolderToJsonInternal(_x24, _x25, _x26) {
        return _copyFolderToJsonInternal2.apply(this, arguments);
      }

      return _copyFolderToJsonInternal;
    }()
    /**
     * copy the folder recursively
     * @param {string} path is the folder to be copied over
     * @param {Function} visitFile is a function called for each visited files
     * @param {Function} visitFolder is a function called for each visited folders
     */

  }, {
    key: "copyFolderToJson",
    value: function () {
      var _copyFolderToJson = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(path, visitFile, visitFolder) {
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                visitFile = visitFile || function () {
                  /* do nothing. */
                };

                visitFolder = visitFolder || function () {
                  /* do nothing. */
                };

                _context13.next = 4;
                return this._copyFolderToJsonInternal(path, visitFile, visitFolder);

              case 4:
                return _context13.abrupt("return", _context13.sent);

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function copyFolderToJson(_x27, _x28, _x29) {
        return _copyFolderToJson.apply(this, arguments);
      }

      return copyFolderToJson;
    }()
  }, {
    key: "removeFile",
    value: function () {
      var _removeFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(path) {
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                path = this.removePrefix(path);
                _context14.next = 3;
                return window.remixFileSystem.exists(path);

              case 3:
                _context14.t0 = _context14.sent;

                if (!_context14.t0) {
                  _context14.next = 8;
                  break;
                }

                _context14.next = 7;
                return window.remixFileSystem.stat(path);

              case 7:
                _context14.t0 = !_context14.sent.isDirectory();

              case 8:
                if (!_context14.t0) {
                  _context14.next = 15;
                  break;
                }

                _context14.next = 11;
                return window.remixFileSystem.unlink(path);

              case 11:
                this.event.emit('fileRemoved', this._normalizePath(path));
                return _context14.abrupt("return", true);

              case 15:
                return _context14.abrupt("return", false);

              case 16:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function removeFile(_x30) {
        return _removeFile.apply(this, arguments);
      }

      return removeFile;
    }()
  }, {
    key: "rename",
    value: function () {
      var _rename = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(oldPath, newPath, isFolder) {
        var unprefixedoldPath, unprefixednewPath;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                unprefixedoldPath = this.removePrefix(oldPath);
                unprefixednewPath = this.removePrefix(newPath);
                _context15.next = 4;
                return this._exists(unprefixedoldPath);

              case 4:
                if (!_context15.sent) {
                  _context15.next = 9;
                  break;
                }

                _context15.next = 7;
                return window.remixFileSystem.rename(unprefixedoldPath, unprefixednewPath);

              case 7:
                this.event.emit('fileRenamed', this._normalizePath(unprefixedoldPath), this._normalizePath(unprefixednewPath), isFolder);
                return _context15.abrupt("return", true);

              case 9:
                return _context15.abrupt("return", false);

              case 10:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function rename(_x31, _x32, _x33) {
        return _rename.apply(this, arguments);
      }

      return rename;
    }()
  }, {
    key: "resolveDirectory",
    value: function () {
      var _resolveDirectory = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16(path, cb) {
        var files, ret, _iterator4, _step4, element, absPath;

        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                path = this.removePrefix(path);
                if (path.indexOf('/') !== 0) path = '/' + path;
                _context16.prev = 2;
                _context16.next = 5;
                return window.remixFileSystem.readdir(path);

              case 5:
                files = _context16.sent;
                ret = {};

                if (!files) {
                  _context16.next = 30;
                  break;
                }

                _iterator4 = _createForOfIteratorHelper(files);
                _context16.prev = 9;

                _iterator4.s();

              case 11:
                if ((_step4 = _iterator4.n()).done) {
                  _context16.next = 22;
                  break;
                }

                element = _step4.value;
                path = path.replace(/^\/|\/$/g, ''); // remove first and last slash

                element = element.replace(/^\/|\/$/g, ''); // remove first and last slash

                absPath = (path === '/' ? '' : path) + '/' + element;
                _context16.next = 18;
                return window.remixFileSystem.stat(absPath);

              case 18:
                _context16.t0 = _context16.sent.isDirectory();
                ret[absPath.indexOf('/') === 0 ? absPath.substr(1, absPath.length) : absPath] = {
                  isDirectory: _context16.t0
                };

              case 20:
                _context16.next = 11;
                break;

              case 22:
                _context16.next = 27;
                break;

              case 24:
                _context16.prev = 24;
                _context16.t1 = _context16["catch"](9);

                _iterator4.e(_context16.t1);

              case 27:
                _context16.prev = 27;

                _iterator4.f();

                return _context16.finish(27);

              case 30:
                if (cb) cb(null, ret);
                return _context16.abrupt("return", ret);

              case 34:
                _context16.prev = 34;
                _context16.t2 = _context16["catch"](2);
                if (cb) cb(_context16.t2, null);

              case 37:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[2, 34], [9, 24, 27, 30]]);
      }));

      function resolveDirectory(_x34, _x35) {
        return _resolveDirectory.apply(this, arguments);
      }

      return resolveDirectory;
    }()
  }, {
    key: "removePrefix",
    value: function removePrefix(path) {
      path = path.indexOf(this.type) === 0 ? path.replace(this.type, '') : path;
      if (path === '') return '/';
      return path;
    }
  }, {
    key: "_normalizePath",
    value: function _normalizePath(path) {
      return this.type + path;
    }
  }, {
    key: "isSubDirectory",
    value: function isSubDirectory(parent, child) {
      if (!parent) return false;
      if (parent === child) return true;
      var relative = pathModule.relative(parent, child);
      return !!relative && relative.split(pathModule.sep)[0] !== '..';
    }
  }]);
  return FileProvider;
}();

module.exports = FileProvider;

/***/ }),
/* 1363 */,
/* 1364 */,
/* 1365 */,
/* 1366 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2496);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 1367 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2510);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 1368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordWrapText = exports.warnText = exports.textSecondary = exports.textDark = exports.swarmSettingsTitle = exports.swarmSettingsText = exports.matomoAnalytics = exports.labels = exports.ipfsSettingsText = exports.gitAccessTokenTitle = exports.gitAccessTokenText2 = exports.gitAccessTokenText = exports.gitAccessTokenLink = exports.generateContractMetadataText = exports.etherscanTokenTitle = exports.etherscanTokenLink = exports.etherscanAccessTokenText2 = exports.etherscanAccessTokenText = exports.ethereunVMText = exports.enablePersonalModeText = void 0;
const generateContractMetadataText = 'Generate contract metadata. Generate a JSON file in the contract folder. Allows to specify library addresses the contract depends on. If nothing is specified, Remix deploys libraries automatically.';
exports.generateContractMetadataText = generateContractMetadataText;
const textSecondary = 'text-secondary';
exports.textSecondary = textSecondary;
const textDark = 'text-dark';
exports.textDark = textDark;
const warnText = 'Be sure the endpoint is opened before enabling it. \nThis mode allows a user to provide a passphrase in the Remix interface without having to unlock the account. Although this is very convenient, you should completely trust the backend you are connected to (Geth, Parity, ...). Remix never persists any passphrase'.split('\n').map(s => s.trim()).join(' ');
exports.warnText = warnText;
const gitAccessTokenTitle = 'GitHub Access Token';
exports.gitAccessTokenTitle = gitAccessTokenTitle;
const gitAccessTokenText = 'Manage the access token used to publish to Gist and retrieve GitHub contents.';
exports.gitAccessTokenText = gitAccessTokenText;
const gitAccessTokenText2 = 'Go to github token page (link below) to create a new token and save it in Remix. Make sure this token has only \'create gist\' permission.';
exports.gitAccessTokenText2 = gitAccessTokenText2;
const gitAccessTokenLink = 'https://github.com/settings/tokens';
exports.gitAccessTokenLink = gitAccessTokenLink;
const etherscanTokenTitle = 'EtherScan Access Token';
exports.etherscanTokenTitle = etherscanTokenTitle;
const etherscanTokenLink = 'https://etherscan.io/myapikey';
exports.etherscanTokenLink = etherscanTokenLink;
const etherscanAccessTokenText = 'Manage the api key used to interact with Etherscan.';
exports.etherscanAccessTokenText = etherscanAccessTokenText;
const etherscanAccessTokenText2 = 'Go to Etherscan api key page (link below) to create a new api key and save it in Remix.';
exports.etherscanAccessTokenText2 = etherscanAccessTokenText2;
const ethereunVMText = 'Always use Remix VM at load';
exports.ethereunVMText = ethereunVMText;
const wordWrapText = 'Word wrap in editor';
exports.wordWrapText = wordWrapText;
const enablePersonalModeText = ' Enable Personal Mode for Remix Provider. Transaction sent over Web3 will use the web3.personal API.\n';
exports.enablePersonalModeText = enablePersonalModeText;
const matomoAnalytics = 'Enable Matomo Analytics. We do not collect personally identifiable information (PII). The info is used to improve the site’s UX & UI. See more about ';
exports.matomoAnalytics = matomoAnalytics;
const swarmSettingsTitle = 'Swarm Settings';
exports.swarmSettingsTitle = swarmSettingsTitle;
const swarmSettingsText = 'Swarm Settings';
exports.swarmSettingsText = swarmSettingsText;
const ipfsSettingsText = 'IPFS Settings';
exports.ipfsSettingsText = ipfsSettingsText;
const labels = {
  'gist': {
    'link': gitAccessTokenLink,
    'title': gitAccessTokenTitle,
    'message1': gitAccessTokenText,
    'message2': gitAccessTokenText2,
    'key': 'gist-access-token'
  },
  'etherscan': {
    'link': etherscanTokenLink,
    'title': etherscanTokenTitle,
    'message1': etherscanAccessTokenText,
    'message2': etherscanAccessTokenText2,
    'key': 'etherscan-access-token'
  }
};
exports.labels = labels;

/***/ }),
/* 1369 */,
/* 1370 */,
/* 1371 */,
/* 1372 */,
/* 1373 */,
/* 1374 */,
/* 1375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runTest = void 0;

const tslib_1 = __webpack_require__(23);

const async_1 = (0, tslib_1.__importDefault)(__webpack_require__(222));
const changeCase = (0, tslib_1.__importStar)(__webpack_require__(2946));
const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));
const assertionEvents_1 = (0, tslib_1.__importDefault)(__webpack_require__(2649));
/**
 * @dev Get function name using method signature
 * @param signature siganture
 * @param methodIdentifiers Object containing all methods identifier
 */

function getFunctionFullName(signature, methodIdentifiers) {
  for (const method in methodIdentifiers) {
    if (signature.replace('0x', '') === methodIdentifiers[method].replace('0x', '')) {
      return method;
    }
  }

  return null;
}
/**
 * @dev Check if function is constant using function ABI
 * @param funcABI function ABI
 */


function isConstant(funcABI) {
  return funcABI.constant || funcABI.stateMutability === 'view' || funcABI.stateMutability === 'pure';
}
/**
 * @dev Check if function is payable using function ABI
 * @param funcABI function ABI
 */


function isPayable(funcABI) {
  return funcABI.payable || funcABI.stateMutability === 'payable';
}
/**
 * @dev Check node name
 * @param node AST node
 * @param name name
 */


function isNodeName(node, name) {
  return node.name === name;
}
/**
 * @dev Check node type
 * @param node AST node
 * @param type type
 */


function isNodeType(node, type) {
  return node.nodeType === type;
}
/**
 * @dev Check if node type is from the typesList
 * @param node AST node to be checked
 * @param typesList list of types
 */


function isNodeTypeIn(node, typesList) {
  return typesList.includes(node.nodeType);
}
/**
 * @dev Get overrided sender provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */


function getOverridedSender(userdoc, signature, methodIdentifiers) {
  const fullName = getFunctionFullName(signature, methodIdentifiers);
  const senderRegex = /#sender: account-+(\d)/g;
  const accountIndex = fullName && userdoc.methods[fullName] ? senderRegex.exec(userdoc.methods[fullName].notice) : null;
  return fullName && accountIndex ? accountIndex[1] : null;
}
/**
 * @dev Get value provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */


function getProvidedValue(userdoc, signature, methodIdentifiers) {
  const fullName = getFunctionFullName(signature, methodIdentifiers);
  const valueRegex = /#value: (\d+)/g;
  const value = fullName && userdoc.methods[fullName] ? valueRegex.exec(userdoc.methods[fullName].notice) : null;
  return fullName && value ? value[1] : null;
}
/**
 * @dev returns functions of a test contract file in same sequence they appear in file (using passed AST)
 * @param fileAST AST of test contract file source
 * @param testContractName Name of test contract
 */


function getAvailableFunctions(fileAST, testContractName) {
  let funcList = [];

  if (fileAST.nodes && fileAST.nodes.length > 0) {
    const contractAST = fileAST.nodes.filter(node => isNodeName(node, testContractName) && isNodeType(node, 'ContractDefinition'));

    if (contractAST.length > 0 && contractAST[0].nodes) {
      const funcNodes = contractAST[0].nodes.filter(node => node.kind === 'function' && isNodeType(node, 'FunctionDefinition') || isNodeType(node, 'FunctionDefinition'));
      funcList = funcNodes.map(node => node.name);
    }
  }

  return funcList;
}

function getAssertMethodLocation(fileAST, testContractName, functionName, assertMethod) {
  var _a, _b, _c;

  if ((_a = fileAST.nodes) === null || _a === void 0 ? void 0 : _a.length) {
    const contractAST = fileAST.nodes.find(node => isNodeName(node, testContractName) && isNodeType(node, 'ContractDefinition'));

    if ((_b = contractAST === null || contractAST === void 0 ? void 0 : contractAST.nodes) === null || _b === void 0 ? void 0 : _b.length) {
      const funcNode = contractAST.nodes.find(node => isNodeName(node, functionName) && isNodeType(node, 'FunctionDefinition')); // Check if statement nodeType is 'ExpressionStatement' or 'Return', for examples:
      // Assert.equal(foo.get(), 100, "initial value is not correct");
      // return Assert.equal(foo.get(), 100, "initial value is not correct");

      const expressions = funcNode.body.statements.filter(s => isNodeTypeIn(s, ['ExpressionStatement', 'Return']) && isNodeType(s.expression, 'FunctionCall'));
      const assetExpression = expressions.find(e => e.expression.expression && isNodeType(e.expression.expression, 'MemberAccess') && e.expression.expression.memberName === assertMethod && isNodeName(e.expression.expression.expression, 'Assert'));
      return (_c = assetExpression === null || assetExpression === void 0 ? void 0 : assetExpression.expression) === null || _c === void 0 ? void 0 : _c.src;
    }
  }
}
/**
 * @dev returns ABI of passed method list from passed interface
 * @param jsonInterface Json Interface
 * @param funcList Methods to extract the interface of
 */


function getTestFunctionsInterface(jsonInterface, funcList) {
  const functionsInterface = [];
  const specialFunctions = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];

  for (const func of funcList) {
    if (!specialFunctions.includes(func)) {
      const funcInterface = jsonInterface.find(node => node.type === 'function' && node.name === func);
      if (funcInterface) functionsInterface.push(funcInterface);
    }
  }

  return functionsInterface;
}
/**
 * @dev returns ABI of special functions from passed interface
 * @param jsonInterface Json Interface
 */


function getSpecialFunctionsInterface(jsonInterface) {
  const specialFunctionsInterface = {};
  const funcList = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];

  for (const func of funcList) {
    const funcInterface = jsonInterface.find(node => node.type === 'function' && node.name === func);

    if (funcInterface) {
      specialFunctionsInterface[func] = funcInterface;
    }
  }

  return specialFunctionsInterface;
}
/**
 * @dev Prepare a list of tests to run using test contract file ABI, AST & contract name
 * @param jsonInterface File JSON interface
 * @param fileAST File AST
 * @param testContractName Test contract name
 */


function createRunList(jsonInterface, fileAST, testContractName) {
  const availableFunctions = getAvailableFunctions(fileAST, testContractName);
  const testFunctionsInterface = getTestFunctionsInterface(jsonInterface, availableFunctions);
  const specialFunctionsInterface = getSpecialFunctionsInterface(jsonInterface);
  const runList = [];

  if (availableFunctions.includes('beforeAll')) {
    const func = specialFunctionsInterface['beforeAll'];
    runList.push({
      name: 'beforeAll',
      inputs: func.inputs,
      signature: func.signature,
      type: 'internal',
      constant: isConstant(func),
      payable: isPayable(func)
    });
  }

  for (const func of testFunctionsInterface) {
    if (availableFunctions.includes('beforeEach')) {
      const func = specialFunctionsInterface['beforeEach'];
      runList.push({
        name: 'beforeEach',
        inputs: func.inputs,
        signature: func.signature,
        type: 'internal',
        constant: isConstant(func),
        payable: isPayable(func)
      });
    }

    if (func.name && func.inputs) runList.push({
      name: func.name,
      inputs: func.inputs,
      signature: func.signature,
      type: 'test',
      constant: isConstant(func),
      payable: isPayable(func)
    });

    if (availableFunctions.indexOf('afterEach') >= 0) {
      const func = specialFunctionsInterface['afterEach'];
      runList.push({
        name: 'afterEach',
        inputs: func.inputs,
        signature: func.signature,
        type: 'internal',
        constant: isConstant(func),
        payable: isPayable(func)
      });
    }
  }

  if (availableFunctions.indexOf('afterAll') >= 0) {
    const func = specialFunctionsInterface['afterAll'];
    runList.push({
      name: 'afterAll',
      inputs: func.inputs,
      signature: func.signature,
      type: 'internal',
      constant: isConstant(func),
      payable: isPayable(func)
    });
  }

  return runList;
}

function runTest(testName, testObject, contractDetails, fileAST, opts, testCallback, resultsCallback) {
  let passingNum = 0;
  let failureNum = 0;
  let timePassed = 0;
  const isJSONInterfaceAvailable = testObject && testObject.options && testObject.options.jsonInterface;

  if (!isJSONInterfaceAvailable) {
    return resultsCallback(new Error('Contract interface not available'), {
      passingNum,
      failureNum,
      timePassed
    });
  }

  const runList = createRunList(testObject.options.jsonInterface, fileAST, testName);
  const web3 = opts.web3 || new web3_1.default();
  const accts = {
    type: 'accountList',
    value: opts.accounts
  };
  testCallback(undefined, accts);
  const resp = {
    type: 'contract',
    value: testName,
    filename: testObject.filename
  };
  testCallback(undefined, resp);
  async_1.default.eachOfLimit(runList, 1, function (func, index, next) {
    let sender = null;
    let hhLogs;

    if (func.signature) {
      sender = getOverridedSender(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);

      if (opts.accounts && sender) {
        sender = opts.accounts[sender];
      }
    }

    let sendParams = null;
    if (sender) sendParams = {
      from: sender
    };

    if (func.inputs && func.inputs.length > 0) {
      return resultsCallback(new Error(`Method '${func.name}' can not have parameters inside a test contract`), {
        passingNum,
        failureNum,
        timePassed
      });
    }

    const method = testObject.methods[func.name].apply(testObject.methods[func.name], []);
    const startTime = Date.now();
    let debugTxHash;

    if (func.constant) {
      sendParams = {};
      const tagTimestamp = 'remix_tests_tag' + Date.now();
      sendParams.timestamp = tagTimestamp;
      method.call(sendParams).then(result => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const time = (Date.now() - startTime) / 1000.0;
        let tagTxHash;
        if (web3.eth && web3.eth.getHashFromTagBySimulator) tagTxHash = yield web3.eth.getHashFromTagBySimulator(tagTimestamp);
        if (web3.eth && web3.eth.getHHLogsForTx) hhLogs = yield web3.eth.getHHLogsForTx(tagTxHash);
        debugTxHash = tagTxHash;

        if (result) {
          const resp = {
            type: 'testPass',
            value: changeCase.sentenceCase(func.name),
            filename: testObject.filename,
            time: time,
            context: testName,
            web3,
            debugTxHash
          };
          if (hhLogs && hhLogs.length) resp.hhLogs = hhLogs;
          testCallback(undefined, resp);
          passingNum += 1;
          timePassed += time;
        } else {
          const resp = {
            type: 'testFailure',
            value: changeCase.sentenceCase(func.name),
            filename: testObject.filename,
            time: time,
            errMsg: 'function returned false',
            context: testName,
            web3,
            debugTxHash
          };
          if (hhLogs && hhLogs.length) resp.hhLogs = hhLogs;
          testCallback(undefined, resp);
          failureNum += 1;
          timePassed += time;
        }

        next();
      }));
    } else {
      if (func.payable) {
        const value = getProvidedValue(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);

        if (value) {
          if (sendParams) sendParams.value = value;else sendParams = {
            value
          };
        }
      }

      if (!sendParams) sendParams = {};
      sendParams.gas = 10000000 * 8;
      method.send(sendParams).on('receipt', receipt => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        try {
          debugTxHash = receipt.transactionHash;
          if (web3.eth && web3.eth.getHHLogsForTx) hhLogs = yield web3.eth.getHHLogsForTx(receipt.transactionHash);
          const time = (Date.now() - startTime) / 1000.0;
          const assertionEventHashes = assertionEvents_1.default.map(e => web3_1.default.utils.sha3(e.name + '(' + e.params.join() + ')'));
          let testPassed = false;

          for (const i in receipt.events) {
            let events = receipt.events[i];
            if (!Array.isArray(events)) events = [events];

            for (const event of events) {
              const eIndex = assertionEventHashes.indexOf(event.raw.topics[0]); // event name topic will always be at index 0

              if (eIndex >= 0) {
                const testEvent = web3.eth.abi.decodeParameters(assertionEvents_1.default[eIndex].params, event.raw.data);

                if (!testEvent[0]) {
                  const assertMethod = testEvent[2];

                  if (assertMethod === 'ok') {
                    // for 'Assert.ok' method
                    testEvent[3] = 'false';
                    testEvent[4] = 'true';
                  }

                  const location = getAssertMethodLocation(fileAST, testName, func.name, assertMethod);
                  const resp = {
                    type: 'testFailure',
                    value: changeCase.sentenceCase(func.name),
                    filename: testObject.filename,
                    time: time,
                    errMsg: testEvent[1],
                    context: testName,
                    assertMethod,
                    returned: testEvent[3],
                    expected: testEvent[4],
                    location,
                    web3,
                    debugTxHash
                  };
                  if (hhLogs && hhLogs.length) resp.hhLogs = hhLogs;
                  testCallback(undefined, resp);
                  failureNum += 1;
                  timePassed += time;
                  return next();
                }

                testPassed = true;
              }
            }
          }

          if (testPassed) {
            const resp = {
              type: 'testPass',
              value: changeCase.sentenceCase(func.name),
              filename: testObject.filename,
              time: time,
              context: testName,
              web3,
              debugTxHash
            };
            if (hhLogs && hhLogs.length) resp.hhLogs = hhLogs;
            testCallback(undefined, resp);
            passingNum += 1;
            timePassed += time;
          } else if (hhLogs && hhLogs.length) {
            const resp = {
              type: 'logOnly',
              value: changeCase.sentenceCase(func.name),
              filename: testObject.filename,
              time: time,
              context: testName,
              hhLogs
            };
            testCallback(undefined, resp);
            timePassed += time;
          }

          return next();
        } catch (err) {
          console.error(err);
          return next(err);
        }
      })).on('error', err => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const time = (Date.now() - startTime) / 1000.0;
        const resp = {
          type: 'testFailure',
          value: changeCase.sentenceCase(func.name),
          filename: testObject.filename,
          time: time,
          errMsg: err.message,
          context: testName,
          web3
        };

        if (err.message.includes('Transaction has been reverted by the EVM')) {
          const txHash = JSON.parse(err.message.replace('Transaction has been reverted by the EVM:', '')).transactionHash;
          if (web3.eth && web3.eth.getHHLogsForTx) hhLogs = yield web3.eth.getHHLogsForTx(txHash);
          if (hhLogs && hhLogs.length) resp.hhLogs = hhLogs;
          resp.debugTxHash = txHash;
        }

        testCallback(undefined, resp);
        failureNum += 1;
        timePassed += time;
        return next();
      }));
    }
  }, function (error) {
    resultsCallback(error, {
      passingNum,
      failureNum,
      timePassed
    });
  });
}

exports.runTest = runTest;

/***/ }),
/* 1376 */,
/* 1377 */,
/* 1378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compileContractSources = exports.compileFileOrFiles = exports.writeTestAccountsContract = void 0;

const tslib_1 = __webpack_require__(23);

const fileSystem_1 = (0, tslib_1.__importDefault)(__webpack_require__(1603));
const async_1 = (0, tslib_1.__importDefault)(__webpack_require__(222));
const path_1 = (0, tslib_1.__importDefault)(__webpack_require__(1124));
const deep_equal_1 = (0, tslib_1.__importDefault)(__webpack_require__(1369));
const logger_1 = (0, tslib_1.__importDefault)(__webpack_require__(2660));

const remix_solidity_1 = __webpack_require__(1149);

const types_1 = __webpack_require__(1627);

const logger = new logger_1.default();
const log = logger.logger;

function regexIndexOf(inputString, regex, startpos = 0) {
  const indexOf = inputString.substring(startpos).search(regex);
  return indexOf >= 0 ? indexOf + startpos : indexOf;
}

function writeTestAccountsContract(accounts) {
  const testAccountContract = __webpack_require__(2727); // eslint-disable-line


  let body = `address[${accounts.length}] memory accounts;`;
  if (!accounts.length) body += ';';else {
    accounts.map((address, index) => {
      body += `\n\t\taccounts[${index}] = ${address};\n`;
    });
  }
  return testAccountContract.replace('>accounts<', body);
}

exports.writeTestAccountsContract = writeTestAccountsContract;
/**
 * @dev Check if path includes name of a remix test file
 * @param path file path to check
 */

function isRemixTestFile(path) {
  return ['tests.sol', 'remix_tests.sol', 'remix_accounts.sol'].some(name => path.includes(name));
}
/**
 * @dev Process file to prepare sources object to be passed in solc compiler input
 *
 * See: https://solidity.readthedocs.io/en/latest/using-the-compiler.html#input-description
 *
 * @param filePath path of file to process
 * @param sources existing 'sources' object in which keys are the "global" names of the source files and
 *                value is object containing content of corresponding file with under key 'content'
 * @param isRoot True, If file is a root test contract file which is getting processed, not an imported file
 */


function processFile(filePath, sources, isRoot = false) {
  const importRegEx = /import ['"](.+?)['"];/g;
  const isFileAlreadyInSources = Object.keys(sources).includes(filePath); // Return if file is a remix test file or already processed

  if (isRemixTestFile(filePath) || isFileAlreadyInSources) {
    return;
  }

  let content = fileSystem_1.default.readFileSync(filePath, {
    encoding: 'utf-8'
  });
  const testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm; // import 'remix_tests.sol', if file is a root test contract file and doesn't already have it

  if (isRoot && filePath.endsWith('_test.sol') && regexIndexOf(content, testFileImportRegEx) < 0) {
    const includeTestLibs = '\nimport \'remix_tests.sol\';\n';
    content = includeTestLibs.concat(content);
  }

  sources[filePath] = {
    content
  };
}

const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '-';
const isBrowser = !(typeof window === 'undefined' || userAgent.indexOf(' electron/') > -1);
/**
 * @dev Compile file or files before running tests (used for CLI execution)
 * @param filename Name of file
 * @param isDirectory True, if path is a directory
 * @param opts Options
 * @param cb Callback
 *
 * TODO: replace this with remix's own compiler code
 */

function compileFileOrFiles(filename, isDirectory, opts, compilerConfig, cb) {
  let compiler;
  const accounts = opts.accounts || [];
  const sources = {
    'tests.sol': {
      content: __webpack_require__(1387)
    },
    'remix_tests.sol': {
      content: __webpack_require__(1387)
    },
    'remix_accounts.sol': {
      content: writeTestAccountsContract(accounts)
    }
  };
  const filepath = isDirectory ? filename : path_1.default.dirname(filename);

  try {
    if (!isDirectory && fileSystem_1.default.existsSync(filename)) {
      if (filename.split('.').pop() === 'sol') {
        processFile(filename, sources, true);
      } else {
        throw new Error('Not a solidity file');
      }
    } else {
      // walkSync only if it is a directory
      let testFileCount = 0;
      fileSystem_1.default.walkSync(filepath, foundpath => {
        // only process .sol files
        if (foundpath.split('.').pop() === 'sol' && foundpath.endsWith('_test.sol')) {
          testFileCount++;
          processFile(foundpath, sources, true);
        }
      });

      if (testFileCount > 0) {
        log.info(`${testFileCount} Solidity test file${testFileCount === 1 ? '' : 's'} found`);
      } else {
        log.error('No Solidity test file found. Make sure your test file ends with \'_test.sol\'');
        process.exit();
      }
    }
  } catch (e) {
    // eslint-disable-line no-useless-catch
    throw e;
  } finally {
    async_1.default.waterfall([function loadCompiler(next) {
      compiler = new remix_solidity_1.Compiler((url, cb) => {
        try {
          cb(null, fileSystem_1.default.readFileSync(url, 'utf-8'));
        } catch (e) {
          cb(e.message);
        }
      });

      if (compilerConfig) {
        const {
          currentCompilerUrl,
          evmVersion,
          optimize,
          runs
        } = compilerConfig;
        if (evmVersion) compiler.set('evmVersion', evmVersion);
        if (optimize) compiler.set('optimize', optimize);
        if (runs) compiler.set('runs', runs);

        if (currentCompilerUrl) {
          compiler.loadRemoteVersion(currentCompilerUrl);
          compiler.event.register('compilerLoaded', this, function (version) {
            next();
          });
        } else {
          compiler.onInternalCompilerLoaded();
          next();
        }
      } else {
        compiler.onInternalCompilerLoaded();
        next();
      }
    }, function doCompilation(next) {
      // @ts-ignore
      compiler.event.register('compilationFinished', this, (success, data, source, input, version) => {
        next(null, data);
      });
      compiler.compile(sources, filepath);
    }], function (err, result) {
      const error = [];
      if (result.error) error.push(result.error);
      const errors = (result.errors || error).filter(e => e.type === 'Error' || e.severity === 'error');

      if (errors.length > 0) {
        if (!isBrowser) __webpack_require__(1388).fatal(errors); // eslint-disable-line

        return cb(new types_1.CompilationErrors(errors));
      }

      cb(err, result.contracts, result.sources); // return callback with contract details & ASTs
    });
  }
}

exports.compileFileOrFiles = compileFileOrFiles;
/**
 * @dev Compile contract source before running tests (used for IDE tests execution)
 * @param sources sources
 * @param compilerConfig current compiler configuration
 * @param importFileCb Import file callback
 * @param opts Options
 * @param cb Callback
 */

function compileContractSources(sources, newCompConfig, importFileCb, UTRunner, opts, cb) {
  let compiler;
  const filepath = opts.testFilePath || '';
  const testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
  const includeTestLibs = '\nimport \'remix_tests.sol\';\n';

  for (const file in sources) {
    const c = sources[file].content;

    if (file.endsWith('_test.sol') && c && regexIndexOf(c, testFileImportRegEx) < 0) {
      sources[file].content = includeTestLibs.concat(c);
    }
  }

  async_1.default.waterfall([next => {
    if (!compiler || !(0, deep_equal_1.default)(UTRunner.compilerConfig, newCompConfig)) {
      UTRunner.compilerConfig = newCompConfig;
      const {
        currentCompilerUrl,
        evmVersion,
        optimize,
        runs,
        usingWorker
      } = newCompConfig;
      compiler = new remix_solidity_1.Compiler(importFileCb);
      compiler.set('evmVersion', evmVersion);
      compiler.set('optimize', optimize);
      compiler.set('runs', runs);
      compiler.loadVersion(usingWorker, currentCompilerUrl); // @ts-ignore

      compiler.event.register('compilerLoaded', this, version => {
        next();
      });
    } else {
      compiler = UTRunner.compiler;
      next();
    }
  }, next => {
    const compilationFinishedCb = (success, data, source, input, version) => {
      // data.error usually exists for exceptions like worker error etc.
      if (!data.error) UTRunner.compiler = compiler;
      if (opts && opts.event) opts.event.emit('compilationFinished', success, data, source, input, version);
      next(null, data);
    };

    compiler.event.unregister('compilationFinished', compilationFinishedCb); // @ts-ignore

    compiler.event.register('compilationFinished', compilationFinishedCb);
    compiler.compile(sources, filepath);
  }], function (err, result) {
    const error = [];
    if (result.error) error.push(result.error);
    const errors = (result.errors || error).filter(e => e.type === 'Error' || e.severity === 'error');

    if (errors.length > 0) {
      if (!isBrowser) __webpack_require__(1388).fatal(errors); // eslint-disable-line

      return cb(new types_1.CompilationErrors(errors));
    }

    cb(err, result.contracts, result.sources); // return callback with contract details & ASTs
  });
}

exports.compileContractSources = compileContractSources;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 1379 */,
/* 1380 */,
/* 1381 */,
/* 1382 */,
/* 1383 */,
/* 1384 */,
/* 1385 */,
/* 1386 */,
/* 1387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = `// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.4.22 <0.9.0;

library Assert {

  event AssertionEvent(
    bool passed,
    string message,
    string methodName
  );

  event AssertionEventUint(
    bool passed,
    string message,
    string methodName,
    uint256 returned,
    uint256 expected
  );

  event AssertionEventInt(
    bool passed,
    string message,
    string methodName,
    int256 returned,
    int256 expected
  );

  event AssertionEventBool(
    bool passed,
    string message,
    string methodName,
    bool returned,
    bool expected
  );

  event AssertionEventAddress(
    bool passed,
    string message,
    string methodName,
    address returned,
    address expected
  );

  event AssertionEventBytes32(
    bool passed,
    string message,
    string methodName,
    bytes32 returned,
    bytes32 expected
  );

  event AssertionEventString(
    bool passed,
    string message,
    string methodName,
    string returned,
    string expected
  );

  event AssertionEventUintInt(
    bool passed,
    string message,
    string methodName,
    uint256 returned,
    int256 expected
  );

  event AssertionEventIntUint(
    bool passed,
    string message,
    string methodName,
    int256 returned,
    uint256 expected
  );

  function ok(bool a, string memory message) public returns (bool result) {
    result = a;
    emit AssertionEvent(result, message, "ok");
  }

  function equal(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventUint(result, message, "equal", a, b);
  }

  function equal(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventInt(result, message, "equal", a, b);
  }

  function equal(bool a, bool b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventBool(result, message, "equal", a, b);
  }

  // TODO: only for certain versions of solc
  //function equal(fixed a, fixed b, string message) public returns (bool result) {
  //  result = (a == b);
  //  emit AssertionEvent(result, message);
  //}

  // TODO: only for certain versions of solc
  //function equal(ufixed a, ufixed b, string message) public returns (bool result) {
  //  result = (a == b);
  //  emit AssertionEvent(result, message);
  //}

  function equal(address a, address b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventAddress(result, message, "equal", a, b);
  }

  function equal(bytes32 a, bytes32 b, string memory message) public returns (bool result) {
    result = (a == b);
    emit AssertionEventBytes32(result, message, "equal", a, b);
  }

  function equal(string memory a, string memory b, string memory message) public returns (bool result) {
     result = (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b)));
     emit AssertionEventString(result, message, "equal", a, b);
  }

  function notEqual(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventUint(result, message, "notEqual", a, b);
  }

  function notEqual(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventInt(result, message, "notEqual", a, b);
  }

  function notEqual(bool a, bool b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventBool(result, message, "notEqual", a, b);
  }

  // TODO: only for certain versions of solc
  //function notEqual(fixed a, fixed b, string message) public returns (bool result) {
  //  result = (a != b);
  //  emit AssertionEvent(result, message);
  //}

  // TODO: only for certain versions of solc
  //function notEqual(ufixed a, ufixed b, string message) public returns (bool result) {
  //  result = (a != b);
  //  emit AssertionEvent(result, message);
  //}

  function notEqual(address a, address b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventAddress(result, message, "notEqual", a, b);
  }

  function notEqual(bytes32 a, bytes32 b, string memory message) public returns (bool result) {
    result = (a != b);
    emit AssertionEventBytes32(result, message, "notEqual", a, b);
  }

  function notEqual(string memory a, string memory b, string memory message) public returns (bool result) {
    result = (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b)));
    emit AssertionEventString(result, message, "notEqual", a, b);
  }

  /*----------------- Greater than --------------------*/
  function greaterThan(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a > b);
    emit AssertionEventUint(result, message, "greaterThan", a, b);
  }

  function greaterThan(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a > b);
    emit AssertionEventInt(result, message, "greaterThan", a, b);
  }
  // TODO: safely compare between uint and int
  function greaterThan(uint256 a, int256 b, string memory message) public returns (bool result) {
    if(b < int(0)) {
      // int is negative uint "a" always greater
      result = true;
    } else {
      result = (a > uint(b));
    }
    emit AssertionEventUintInt(result, message, "greaterThan", a, b);
  }
  function greaterThan(int256 a, uint256 b, string memory message) public returns (bool result) {
    if(a < int(0)) {
      // int is negative uint "b" always greater
      result = false;
    } else {
      result = (uint(a) > b);
    }
    emit AssertionEventIntUint(result, message, "greaterThan", a, b);
  }
  /*----------------- Lesser than --------------------*/
  function lesserThan(uint256 a, uint256 b, string memory message) public returns (bool result) {
    result = (a < b);
    emit AssertionEventUint(result, message, "lesserThan", a, b);
  }

  function lesserThan(int256 a, int256 b, string memory message) public returns (bool result) {
    result = (a < b);
    emit AssertionEventInt(result, message, "lesserThan", a, b);
  }
  // TODO: safely compare between uint and int
  function lesserThan(uint256 a, int256 b, string memory message) public returns (bool result) {
    if(b < int(0)) {
      // int is negative int "b" always lesser
      result = false;
    } else {
      result = (a < uint(b));
    }
    emit AssertionEventUintInt(result, message, "lesserThan", a, b);
  }

  function lesserThan(int256 a, uint256 b, string memory message) public returns (bool result) {
    if(a < int(0)) {
      // int is negative int "a" always lesser
      result = true;
    } else {
      result = (uint(a) < b);
    }
    emit AssertionEventIntUint(result, message, "lesserThan", a, b);
  }
}
`;

/***/ }),
/* 1388 */,
/* 1389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileSystemContext = void 0;

var _react = __webpack_require__(29);

const FileSystemContext = /*#__PURE__*/(0, _react.createContext)(null);
exports.FileSystemContext = FileSystemContext;

/***/ }),
/* 1390 */,
/* 1391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setWorkspaces = exports.setRenameWorkspace = exports.setReadOnlyMode = exports.setMode = exports.setExpandPath = exports.setDeleteWorkspace = exports.setCurrentWorkspace = exports.setContextMenuItem = exports.rootFolderChangedSuccess = exports.removeInputFieldSuccess = exports.removeFocus = exports.removeContextMenuItem = exports.loadLocalhostSuccess = exports.loadLocalhostRequest = exports.loadLocalhostError = exports.hidePopUp = exports.hideNotification = exports.fsInitializationCompleted = exports.folderAddedSuccess = exports.focusElement = exports.fileRenamedSuccess = exports.fileRemovedSuccess = exports.fileAddedSuccess = exports.fetchWorkspaceDirectorySuccess = exports.fetchWorkspaceDirectoryRequest = exports.fetchWorkspaceDirectoryError = exports.fetchDirectorySuccess = exports.fetchDirectoryRequest = exports.fetchDirectoryError = exports.displayPopUp = exports.displayNotification = exports.createWorkspaceSuccess = exports.createWorkspaceRequest = exports.createWorkspaceError = exports.cloneRepositorySuccess = exports.cloneRepositoryRequest = exports.cloneRepositoryFailed = exports.addInputFieldSuccess = void 0;

const setCurrentWorkspace = workspace => {
  return {
    type: 'SET_CURRENT_WORKSPACE',
    payload: workspace
  };
};

exports.setCurrentWorkspace = setCurrentWorkspace;

const setWorkspaces = workspaces => {
  return {
    type: 'SET_WORKSPACES',
    payload: workspaces
  };
};

exports.setWorkspaces = setWorkspaces;

const setMode = mode => {
  return {
    type: 'SET_MODE',
    payload: mode
  };
};

exports.setMode = setMode;

const fetchDirectoryError = error => {
  return {
    type: 'FETCH_DIRECTORY_ERROR',
    payload: error
  };
};

exports.fetchDirectoryError = fetchDirectoryError;

const fetchDirectoryRequest = promise => {
  return {
    type: 'FETCH_DIRECTORY_REQUEST',
    payload: promise
  };
};

exports.fetchDirectoryRequest = fetchDirectoryRequest;

const fetchDirectorySuccess = (path, fileTree) => {
  return {
    type: 'FETCH_DIRECTORY_SUCCESS',
    payload: {
      path,
      fileTree
    }
  };
};

exports.fetchDirectorySuccess = fetchDirectorySuccess;

const displayNotification = (title, message, labelOk, labelCancel, actionOk, actionCancel) => {
  return {
    type: 'DISPLAY_NOTIFICATION',
    payload: {
      title,
      message,
      labelOk,
      labelCancel,
      actionOk,
      actionCancel
    }
  };
};

exports.displayNotification = displayNotification;

const hideNotification = () => {
  return {
    type: 'HIDE_NOTIFICATION'
  };
};

exports.hideNotification = hideNotification;

const fileAddedSuccess = filePath => {
  return {
    type: 'FILE_ADDED_SUCCESS',
    payload: filePath
  };
};

exports.fileAddedSuccess = fileAddedSuccess;

const folderAddedSuccess = (path, folderPath, fileTree) => {
  return {
    type: 'FOLDER_ADDED_SUCCESS',
    payload: {
      path,
      folderPath,
      fileTree
    }
  };
};

exports.folderAddedSuccess = folderAddedSuccess;

const fileRemovedSuccess = removePath => {
  return {
    type: 'FILE_REMOVED_SUCCESS',
    payload: removePath
  };
};

exports.fileRemovedSuccess = fileRemovedSuccess;

const fileRenamedSuccess = (path, oldPath, fileTree) => {
  return {
    type: 'FILE_RENAMED_SUCCESS',
    payload: {
      path,
      oldPath,
      fileTree
    }
  };
};

exports.fileRenamedSuccess = fileRenamedSuccess;

const rootFolderChangedSuccess = path => {
  return {
    type: 'ROOT_FOLDER_CHANGED',
    payload: path
  };
};

exports.rootFolderChangedSuccess = rootFolderChangedSuccess;

const addInputFieldSuccess = (path, fileTree, type) => {
  return {
    type: 'ADD_INPUT_FIELD',
    payload: {
      path,
      fileTree,
      type
    }
  };
};

exports.addInputFieldSuccess = addInputFieldSuccess;

const removeInputFieldSuccess = path => {
  return {
    type: 'REMOVE_INPUT_FIELD',
    payload: {
      path
    }
  };
};

exports.removeInputFieldSuccess = removeInputFieldSuccess;

const setReadOnlyMode = mode => {
  return {
    type: 'SET_READ_ONLY_MODE',
    payload: mode
  };
};

exports.setReadOnlyMode = setReadOnlyMode;

const createWorkspaceError = error => {
  return {
    type: 'CREATE_WORKSPACE_ERROR',
    payload: error
  };
};

exports.createWorkspaceError = createWorkspaceError;

const createWorkspaceRequest = promise => {
  return {
    type: 'CREATE_WORKSPACE_REQUEST',
    payload: promise
  };
};

exports.createWorkspaceRequest = createWorkspaceRequest;

const createWorkspaceSuccess = workspaceName => {
  return {
    type: 'CREATE_WORKSPACE_SUCCESS',
    payload: workspaceName
  };
};

exports.createWorkspaceSuccess = createWorkspaceSuccess;

const fetchWorkspaceDirectoryError = error => {
  return {
    type: 'FETCH_WORKSPACE_DIRECTORY_ERROR',
    payload: error
  };
};

exports.fetchWorkspaceDirectoryError = fetchWorkspaceDirectoryError;

const fetchWorkspaceDirectoryRequest = promise => {
  return {
    type: 'FETCH_WORKSPACE_DIRECTORY_REQUEST',
    payload: promise
  };
};

exports.fetchWorkspaceDirectoryRequest = fetchWorkspaceDirectoryRequest;

const fetchWorkspaceDirectorySuccess = (path, fileTree) => {
  return {
    type: 'FETCH_WORKSPACE_DIRECTORY_SUCCESS',
    payload: {
      path,
      fileTree
    }
  };
};

exports.fetchWorkspaceDirectorySuccess = fetchWorkspaceDirectorySuccess;

const setRenameWorkspace = (oldName, workspaceName) => {
  return {
    type: 'RENAME_WORKSPACE',
    payload: {
      oldName,
      workspaceName
    }
  };
};

exports.setRenameWorkspace = setRenameWorkspace;

const setDeleteWorkspace = workspaceName => {
  return {
    type: 'DELETE_WORKSPACE',
    payload: workspaceName
  };
};

exports.setDeleteWorkspace = setDeleteWorkspace;

const displayPopUp = message => {
  return {
    type: 'DISPLAY_POPUP_MESSAGE',
    payload: message
  };
};

exports.displayPopUp = displayPopUp;

const hidePopUp = () => {
  return {
    type: 'HIDE_POPUP_MESSAGE'
  };
};

exports.hidePopUp = hidePopUp;

const focusElement = elements => {
  return {
    type: 'SET_FOCUS_ELEMENT',
    payload: elements
  };
};

exports.focusElement = focusElement;

const removeFocus = name => {
  return {
    type: 'REMOVE_FOCUS_ELEMENT',
    payload: name
  };
};

exports.removeFocus = removeFocus;

const setContextMenuItem = item => {
  return {
    type: 'SET_CONTEXT_MENU_ITEM',
    payload: item
  };
};

exports.setContextMenuItem = setContextMenuItem;

const removeContextMenuItem = plugin => {
  return {
    type: 'REMOVE_CONTEXT_MENU_ITEM',
    payload: plugin
  };
};

exports.removeContextMenuItem = removeContextMenuItem;

const setExpandPath = paths => {
  return {
    type: 'SET_EXPAND_PATH',
    payload: paths
  };
};

exports.setExpandPath = setExpandPath;

const loadLocalhostError = error => {
  return {
    type: 'LOAD_LOCALHOST_ERROR',
    payload: error
  };
};

exports.loadLocalhostError = loadLocalhostError;

const loadLocalhostRequest = () => {
  return {
    type: 'LOAD_LOCALHOST_REQUEST'
  };
};

exports.loadLocalhostRequest = loadLocalhostRequest;

const loadLocalhostSuccess = () => {
  return {
    type: 'LOAD_LOCALHOST_SUCCESS'
  };
};

exports.loadLocalhostSuccess = loadLocalhostSuccess;

const fsInitializationCompleted = () => {
  return {
    type: 'FS_INITIALIZATION_COMPLETED'
  };
};

exports.fsInitializationCompleted = fsInitializationCompleted;

const cloneRepositoryRequest = () => {
  return {
    type: 'CLONE_REPOSITORY_REQUEST'
  };
};

exports.cloneRepositoryRequest = cloneRepositoryRequest;

const cloneRepositorySuccess = () => {
  return {
    type: 'CLONE_REPOSITORY_SUCCESS'
  };
};

exports.cloneRepositorySuccess = cloneRepositorySuccess;

const cloneRepositoryFailed = () => {
  return {
    type: 'CLONE_REPOSITORY_FAILED'
  };
};

exports.cloneRepositoryFailed = cloneRepositoryFailed;

/***/ }),
/* 1392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WARN = exports.UNKNOWN_TRANSACTION = exports.SCRIPT = exports.NEW_TRANSACTION = exports.NEW_CALL = exports.NEW_BLOCK = exports.LOG = exports.LISTEN_ON_NETWORK = exports.KNOWN_TRANSACTION = exports.INFO = exports.HTML = exports.ERROR = exports.EMPTY_BLOCK = exports.CMD_HISTORY = exports.CLEAR_CONSOLE = void 0;
const KNOWN_TRANSACTION = 'knownTransaction';
exports.KNOWN_TRANSACTION = KNOWN_TRANSACTION;
const UNKNOWN_TRANSACTION = 'unknownTransaction';
exports.UNKNOWN_TRANSACTION = UNKNOWN_TRANSACTION;
const EMPTY_BLOCK = 'emptyBlock';
exports.EMPTY_BLOCK = EMPTY_BLOCK;
const NEW_TRANSACTION = 'newTransaction';
exports.NEW_TRANSACTION = NEW_TRANSACTION;
const NEW_BLOCK = 'newBlock';
exports.NEW_BLOCK = NEW_BLOCK;
const NEW_CALL = 'newCall';
exports.NEW_CALL = NEW_CALL;
const HTML = 'html';
exports.HTML = HTML;
const LOG = 'log';
exports.LOG = LOG;
const INFO = 'info';
exports.INFO = INFO;
const WARN = 'warn';
exports.WARN = WARN;
const ERROR = 'error';
exports.ERROR = ERROR;
const SCRIPT = 'script';
exports.SCRIPT = SCRIPT;
const CLEAR_CONSOLE = 'clearconsole';
exports.CLEAR_CONSOLE = CLEAR_CONSOLE;
const LISTEN_ON_NETWORK = 'listenOnNetWork';
exports.LISTEN_ON_NETWORK = LISTEN_ON_NETWORK;
const CMD_HISTORY = 'cmdHistory';
exports.CMD_HISTORY = CMD_HISTORY;

/***/ }),
/* 1393 */,
/* 1394 */,
/* 1395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
const CheckTxStatus = ({
  tx,
  type
}) => {
  if (tx.status === '0x1' || tx.status === true) {
    return /*#__PURE__*/_react.default.createElement("i", {
      className: "remix_ui_terminal_txStatus remix_ui_terminal_succeeded fas fa-check-circle"
    });
  }

  if (type === 'call' || type === 'unknownCall' || type === 'unknown') {
    return /*#__PURE__*/_react.default.createElement("i", {
      className: "remix_ui_terminal_txStatus remix_ui_terminal_call"
    }, "call");
  } else if (tx.status === '0x0' || tx.status === false) {
    return /*#__PURE__*/_react.default.createElement("i", {
      className: "remix_ui_terminal_txStatus remix_ui_terminal_failed fas fa-times-circle"
    });
  } else {
    return /*#__PURE__*/_react.default.createElement("i", {
      className: "remix_ui_terminal_txStatus fas fa-circle-thin",
      title: "Status not available"
    });
  }
};

var _default = CheckTxStatus;
exports.default = _default;

/***/ }),
/* 1396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _clipboard = __webpack_require__(1154);

var _helper = __webpack_require__(1121);

var _remixLib = __webpack_require__(311);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const typeConversion = _remixLib.execution.typeConversion;

const showTable = (opts, showTableHash) => {
  let msg = '';
  let toHash;
  const data = opts.data; // opts.data = data.tx

  if (data.to) {
    toHash = opts.to + ' ' + data.to;
  } else {
    toHash = opts.to;
  }

  let callWarning = '';

  if (opts.isCall) {
    callWarning = '(Cost only applies when called by a contract)';
  }

  if (!opts.isCall) {
    if (opts.status !== undefined && opts.status !== null) {
      if (opts.status === '0x0' || opts.status === false) {
        msg = 'Transaction mined but execution failed';
      } else if (opts.status === '0x1' || opts.status === true) {
        msg = 'Transaction mined and execution succeed';
      }
    } else {
      msg = 'Status not available at the moment';
    }
  }

  let stringified = ' - ';

  if (opts.logs && opts.logs.decoded) {
    stringified = typeConversion.stringify(opts.logs.decoded);
  }

  const val = opts.val != null ? typeConversion.toInt(opts.val) : 0;
  return /*#__PURE__*/_react.default.createElement("table", {
    className: `mt-1 mb-2 mr-4  align-self-center ${showTableHash.includes(opts.hash) ? 'active' : ''}`,
    id: "txTable",
    "data-id": `txLoggerTable${opts.hash}`
  }, /*#__PURE__*/_react.default.createElement("tbody", null, opts.status !== undefined ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "status"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableStatus${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, `${opts.status} ${msg}`)) : null, opts.hash && !opts.isCall ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "transaction hash"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts.hash, /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.hash
  }))) : null, opts.contractAddress ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "contract address"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableContractAddress${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts.contractAddress, /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.contractAddress
  }))) : null, opts.from ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "td tableTitle",
    "data-shared": `key_${opts.hash}`
  }, "from"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableFrom${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts.from, /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.from
  }))) : null, opts.to ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "to"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableTo${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, toHash, /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: data.to ? data.to : toHash
  }))) : null, opts.gas ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "gas"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableGas${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts.gas, " gas", /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.gas
  }))) : null, opts.transactionCost ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "transaction cost"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableTransactionCost${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts.transactionCost, " gas ", callWarning, /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.transactionCost
  }))) : null, opts.executionCost ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "execution cost"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableExecutionHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts.executionCost, " gas ", callWarning, /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.executionCost
  }))) : null, opts.input ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "input"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, (0, _helper.shortenHexData)(opts.input), /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts.input
  }))) : null, opts['decoded input'] ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "decoded input"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts['decoded input'].trim(), /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts['decoded input']
  }))) : null, opts['decoded output'] ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "decoded output"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, opts['decoded output'], /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: opts['decoded output']
  }))) : null, opts.logs ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "logs"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, JSON.stringify(stringified, null, '\t'), /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: JSON.stringify(stringified, null, '\t')
  }), /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: JSON.stringify(opts.logs.raw || '0')
  }))) : null, opts.val ? /*#__PURE__*/_react.default.createElement("tr", {
    className: "remix_ui_terminal_tr"
  }, /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-shared": `key_${opts.hash}`
  }, "val"), /*#__PURE__*/_react.default.createElement("td", {
    className: "remix_ui_terminal_td",
    "data-id": `txLoggerTableHash${opts.hash}`,
    "data-shared": `pair_${opts.hash}`
  }, val, " wei", /*#__PURE__*/_react.default.createElement(_clipboard.CopyToClipboard, {
    content: `${val} wei`
  }))) : null));
};

var _default = showTable;
exports.default = _default;

/***/ }),
/* 1397 */,
/* 1398 */,
/* 1399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContractGUI = ContractGUI;

var _react = _interopRequireWildcard(__webpack_require__(29));

var remixLib = _interopRequireWildcard(__webpack_require__(311));

var _clipboard = __webpack_require__(1154);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
const txFormat = remixLib.execution.txFormat;

function ContractGUI(props) {
  const [title, setTitle] = (0, _react.useState)('');
  const [basicInput, setBasicInput] = (0, _react.useState)('');
  const [toggleContainer, setToggleContainer] = (0, _react.useState)(false);
  const [buttonOptions, setButtonOptions] = (0, _react.useState)({
    title: '',
    content: '',
    classList: '',
    dataId: ''
  });
  const [toggleDeployProxy, setToggleDeployProxy] = (0, _react.useState)(false);
  const [toggleUpgradeImp, setToggleUpgradeImp] = (0, _react.useState)(false);
  const [deployState, setDeployState] = (0, _react.useState)({
    deploy: false,
    upgrade: false
  });
  const [useLastProxy, setUseLastProxy] = (0, _react.useState)(false);
  const [proxyAddress, setProxyAddress] = (0, _react.useState)('');
  const multiFields = (0, _react.useRef)([]);
  const initializeFields = (0, _react.useRef)([]);
  const basicInputRef = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    if (props.deployOption && Array.isArray(props.deployOption)) {
      if (props.deployOption[0] && props.deployOption[0].title === 'Deploy with Proxy' && props.deployOption[0].active) handleDeployProxySelect(true);else if (props.deployOption[1] && props.deployOption[1].title === 'Upgrade with Proxy' && props.deployOption[1].active) handleUpgradeImpSelect(true);
    }
  }, [props.deployOption]);
  (0, _react.useEffect)(() => {
    if (props.title) {
      setTitle(props.title);
    } else if (props.funcABI.name) {
      setTitle(props.funcABI.name);
    } else {
      setTitle(props.funcABI.type === 'receive' ? '(receive)' : '(fallback)');
    }

    setBasicInput(''); // we have the reset the fields before reseting the previous references.

    basicInputRef.current.value = '';
    multiFields.current.filter(el => el !== null && el !== undefined).forEach(el => el.value = '');
    multiFields.current = [];
  }, [props.title, props.funcABI]);
  (0, _react.useEffect)(() => {
    if (props.lookupOnly) {
      //   // call. stateMutability is either pure or view
      setButtonOptions({
        title: title + ' - call',
        content: 'call',
        classList: 'btn-info',
        dataId: title + ' - call'
      });
    } else if (props.funcABI.stateMutability === 'payable' || props.funcABI.payable) {
      //   // transact. stateMutability = payable
      setButtonOptions({
        title: title + ' - transact (payable)',
        content: 'transact',
        classList: 'btn-danger',
        dataId: title + ' - transact (payable)'
      });
    } else {
      //   // transact. stateMutability = nonpayable
      setButtonOptions({
        title: title + ' - transact (not payable)',
        content: 'transact',
        classList: 'btn-warning',
        dataId: title + ' - transact (not payable)'
      });
    }
  }, [props.lookupOnly, props.funcABI, title]);

  const getContentOnCTC = () => {
    const multiString = getMultiValsString(multiFields.current); // copy-to-clipboard icon is only visible for method requiring input params

    if (!multiString) {
      return 'cannot encode empty arguments';
    }

    const multiJSON = JSON.parse('[' + multiString + ']');
    const encodeObj = txFormat.encodeData(props.funcABI, multiJSON, props.funcABI.type === 'constructor' ? props.evmBC : null);

    if (encodeObj.error) {
      console.error(encodeObj.error);
      return encodeObj.error;
    } else {
      return encodeObj.data;
    }
  };

  const switchMethodViewOn = () => {
    setToggleContainer(true);
    makeMultiVal();
  };

  const switchMethodViewOff = () => {
    setToggleContainer(false);
    const multiValString = getMultiValsString(multiFields.current);
    if (multiValString) setBasicInput(multiValString);
  };

  const getMultiValsString = fields => {
    const valArray = fields;
    let ret = '';
    const valArrayTest = [];

    for (let j = 0; j < valArray.length; j++) {
      if (ret !== '') ret += ',';
      let elVal = valArray[j] ? valArray[j].value : '';
      valArrayTest.push(elVal);
      elVal = elVal.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

      elVal = elVal.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

      if (elVal) {
        try {
          JSON.parse(elVal);
        } catch (e) {
          elVal = '"' + elVal + '"';
        }
      }

      ret += elVal;
    }

    const valStringTest = valArrayTest.join('');

    if (valStringTest) {
      return ret;
    } else {
      return '';
    }
  };

  const makeMultiVal = () => {
    let inputString = basicInput;

    if (inputString) {
      inputString = inputString.replace(/(^|,\s+|,)(\d+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted number by quoted number

      inputString = inputString.replace(/(^|,\s+|,)(0[xX][0-9a-fA-F]+)(\s+,|,|$)/g, '$1"$2"$3'); // replace non quoted hex string by quoted hex string

      const inputJSON = JSON.parse('[' + inputString + ']');
      const multiInputs = multiFields.current;

      for (let k = 0; k < multiInputs.length; k++) {
        if (inputJSON[k]) {
          multiInputs[k].value = JSON.stringify(inputJSON[k]);
        }
      }
    }
  };

  const handleActionClick = () => {
    if (deployState.deploy) {
      const proxyInitializeString = getMultiValsString(initializeFields.current);
      props.clickCallBack(props.initializerOptions.inputs.inputs, proxyInitializeString, ['Deploy with Proxy']);
    } else if (deployState.upgrade) {
      props.clickCallBack(props.funcABI.inputs, proxyAddress, ['Upgrade with Proxy']);
    } else {
      props.clickCallBack(props.funcABI.inputs, basicInput);
    }
  };

  const handleBasicInput = e => {
    const value = e.target.value;
    setBasicInput(value);
  };

  const handleExpandMultiClick = () => {
    const valsString = getMultiValsString(multiFields.current);

    if (valsString) {
      props.clickCallBack(props.funcABI.inputs, valsString);
    } else {
      props.clickCallBack(props.funcABI.inputs, '');
    }
  };

  const handleToggleDeployProxy = () => {
    setToggleDeployProxy(!toggleDeployProxy);
  };

  const handleDeployProxySelect = value => {
    if (value) setToggleUpgradeImp(false);
    setToggleDeployProxy(value);
    setDeployState({
      upgrade: false,
      deploy: value
    });
  };

  const handleToggleUpgradeImp = () => {
    setToggleUpgradeImp(!toggleUpgradeImp);
  };

  const handleUpgradeImpSelect = value => {
    setToggleUpgradeImp(value);

    if (value) {
      setToggleDeployProxy(false);
      if (useLastProxy) setProxyAddress(props.savedProxyAddress);
    }

    setDeployState({
      deploy: false,
      upgrade: value
    });
  };

  const handleUseLastProxySelect = e => {
    const value = e.target.checked;
    const address = props.savedProxyAddress;
    setUseLastProxy(value);
    setProxyAddress(address || '');
  };

  const handleSetProxyAddress = e => {
    const value = e.target.value;
    setProxyAddress(value);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: `udapp_contractProperty ${props.funcABI.inputs && props.funcABI.inputs.length > 0 || props.funcABI.type === 'fallback' || props.funcABI.type === 'receive' ? 'udapp_hasArgs' : ''}`,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_contractActionsContainerSingle pt-2",
      style: {
        display: toggleContainer ? 'none' : 'flex'
      },
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        onClick: handleActionClick,
        title: buttonOptions.title,
        className: `udapp_instanceButton ${props.widthClass} btn btn-sm ${buttonOptions.classList}`,
        "data-id": buttonOptions.dataId,
        children: title
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        className: "form-control",
        "data-id": props.funcABI.type === 'fallback' || props.funcABI.type === 'receive' ? `'(${props.funcABI.type}')` : 'multiParamManagerBasicInputField',
        placeholder: props.inputs,
        title: props.funcABI.type === 'fallback' || props.funcABI.type === 'receive' ? `'(${props.funcABI.type}')` : props.inputs,
        onChange: handleBasicInput,
        ref: basicInputRef,
        style: {
          visibility: !(props.funcABI.inputs && props.funcABI.inputs.length > 0 || props.funcABI.type === 'fallback' || props.funcABI.type === 'receive') ? 'hidden' : 'visible'
        }
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: "fas fa-angle-down udapp_methCaret",
        onClick: switchMethodViewOn,
        title: title,
        style: {
          visibility: !(props.funcABI.inputs && props.funcABI.inputs.length > 0) ? 'hidden' : 'visible'
        }
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "udapp_contractActionsContainerMulti",
      style: {
        display: toggleContainer ? 'flex' : 'none'
      },
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "udapp_contractActionsContainerMultiInner text-dark",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          onClick: switchMethodViewOff,
          className: "udapp_multiHeader",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "udapp_multiTitle run-instance-multi-title",
            children: title
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            className: "fas fa-angle-up udapp_methCaret"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          children: props.funcABI.inputs.map((inp, index) => {
            return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "udapp_multiArg",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
                htmlFor: inp.name,
                children: [" ", inp.name, ": "]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
                ref: el => {
                  multiFields.current[index] = el;
                },
                className: "form-control",
                placeholder: inp.type,
                title: inp.name,
                "data-id": `multiParamManagerInput${inp.name}`
              })]
            }, index);
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "udapp_group udapp_multiArg",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
            tip: "Encode values of input fields & copy to clipboard",
            icon: "fa-clipboard",
            direction: 'bottom',
            getContent: getContentOnCTC
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            onClick: handleExpandMultiClick,
            title: buttonOptions.title,
            "data-id": buttonOptions.dataId,
            className: `udapp_instanceButton ${buttonOptions.classList}`,
            children: buttonOptions.content
          })]
        })]
      })
    }), props.deployOption && (props.deployOption || []).length > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex justify-content-between",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex py-1 align-items-center custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "deployWithProxy",
            "data-id": "contractGUIDeployWithProxy",
            className: "form-check-input custom-control-input",
            type: "checkbox",
            onChange: e => handleDeployProxySelect(e.target.checked),
            checked: deployState.deploy
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            htmlFor: "deployWithProxy",
            "data-id": "contractGUIDeployWithProxyLabel",
            className: "m-0 form-check-label custom-control-label udapp_checkboxAlign",
            title: "An ERC1967 proxy contract will be deployed along with the selected implementation contract.",
            children: "Deploy with Proxy"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          children: props.initializerOptions && props.initializerOptions.initializeInputs ? /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            onClick: handleToggleDeployProxy,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              className: !toggleDeployProxy ? 'fas fa-angle-right pt-2' : 'fas fa-angle-down',
              "aria-hidden": "true"
            })
          }) : null
        })]
      }), props.initializerOptions && props.initializerOptions.initializeInputs ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: `pl-4 flex-column ${toggleDeployProxy ? "d-flex" : "d-none"}`,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: `flex-column 'd-flex'}`,
          children: props.initializerOptions.inputs.inputs.map((inp, index) => {
            return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "mb-2",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
                className: "mt-2 text-left d-block",
                htmlFor: inp.name,
                children: [" ", inp.name, ": "]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
                ref: el => {
                  initializeFields.current[index] = el;
                },
                style: {
                  height: 32
                },
                className: "form-control udapp_input",
                placeholder: inp.type,
                title: inp.name
              })]
            }, index);
          })
        })
      }) : null, /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex justify-content-between",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex py-1 align-items-center custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "upgradeImplementation",
            "data-id": "contractGUIUpgradeImplementation",
            className: "form-check-input custom-control-input",
            type: "checkbox",
            onChange: e => handleUpgradeImpSelect(e.target.checked),
            checked: deployState.upgrade
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            htmlFor: "upgradeImplementation",
            "data-id": "contractGUIUpgradeImplementationLabel",
            className: "m-0 form-check-label custom-control-label udapp_checkboxAlign",
            title: "The implementation contract will be deployed and then the proxy contract will be updated with new implementation's address.",
            children: "Upgrade with Proxy"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          onClick: handleToggleUpgradeImp,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            className: !toggleUpgradeImp ? 'fas fa-angle-right pt-2' : 'fas fa-angle-down',
            "aria-hidden": "true"
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: `pl-4 flex-column ${toggleUpgradeImp ? "d-flex" : "d-none"}`,
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: `flex-column 'd-flex'}`,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex py-1 align-items-center custom-control custom-checkbox",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              id: "proxyAddress",
              "data-id": "contractGUIProxyAddress",
              className: "form-check-input custom-control-input",
              type: "checkbox",
              onChange: handleUseLastProxySelect,
              checked: useLastProxy
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              htmlFor: "proxyAddress",
              "data-id": "contractGUIProxyAddressLabel",
              className: "m-0 form-check-label custom-control-label udapp_checkboxAlign",
              title: "Select this option to use the last deployed ERC1967 contract on the current network.",
              style: {
                fontSize: 12
              },
              children: "Use last deployed ERC1967 contract"
            })]
          }), !useLastProxy ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "mb-2",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "mt-2 text-left d-block",
              children: "Proxy Address: "
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              style: {
                height: 32
              },
              className: "form-control udapp_input",
              "data-id": "ERC1967AddressInput",
              placeholder: "proxy address",
              title: "Enter previously deployed proxy address on the selected network",
              onChange: handleSetProxyAddress
            })]
          }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "text-capitalize",
            "data-id": "lastDeployedERC1967Address",
            style: {
              fontSize: '.8em'
            },
            children: proxyAddress || 'No proxy address available'
          })]
        })
      })]
    }) : null]
  });
}

/***/ }),
/* 1400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PassphrasePrompt = PassphrasePrompt;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
function PassphrasePrompt(props) {
  const handleSignPassphrase = e => {
    props.setPassphrase(e.target.value);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [" ", props.message, /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        id: "prompt_text",
        type: "password",
        name: "prompt_text",
        className: "form-control",
        style: {
          width: '100%'
        },
        onInput: handleSignPassphrase,
        "data-id": "modalDialogCustomPromptText",
        defaultValue: props.defaultValue
      })
    })]
  });
}

/***/ }),
/* 1401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SET_TX_FEE_CONTENT = exports.SET_SEND_VALUE = exports.SET_SEND_UNIT = exports.SET_SELECTED_ACCOUNT = exports.SET_RECORDER_COUNT = exports.SET_PROXY_ENV_ADDRESS = exports.SET_PERSONAL_MODE = exports.SET_PATH_TO_SCENARIO = exports.SET_PASSPHRASE = exports.SET_NETWORK_NAME = exports.SET_MAX_PRIORITY_FEE = exports.SET_MAX_FEE = exports.SET_MATCH_PASSPHRASE = exports.SET_LOAD_TYPE = exports.SET_IPFS_CHECKED_STATE = exports.SET_GAS_PRICE_STATUS = exports.SET_GAS_PRICE = exports.SET_GAS_LIMIT = exports.SET_EXTERNAL_WEB3_ENDPOINT = exports.SET_EXECUTION_ENVIRONMENT = exports.SET_DEPLOY_OPTIONS = exports.SET_DECODED_RESPONSE = exports.SET_CURRENT_FILE = exports.SET_CURRENT_CONTRACT = exports.SET_CONFIRM_SETTINGS = exports.SET_BASE_FEE_PER_GAS = exports.RESET_STATE = exports.REMOVE_PROVIDER = exports.REMOVE_INSTANCE = exports.REMOVE_DEPLOY_OPTION = exports.HIDE_POPUP_MESSAGE = exports.HIDE_NOTIFICATION = exports.FETCH_PROVIDER_LIST_SUCCESS = exports.FETCH_PROVIDER_LIST_REQUEST = exports.FETCH_PROVIDER_LIST_FAILED = exports.FETCH_CONTRACT_LIST_SUCCESS = exports.FETCH_CONTRACT_LIST_REQUEST = exports.FETCH_CONTRACT_LIST_FAILED = exports.FETCH_ACCOUNTS_LIST_SUCCESS = exports.FETCH_ACCOUNTS_LIST_REQUEST = exports.FETCH_ACCOUNTS_LIST_FAILED = exports.DISPLAY_POPUP_MESSAGE = exports.DISPLAY_NOTIFICATION = exports.CLEAR_RECORDER_COUNT = exports.CLEAR_INSTANCES = exports.ADD_PROVIDER = exports.ADD_INSTANCE = exports.ADD_DEPLOY_OPTION = void 0;
const FETCH_ACCOUNTS_LIST_REQUEST = 'FETCH_ACCOUNTS_LIST_REQUEST';
exports.FETCH_ACCOUNTS_LIST_REQUEST = FETCH_ACCOUNTS_LIST_REQUEST;
const FETCH_ACCOUNTS_LIST_SUCCESS = 'FETCH_ACCOUNTS_LIST_SUCCESS';
exports.FETCH_ACCOUNTS_LIST_SUCCESS = FETCH_ACCOUNTS_LIST_SUCCESS;
const FETCH_ACCOUNTS_LIST_FAILED = 'FETCH_ACCOUNTS_LIST_FAILED';
exports.FETCH_ACCOUNTS_LIST_FAILED = FETCH_ACCOUNTS_LIST_FAILED;
const SET_SEND_VALUE = 'SET_SEND_VALUE';
exports.SET_SEND_VALUE = SET_SEND_VALUE;
const SET_SELECTED_ACCOUNT = 'SET_SELECTED_ACCOUNT';
exports.SET_SELECTED_ACCOUNT = SET_SELECTED_ACCOUNT;
const SET_SEND_UNIT = 'SET_SEND_UNIT';
exports.SET_SEND_UNIT = SET_SEND_UNIT;
const SET_GAS_LIMIT = 'SET_GAS_LIMIT';
exports.SET_GAS_LIMIT = SET_GAS_LIMIT;
const SET_EXECUTION_ENVIRONMENT = 'SET_EXECUTION_ENVIRONMENT';
exports.SET_EXECUTION_ENVIRONMENT = SET_EXECUTION_ENVIRONMENT;
const SET_PERSONAL_MODE = 'SET_PERSONAL_MODE';
exports.SET_PERSONAL_MODE = SET_PERSONAL_MODE;
const SET_NETWORK_NAME = 'SET_NETWORK_NAME';
exports.SET_NETWORK_NAME = SET_NETWORK_NAME;
const FETCH_PROVIDER_LIST_REQUEST = 'FETCH_PROVIDER_LIST_REQUEST';
exports.FETCH_PROVIDER_LIST_REQUEST = FETCH_PROVIDER_LIST_REQUEST;
const FETCH_PROVIDER_LIST_SUCCESS = 'FETCH_PROVIDER_LIST_SUCCESS';
exports.FETCH_PROVIDER_LIST_SUCCESS = FETCH_PROVIDER_LIST_SUCCESS;
const FETCH_PROVIDER_LIST_FAILED = 'FETCH_PROVIDER_LIST_FAILED';
exports.FETCH_PROVIDER_LIST_FAILED = FETCH_PROVIDER_LIST_FAILED;
const ADD_PROVIDER = 'ADD_PROVIDER';
exports.ADD_PROVIDER = ADD_PROVIDER;
const REMOVE_PROVIDER = 'REMOVE_PROVIDER';
exports.REMOVE_PROVIDER = REMOVE_PROVIDER;
const DISPLAY_NOTIFICATION = 'DISPLAY_NOTIFICATION';
exports.DISPLAY_NOTIFICATION = DISPLAY_NOTIFICATION;
const HIDE_NOTIFICATION = 'HIDE_NOTIFICATION';
exports.HIDE_NOTIFICATION = HIDE_NOTIFICATION;
const SET_EXTERNAL_WEB3_ENDPOINT = 'SET_EXTERNAL_WEB3_ENDPOINT';
exports.SET_EXTERNAL_WEB3_ENDPOINT = SET_EXTERNAL_WEB3_ENDPOINT;
const DISPLAY_POPUP_MESSAGE = 'DISPLAY_POPUP_MESSAGE';
exports.DISPLAY_POPUP_MESSAGE = DISPLAY_POPUP_MESSAGE;
const HIDE_POPUP_MESSAGE = 'HIDE_POPUP_MESSAGE';
exports.HIDE_POPUP_MESSAGE = HIDE_POPUP_MESSAGE;
const SET_PASSPHRASE = 'SET_PASSPHRASE';
exports.SET_PASSPHRASE = SET_PASSPHRASE;
const SET_MATCH_PASSPHRASE = 'SET_MATCH_PASSPHRASE';
exports.SET_MATCH_PASSPHRASE = SET_MATCH_PASSPHRASE;
const FETCH_CONTRACT_LIST_REQUEST = 'FETCH_CONTRACT_LIST_REQUEST';
exports.FETCH_CONTRACT_LIST_REQUEST = FETCH_CONTRACT_LIST_REQUEST;
const FETCH_CONTRACT_LIST_SUCCESS = 'FETCH_CONTRACT_LIST_SUCCESS';
exports.FETCH_CONTRACT_LIST_SUCCESS = FETCH_CONTRACT_LIST_SUCCESS;
const FETCH_CONTRACT_LIST_FAILED = 'FETCH_CONTRACT_LIST_FAILED';
exports.FETCH_CONTRACT_LIST_FAILED = FETCH_CONTRACT_LIST_FAILED;
const SET_LOAD_TYPE = 'SET_LOAD_TYPE';
exports.SET_LOAD_TYPE = SET_LOAD_TYPE;
const SET_CURRENT_FILE = 'SET_CURRENT_FILE';
exports.SET_CURRENT_FILE = SET_CURRENT_FILE;
const SET_IPFS_CHECKED_STATE = 'SET_IPFS_CHECKED_STATE';
exports.SET_IPFS_CHECKED_STATE = SET_IPFS_CHECKED_STATE;
const SET_GAS_PRICE_STATUS = 'SET_GAS_PRICE_STATUS';
exports.SET_GAS_PRICE_STATUS = SET_GAS_PRICE_STATUS;
const SET_CONFIRM_SETTINGS = 'SET_CONFIRM_SETTINGS';
exports.SET_CONFIRM_SETTINGS = SET_CONFIRM_SETTINGS;
const SET_MAX_FEE = 'SET_MAX_FEE';
exports.SET_MAX_FEE = SET_MAX_FEE;
const SET_MAX_PRIORITY_FEE = 'SET_MAX_PRIORITY_FEE';
exports.SET_MAX_PRIORITY_FEE = SET_MAX_PRIORITY_FEE;
const SET_BASE_FEE_PER_GAS = 'SET_BASE_FEE_PER_GAS';
exports.SET_BASE_FEE_PER_GAS = SET_BASE_FEE_PER_GAS;
const SET_GAS_PRICE = 'SET_GAS_PRICE';
exports.SET_GAS_PRICE = SET_GAS_PRICE;
const SET_TX_FEE_CONTENT = 'SET_TX_FEE_CONTENT';
exports.SET_TX_FEE_CONTENT = SET_TX_FEE_CONTENT;
const ADD_INSTANCE = 'ADD_INSTANCE';
exports.ADD_INSTANCE = ADD_INSTANCE;
const REMOVE_INSTANCE = 'REMOVE_INSTANCE';
exports.REMOVE_INSTANCE = REMOVE_INSTANCE;
const CLEAR_INSTANCES = 'CLEAR_INSTANCES';
exports.CLEAR_INSTANCES = CLEAR_INSTANCES;
const SET_DECODED_RESPONSE = 'SET_DECODED_RESPONSE';
exports.SET_DECODED_RESPONSE = SET_DECODED_RESPONSE;
const SET_PATH_TO_SCENARIO = 'SET_PATH_TO_SCENARIO';
exports.SET_PATH_TO_SCENARIO = SET_PATH_TO_SCENARIO;
const SET_RECORDER_COUNT = 'SET_RECORDER_COUNT';
exports.SET_RECORDER_COUNT = SET_RECORDER_COUNT;
const CLEAR_RECORDER_COUNT = 'CLEAR_RECORDER_COUNT';
exports.CLEAR_RECORDER_COUNT = CLEAR_RECORDER_COUNT;
const RESET_STATE = 'RESET_STATE';
exports.RESET_STATE = RESET_STATE;
const ADD_DEPLOY_OPTION = 'ADD_DEPLOY_OPTION';
exports.ADD_DEPLOY_OPTION = ADD_DEPLOY_OPTION;
const REMOVE_DEPLOY_OPTION = 'REMOVE_DEPLOY_OPTION';
exports.REMOVE_DEPLOY_OPTION = REMOVE_DEPLOY_OPTION;
const SET_DEPLOY_OPTIONS = 'SET_DEPLOY_OPTIONS';
exports.SET_DEPLOY_OPTIONS = SET_DEPLOY_OPTIONS;
const SET_CURRENT_CONTRACT = 'SET_CURRENT_CONTRACT';
exports.SET_CURRENT_CONTRACT = SET_CURRENT_CONTRACT;
const SET_PROXY_ENV_ADDRESS = 'SET_PROXY_ENV_ADDRESS';
exports.SET_PROXY_ENV_ADDRESS = SET_PROXY_ENV_ADDRESS;

/***/ }),
/* 1402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateAccountBalances = exports.signMessageWithAddress = exports.setFinalContext = exports.setExecutionContext = exports.fillAccountsList = exports.createNewBlockchainAccount = void 0;

var _helper = __webpack_require__(1121);

var _actions = __webpack_require__(1211);

var _payload = __webpack_require__(1188);

const updateAccountBalances = (plugin, dispatch) => {
  const accounts = plugin.REACT_API.accounts.loadedAccounts;
  Object.keys(accounts).map(value => {
    plugin.blockchain.getBalanceInEther(value, (err, balance) => {
      if (err) return;
      const updated = (0, _helper.shortenAddress)(value, balance);
      accounts[value] = updated;
    });
  });
  dispatch((0, _payload.fetchAccountsListSuccess)(accounts));
};

exports.updateAccountBalances = updateAccountBalances;

const fillAccountsList = async (plugin, dispatch) => {
  try {
    dispatch((0, _payload.fetchAccountsListRequest)());
    const promise = plugin.blockchain.getAccounts();
    promise.then(async accounts => {
      const loadedAccounts = {};
      if (!accounts) accounts = []; // allSettled is undefined..
      // so the current promise (all) will finish when:
      // - all the promises resolve
      // - at least one reject
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all

      await Promise.all(accounts.map(account => {
        return new Promise((resolve, reject) => {
          plugin.blockchain.getBalanceInEther(account, (err, balance) => {
            if (err) return reject(err);
            const updated = (0, _helper.shortenAddress)(account, balance);
            loadedAccounts[account] = updated;
            resolve(account);
          });
        });
      }));
      const provider = plugin.blockchain.getProvider();

      if (provider === 'injected') {
        const selectedAddress = plugin.blockchain.getInjectedWeb3Address();
        if (!Object.keys(loadedAccounts).includes(selectedAddress)) (0, _actions.setAccount)(dispatch, null);
      }

      dispatch((0, _payload.fetchAccountsListSuccess)(loadedAccounts));
    }).catch(e => {
      dispatch((0, _payload.fetchAccountsListFailed)(e.message));
    });
  } catch (e) {
    dispatch((0, _payload.displayPopUp)(`Cannot get account list: ${e}`));
  }
};

exports.fillAccountsList = fillAccountsList;

const setFinalContext = (plugin, dispatch) => {
  // set the final context. Cause it is possible that this is not the one we've originaly selected
  const value = _getProviderDropdownValue(plugin);

  (0, _actions.setExecEnv)(dispatch, value);
  (0, _actions.clearInstances)(dispatch);
};

exports.setFinalContext = setFinalContext;

const _getProviderDropdownValue = plugin => {
  const provider = plugin.blockchain.getProvider();
  const fork = plugin.blockchain.getCurrentFork();
  return provider === 'vm' ? provider + '-' + fork : provider;
};

const setExecutionContext = (plugin, dispatch, executionContext) => {
  plugin.blockchain.changeExecutionContext(executionContext, null, alertMsg => {
    plugin.call('notification', 'toast', alertMsg);
  }, () => {
    setFinalContext(plugin, dispatch);
  });
};

exports.setExecutionContext = setExecutionContext;

const createNewBlockchainAccount = async (plugin, dispatch, cbMessage) => {
  plugin.blockchain.newAccount('', cb => {
    dispatch((0, _payload.displayNotification)('Enter Passphrase', cbMessage, 'OK', 'Cancel', async () => {
      if (plugin.REACT_API.passphrase === plugin.REACT_API.matchPassphrase) {
        cb(plugin.REACT_API.passphrase);
      } else {
        dispatch((0, _payload.displayNotification)('Error', 'Passphase does not match', 'OK', null));
      }

      (0, _payload.setPassphrase)('');
      (0, _payload.setMatchPassphrase)('');
    }, () => {}));
  }, async (error, address) => {
    if (error) {
      return dispatch((0, _payload.displayPopUp)('Cannot create an account: ' + error));
    }

    dispatch((0, _payload.displayPopUp)(`account ${address} created`));
    await fillAccountsList(plugin, dispatch);
  });
};

exports.createNewBlockchainAccount = createNewBlockchainAccount;

const signMessageWithAddress = (plugin, dispatch, account, message, modalContent, passphrase) => {
  plugin.blockchain.signMessage(message, account, passphrase, (err, msgHash, signedData) => {
    if (err) {
      return (0, _payload.displayPopUp)(err);
    }

    dispatch((0, _payload.displayNotification)('Signed Message', modalContent(msgHash, signedData), 'OK', null, () => {}, null));
  });
};

exports.signMessageWithAddress = signMessageWithAddress;

/***/ }),
/* 1403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compiler = void 0;

const abi_1 = __webpack_require__(1678);

const webworkify = __webpack_require__(1704);

const compiler_input_1 = __webpack_require__(1407);

const eventManager_1 = __webpack_require__(1705);

const helper_1 = __webpack_require__(1279);

const types_1 = __webpack_require__(1408);
/*
  trigger compilationFinished, compilerLoaded, compilationStarted, compilationDuration
*/


class Compiler {
  constructor(handleImportCall) {
    this.handleImportCall = handleImportCall;
    this.event = new eventManager_1.default();
    this.state = {
      compileJSON: null,
      worker: null,
      currentVersion: null,
      optimize: false,
      runs: 200,
      evmVersion: null,
      language: 'Solidity',
      compilationStartTime: null,
      target: null,
      useFileConfiguration: false,
      configFileContent: '',
      lastCompilationResult: {
        data: null,
        source: null
      }
    };
    this.event.register('compilationFinished', (success, data, source, input, version) => {
      if (success && this.state.compilationStartTime) {
        this.event.trigger('compilationDuration', [new Date().getTime() - this.state.compilationStartTime]);
      }

      this.state.compilationStartTime = null;
    });
    this.event.register('compilationStarted', () => {
      this.state.compilationStartTime = new Date().getTime();
    });
  }
  /**
   * @dev Setter function for CompilerState's properties (used by IDE)
   * @param key key
   * @param value value of key in CompilerState
   */


  set(key, value) {
    this.state[key] = value;
    if (key === 'runs') this.state['runs'] = parseInt(value);
  }
  /**
   * @dev Internal function to compile the contract after gathering imports
   * @param files source file
   * @param missingInputs missing import file path list
   */


  internalCompile(files, missingInputs) {
    this.gatherImports(files, missingInputs, (error, input) => {
      if (error) {
        this.state.lastCompilationResult = null;
        this.event.trigger('compilationFinished', [false, {
          error: {
            formattedMessage: error,
            severity: 'error'
          }
        }, files, input, this.state.currentVersion]);
      } else if (this.state.compileJSON && input) {
        this.state.compileJSON(input);
      }
    });
  }
  /**
   * @dev Compile source files (used by IDE)
   * @param files source files
   * @param target target file name (This is passed as it is to IDE)
   */


  compile(files, target) {
    this.state.target = target;
    this.event.trigger('compilationStarted', []);
    this.internalCompile(files);
  }
  /**
   * @dev Called when compiler is loaded, set current compiler version
   * @param version compiler version
   */


  onCompilerLoaded(version) {
    this.state.currentVersion = version;
    this.event.trigger('compilerLoaded', [version]);
  }
  /**
   * @dev Called when compiler is loaded internally (without worker)
   */


  onInternalCompilerLoaded() {
    if (this.state.worker === null) {
      const compiler = typeof window !== 'undefined' && window['Module'] ? __webpack_require__(1280)(window['Module']) : __webpack_require__(1419); // eslint-disable-line

      this.state.compileJSON = source => {
        const missingInputs = [];

        const missingInputsCallback = path => {
          missingInputs.push(path);
          return {
            error: 'Deferred import'
          };
        };

        let result = {};
        let input = "";

        try {
          if (source && source.sources) {
            const {
              optimize,
              runs,
              evmVersion,
              language,
              useFileConfiguration,
              configFileContent
            } = this.state;

            if (useFileConfiguration) {
              input = (0, compiler_input_1.compilerInputForConfigFile)(source.sources, JSON.parse(configFileContent));
            } else {
              input = (0, compiler_input_1.default)(source.sources, {
                optimize,
                runs,
                evmVersion,
                language
              });
            }

            result = JSON.parse(compiler.compile(input, {
              import: missingInputsCallback
            }));
          }
        } catch (exception) {
          result = {
            error: {
              formattedMessage: 'Uncaught JavaScript exception:\n' + exception,
              severity: 'error',
              mode: 'panic'
            }
          };
        }

        this.onCompilationFinished(result, missingInputs, source, input, this.state.currentVersion);
      };

      this.onCompilerLoaded(compiler.version());
    }
  }
  /**
   * @dev Called when compilation is finished
   * @param data compilation result data
   * @param missingInputs missing imports
   * @param source Source
   */


  onCompilationFinished(data, missingInputs, source, input, version) {
    let noFatalErrors = true; // ie warnings are ok

    const checkIfFatalError = error => {
      // Ignore warnings and the 'Deferred import' error as those are generated by us as a workaround
      const isValidError = error.message && error.message.includes('Deferred import') ? false : error.severity !== 'warning';
      if (isValidError) noFatalErrors = false;
    };

    if (data.error) checkIfFatalError(data.error);
    if (data.errors) data.errors.forEach(err => checkIfFatalError(err));

    if (!noFatalErrors) {
      // There are fatal errors, abort here
      this.state.lastCompilationResult = null;
      this.event.trigger('compilationFinished', [false, data, source, input, version]);
    } else if (missingInputs !== undefined && missingInputs.length > 0 && source && source.sources) {
      // try compiling again with the new set of inputs
      this.internalCompile(source.sources, missingInputs);
    } else {
      data = this.updateInterface(data);

      if (source) {
        source.target = this.state.target;
        this.state.lastCompilationResult = {
          data: data,
          source: source
        };
      }

      this.event.trigger('compilationFinished', [true, data, source, input, version]);
    }
  }
  /**
   * @dev Load compiler using given version (used by remix-tests CLI)
   * @param version compiler version
   */


  loadRemoteVersion(version) {
    console.log(`Loading remote solc version ${version} ...`);

    const compiler = __webpack_require__(1419); // eslint-disable-line


    compiler.loadRemoteVersion(version, (err, remoteCompiler) => {
      if (err) {
        console.error('Error in loading remote solc compiler: ', err);
      } else {
        this.state.compileJSON = source => {
          const missingInputs = [];

          const missingInputsCallback = path => {
            missingInputs.push(path);
            return {
              error: 'Deferred import'
            };
          };

          let result = {};
          let input = "";

          try {
            if (source && source.sources) {
              const {
                optimize,
                runs,
                evmVersion,
                language,
                useFileConfiguration,
                configFileContent
              } = this.state;

              if (useFileConfiguration) {
                input = (0, compiler_input_1.compilerInputForConfigFile)(source.sources, JSON.parse(configFileContent));
              } else {
                input = (0, compiler_input_1.default)(source.sources, {
                  optimize,
                  runs,
                  evmVersion,
                  language
                });
              }

              result = JSON.parse(remoteCompiler.compile(input, {
                import: missingInputsCallback
              }));
            }
          } catch (exception) {
            result = {
              error: {
                formattedMessage: 'Uncaught JavaScript exception:\n' + exception,
                severity: 'error',
                mode: 'panic'
              }
            };
          }

          this.onCompilationFinished(result, missingInputs, source, input, version);
        };

        this.onCompilerLoaded(version);
      }
    });
  }
  /**
   * @dev Load compiler using given URL (used by IDE)
   * @param usingWorker if true, load compiler using worker
   * @param url URL to load compiler from
   */


  loadVersion(usingWorker, url) {
    console.log('Loading ' + url + ' ' + (usingWorker ? 'with worker' : 'without worker'));
    this.event.trigger('loadingCompiler', [url, usingWorker]);

    if (this.state.worker) {
      this.state.worker.terminate();
      this.state.worker = null;
    }

    if (usingWorker) {
      this.loadWorker(url);
    } else {
      this.loadInternal(url);
    }
  }
  /**
   * @dev Load compiler using 'script' element (without worker)
   * @param url URL to load compiler from
   */


  loadInternal(url) {
    delete window['Module']; // NOTE: workaround some browsers?

    window['Module'] = undefined; // Set a safe fallback until the new one is loaded

    this.state.compileJSON = source => {
      this.onCompilationFinished({
        error: {
          formattedMessage: 'Compiler not yet loaded.'
        }
      });
    };

    const newScript = document.createElement('script');
    newScript.type = 'text/javascript';
    newScript.src = url;
    document.getElementsByTagName('head')[0].appendChild(newScript);
    const check = window.setInterval(() => {
      if (!window['Module']) {
        return;
      }

      window.clearInterval(check);
      this.onInternalCompilerLoaded();
    }, 200);
  }
  /**
   * @dev Load compiler using web worker
   * @param url URL to load compiler from
   */


  loadWorker(url) {
    this.state.worker = webworkify(/*require.resolve*/(1722));
    const jobs = [];
    this.state.worker.addEventListener('message', msg => {
      const data = msg.data;

      switch (data.cmd) {
        case 'versionLoaded':
          if (data.data) this.onCompilerLoaded(data.data);
          break;

        case 'compiled':
          {
            let result;

            if (data.data && data.job !== undefined && data.job >= 0) {
              try {
                result = JSON.parse(data.data);
              } catch (exception) {
                result = {
                  error: {
                    formattedMessage: 'Invalid JSON output from the compiler: ' + exception
                  }
                };
              }

              let sources = {};

              if (data.job in jobs !== undefined) {
                sources = jobs[data.job].sources;
                delete jobs[data.job];
              }

              this.onCompilationFinished(result, data.missingInputs, sources, data.input, this.state.currentVersion);
            }

            break;
          }
      }
    });
    this.state.worker.addEventListener('error', msg => {
      const formattedMessage = `Worker error: ${msg.data && msg.data !== undefined ? msg.data : msg['message']}`;
      this.onCompilationFinished({
        error: {
          formattedMessage
        }
      });
    });

    this.state.compileJSON = source => {
      if (source && source.sources) {
        const {
          optimize,
          runs,
          evmVersion,
          language,
          useFileConfiguration,
          configFileContent
        } = this.state;
        jobs.push({
          sources: source
        });
        let input = "";

        try {
          if (useFileConfiguration) {
            input = (0, compiler_input_1.compilerInputForConfigFile)(source.sources, JSON.parse(configFileContent));
          } else {
            input = (0, compiler_input_1.default)(source.sources, {
              optimize,
              runs,
              evmVersion,
              language
            });
          }
        } catch (exception) {
          this.onCompilationFinished({
            error: {
              formattedMessage: exception.message
            }
          }, [], source, "", this.state.currentVersion);
          return;
        }

        this.state.worker.postMessage({
          cmd: 'compile',
          job: jobs.length - 1,
          input: input
        });
      }
    };

    this.state.worker.postMessage({
      cmd: 'loadVersion',
      data: url
    });
  }
  /**
   * @dev Gather imports for compilation
   * @param files file sources
   * @param importHints import file list
   * @param cb callback
   */


  gatherImports(files, importHints, cb) {
    importHints = importHints || []; // FIXME: This will only match imports if the file begins with one '.'
    // It should tokenize by lines and check each.

    const importRegex = /^\s*import\s*['"]([^'"]+)['"];/g;

    for (const fileName in files) {
      let match;

      while (match = importRegex.exec(files[fileName].content)) {
        let importFilePath = match[1];

        if (importFilePath.startsWith('./')) {
          const path = /(.*\/).*/.exec(fileName);
          importFilePath = path ? importFilePath.replace('./', path[1]) : importFilePath.slice(2);
        }

        if (!importHints.includes(importFilePath)) importHints.push(importFilePath);
      }
    }

    while (importHints.length > 0) {
      const m = importHints.pop();
      if (m && m in files) continue;

      if (this.handleImportCall) {
        this.handleImportCall(m, (err, content) => {
          if (err && cb) cb(err);else {
            files[m] = {
              content
            };
            this.gatherImports(files, importHints, cb);
          }
        });
      }

      return;
    }

    if (cb) {
      cb(null, {
        sources: files
      });
    }
  }
  /**
   * @dev Truncate version string
   * @param version version
   */


  truncateVersion(version) {
    const tmp = /^(\d+.\d+.\d+)/.exec(version);
    return tmp ? tmp[1] : version;
  }
  /**
   * @dev Update ABI according to current compiler version
   * @param data Compilation result
   */


  updateInterface(data) {
    helper_1.default.visitContracts(data.contracts, contract => {
      if (!contract.object.abi) contract.object.abi = [];

      if (this.state.language === 'Yul' && contract.object.abi.length === 0) {
        // yul compiler does not return any abi,
        // we default to accept the fallback function (which expect raw data as argument).
        contract.object.abi.push({
          payable: true,
          stateMutability: 'payable',
          type: 'fallback'
        });
      }

      if (data && data.contracts && this.state.currentVersion) {
        const version = this.truncateVersion(this.state.currentVersion);
        data.contracts[contract.file][contract.name].abi = (0, abi_1.update)(version, contract.object.abi); // if "constant" , payable must not be true and stateMutability must be view.
        // see https://github.com/ethereum/solc-js/issues/500

        for (const item of data.contracts[contract.file][contract.name].abi) {
          if ((0, types_1.isFunctionDescription)(item) && item.constant) {
            item.payable = false;
            item.stateMutability = 'view';
          }
        }
      }
    });
    return data;
  }
  /**
   * @dev Get contract obj of the given contract name from last compilation result.
   * @param name contract name
   */


  getContract(name) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return helper_1.default.getContract(name, this.state.lastCompilationResult.data.contracts);
    }

    return null;
  }
  /**
   * @dev Call the given callback for all the contracts from last compilation result
   * @param cb callback
   */


  visitContracts(cb) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return helper_1.default.visitContracts(this.state.lastCompilationResult.data.contracts, cb);
    }

    return null;
  }
  /**
   * @dev Get the compiled contracts data from last compilation result
   */


  getContracts() {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.contracts) {
      return this.state.lastCompilationResult.data.contracts;
    }

    return null;
  }
  /**
   * @dev Get sources from last compilation result
   */


  getSources() {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source) {
      return this.state.lastCompilationResult.source.sources;
    }

    return null;
  }
  /**
   * @dev Get sources of passed file name from last compilation result
   * @param fileName file name
   */


  getSource(fileName) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.source && this.state.lastCompilationResult.source.sources) {
      return this.state.lastCompilationResult.source.sources[fileName];
    }

    return null;
  }
  /**
   * @dev Get source name at passed index from last compilation result
   * @param index    - index of the source
   */


  getSourceName(index) {
    if (this.state.lastCompilationResult && this.state.lastCompilationResult.data && this.state.lastCompilationResult.data.sources) {
      return Object.keys(this.state.lastCompilationResult.data.sources)[index];
    }

    return null;
  }

}

exports.Compiler = Compiler;

/***/ }),
/* 1404 */,
/* 1405 */,
/* 1406 */,
/* 1407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compilerInputForConfigFile = exports.getValidLanguage = exports.Languages = void 0;

exports.default = (sources, opts) => {
  const o = {
    language: 'Solidity',
    sources: sources,
    settings: {
      optimizer: {
        enabled: opts.optimize === true || opts.optimize === 1,
        runs: opts.runs || 200
      },
      libraries: opts.libraries,
      outputSelection: {
        '*': {
          '': ['ast'],
          '*': ['abi', 'metadata', 'devdoc', 'userdoc', 'storageLayout', 'evm.legacyAssembly', 'evm.bytecode', 'evm.deployedBytecode', 'evm.methodIdentifiers', 'evm.gasEstimates', 'evm.assembly']
        }
      }
    }
  };

  if (opts.evmVersion) {
    if (opts.evmVersion.toLowerCase() == 'default') {
      opts.evmVersion = null;
    } else {
      o.settings.evmVersion = opts.evmVersion;
    }
  }

  if (opts.language) {
    o.language = opts.language;
  }

  if (opts.language === 'Yul' && o.settings.optimizer.enabled) {
    if (!o.settings.optimizer.details) {
      o.settings.optimizer.details = {};
    }

    o.settings.optimizer.details.yul = true;
  }

  return JSON.stringify(o);
};

exports.Languages = ['Solidity', 'Yul'];

function getValidLanguage(val) {
  if (val !== undefined && val !== null && val) {
    const lang = val.slice(0, 1).toUpperCase() + val.slice(1).toLowerCase();
    return exports.Languages.indexOf(lang) > -1 ? lang : null;
  }

  return null;
}

exports.getValidLanguage = getValidLanguage;

function compilerInputForConfigFile(sources, opts) {
  opts.sources = sources;
  return JSON.stringify(opts);
}

exports.compilerInputForConfigFile = compilerInputForConfigFile;

/***/ }),
/* 1408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEventDescription = exports.isFunctionDescription = void 0;

const isFunctionDescription = item => item.stateMutability !== undefined;

exports.isFunctionDescription = isFunctionDescription;

const isEventDescription = item => item.type === 'event';

exports.isEventDescription = isEventDescription;

/***/ }),
/* 1409 */,
/* 1410 */,
/* 1411 */,
/* 1412 */,
/* 1413 */,
/* 1414 */,
/* 1415 */,
/* 1416 */,
/* 1417 */,
/* 1418 */,
/* 1419 */,
/* 1420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisedMiniXhr = exports.canUseWorker = exports.urlFromVersion = exports.pathToURL = exports.baseURLWasm = exports.baseURLBin = void 0;

const semver = __webpack_require__(1231);

const minixhr = __webpack_require__(1724);
/* global Worker */


exports.baseURLBin = 'https://binaries.soliditylang.org/bin';
exports.baseURLWasm = 'https://binaries.soliditylang.org/wasm';
exports.pathToURL = {};
/**
 * Retrieves the URL of the given compiler version
 * @param version is the version of compiler with or without 'soljson-v' prefix and .js postfix
 */

function urlFromVersion(version) {
  let url;

  if (version === 'builtin') {
    let location = window.document.location;
    let path = location.pathname;
    if (!path.startsWith('/')) path = '/' + path;
    location = `${location.protocol}//${location.host}${path}assets/js`;
    if (location.endsWith('index.html')) location = location.substring(0, location.length - 10);
    if (!location.endsWith('/')) location += '/';
    url = `${location}soljson.js`;
  } else {
    version = version.replace('.Emscripten.clang', '');
    if (!version.startsWith('soljson-v')) version = 'soljson-v' + version;
    if (!version.endsWith('.js')) version = version + '.js';
    url = `${exports.pathToURL[version]}/${version}`;
  }

  return url;
}

exports.urlFromVersion = urlFromVersion;
/**
 * Checks if the worker can be used to load a compiler.
 * checks a compiler whitelist, browser support and OS.
 */

function canUseWorker(selectedVersion) {
  if (selectedVersion.startsWith('http')) {
    return browserSupportWorker();
  }

  const version = semver.coerce(selectedVersion);

  if (!version) {
    return browserSupportWorker();
  }

  const isNightly = selectedVersion.includes('nightly');
  return browserSupportWorker() && ( // All compiler versions (including nightlies) after 0.6.3 are wasm compiled
  semver.gt(version, '0.6.3') || // Only releases are wasm compiled starting with 0.3.6
  semver.gte(version, '0.3.6') && !isNightly);
}

exports.canUseWorker = canUseWorker;

function browserSupportWorker() {
  return document.location.protocol !== 'file:' && Worker !== undefined;
} // returns a promise for minixhr


function promisedMiniXhr(url) {
  return new Promise((resolve, reject) => {
    minixhr(url, (json, event) => {
      resolve({
        json,
        event
      });
    });
  });
}

exports.promisedMiniXhr = promisedMiniXhr;

/***/ }),
/* 1421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerAbstract = void 0;

const helper_1 = __webpack_require__(1279);

class CompilerAbstract {
  constructor(languageversion, data, source, input) {
    this.languageversion = languageversion;
    this.data = data;
    this.source = source; // source code

    this.input = input; // source code
  }

  getContracts() {
    return this.data.contracts || {};
  }

  getContract(name) {
    return helper_1.default.getContract(name, this.data.contracts);
  }

  visitContracts(calllback) {
    return helper_1.default.visitContracts(this.data.contracts, calllback);
  }

  getData() {
    return this.data;
  }

  getInput() {
    return this.input;
  }

  getAsts() {
    return this.data.sources; // ast
  }

  getSourceName(fileIndex) {
    if (this.data && this.data.sources) {
      return Object.keys(this.data.sources)[fileIndex];
    } else if (Object.keys(this.source.sources).length === 1) {
      // if we don't have ast, we return the only one filename present.
      const sourcesArray = Object.keys(this.source.sources);
      return sourcesArray[0];
    }

    return null;
  }

  getSourceCode() {
    return this.source;
  }

}

exports.CompilerAbstract = CompilerAbstract;

/***/ }),
/* 1422 */,
/* 1423 */,
/* 1424 */,
/* 1425 */,
/* 1426 */,
/* 1427 */,
/* 1428 */,
/* 1429 */,
/* 1430 */,
/* 1431 */,
/* 1432 */,
/* 1433 */,
/* 1434 */,
/* 1435 */,
/* 1436 */,
/* 1437 */,
/* 1438 */,
/* 1439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.terminalLogger = exports.runTransactions = exports.promptHandler = exports.loadAddress = exports.getSelectedContract = exports.getFuncABIInputs = exports.getContext = exports.createInstance = exports.continueHandler = exports.confirmationHandler = void 0;

var remixLib = _interopRequireWildcard(__webpack_require__(311));

var _payload = __webpack_require__(1188);

var _actions = __webpack_require__(1211);

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const _paq = window._paq = window._paq || []; //eslint-disable-line


const txHelper = remixLib.execution.txHelper;
const txFormat = remixLib.execution.txFormat;

const loadContractFromAddress = (plugin, address, confirmCb, cb) => {
  if (/.(.abi)$/.exec(plugin.config.get('currentFile'))) {
    confirmCb(() => {
      let abi;

      try {
        abi = JSON.parse(plugin.editor.currentContent());
      } catch (e) {
        return cb('Failed to parse the current file as JSON ABI.');
      }

      _paq.push(['trackEvent', 'udapp', 'AtAddressLoadWithABI']);

      cb(null, 'abi', abi);
    });
  } else {
    _paq.push(['trackEvent', 'udapp', 'AtAddressLoadWithArtifacts']);

    cb(null, 'instance');
  }
};

const getSelectedContract = (contractName, compiler) => {
  if (!contractName) return null; // const compiler = plugin.compilersArtefacts[compilerAtributeName]

  if (!compiler) return null;
  const contract = compiler.getContract(contractName);
  return {
    name: contractName,
    contract: contract,
    compiler: compiler,
    abi: contract.object.abi,
    bytecodeObject: contract.object.evm.bytecode.object,
    bytecodeLinkReferences: contract.object.evm.bytecode.linkReferences,
    object: contract.object,
    deployedBytecode: contract.object.evm.deployedBytecode,
    getConstructorInterface: () => {
      return txHelper.getConstructorInterface(contract.object.abi);
    },
    getConstructorInputs: () => {
      const constructorInteface = txHelper.getConstructorInterface(contract.object.abi);
      return txHelper.inputParametersDeclarationToString(constructorInteface.inputs);
    },
    isOverSizeLimit: () => {
      const deployedBytecode = contract.object.evm.deployedBytecode;
      return deployedBytecode && deployedBytecode.object.length / 2 > 24576;
    },
    metadata: contract.object.metadata
  };
};

exports.getSelectedContract = getSelectedContract;

const getCompilerContracts = plugin => {
  return plugin.compilersArtefacts.__last.getData().contracts;
};

const terminalLogger = (plugin, view) => {
  plugin.call('terminal', 'logHtml', view);
};

exports.terminalLogger = terminalLogger;

const confirmationHandler = (plugin, dispatch, confirmDialogContent, network, tx, gasEstimation, continueTxExecution, cancelCb) => {
  return continueTxExecution(null);
};

exports.confirmationHandler = confirmationHandler;

const getConfirmationCb = (plugin, dispatch, confirmDialogContent) => {
  // this code is the same as in recorder.js. TODO need to be refactored out
  return (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
    confirmationHandler(plugin, dispatch, confirmDialogContent, network, tx, gasEstimation, continueTxExecution, cancelCb);
  };
};

const continueHandler = (dispatch, gasEstimationPrompt, error, continueTxExecution, cancelCb) => {
  if (error) {
    const msg = typeof error !== 'string' ? error.message : error;
    dispatch((0, _payload.displayNotification)('Gas estimation failed', gasEstimationPrompt(msg), 'Send Transaction', 'Cancel Transaction', () => {
      continueTxExecution();
    }, () => {
      cancelCb();
    }));
  } else {
    continueTxExecution();
  }
};

exports.continueHandler = continueHandler;

const promptHandler = (dispatch, passphrasePrompt, okCb, cancelCb) => {
  dispatch((0, _payload.displayNotification)('Passphrase requested', passphrasePrompt('Personal mode is enabled. Please provide passphrase of account'), 'OK', 'Cancel', okCb, cancelCb));
};

exports.promptHandler = promptHandler;

const createInstance = async (plugin, dispatch, selectedContract, gasEstimationPrompt, passphrasePrompt, publishToStorage, mainnetPrompt, isOverSizePrompt, args, deployMode) => {
  const isProxyDeployment = (deployMode || []).find(mode => mode === 'Deploy with Proxy');
  const isContractUpgrade = (deployMode || []).find(mode => mode === 'Upgrade with Proxy');

  const statusCb = msg => {
    const log = (0, _helper.logBuilder)(msg);
    return terminalLogger(plugin, log);
  };

  const finalCb = (error, contractObject, address) => {
    if (error) {
      const log = (0, _helper.logBuilder)(error);
      return terminalLogger(plugin, log);
    }

    (0, _actions.addInstance)(dispatch, {
      contractData: contractObject,
      address,
      name: contractObject.name
    });
    const data = plugin.compilersArtefacts.getCompilerAbstract(contractObject.contract.file);
    plugin.compilersArtefacts.addResolvedContract((0, _helper.addressToString)(address), data);

    if (plugin.REACT_API.ipfsChecked) {
      _paq.push(['trackEvent', 'udapp', 'DeployAndPublish', plugin.REACT_API.networkName]);

      publishToStorage('ipfs', selectedContract);
    } else {
      _paq.push(['trackEvent', 'udapp', 'DeployOnly', plugin.REACT_API.networkName]);
    }

    if (isProxyDeployment) {
      const initABI = contractObject.abi.find(abi => abi.name === 'initialize');
      plugin.call('openzeppelin-proxy', 'executeUUPSProxy', (0, _helper.addressToString)(address), args, initABI, contractObject);
    } else if (isContractUpgrade) {
      plugin.call('openzeppelin-proxy', 'executeUUPSContractUpgrade', args, (0, _helper.addressToString)(address), contractObject);
    }
  };

  let contractMetadata;

  try {
    contractMetadata = await plugin.call('compilerMetadata', 'deployMetadataOf', selectedContract.name, selectedContract.contract.file);
  } catch (error) {
    return statusCb(`creation of ${selectedContract.name} errored: ${error.message ? error.message : error}`);
  }

  const compilerContracts = getCompilerContracts(plugin);
  const confirmationCb = getConfirmationCb(plugin, dispatch, mainnetPrompt);

  if (selectedContract.isOverSizeLimit()) {
    return dispatch((0, _payload.displayNotification)('Contract code size over limit', isOverSizePrompt(), 'Force Send', 'Cancel', () => {
      deployContract(plugin, selectedContract, !isProxyDeployment && !isContractUpgrade ? args : '', contractMetadata, compilerContracts, {
        continueCb: (error, continueTxExecution, cancelCb) => {
          continueHandler(dispatch, gasEstimationPrompt, error, continueTxExecution, cancelCb);
        },
        promptCb: (okCb, cancelCb) => {
          promptHandler(dispatch, passphrasePrompt, okCb, cancelCb);
        },
        statusCb,
        finalCb
      }, confirmationCb);
    }, () => {
      const log = (0, _helper.logBuilder)(`creation of ${selectedContract.name} canceled by user.`);
      return terminalLogger(plugin, log);
    }));
  }

  deployContract(plugin, selectedContract, !isProxyDeployment && !isContractUpgrade ? args : '', contractMetadata, compilerContracts, {
    continueCb: (error, continueTxExecution, cancelCb) => {
      continueHandler(dispatch, gasEstimationPrompt, error, continueTxExecution, cancelCb);
    },
    promptCb: (okCb, cancelCb) => {
      promptHandler(dispatch, passphrasePrompt, okCb, cancelCb);
    },
    statusCb,
    finalCb
  }, confirmationCb);
};

exports.createInstance = createInstance;

const deployContract = (plugin, selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) => {
  _paq.push(['trackEvent', 'udapp', 'DeployContractTo', plugin.REACT_API.networkName]);

  const {
    statusCb
  } = callbacks;

  if (!contractMetadata || contractMetadata && contractMetadata.autoDeployLib) {
    return plugin.blockchain.deployContractAndLibraries(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb);
  }

  if (Object.keys(selectedContract.bytecodeLinkReferences).length) statusCb(`linking ${JSON.stringify(selectedContract.bytecodeLinkReferences, null, '\t')} using ${JSON.stringify(contractMetadata.linkReferences, null, '\t')}`);
  plugin.blockchain.deployContractWithLibrary(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb);
};

const loadAddress = (plugin, dispatch, contract, address) => {
  loadContractFromAddress(plugin, address, cb => {
    dispatch((0, _payload.displayNotification)('At Address', `Do you really want to interact with ${address} using the current ABI definition?`, 'OK', 'Cancel', cb, null));
  }, (error, loadType, abi) => {
    if (error) {
      return dispatch((0, _payload.displayNotification)('Alert', error, 'OK', null));
    }

    if (loadType === 'abi') {
      return (0, _actions.addInstance)(dispatch, {
        abi,
        address,
        name: '<at address>'
      });
    } else if (loadType === 'instance') {
      if (!contract) return dispatch((0, _payload.displayPopUp)('No compiled contracts found.'));
      const currentFile = plugin.REACT_API.contracts.currentFile;
      const compiler = plugin.REACT_API.contracts.contractList[currentFile].find(item => item.alias === contract.name);
      const contractData = getSelectedContract(contract.name, compiler.compiler);
      return (0, _actions.addInstance)(dispatch, {
        contractData,
        address,
        name: contract.name
      });
    }
  });
};

exports.loadAddress = loadAddress;

const getContext = plugin => {
  return plugin.blockchain.context();
};

exports.getContext = getContext;

const runTransactions = (plugin, dispatch, instanceIndex, lookupOnly, funcABI, inputsValues, contractName, contractABI, contract, address, logMsg, mainnetPrompt, gasEstimationPrompt, passphrasePrompt, funcIndex) => {
  let callinfo = '';
  if (lookupOnly) callinfo = 'call';else if (funcABI.type === 'fallback' || funcABI.type === 'receive') callinfo = 'lowLevelInteracions';else callinfo = 'transact';

  _paq.push(['trackEvent', 'udapp', callinfo, plugin.blockchain.getCurrentNetworkStatus().network.name]);

  const params = funcABI.type !== 'fallback' ? inputsValues : '';
  plugin.blockchain.runOrCallContractMethod(contractName, contractABI, funcABI, contract, inputsValues, address, params, lookupOnly, logMsg, msg => {
    const log = (0, _helper.logBuilder)(msg);
    return terminalLogger(plugin, log);
  }, returnValue => {
    const response = txFormat.decodeResponse(returnValue, funcABI);
    dispatch((0, _payload.setDecodedResponse)(instanceIndex, response, funcIndex));
  }, (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
    confirmationHandler(plugin, dispatch, mainnetPrompt, network, tx, gasEstimation, continueTxExecution, cancelCb);
  }, (error, continueTxExecution, cancelCb) => {
    continueHandler(dispatch, gasEstimationPrompt, error, continueTxExecution, cancelCb);
  }, (okCb, cancelCb) => {
    promptHandler(dispatch, passphrasePrompt, okCb, cancelCb);
  });
};

exports.runTransactions = runTransactions;

const getFuncABIInputs = (plugin, funcABI) => {
  return plugin.blockchain.getInputs(funcABI);
};

exports.getFuncABIInputs = getFuncABIInputs;

/***/ }),
/* 1440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _publishToStorage = __webpack_require__(1834);

Object.keys(_publishToStorage).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _publishToStorage[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _publishToStorage[key];
    }
  });
});

/***/ }),
/* 1441 */,
/* 1442 */,
/* 1443 */,
/* 1444 */,
/* 1445 */,
/* 1446 */,
/* 1447 */,
/* 1448 */,
/* 1449 */,
/* 1450 */,
/* 1451 */,
/* 1452 */,
/* 1453 */,
/* 1454 */,
/* 1455 */,
/* 1456 */,
/* 1457 */,
/* 1458 */,
/* 1459 */,
/* 1460 */,
/* 1461 */,
/* 1462 */,
/* 1463 */,
/* 1464 */,
/* 1465 */,
/* 1466 */,
/* 1467 */,
/* 1468 */,
/* 1469 */,
/* 1470 */,
/* 1471 */,
/* 1472 */,
/* 1473 */,
/* 1474 */,
/* 1475 */,
/* 1476 */,
/* 1477 */,
/* 1478 */,
/* 1479 */,
/* 1480 */,
/* 1481 */,
/* 1482 */,
/* 1483 */,
/* 1484 */,
/* 1485 */,
/* 1486 */,
/* 1487 */,
/* 1488 */,
/* 1489 */,
/* 1490 */,
/* 1491 */,
/* 1492 */,
/* 1493 */,
/* 1494 */,
/* 1495 */,
/* 1496 */,
/* 1497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.themes = exports.ThemeContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

// eslint-disable-line
const themes = {
  light: {
    filter: 'invert(0)',
    name: 'light'
  },
  dark: {
    filter: 'invert(1)',
    name: 'dark'
  }
};
exports.themes = themes;

const ThemeContext = /*#__PURE__*/_react.default.createContext(themes.dark // default value
);

exports.ThemeContext = ThemeContext;

/***/ }),
/* 1498 */,
/* 1499 */,
/* 1500 */,
/* 1501 */,
/* 1502 */,
/* 1503 */,
/* 1504 */,
/* 1505 */,
/* 1506 */,
/* 1507 */,
/* 1508 */,
/* 1509 */,
/* 1510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AstWalker = exports.isYulAstNode = exports.isAstNode = void 0;

const events_1 = __webpack_require__(40);

const isObject = function (obj) {
  return obj != null && obj.constructor.name === 'Object';
};

function isAstNode(node) {
  return isObject(node) && 'id' in node && 'nodeType' in node && 'src' in node;
}

exports.isAstNode = isAstNode;

function isYulAstNode(node) {
  return isObject(node) && 'nodeType' in node && 'src' in node;
}

exports.isYulAstNode = isYulAstNode;
/**
 * Crawl the given AST through the function walk(ast, callback)
 */

/**
 * visit all the AST nodes
 *
 * @param {Object} ast  - AST node
 * @return EventEmitter
 * event('node', <Node Type | false>) will be fired for every node of type <Node Type>.
 * event('node', "*") will be fired for all other nodes.
 * in each case, if the event emits false it does not descend into children.
 * If no event for the current type, children are visited.
 */
// eslint-disable-next-line no-redeclare

class AstWalker extends events_1.EventEmitter {
  manageCallback(node, callback // eslint-disable-line @typescript-eslint/ban-types
  ) {
    // FIXME: we shouldn't be doing this callback determination type on each AST node,
    // since the callback function is set once per walk.
    // Better would be to store the right one as a variable and
    // return that.
    if (node) {
      if (node.name in callback) {
        return callback[node.name](node);
      } else {
        return callback['*'](node);
      }
    }

    if (node) {
      if (node.nodeType in callback) {
        /* istanbul ignore next */
        return callback[node.nodeType](node);
      } else {
        /* istanbul ignore next */
        return callback['*'](node);
      }
    }
  }

  normalizeNodes(nodes) {
    // Remove null, undefined and empty elements if any
    nodes = nodes.filter(e => e); // If any element in nodes is array, extract its members

    const objNodes = [];
    nodes.forEach(x => {
      if (Array.isArray(x)) objNodes.push(...x);else objNodes.push(x);
    }); // Filter duplicate nodes using id field

    const normalizedNodes = [];
    objNodes.forEach(element => {
      const firstIndex = normalizedNodes.findIndex(e => e.id === element.id);
      if (firstIndex === -1) normalizedNodes.push(element);
    });
    return normalizedNodes;
  }

  getASTNodeChildren(ast) {
    var _a;

    let nodes = ast.nodes || // for ContractDefinition
    ast.body || // for FunctionDefinition, ModifierDefinition, WhileStatement, DoWhileStatement, ForStatement
    ast.statements || // for Block, YulBlock
    ast.members || // for StructDefinition, EnumDefinition
    ast.overrides || // for OverrideSpecifier
    ast.parameters || // for ParameterList, EventDefinition
    ast.declarations || // for VariableDeclarationStatement
    ast.expression || // for Return, ExpressionStatement, FunctionCall, FunctionCallOptions, MemberAccess
    ast.components || // for TupleExpression
    ast.subExpression || // for UnaryOperation
    ast.eventCall || // for EmitStatement
    []; // If 'nodes' is not an array, convert it into one, for example: ast.body

    if (nodes && !Array.isArray(nodes)) {
      const tempArr = [];
      tempArr.push(nodes);
      nodes = tempArr;
    } // To break object referencing


    nodes = [...nodes];

    if (ast.nodes && ((_a = ast.baseContracts) === null || _a === void 0 ? void 0 : _a.length)) {
      // for ContractDefinition
      nodes.push(...ast.baseContracts);
    } else if (ast.body && ast.overrides && ast.parameters && ast.returnParameters && ast.modifiers) {
      // for FunctionDefinition
      nodes.push(ast.overrides);
      nodes.push(ast.parameters);
      nodes.push(ast.returnParameters);
      nodes.push(ast.modifiers);
    } else if (ast.typeName) {
      // for VariableDeclaration, NewExpression, ElementaryTypeNameExpression
      nodes.push(ast.typeName);
    } else if (ast.body && ast.overrides && ast.parameters) {
      // for ModifierDefinition
      nodes.push(ast.overrides);
      nodes.push(ast.parameters);
    } else if (ast.modifierName && ast.arguments) {
      // for ModifierInvocation
      nodes.push(ast.modifierName);
      nodes.push(ast.arguments);
    } else if (ast.parameterTypes && ast.returnParameterTypes) {
      // for ModifierInvocation
      nodes.push(ast.parameterTypes);
      nodes.push(ast.returnParameterTypes);
    } else if (ast.keyType && ast.valueType) {
      // for Mapping
      nodes.push(ast.keyType);
      nodes.push(ast.valueType);
    } else if (ast.baseType && ast.length) {
      // for ArrayTypeName
      nodes.push(ast.baseType);
      nodes.push(ast.length);
    } else if (ast.AST) {
      // for InlineAssembly
      nodes.push(ast.AST);
    } else if (ast.condition && (ast.trueBody || ast.falseBody || ast.body)) {
      // for IfStatement, WhileStatement, DoWhileStatement
      nodes.push(ast.condition);
      nodes.push(ast.trueBody);
      nodes.push(ast.falseBody);
    } else if (ast.parameters && ast.block) {
      // for TryCatchClause
      nodes.push(ast.block);
    } else if (ast.externalCall && ast.clauses) {
      // for TryStatement
      nodes.push(ast.externalCall);
      nodes.push(ast.clauses);
    } else if (ast.body && ast.condition && ast.initializationExpression && ast.loopExpression) {
      // for ForStatement
      nodes.push(ast.condition);
      nodes.push(ast.initializationExpression);
      nodes.push(ast.loopExpression);
    } else if (ast.declarations && ast.initialValue) {
      // for VariableDeclarationStatement
      nodes.push(ast.initialValue);
    } else if (ast.condition && (ast.trueExpression || ast.falseExpression)) {
      // for Conditional
      nodes.push(ast.condition);
      nodes.push(ast.trueExpression);
      nodes.push(ast.falseExpression);
    } else if (ast.leftHandSide && ast.rightHandSide) {
      // for Assignment
      nodes.push(ast.leftHandSide);
      nodes.push(ast.rightHandSide);
    } else if (ast.leftExpression && ast.rightExpression) {
      // for BinaryOperation
      nodes.push(ast.leftExpression);
      nodes.push(ast.rightExpression);
    } else if (ast.expression && (ast.arguments || ast.options)) {
      // for FunctionCall, FunctionCallOptions
      nodes.push(ast.arguments ? ast.arguments : ast.options);
    } else if (ast.baseExpression && (ast.indexExpression || ast.startExpression && ast.endExpression)) {
      // for IndexAccess, IndexRangeAccess
      nodes.push(ast.baseExpression);
      if (ast.indexExpression) nodes.push(ast.indexExpression);else {
        nodes.push(ast.startExpression);
        nodes.push(ast.endExpression);
      }
    }

    return this.normalizeNodes(nodes);
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walk(ast, callback) {
    if (ast) {
      const children = this.getASTNodeChildren(ast);

      if (callback) {
        if (callback instanceof Function) {
          callback = Object({
            '*': callback
          });
        }

        if (!('*' in callback)) {
          callback['*'] = function () {
            return true;
          };
        }

        if (this.manageCallback(ast, callback) && (children === null || children === void 0 ? void 0 : children.length)) {
          for (const k in children) {
            const child = children[k];
            this.walk(child, callback);
          }
        }
      } else {
        if (children === null || children === void 0 ? void 0 : children.length) {
          for (const k in children) {
            const child = children[k];
            this.emit('node', child);
            this.walk(child);
          }
        }
      }
    }
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walkFullInternal(ast, callback) {
    if (isAstNode(ast) || isYulAstNode(ast)) {
      // console.log(`XXX id ${ast.id}, nodeType: ${ast.nodeType}, src: ${ast.src}`);
      callback(ast);

      for (const k of Object.keys(ast)) {
        // Possible optimization:
        // if (k in ['id', 'src', 'nodeType']) continue;
        const astItem = ast[k];

        if (Array.isArray(astItem)) {
          for (const child of astItem) {
            if (child) {
              this.walkFullInternal(child, callback);
            }
          }
        } else {
          this.walkFullInternal(astItem, callback);
        }
      }
    }
  } // Normalizes parameter callback and calls walkFullInternal
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


  walkFull(ast, callback) {
    if (isAstNode(ast) || isYulAstNode(ast)) return this.walkFullInternal(ast, callback);
  } // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/explicit-module-boundary-types


  walkAstList(sourcesList, cb) {
    if (cb) {
      if (sourcesList.ast) {
        this.walk(sourcesList.ast, cb);
      }
    } else {
      if (sourcesList.ast) {
        this.walk(sourcesList.ast);
      }
    }
  }

}

exports.AstWalker = AstWalker;

/***/ }),
/* 1511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ethdebugger = void 0;

const tslib_1 = __webpack_require__(23);

const storageViewer_1 = __webpack_require__(1218);

const storageResolver_1 = __webpack_require__(1327);

const traceManager_1 = __webpack_require__(2167);

const codeManager_1 = __webpack_require__(2171);

const traceHelper_1 = __webpack_require__(1146);

const eventManager_1 = __webpack_require__(1157);

const solidity_decoder_1 = __webpack_require__(1513);
/**
  * Ethdebugger is a wrapper around a few classes that helps debugging a transaction
  *
  * - TraceManager - Load / Analyze the trace and retrieve details of specific test
  * - CodeManager - Retrieve loaded byte code and help to resolve AST item from vmtrace index
  * - SolidityProxy - Basically used to extract state variable from AST
  * - Breakpoint Manager - Used to add / remove / jumpto breakpoint
  * - InternalCallTree - Used to retrieved local variables
  * - StorageResolver - Help resolving the storage accross different steps
  *
  * @param {Map} opts  -  { function compilationResult } //
  */


class Ethdebugger {
  constructor(opts) {
    this.compilationResult = opts.compilationResult || function (contractAddress) {
      return null;
    };

    this.web3 = opts.web3;
    this.opts = opts;
    this.event = new eventManager_1.EventManager();
    this.traceManager = new traceManager_1.TraceManager({
      web3: this.web3
    });
    this.codeManager = new codeManager_1.CodeManager(this.traceManager);
    this.solidityProxy = new solidity_decoder_1.SolidityProxy({
      getCurrentCalledAddressAt: this.traceManager.getCurrentCalledAddressAt.bind(this.traceManager),
      getCode: this.codeManager.getCode.bind(this.codeManager)
    });
    this.storageResolver = null;
    const includeLocalVariables = true;
    this.callTree = new solidity_decoder_1.InternalCallTree(this.event, this.traceManager, this.solidityProxy, this.codeManager, Object.assign(Object.assign({}, opts), {
      includeLocalVariables
    }));
  }

  setManagers() {
    this.traceManager = new traceManager_1.TraceManager({
      web3: this.web3
    });
    this.codeManager = new codeManager_1.CodeManager(this.traceManager);
    this.solidityProxy = new solidity_decoder_1.SolidityProxy({
      getCurrentCalledAddressAt: this.traceManager.getCurrentCalledAddressAt.bind(this.traceManager),
      getCode: this.codeManager.getCode.bind(this.codeManager)
    });
    this.storageResolver = null;
    const includeLocalVariables = true;
    this.callTree = new solidity_decoder_1.InternalCallTree(this.event, this.traceManager, this.solidityProxy, this.codeManager, Object.assign(Object.assign({}, this.opts), {
      includeLocalVariables
    }));
  }

  resolveStep(index) {
    this.codeManager.resolveStep(index, this.tx);
  }

  setCompilationResult(compilationResult) {
    this.solidityProxy.reset(compilationResult && compilationResult.data || {});
  }

  sourceLocationFromVMTraceIndex(address, stepIndex) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      return this.callTree.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, stepIndex, this.solidityProxy.contracts);
    });
  }

  getValidSourceLocationFromVMTraceIndex(address, stepIndex) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      return this.callTree.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, stepIndex, this.solidityProxy.contracts);
    });
  }

  sourceLocationFromInstructionIndex(address, instIndex, callback) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      return this.callTree.sourceLocationTracker.getSourceLocationFromInstructionIndex(address, instIndex, this.solidityProxy.contracts);
    });
  }
  /* breakpoint */


  setBreakpointManager(breakpointManager) {
    this.breakpointManager = breakpointManager;
  }
  /* decode locals */


  extractLocalsAt(step) {
    return this.callTree.findScope(step);
  }

  decodeLocalsAt(step, sourceLocation, callback) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        const stack = this.traceManager.getStackAt(step);
        const memory = this.traceManager.getMemoryAt(step);
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const calldata = this.traceManager.getCallDataAt(step);

        try {
          const storageViewer = new storageViewer_1.StorageViewer({
            stepIndex: step,
            tx: this.tx,
            address: address
          }, this.storageResolver, this.traceManager);
          const locals = yield solidity_decoder_1.localDecoder.solidityLocals(step, this.callTree, stack, memory, storageViewer, calldata, sourceLocation, null);

          if (locals['error']) {
            return callback(locals['error']);
          }

          return callback(null, locals);
        } catch (e) {
          callback(e.message);
        }
      } catch (error) {
        callback(error);
      }
    });
  }
  /* decode state */


  extractStateAt(step) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      return this.solidityProxy.extractStateVariablesAt(step);
    });
  }

  decodeStateAt(step, stateVars, callback) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: step,
          tx: this.tx,
          address: address
        }, this.storageResolver, this.traceManager);
        const result = yield solidity_decoder_1.stateDecoder.decodeState(stateVars, storageViewer);
        return result;
      } catch (error) {
        callback(error);
      }
    });
  }

  storageViewAt(step, address) {
    return new storageViewer_1.StorageViewer({
      stepIndex: step,
      tx: this.tx,
      address: address
    }, this.storageResolver, this.traceManager);
  }

  updateWeb3(web3) {
    this.web3 = web3;
    this.setManagers();
  }

  unLoad() {
    this.traceManager.init();
    this.codeManager.clear();
    this.event.trigger('traceUnloaded');
  }

  debug(tx) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (this.traceManager.isLoading) {
        return;
      }

      tx.to = tx.to || (0, traceHelper_1.contractCreationToken)('0');
      this.tx = tx;
      yield this.traceManager.resolveTrace(tx);
      this.setCompilationResult(yield this.compilationResult(tx.to));
      this.event.trigger('newTraceLoaded', [this.traceManager.trace]);

      if (this.breakpointManager && this.breakpointManager.hasBreakpoint()) {
        this.breakpointManager.jumpNextBreakpoint(false);
      }

      this.storageResolver = new storageResolver_1.StorageResolver({
        web3: this.traceManager.web3
      });
    });
  }

}

exports.Ethdebugger = Ethdebugger;

/***/ }),
/* 1512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeMappingsKeys = void 0;

const tslib_1 = __webpack_require__(23);

const util_1 = __webpack_require__(1143);
/**
  * extract the mappings location from the storage
  * like { "<mapping_slot>" : { "<mapping-key1>": preimageOf1 }, { "<mapping-key2>": preimageOf2 }, ... }
  *
  * @param {Object} storage  - storage given by storage Viewer (basically a mapping hashedkey : {key, value})
  * @param {Array} corrections - used in case the calculated sha3 has been modifyed before SSTORE (notably used for struct in mapping).
  * @param {Function} callback  - calback
  * @return {Map} - solidity mapping location (e.g { "<mapping_slot>" : { "<mapping-key1>": preimageOf1 }, { "<mapping-key2>": preimageOf2 }, ... })
  */


function decodeMappingsKeys(web3, storage, corrections) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    const ret = {};
    if (!corrections.length) corrections.push({
      offset: 0,
      slot: 0
    });

    for (const hashedLoc in storage) {
      let preimage;

      try {
        const key = storage[hashedLoc].key;

        for (const k in corrections) {
          const corrected = (0, util_1.sub)(key, corrections[k].slot).toString(16);
          preimage = yield getPreimage(web3, '0x' + corrected);
          if (preimage) break;
        }
      } catch (e) {} // eslint-disable-line no-empty


      if (preimage) {
        // got preimage!
        // get mapping position (i.e. storage slot), its the last 32 bytes
        const slotByteOffset = preimage.length - 64;
        const mappingSlot = preimage.substr(slotByteOffset);
        const mappingKey = preimage.substr(0, slotByteOffset);

        if (!ret[mappingSlot]) {
          ret[mappingSlot] = {};
        }

        ret[mappingSlot][mappingKey] = preimage;
      }
    }

    return ret;
  });
}

exports.decodeMappingsKeys = decodeMappingsKeys;
/**
  * Uses web3 to return preimage of a key
  *
  * @param {String} key  - key to retrieve the preimage of
  * @return {String} - preimage of the given key
  */

function getPreimage(web3, key) {
  return new Promise((resolve, reject) => {
    web3.debug.preimage(key.indexOf('0x') === 0 ? key : '0x' + key, (error, preimage) => {
      if (error) {
        return resolve(null);
      }

      resolve(preimage);
    });
  });
}

/***/ }),
/* 1513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalCallTree = exports.localDecoder = exports.stateDecoder = exports.SolidityProxy = void 0;

const tslib_1 = __webpack_require__(23);

const solidityProxy_1 = __webpack_require__(2179);

Object.defineProperty(exports, "SolidityProxy", {
  enumerable: true,
  get: function () {
    return solidityProxy_1.SolidityProxy;
  }
});
const stateDecoder = (0, tslib_1.__importStar)(__webpack_require__(1331));
exports.stateDecoder = stateDecoder;
const localDecoder = (0, tslib_1.__importStar)(__webpack_require__(1518));
exports.localDecoder = localDecoder;

const internalCallTree_1 = __webpack_require__(2190);

Object.defineProperty(exports, "InternalCallTree", {
  enumerable: true,
  get: function () {
    return internalCallTree_1.InternalCallTree;
  }
});

/***/ }),
/* 1514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractStatesDefinitions = exports.extractStateDefinitions = exports.getLinearizedBaseContracts = exports.extractOrphanDefinitions = exports.extractContractDefinitions = void 0;

const remix_astwalker_1 = __webpack_require__(1180);
/**
  * return all contract definitions of the given @astList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @return {Object} - returns a mapping from AST node ids to AST nodes for the contracts
  */


function extractContractDefinitions(sourcesList) {
  const ret = {
    contractsById: {},
    contractsByName: {},
    sourcesByContract: {}
  };
  const walker = new remix_astwalker_1.AstWalker();

  for (const k in sourcesList) {
    walker.walkFull(sourcesList[k].ast, node => {
      if (node.nodeType === 'ContractDefinition') {
        ret.contractsById[node.id] = node;
        ret.sourcesByContract[node.id] = k;
        ret.contractsByName[k + ':' + node.name] = node;
      }
    });
  }

  return ret;
}

exports.extractContractDefinitions = extractContractDefinitions;
/**
  * return nodes from an ast @arg sourcesList that are declared outside of a ContractDefinition @astList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @return {Object} - returns a list of node
  */

function extractOrphanDefinitions(sourcesList) {
  const ret = [];

  for (const k in sourcesList) {
    const ast = sourcesList[k].ast;

    if (ast.nodes && ast.nodes.length) {
      for (const node of ast.nodes) {
        if (node.nodeType !== 'ContractDefinition') {
          ret.push(node);
        }
      }
    }
  }

  return ret;
}

exports.extractOrphanDefinitions = extractOrphanDefinitions;
/**
  * returns the linearized base contracts of the contract @arg id
  *
  * @param {Int} id - contract id to resolve
  * @param {Map} contracts  - all contracts defined in the current context
  * @return {Array} - array of base contracts in derived to base order as AST nodes.
  */

function getLinearizedBaseContracts(id, contractsById) {
  return contractsById[id].linearizedBaseContracts.map(function (id) {
    return contractsById[id];
  });
}

exports.getLinearizedBaseContracts = getLinearizedBaseContracts;
/**
  * return state var and type definition of the given contract
  *
  * @param {String} contractName - contract for which state var should be resolved
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @param {Object} [contracts] - map of contract definitions (contains contractsById, contractsByName)
  * @return {Object} - return an object containing: stateItems - list of all the children node of the @arg contractName
  *                                                 stateVariables - list of all the variable declaration of the @arg contractName
  */

function extractStateDefinitions(contractName, sourcesList, contracts) {
  if (!contracts) {
    contracts = extractContractDefinitions(sourcesList);
  }

  const node = contracts.contractsByName[contractName];

  if (!node) {
    return null;
  }

  const stateItems = extractOrphanDefinitions(sourcesList);
  const stateVar = [];
  const baseContracts = getLinearizedBaseContracts(node.id, contracts.contractsById);
  baseContracts.reverse();

  for (const k in baseContracts) {
    const ctr = baseContracts[k];

    for (const i in ctr.nodes) {
      const item = ctr.nodes[i];
      stateItems.push(item);

      if (item.nodeType === 'VariableDeclaration') {
        stateVar.push(item);
      }
    }
  }

  return {
    stateDefinitions: stateItems,
    stateVariables: stateVar
  };
}

exports.extractStateDefinitions = extractStateDefinitions;
/**
  * return state var and type definition of all the contracts from the given @args sourcesList
  *
  * @param {Object} sourcesList - sources list (containing root AST node)
  * @param {Object} [contracts] - map of contract definitions (contains contractsById, contractsByName)
  * @return {Object} - returns a mapping between contract name and contract state
  */

function extractStatesDefinitions(sourcesList, contracts) {
  if (!contracts) {
    contracts = extractContractDefinitions(sourcesList);
  }

  const ret = {};

  for (const contract in contracts.contractsById) {
    const name = contracts.contractsById[contract].name;
    const source = contracts.sourcesByContract[contract];
    const fullName = source + ':' + name;
    const state = extractStateDefinitions(fullName, sourcesList, contracts);
    ret[fullName] = state;
    ret[name] = state; // solc < 0.4.9
  }

  return ret;
}

exports.extractStatesDefinitions = extractStatesDefinitions;

/***/ }),
/* 1515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Struct = exports.Enum = exports.Array = exports.String = exports.Int = exports.FixedByteArray = exports.DynamicByteArray = exports.Bool = exports.Address = exports.Uint = exports.computeOffsets = exports.parseType = void 0;

const Address_1 = __webpack_require__(2180);

const ArrayType_1 = __webpack_require__(2181);

const Bool_1 = __webpack_require__(2182);

const DynamicByteArray_1 = __webpack_require__(1516);

const FixedByteArray_1 = __webpack_require__(2183);

const Enum_1 = __webpack_require__(2184);

const StringType_1 = __webpack_require__(2185);

const Struct_1 = __webpack_require__(2186);

const Int_1 = __webpack_require__(2187);

const Uint_1 = __webpack_require__(2188);

const Mapping_1 = __webpack_require__(1517);

const FunctionType_1 = __webpack_require__(2189);

const util_1 = __webpack_require__(1143);
/**
  * mapping decode the given @arg type
  *
  * @param {String} type - type given by the AST
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function mapping(type, stateDefinitions, contractName) {
  const match = type.match(/mapping\((.*?)=>(.*)\)$/);
  const keyTypeName = match[1].trim();
  const valueTypeName = match[2].trim();
  const keyType = parseType(keyTypeName, stateDefinitions, contractName, 'storage');
  const valueType = parseType(valueTypeName, stateDefinitions, contractName, 'storage');
  const underlyingTypes = {
    keyType: keyType,
    valueType: valueType
  };
  return new Mapping_1.Mapping(underlyingTypes, 'location', (0, util_1.removeLocation)(type));
}
/**
  * Uint decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g uint256, uint32)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function uint(type) {
  type = type === 'uint' ? 'uint256' : type;
  const storageBytes = parseInt(type.replace('uint', '')) / 8;
  return new Uint_1.Uint(storageBytes);
}

exports.Uint = uint;
/**
  * Int decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g int256, int32)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function int(type) {
  type = type === 'int' ? 'int256' : type;
  const storageBytes = parseInt(type.replace('int', '')) / 8;
  return new Int_1.Int(storageBytes);
}

exports.Int = int;
/**
  * Address decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g address)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function address(type) {
  return new Address_1.Address();
}

exports.Address = address;
/**
  * Bool decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bool)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function bool(type) {
  return new Bool_1.Bool();
}

exports.Bool = bool;

function functionType(type, stateDefinitions, contractName, location) {
  return new FunctionType_1.FunctionType(type, stateDefinitions, contractName, location);
}
/**
  * DynamicByteArray decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bytes storage ref)
  * @param {null} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {null} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */


function dynamicByteArray(type, stateDefinitions, contractName, location) {
  if (!location) {
    location = (0, util_1.extractLocation)(type);
  }

  if (location) {
    return new DynamicByteArray_1.DynamicByteArray(location);
  } else {
    return null;
  }
}

exports.DynamicByteArray = dynamicByteArray;
/**
  * FixedByteArray decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g bytes16)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function fixedByteArray(type) {
  const storageBytes = parseInt(type.replace('bytes', ''));
  return new FixedByteArray_1.FixedByteArray(storageBytes);
}

exports.FixedByteArray = fixedByteArray;
/**
  * StringType decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g string storage ref)
  * @param {null} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {null} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName}
  */

function stringType(type, stateDefinitions, contractName, location) {
  if (!location) {
    location = (0, util_1.extractLocation)(type);
  }

  if (location) {
    return new StringType_1.StringType(location);
  } else {
    return null;
  }
}

exports.String = stringType;
/**
  * ArrayType decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g int256[] storage ref, int256[] storage ref[] storage ref)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, arraySize, subArray}
  */

function array(type, stateDefinitions, contractName, location) {
  const match = type.match(/(.*)\[(.*?)\]( storage ref| storage pointer| memory| calldata)?$/);

  if (!match) {
    console.log('unable to parse type ' + type);
    return null;
  }

  if (!location) {
    location = match[3].trim();
  }

  const arraySize = match[2] === '' ? 'dynamic' : parseInt(match[2]);
  const underlyingType = parseType(match[1], stateDefinitions, contractName, location);

  if (underlyingType === null) {
    console.log('unable to parse type ' + type);
    return null;
  }

  return new ArrayType_1.ArrayType(underlyingType, arraySize, location);
}

exports.Array = array;
/**
  * Enum decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g enum enumDef)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, enum}
  */

function enumType(type, stateDefinitions, contractName) {
  const match = type.match(/enum (.*)/);
  const enumDef = getEnum(match[1], stateDefinitions, contractName);

  if (enumDef === null) {
    console.log('unable to retrieve decode info of ' + type);
    return null;
  }

  return new Enum_1.Enum(enumDef);
}

exports.Enum = enumType;
/**
  * Struct decode the given @arg type
  *
  * @param {String} type - type given by the AST (e.g struct structDef storage ref)
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} returns decoded info about the current type: { storageBytes, typeName, members}
  */

function struct(type, stateDefinitions, contractName, location) {
  const match = type.match(/struct (\S*?)( storage ref| storage pointer| memory| calldata)?$/);

  if (match) {
    if (!location) {
      location = match[2].trim();
    }

    const memberDetails = getStructMembers(match[1], stateDefinitions, contractName, location); // type is used to extract the ast struct definition

    if (!memberDetails) return null;
    return new Struct_1.Struct(memberDetails, location, match[1]);
  } else {
    return null;
  }
}

exports.Struct = struct;
/**
  * retrieve enum declaration of the given @arg type
  *
  * @param {String} type - type given by the AST (e.g enum enumDef)
  * @param {Object} stateDefinitions  - all state declarations given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @return {Array} - containing all value declaration of the current enum type
  */

function getEnum(type, stateDefinitions, contractName) {
  const split = type.split('.');

  if (!split.length) {
    type = contractName + '.' + type;
  } else {
    contractName = split[0];
  }

  const state = stateDefinitions[contractName];

  if (state) {
    for (const dec of state.stateDefinitions) {
      if (dec && dec.name && type === contractName + '.' + dec.name) {
        return dec;
      }
    }
  }

  return null;
}
/**
  * retrieve memebers declared in the given @arg tye
  *
  * @param {String} typeName - name of the struct type (e.g struct <name>)
  * @param {Object} stateDefinitions  - all state definition given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Array} containing all members of the current struct type
  */


function getStructMembers(type, stateDefinitions, contractName, location) {
  if (type.indexOf('.') === -1) {
    type = contractName + '.' + type;
  }

  if (!contractName) {
    contractName = type.split('.')[0];
  }

  const state = stateDefinitions[contractName];

  if (state) {
    for (const dec of state.stateDefinitions) {
      if (dec.nodeType === 'StructDefinition' && type === contractName + '.' + dec.name) {
        const offsets = computeOffsets(dec.members, stateDefinitions, contractName, location);

        if (!offsets) {
          return null;
        }

        return {
          members: offsets.typesOffsets,
          storageSlots: offsets.endLocation.slot
        };
      }
    }
  }

  return null;
}
/**
  * parse the full type
  *
  * @param {String} fullType - type given by the AST (ex: uint[2] storage ref[2])
  * @return {String} returns the token type (used to instanciate the right decoder) (uint[2] storage ref[2] will return 'array', uint256 will return uintX)
  */


function typeClass(fullType) {
  fullType = (0, util_1.removeLocation)(fullType);

  if (fullType.lastIndexOf(']') === fullType.length - 1) {
    return 'array';
  }

  if (fullType.indexOf('mapping') === 0) {
    return 'mapping';
  }

  if (fullType.indexOf(' ') !== -1) {
    fullType = fullType.split(' ')[0];
  }

  const char = fullType.indexOf('bytes') === 0 ? 'X' : '';
  return fullType.replace(/[0-9]+/g, char);
}
/**
  * parse the type and return an object representing the type
  *
  * @param {Object} type - type name given by the ast node
  * @param {Object} stateDefinitions - all state stateDefinitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Object} - return the corresponding decoder or null on error
  */


function parseType(type, stateDefinitions, contractName, location) {
  const decodeInfos = {
    contract: address,
    address: address,
    array: array,
    bool: bool,
    bytes: dynamicByteArray,
    bytesX: fixedByteArray,
    enum: enumType,
    string: stringType,
    struct: struct,
    int: int,
    uint: uint,
    mapping: mapping,
    function: functionType
  };
  const currentType = typeClass(type);

  if (currentType === null) {
    console.log('unable to retrieve decode info of ' + type);
    return null;
  }

  if (decodeInfos[currentType]) {
    return decodeInfos[currentType](type, stateDefinitions, contractName, location);
  } else {
    return null;
  }
}

exports.parseType = parseType;
/**
  * compute offset (slot offset and byte offset of the @arg list of types)
  *
  * @param {Array} types - list of types
  * @param {Object} stateDefinitions - all state definitions given by the AST (including struct and enum type declaration) for all contracts
  * @param {String} contractName - contract the @args typeName belongs to
  * @param {String} location - location of the data (storage ref| storage pointer| memory| calldata)
  * @return {Array} - return an array of types item: {name, type, location}. location defines the byte offset and slot offset
  */

function computeOffsets(types, stateDefinitions, contractName, location) {
  const ret = [];
  const storagelocation = {
    offset: 0,
    slot: 0
  };

  for (const i in types) {
    const variable = types[i];
    const type = parseType(variable.typeDescriptions.typeString, stateDefinitions, contractName, location);

    if (!type) {
      console.log('unable to retrieve decode info of ' + variable.typeDescriptions.typeString);
      return null;
    }

    const immutable = variable.mutability === 'immutable';
    const hasStorageSlots = !immutable && !variable.constant;

    if (hasStorageSlots && storagelocation.offset + type.storageBytes > 32) {
      storagelocation.slot++;
      storagelocation.offset = 0;
    }

    ret.push({
      name: variable.name,
      type: type,
      constant: variable.constant,
      immutable,
      storagelocation: {
        offset: !hasStorageSlots ? 0 : storagelocation.offset,
        slot: !hasStorageSlots ? 0 : storagelocation.slot
      }
    });

    if (hasStorageSlots) {
      if (type.storageSlots === 1 && storagelocation.offset + type.storageBytes <= 32) {
        storagelocation.offset += type.storageBytes;
      } else {
        storagelocation.slot += type.storageSlots;
        storagelocation.offset = 0;
      }
    }
  }

  if (storagelocation.offset > 0) {
    storagelocation.slot++;
  }

  return {
    typesOffsets: ret,
    endLocation: storagelocation
  };
}

exports.computeOffsets = computeOffsets;

/***/ }),
/* 1516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DynamicByteArray = void 0;

const tslib_1 = __webpack_require__(23);

const util_1 = __webpack_require__(1143);

const remix_lib_1 = __webpack_require__(311);

const ethereumjs_util_1 = __webpack_require__(34);

const RefType_1 = __webpack_require__(1254);

const sha3256 = remix_lib_1.util.sha3_256;

class DynamicByteArray extends RefType_1.RefType {
  constructor(location) {
    super(1, 32, 'bytes', location);
  }

  decodeFromStorage(location, storageResolver) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      let value = '0x0';

      try {
        value = yield (0, util_1.extractHexValue)(location, storageResolver, this.storageBytes);
      } catch (e) {
        console.log(e);
        return {
          error: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }

      const length = new ethereumjs_util_1.BN(value, 16);

      if (length.testn(0)) {
        let dataPos = new ethereumjs_util_1.BN(sha3256(location.slot).replace('0x', ''), 16);
        let ret = '';
        let currentSlot = '0x';

        try {
          currentSlot = yield (0, util_1.readFromStorage)(dataPos, storageResolver);
        } catch (e) {
          console.log(e);
          return {
            error: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }

        while (length.gt(new ethereumjs_util_1.BN(ret.length)) && ret.length < 32000) {
          currentSlot = currentSlot.replace('0x', '');
          ret += currentSlot;
          dataPos = dataPos.add(new ethereumjs_util_1.BN(1));

          try {
            currentSlot = yield (0, util_1.readFromStorage)(dataPos, storageResolver);
          } catch (e) {
            console.log(e);
            return {
              error: '<decoding failed - ' + e.message + '>',
              type: this.typeName
            };
          }
        }

        return {
          value: '0x' + ret.replace(/(00)+$/, ''),
          length: '0x' + length.toString(16),
          type: this.typeName
        };
      } else {
        const size = parseInt(value.substr(value.length - 2, 2), 16) / 2;
        return {
          value: '0x' + value.substr(0, size * 2),
          length: '0x' + size.toString(16),
          type: this.typeName
        };
      }
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    offset = 2 * offset;
    let length = memory.substr(offset, 64);
    length = 2 * parseInt(length, 16);
    return {
      length: '0x' + length.toString(16),
      value: '0x' + memory.substr(offset + 64, length),
      type: this.typeName
    };
  }

}

exports.DynamicByteArray = DynamicByteArray;

/***/ }),
/* 1517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mapping = void 0;

const tslib_1 = __webpack_require__(23);

const RefType_1 = __webpack_require__(1254);

const util_1 = __webpack_require__(1143);

const ethereumjs_util_1 = __webpack_require__(34);

class Mapping extends RefType_1.RefType {
  constructor(underlyingTypes, location, fullType) {
    super(1, 32, fullType, 'storage');
    this.keyType = underlyingTypes.keyType;
    this.valueType = underlyingTypes.valueType;
    this.initialDecodedState = null;
  }

  decodeFromStorage(location, storageResolver) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const corrections = this.valueType.members ? this.valueType.members.map(value => {
        return value.storagelocation;
      }) : [];

      if (!this.initialDecodedState) {
        // cache the decoded initial storage
        let mappingsInitialPreimages;

        try {
          mappingsInitialPreimages = yield storageResolver.initialMappingsLocation(corrections);
          this.initialDecodedState = yield this.decodeMappingsLocation(mappingsInitialPreimages, location, storageResolver);
        } catch (e) {
          return {
            value: e.message,
            type: this.typeName
          };
        }
      }

      const mappingPreimages = yield storageResolver.mappingsLocation(corrections);
      let ret = yield this.decodeMappingsLocation(mappingPreimages, location, storageResolver); // fetch mapping storage changes

      ret = Object.assign({}, this.initialDecodedState, ret); // merge changes

      return {
        value: ret,
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    // mappings can only exist in storage and not in memory
    // so this should never be called
    return {
      value: '',
      length: '0x0',
      type: this.typeName
    };
  }

  decodeMappingsLocation(preimages, location, storageResolver) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const mapSlot = (0, util_1.normalizeHex)((0, ethereumjs_util_1.bufferToHex)(location.slot));

      if (!preimages[mapSlot]) {
        return {};
      }

      const ret = {};

      for (const i in preimages[mapSlot]) {
        const mapLocation = getMappingLocation(i, location.slot);
        const globalLocation = {
          offset: location.offset,
          slot: mapLocation
        };
        ret[i] = yield this.valueType.decodeFromStorage(globalLocation, storageResolver);
      }

      return ret;
    });
  }

}

exports.Mapping = Mapping;

function getMappingLocation(key, position) {
  // mapping storage location decribed at http://solidity.readthedocs.io/en/develop/miscellaneous.html#layout-of-state-variables-in-storage
  // > the value corresponding to a mapping key k is located at keccak256(k . p) where . is concatenation.
  // key should be a hex string, and position an int
  const mappingK = (0, ethereumjs_util_1.toBuffer)((0, ethereumjs_util_1.addHexPrefix)(key));
  let mappingP = (0, ethereumjs_util_1.toBuffer)((0, ethereumjs_util_1.addHexPrefix)(position));
  mappingP = (0, ethereumjs_util_1.setLengthLeft)(mappingP, 32);
  const mappingKeyBuf = concatTypedArrays(mappingK, mappingP);
  const mappingStorageLocation = (0, ethereumjs_util_1.keccak)(mappingKeyBuf);
  const mappingStorageLocationinBn = new ethereumjs_util_1.BN(mappingStorageLocation, 16);
  return mappingStorageLocationinBn;
}

function concatTypedArrays(a, b) {
  const c = new a.constructor(a.length + b.length);
  c.set(a, 0);
  c.set(b, a.length);
  return c;
}

/***/ }),
/* 1518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.solidityLocals = void 0;

const tslib_1 = __webpack_require__(23);

function solidityLocals(vmtraceIndex, internalTreeCall, stack, memory, storageResolver, calldata, currentSourceLocation, cursor) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    const scope = internalTreeCall.findScope(vmtraceIndex);

    if (!scope) {
      const error = {
        message: 'Can\'t display locals. reason: compilation result might not have been provided'
      };
      throw error;
    }

    const locals = {};
    memory = formatMemory(memory);
    let anonymousIncr = 1;

    for (const local in scope.locals) {
      const variable = scope.locals[local];

      if (variable.stackDepth < stack.length && variable.sourceLocation.start <= currentSourceLocation.start) {
        let name = variable.name;

        if (name.indexOf('$') !== -1) {
          name = '<' + anonymousIncr + '>';
          anonymousIncr++;
        }

        try {
          locals[name] = yield variable.type.decodeFromStack(variable.stackDepth, stack, memory, storageResolver, calldata, cursor, variable);
        } catch (e) {
          console.log(e);
          locals[name] = {
            error: '<decoding failed - ' + e.message + '>'
          };
        }
      }
    }

    return locals;
  });
}

exports.solidityLocals = solidityLocals;

function formatMemory(memory) {
  if (memory instanceof Array) {
    memory = memory.join('').replace(/0x/g, '');
  }

  return memory;
}

/***/ }),
/* 1519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Debugger = void 0;

const tslib_1 = __webpack_require__(23);

const Ethdebugger_1 = __webpack_require__(1511);

const eventManager_1 = __webpack_require__(1157);

const traceHelper_1 = __webpack_require__(1146);

const breakpointManager_1 = __webpack_require__(1520);

const stepManager_1 = __webpack_require__(2192);

const VmDebugger_1 = __webpack_require__(2193);

class Debugger {
  constructor(options) {
    this.event = new eventManager_1.EventManager();
    this.offsetToLineColumnConverter = options.offsetToLineColumnConverter;
    /*
      Returns a compilation result for a given address or the last one available if none are found
    */

    this.compilationResult = options.compilationResult || function (contractAddress) {
      return null;
    };

    this.debugger = new Ethdebugger_1.Ethdebugger({
      web3: options.web3,
      debugWithGeneratedSources: options.debugWithGeneratedSources,
      compilationResult: this.compilationResult
    });
    const {
      traceManager,
      callTree,
      solidityProxy
    } = this.debugger;
    this.breakPointManager = new breakpointManager_1.BreakpointManager({
      traceManager,
      callTree,
      solidityProxy,
      locationToRowConverter: sourceLocation => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const compilationResult = yield this.compilationResult();
        if (!compilationResult) return {
          start: null,
          end: null
        };
        return yield this.offsetToLineColumnConverter.offsetToLineColumn(sourceLocation, sourceLocation.file, compilationResult.source.sources, compilationResult.data.sources);
      })
    });
    this.breakPointManager.event.register('breakpointStep', step => {
      this.step_manager.jumpTo(step);
    });
    this.breakPointManager.event.register('noBreakpointHit', step => {
      this.event.trigger('noBreakpointHit', []);
    });
    this.breakPointManager.event.register('locatingBreakpoint', () => {
      this.event.trigger('locatingBreakpoint', []);
    });
    this.debugger.setBreakpointManager(this.breakPointManager);
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.event.trigger('debuggerStatus', [true]);
    });
    this.debugger.event.register('traceUnloaded', this, () => {
      this.event.trigger('debuggerStatus', [false]);
    });
  }

  registerAndHighlightCodeItem(index) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      // register selected code item, highlight the corresponding source location
      // this.debugger.traceManager.getCurrentCalledAddressAt(index, async (error, address) => {
      try {
        const address = this.debugger.traceManager.getCurrentCalledAddressAt(index);
        const compilationResultForAddress = yield this.compilationResult(address);

        if (!compilationResultForAddress) {
          this.event.trigger('newSourceLocation', [null]);
          return;
        }

        this.debugger.callTree.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, index, compilationResultForAddress.data.contracts).then(rawLocation => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
          if (compilationResultForAddress && compilationResultForAddress.data) {
            const generatedSources = this.debugger.callTree.sourceLocationTracker.getGeneratedSourcesFromAddress(address);
            const astSources = Object.assign({}, compilationResultForAddress.data.sources);
            const sources = Object.assign({}, compilationResultForAddress.source.sources);

            if (generatedSources) {
              for (const genSource of generatedSources) {
                astSources[genSource.name] = {
                  id: genSource.id,
                  ast: genSource.ast
                };
                sources[genSource.name] = {
                  content: genSource.contents
                };
              }
            }

            const lineColumnPos = yield this.offsetToLineColumnConverter.offsetToLineColumn(rawLocation, rawLocation.file, sources, astSources);
            this.event.trigger('newSourceLocation', [lineColumnPos, rawLocation, generatedSources, address]);
            this.vmDebuggerLogic.event.trigger('sourceLocationChanged', [rawLocation]);
          } else {
            this.event.trigger('newSourceLocation', [null]);
            this.vmDebuggerLogic.event.trigger('sourceLocationChanged', [null]);
          }
        })).catch(_error => {
          this.event.trigger('newSourceLocation', [null]);
          this.vmDebuggerLogic.event.trigger('sourceLocationChanged', [null]);
        }); // })
      } catch (error) {
        this.event.trigger('newSourceLocation', [null]);
        this.vmDebuggerLogic.event.trigger('sourceLocationChanged', [null]);
        return console.log(error);
      }
    });
  }

  updateWeb3(web3) {
    this.debugger.web3 = web3;
  }

  debug(blockNumber, txNumber, tx, loadingCb) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const web3 = this.debugger.web3;

      if (this.debugger.traceManager.isLoading) {
        return;
      }

      if (tx) {
        if (!tx.to) {
          tx.to = (0, traceHelper_1.contractCreationToken)('0');
        }

        return yield this.debugTx(tx, loadingCb);
      }

      if (txNumber.indexOf('0x') !== -1) {
        tx = yield web3.eth.getTransaction(txNumber);
        if (!tx) throw new Error('cannot find transaction ' + txNumber);
      } else {
        tx = yield web3.eth.getTransactionFromBlock(blockNumber, txNumber);
        if (!tx) throw new Error('cannot find transaction ' + blockNumber + ' ' + txNumber);
      }

      return yield this.debugTx(tx, loadingCb);
    });
  }

  debugTx(tx, loadingCb) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.step_manager = new stepManager_1.DebuggerStepManager(this.debugger, this.debugger.traceManager);
      this.vmDebuggerLogic = new VmDebugger_1.VmDebuggerLogic(this.debugger, tx, this.step_manager, this.debugger.traceManager, this.debugger.codeManager, this.debugger.solidityProxy, this.debugger.callTree);
      this.vmDebuggerLogic.start();
      this.step_manager.event.register('stepChanged', this, stepIndex => {
        if (typeof stepIndex !== 'number' || stepIndex >= this.step_manager.traceLength) {
          return this.event.trigger('endDebug');
        }

        this.debugger.codeManager.resolveStep(stepIndex, tx);
        this.step_manager.event.trigger('indexChanged', [stepIndex]);
        this.vmDebuggerLogic.event.trigger('indexChanged', [stepIndex]);
        this.vmDebuggerLogic.debugger.event.trigger('indexChanged', [stepIndex]);
        this.registerAndHighlightCodeItem(stepIndex);
      });
      loadingCb();
      yield this.debugger.debug(tx);
    });
  }

  unload() {
    this.debugger.unLoad();
    this.event.trigger('debuggerUnloaded');
  }

}

exports.Debugger = Debugger;

/***/ }),
/* 1520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BreakpointManager = void 0;

const tslib_1 = __webpack_require__(23);

const eventManager_1 = __webpack_require__(1157);

const traceHelper_1 = __webpack_require__(1146);
/**
  * allow to manage breakpoint
  *
  * Trigger events: breakpointHit, breakpointAdded, breakpointRemoved
  */


class BreakpointManager {
  /**
    * constructor
    *
    * @param {Object} _debugger - type of EthDebugger
    * @return {Function} _locationToRowConverter - function implemented by editor which return a column/line position for a char source location
    */
  constructor({
    traceManager,
    callTree,
    solidityProxy,
    locationToRowConverter
  }) {
    this.event = new eventManager_1.EventManager();
    this.traceManager = traceManager;
    this.callTree = callTree;
    this.solidityProxy = solidityProxy;
    this.breakpoints = {};
    this.locationToRowConverter = locationToRowConverter;
  }

  setManagers({
    traceManager,
    callTree,
    solidityProxy
  }) {
    this.traceManager = traceManager;
    this.callTree = callTree;
    this.solidityProxy = solidityProxy;
  }
  /**
    * start looking for the next breakpoint
    * @param {Bool} defaultToLimit - if true jump to the end of the trace if no more breakpoint found
    *
    */


  jumpNextBreakpoint(fromStep, defaultToLimit) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (!this.locationToRowConverter) {
        return console.log('row converter not provided');
      }

      this.jump(fromStep || 0, 1, defaultToLimit, this.traceManager.trace);
    });
  }
  /**
    * start looking for the previous breakpoint
    * @param {Bool} defaultToLimit - if true jump to the start of the trace if no more breakpoint found
    *
    */


  jumpPreviousBreakpoint(fromStep, defaultToLimit) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (!this.locationToRowConverter) {
        return console.log('row converter not provided');
      }

      this.jump(fromStep || 0, -1, defaultToLimit, this.traceManager.trace);
    });
  }

  depthChange(step, trace) {
    return trace[step].depth !== trace[step - 1].depth;
  }

  hitLine(currentStep, sourceLocation, previousSourceLocation, trace) {
    // isJumpDestInstruction -> returning from a internal function call
    // depthChange -> returning from an external call
    // sourceLocation.start <= previousSourceLocation.start && ... -> previous src is contained in the current one
    if ((0, traceHelper_1.isJumpDestInstruction)(trace[currentStep]) && previousSourceLocation.jump === 'o' || this.depthChange(currentStep, trace) || sourceLocation.start <= previousSourceLocation.start && sourceLocation.start + sourceLocation.length >= previousSourceLocation.start + previousSourceLocation.length) {
      return false;
    }

    this.event.trigger('breakpointStep', [currentStep]);
    this.event.trigger('breakpointHit', [sourceLocation, currentStep]);
    return true;
  }
  /**
    * start looking for the previous or next breakpoint
    * @param {Int} direction - 1 or -1 direction of the search
    * @param {Bool} defaultToLimit - if true jump to the limit (end if direction is 1, beginning if direction is -1) of the trace if no more breakpoint found
    *
    */


  jump(fromStep, direction, defaultToLimit, trace) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.event.trigger('locatingBreakpoint', []);
      let sourceLocation;
      let previousSourceLocation;
      let currentStep = fromStep + direction;
      let lineHadBreakpoint = false;
      let initialLine;

      while (currentStep > 0 && currentStep < trace.length) {
        try {
          previousSourceLocation = sourceLocation;
          sourceLocation = yield this.callTree.extractValidSourceLocation(currentStep);
        } catch (e) {
          console.log('cannot jump to breakpoint ' + e);
          currentStep += direction;
          continue;
        }

        const lineColumn = yield this.locationToRowConverter(sourceLocation);
        if (!initialLine) initialLine = lineColumn;

        if (initialLine.start.line !== lineColumn.start.line) {
          if (direction === -1 && lineHadBreakpoint) {
            // TODO : improve this when we will build the correct structure before hand
            lineHadBreakpoint = false;

            if (this.hitLine(currentStep + 1, previousSourceLocation, sourceLocation, trace)) {
              return;
            }
          }

          if (this.hasBreakpointAtLine(sourceLocation.file, lineColumn.start.line)) {
            lineHadBreakpoint = true;

            if (this.hitLine(currentStep, sourceLocation, previousSourceLocation, trace)) {
              return;
            }
          }
        }

        currentStep += direction;
      }

      this.event.trigger('noBreakpointHit', []);

      if (!defaultToLimit) {
        return;
      }

      if (direction === -1) {
        this.event.trigger('breakpointStep', [0]);
      } else if (direction === 1) {
        this.event.trigger('breakpointStep', [trace.length - 1]);
      }
    });
  }
  /**
    * check the given pair fileIndex/line against registered breakpoints
    *
    * @param {Int} fileIndex - index of the file content (from the compilation result)
    * @param {Int} line - line number where looking for breakpoint
    * @return {Bool} return true if the given @arg fileIndex @arg line refers to a breakpoint
    */


  hasBreakpointAtLine(fileIndex, line) {
    const filename = this.solidityProxy.fileNameFromIndex(fileIndex);

    if (!(filename && this.breakpoints[filename])) {
      return false;
    }

    const sources = this.breakpoints[filename];

    for (const k in sources) {
      const source = sources[k];

      if (line === source.row) {
        return true;
      }
    }
  }
  /**
    * return true if current manager has breakpoint
    *
    * @return {Bool} true if breapoint registered
    */


  hasBreakpoint() {
    for (const k in this.breakpoints) {
      if (this.breakpoints[k].length) {
        return true;
      }
    }

    return false;
  }
  /**
    * add a new breakpoint to the manager
    *
    * @param {Object} sourceLocation - position of the breakpoint { file: '<file index>', row: '<line number' }
    */


  add(sourceLocation) {
    sourceLocation.row -= 1;

    if (!this.breakpoints[sourceLocation.fileName]) {
      this.breakpoints[sourceLocation.fileName] = [];
    }

    this.breakpoints[sourceLocation.fileName].push(sourceLocation);
    this.event.trigger('breakpointAdded', [sourceLocation]);
  }
  /**
    * remove a breakpoint from the manager
    *
    * @param {Object} sourceLocation - position of the breakpoint { file: '<file index>', row: '<line number' }
    */


  remove(sourceLocation) {
    sourceLocation.row -= 1;
    const sources = this.breakpoints[sourceLocation.fileName];

    if (!sources) {
      return;
    }

    for (const k in sources) {
      const source = sources[k];

      if (sourceLocation.row === source.row) {
        sources.splice(k, 1);
        this.event.trigger('breakpointRemoved', [sourceLocation]);
        break;
      }
    }
  }

}

exports.BreakpointManager = BreakpointManager;

/***/ }),
/* 1521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchContractFromEtherscan = void 0;

const fetchContractFromEtherscan = async (plugin, network, contractAddress, targetPath, key) => {
  let data;
  const compilationTargets = {};
  let etherscanKey;
  if (!key) etherscanKey = await plugin.call('config', 'getAppParameter', 'etherscan-access-token');else etherscanKey = key;

  if (etherscanKey) {
    const endpoint = network.id == 1 ? 'api.etherscan.io' : 'api-' + network.name + '.etherscan.io';
    data = await fetch('https://' + endpoint + '/api?module=contract&action=getsourcecode&address=' + contractAddress + '&apikey=' + etherscanKey);
    data = await data.json(); // etherscan api doc https://docs.etherscan.io/api-endpoints/contracts

    if (data.message === 'OK' && data.status === "1") {
      if (data.result.length) {
        if (data.result[0].SourceCode === '') throw new Error(`contract not verified on Etherscan ${network.name} network`);

        if (data.result[0].SourceCode.startsWith('{')) {
          data.result[0].SourceCode = JSON.parse(data.result[0].SourceCode.replace(/(?:\r\n|\r|\n)/g, '').replace(/^{{/, '{').replace(/}}$/, '}'));
        }
      }
    } else throw new Error('unable to retrieve contract data ' + data.message);
  } else throw new Error('unable to try fetching the source code from etherscan: etherscan access token not found. please go to the Remix settings page and provide an access token.');

  if (!data || !data.result) {
    return null;
  }

  if (typeof data.result[0].SourceCode === 'string') {
    const fileName = `${targetPath}/${data.result[0].ContractName}.sol`;
    await plugin.call('fileManager', 'setFile', fileName, data.result[0].SourceCode);
    compilationTargets[fileName] = {
      content: data.result[0].SourceCode
    };
  } else if (data.result[0].SourceCode && typeof data.result[0].SourceCode == 'object') {
    const sources = data.result[0].SourceCode.sources;

    for (let [file, source] of Object.entries(sources)) {
      // eslint-disable-line
      file = file.replace('browser/', ''); // should be fixed in the remix IDE end.

      file = file.replace(/^\//g, ''); // remove first slash.

      if (await plugin.call('contentImport', 'isExternalUrl', file)) {// nothing to do, the compiler callback will handle those
      } else {
        const path = `${targetPath}/${file}`;
        const content = source.content;
        await plugin.call('fileManager', 'setFile', path, content);
        compilationTargets[path] = {
          content
        };
      }
    }
  }

  let runs = 0;

  try {
    runs = parseInt(data.result[0].Runs);
  } catch (e) {}

  const settings = {
    version: data.result[0].CompilerVersion.replace(/^v/, ''),
    language: 'Solidity',
    evmVersion: data.result[0].EVMVersion.toLowerCase(),
    optimize: data.result[0].OptimizationUsed === '1',
    runs
  };
  return {
    settings,
    compilationTargets
  };
};

exports.fetchContractFromEtherscan = fetchContractFromEtherscan;

/***/ }),
/* 1522 */,
/* 1523 */,
/* 1524 */,
/* 1525 */,
/* 1526 */,
/* 1527 */,
/* 1528 */,
/* 1529 */,
/* 1530 */,
/* 1531 */,
/* 1532 */,
/* 1533 */,
/* 1534 */,
/* 1535 */,
/* 1536 */,
/* 1537 */,
/* 1538 */,
/* 1539 */,
/* 1540 */,
/* 1541 */,
/* 1542 */,
/* 1543 */,
/* 1544 */,
/* 1545 */,
/* 1546 */,
/* 1547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extend = exports.Provider = void 0;

var provider_1 = __webpack_require__(2262);

Object.defineProperty(exports, "Provider", {
  enumerable: true,
  get: function () {
    return provider_1.Provider;
  }
});
Object.defineProperty(exports, "extend", {
  enumerable: true,
  get: function () {
    return provider_1.extend;
  }
});

/***/ }),
/* 1548 */,
/* 1549 */,
/* 1550 */,
/* 1551 */,
/* 1552 */,
/* 1553 */,
/* 1554 */,
/* 1555 */,
/* 1556 */,
/* 1557 */,
/* 1558 */,
/* 1559 */,
/* 1560 */,
/* 1561 */,
/* 1562 */,
/* 1563 */,
/* 1564 */,
/* 1565 */,
/* 1566 */,
/* 1567 */,
/* 1568 */,
/* 1569 */,
/* 1570 */,
/* 1571 */,
/* 1572 */,
/* 1573 */,
/* 1574 */,
/* 1575 */,
/* 1576 */,
/* 1577 */,
/* 1578 */,
/* 1579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addL2Network = exports.InjectedProvider = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engine = __webpack_require__(477);

var _web = _interopRequireDefault(__webpack_require__(1125));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var InjectedProvider = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(InjectedProvider, _Plugin);

  var _super = _createSuper(InjectedProvider);

  function InjectedProvider(profile) {
    var _this;

    (0, _classCallCheck2["default"])(this, InjectedProvider);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "provider", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "chainName", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "chainId", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "rpcUrls", void 0);

    if (window.ethereum) {
      _this.provider = new _web["default"](window.ethereum);
    }

    return _this;
  }

  (0, _createClass2["default"])(InjectedProvider, [{
    key: "sendAsync",
    value: function sendAsync(data) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.sendAsyncInternal(data, resolve, reject);
      });
    }
  }, {
    key: "sendAsyncInternal",
    value: function () {
      var _sendAsyncInternal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(data, resolve, reject) {
        var resultData;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.provider) {
                  _context.next = 3;
                  break;
                }

                this.call('notification', 'toast', 'No injected provider (e.g Metamask) has been found.');
                return _context.abrupt("return", reject(new Error('no injected provider found.')));

              case 3:
                _context.prev = 3;
                if (window && typeof window.ethereum.enable === 'function') window.ethereum.enable();
                _context.next = 7;
                return window.ethereum._metamask.isUnlocked();

              case 7:
                if (_context.sent) {
                  _context.next = 9;
                  break;
                }

                this.call('notification', 'toast', 'Please make sure the injected provider is unlocked (e.g Metamask).');

              case 9:
                _context.next = 11;
                return addL2Network(this.chainName, this.chainId, this.rpcUrls);

              case 11:
                _context.next = 13;
                return this.provider.currentProvider.send(data.method, data.params);

              case 13:
                resultData = _context.sent;
                resolve({
                  jsonrpc: '2.0',
                  result: resultData.result,
                  id: data.id
                });
                _context.next = 20;
                break;

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](3);
                reject(_context.t0);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 17]]);
      }));

      function sendAsyncInternal(_x, _x2, _x3) {
        return _sendAsyncInternal.apply(this, arguments);
      }

      return sendAsyncInternal;
    }()
  }]);
  return InjectedProvider;
}(_engine.Plugin);

exports.InjectedProvider = InjectedProvider;

var addL2Network = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(chainName, chainId, rpcUrls) {
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{
                chainId: chainId
              }]
            });

          case 3:
            _context2.next = 17;
            break;

          case 5:
            _context2.prev = 5;
            _context2.t0 = _context2["catch"](0);

            if (!(_context2.t0.code === 4902)) {
              _context2.next = 17;
              break;
            }

            _context2.prev = 8;
            _context2.next = 11;
            return window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [{
                chainId: chainId,
                chainName: chainName,
                rpcUrls: rpcUrls
              }]
            });

          case 11:
            _context2.next = 13;
            return window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{
                chainId: chainId
              }]
            });

          case 13:
            _context2.next = 17;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t1 = _context2["catch"](8);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 5], [8, 15]]);
  }));

  return function addL2Network(_x4, _x5, _x6) {
    return _ref.apply(this, arguments);
  };
}();

exports.addL2Network = addL2Network;

/***/ }),
/* 1580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchingInitialState = void 0;
const SearchingInitialState = {
  find: '',
  replace: '',
  include: '',
  exclude: '',
  replaceEnabled: false,
  searchResults: [],
  casesensitive: false,
  matchWord: false,
  useRegExp: false,
  replaceWithOutConfirmation: false,
  timeStamp: 0,
  count: 0,
  fileCount: 0,
  maxFiles: 5000,
  maxLines: 5000,
  clipped: false,
  undoBuffer: null,
  currentFile: '',
  workspace: '',
  searching: null,
  run: false
};
exports.SearchingInitialState = SearchingInitialState;

/***/ }),
/* 1581 */,
/* 1582 */,
/* 1583 */,
/* 1584 */,
/* 1585 */,
/* 1586 */,
/* 1587 */,
/* 1588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

/* eslint-disable @typescript-eslint/no-unused-vars,no-use-before-define */
function ModuleHeading({
  headingLabel,
  count
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("nav", {
    className: "plugins-list-header justify-content-between navbar navbar-expand-lg bg-light navbar-light align-items-center",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      className: "navbar-brand plugins-list-title h6 mb-0 mr-2",
      children: headingLabel
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      className: "badge badge-primary",
      style: {
        cursor: 'default'
      },
      "data-id": "pluginManagerComponentInactiveTilesCount",
      children: count
    })]
  });
}

var _default = ModuleHeading;
exports.default = _default;

/***/ }),
/* 1589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _solidityCompiler = __webpack_require__(2505);

Object.keys(_solidityCompiler).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _solidityCompiler[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _solidityCompiler[key];
    }
  });
});

var _logic = __webpack_require__(2515);

Object.keys(_logic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _logic[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _logic[key];
    }
  });
});

/***/ }),
/* 1590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _renderer = __webpack_require__(2512);

Object.keys(_renderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _renderer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _renderer[key];
    }
  });
});

/***/ }),
/* 1591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveCallGraphSymbol = exports.analyseCallGraph = exports.buildGlobalFuncCallGraph = void 0;

const staticAnalysisCommon_1 = __webpack_require__(1122);

function buildLocalFuncCallGraphInternal(functions, nodeFilter, extractNodeIdent, extractFuncDefIdent) {
  const callGraph = {};
  functions.forEach(func => {
    const calls = func.relevantNodes.filter(nodeFilter).map(extractNodeIdent).filter(name => name !== extractFuncDefIdent(func)); // filter self recursive call

    callGraph[extractFuncDefIdent(func)] = {
      node: func,
      calls: calls
    };
  });
  return callGraph;
}
/**
 * Builds a function call graph for the current contracts.
 * Example Contract call graph:
 *
 * {
 *  "KingOfTheEtherThrone": {
 *    "contracts": {...},                                        // Contract node as defined in abstractAstView.js
 *    "functions": {
 *      "KingOfTheEtherThrone.claimThrone(string memory)": {    // function in KingOfEtherThrone
 *        "node": {...},                                        // function node as defined in abstractAstView.js
 *        "calls": {                                            // list of full qualified function names which are called form this function
 *        }
 *      }
 *    }
 *  },
 *  "foo": {
 *    "contract": {...},           // Contract node as definded in abstractAstView.js
 *    "functions": {}             // map from full qualified function name to func node
 *  }
 * }
 *
 * @contracts {list contracts} Expects as input the contract structure defined in abstractAstView.js
 * @return {map (string -> Contract Call Graph)} returns map from contract name to contract call graph
 */


function buildGlobalFuncCallGraph(contracts) {
  const callGraph = {};
  contracts.forEach(contract => {
    const filterNodes = node => {
      return (0, staticAnalysisCommon_1.isLocalCallGraphRelevantNode)(node) || (0, staticAnalysisCommon_1.isExternalDirectCall)(node);
    };

    const getNodeIdent = node => {
      return (0, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent)(contract.node, node);
    };

    const getFunDefIdent = funcDef => {
      return (0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, funcDef.node, funcDef.parameters);
    };

    callGraph[(0, staticAnalysisCommon_1.getContractName)(contract.node)] = {
      contract: contract,
      functions: buildLocalFuncCallGraphInternal(contract.functions, filterNodes, getNodeIdent, getFunDefIdent)
    };
  });
  return callGraph;
}

exports.buildGlobalFuncCallGraph = buildGlobalFuncCallGraph;
/**
 * Walks through the call graph from a defined starting function, true if nodeCheck holds for every relevant node in the callgraph
 * @callGraph {callGraph} As returned by buildGlobalFuncCallGraph
 * @funcName {string} full qualified name of the starting function
 * @context {Object} provides additional context information that can be used by the nodeCheck function
 * @nodeCheck {(ASTNode, context) -> bool} applied on every relevant node in the call graph
 * @return {bool} returns map from contract name to contract call graph
 */

function analyseCallGraph(callGraph, funcName, context, nodeCheck) {
  return analyseCallGraphInternal(callGraph, funcName, context, (a, b) => a || b, nodeCheck, {});
}

exports.analyseCallGraph = analyseCallGraph;

function analyseCallGraphInternal(callGraph, funcName, context, combinator, nodeCheck, visited) {
  const current = resolveCallGraphSymbol(callGraph, funcName);
  if (current === undefined || visited[funcName] === true) return true;
  visited[funcName] = true;
  return combinator(current.node.relevantNodes.reduce((acc, val) => combinator(acc, nodeCheck(val, context)), false), current.calls.reduce((acc, val) => combinator(acc, analyseCallGraphInternal(callGraph, val, context, combinator, nodeCheck, visited)), false));
}

function resolveCallGraphSymbol(callGraph, funcName) {
  return resolveCallGraphSymbolInternal(callGraph, funcName, false);
}

exports.resolveCallGraphSymbol = resolveCallGraphSymbol;

function resolveCallGraphSymbolInternal(callGraph, funcName, silent) {
  let current = null;

  if (funcName.includes('.')) {
    const parts = funcName.split('.');
    const contractPart = parts[0];
    const functionPart = parts[1];
    const currentContract = callGraph[contractPart];

    if (!(currentContract === undefined)) {
      current = currentContract.functions[funcName]; // resolve inheritance hierarchy

      if (current === undefined) {
        // resolve inheritance lookup in linearized fashion
        const inheritsFromNames = currentContract.contract.inheritsFrom.reverse();

        for (let i = 0; i < inheritsFromNames.length; i++) {
          const res = resolveCallGraphSymbolInternal(callGraph, inheritsFromNames[i] + '.' + functionPart, true);
          if (!(res === undefined)) return res;
        }
      }
    } else {
      if (!silent) console.log(`static analysis functionCallGraph.js: Contract ${contractPart} not found in function call graph.`);
    }
  } else {
    throw new Error('functionCallGraph.js: function does not have full qualified name.');
  }

  if (current === undefined && !silent) console.log(`static analysis functionCallGraph.js: ${funcName} not found in function call graph.`);

  if (current !== null) {
    return current;
  }
}

/***/ }),
/* 1592 */,
/* 1593 */,
/* 1594 */,
/* 1595 */,
/* 1596 */,
/* 1597 */,
/* 1598 */,
/* 1599 */,
/* 1600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractData = extractData;

var _ethereumjsUtil = __webpack_require__(34);

// eslint-disable-line
function extractData(item, parent) {
  const ret = {};

  if (item.isProperty || !item.type) {
    return item;
  }

  try {
    if (item.type.lastIndexOf(']') === item.type.length - 1) {
      ret.children = (item.value || []).map(function (item, index) {
        return {
          key: index,
          value: item
        };
      });
      ret.children.unshift({
        key: 'length',
        value: {
          self: new _ethereumjsUtil.BN(item.length.replace('0x', ''), 16).toString(10),
          type: 'uint',
          isProperty: true
        }
      });
      ret.isArray = true;
      ret.self = parent.isArray ? '' : item.type;
      ret.cursor = item.cursor;
      ret.hasNext = item.hasNext;
    } else if (item.type.indexOf('struct') === 0) {
      ret.children = Object.keys(item.value || {}).map(function (key) {
        return {
          key: key,
          value: item.value[key]
        };
      });
      ret.self = item.type;
      ret.isStruct = true;
    } else if (item.type.indexOf('mapping') === 0) {
      ret.children = Object.keys(item.value || {}).map(function (key) {
        return {
          key: key,
          value: item.value[key]
        };
      });
      ret.isMapping = true;
      ret.self = item.type;
    } else {
      ret.children = null;
      ret.self = item.value;
      ret.type = item.type;
    }
  } catch (e) {
    console.log(e);
  }

  return ret;
}

/***/ }),
/* 1601 */,
/* 1602 */,
/* 1603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const tslib_1 = __webpack_require__(23); // Extend fs


const path_1 = (0, tslib_1.__importDefault)(__webpack_require__(1124));

const fs = __webpack_require__(1152); // eslint-disable-line
// https://github.com/mikeal/node-utils/blob/master/file/lib/main.js


fs.walkSync = function (start, callback) {
  fs.readdirSync(start).forEach(name => {
    if (name === 'node_modules') {
      return; // hack
    }

    const abspath = path_1.default.join(start, name);

    if (fs.statSync(abspath).isDirectory()) {
      fs.walkSync(abspath, callback);
    } else {
      callback(abspath);
    }
  });
};

module.exports = fs;

/***/ }),
/* 1604 */,
/* 1605 */,
/* 1606 */,
/* 1607 */,
/* 1608 */,
/* 1609 */,
/* 1610 */,
/* 1611 */,
/* 1612 */,
/* 1613 */,
/* 1614 */,
/* 1615 */,
/* 1616 */,
/* 1617 */,
/* 1618 */,
/* 1619 */,
/* 1620 */,
/* 1621 */,
/* 1622 */,
/* 1623 */,
/* 1624 */,
/* 1625 */,
/* 1626 */,
/* 1627 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilationErrors = void 0; // eslint-disable-next-line no-redeclare

class CompilationErrors extends Error {
  constructor(errors) {
    const mapError = errors.map(e => {
      return e.formattedMessage || e.message;
    });
    super(mapError.join('\n'));
    this.errors = errors;
    this.name = 'CompilationErrors';
  }

}

exports.CompilationErrors = CompilationErrors;

/***/ }),
/* 1628 */,
/* 1629 */,
/* 1630 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deployAll = void 0;

const tslib_1 = __webpack_require__(23);

const async_1 = (0, tslib_1.__importDefault)(__webpack_require__(222));

const remix_lib_1 = __webpack_require__(311);
/**
 * @dev Deploy all contracts from compilation result
 * @param compileResult compilation result
 * @param web3 web3 object
 * @param withDoubleGas If true, try deployment with gas double of estimation (used for Out-of-gas error only)
 * @param callback Callback
 */


function deployAll(compileResult, web3, testsAccounts, withDoubleGas, deployCb, callback) {
  const compiledObject = {};
  const contracts = {};
  const accounts = testsAccounts;
  async_1.default.waterfall([function getContractData(next) {
    for (const contractFile in compileResult) {
      for (const contractName in compileResult[contractFile]) {
        const contract = compileResult[contractFile][contractName];
        const className = contractName;
        const filename = contractFile;
        const abi = contract.abi;
        const code = contract.evm.bytecode.object;
        compiledObject[className] = {};
        compiledObject[className].abi = abi;
        compiledObject[className].code = code;
        compiledObject[className].filename = filename;
        compiledObject[className].className = className;
        compiledObject[className].raw = contract;

        if (contractFile.endsWith('_test.sol')) {
          compiledObject[className].isTest = true;
        }
      }
    }

    next();
  }, function determineContractsToDeploy(next) {
    const contractsToDeploy = ['Assert'];
    const allContracts = Object.keys(compiledObject);

    for (const contractName of allContracts) {
      if (contractName === 'Assert') {
        continue;
      }

      if (compiledObject[contractName].isTest) {
        contractsToDeploy.push(contractName);
      }
    }

    next(null, contractsToDeploy);
  }, function deployContracts(contractsToDeploy, next) {
    const deployRunner = (deployObject, contractObject, contractName, filename, callback) => {
      deployObject.estimateGas().then(gasValue => {
        const gasBase = Math.ceil(gasValue * 1.2);
        const gas = withDoubleGas ? gasBase * 2 : gasBase;
        deployObject.send({
          from: accounts[0],
          gas: gas
        }).on('receipt', function (receipt) {
          return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            contractObject.options.address = receipt.contractAddress;
            contractObject.options.from = accounts[0];
            contractObject.options.gas = 5000 * 1000;
            compiledObject[contractName].deployedAddress = receipt.contractAddress;
            contracts[contractName] = contractObject;
            contracts[contractName].filename = filename;
            if (deployCb) yield deployCb(filename, receipt.contractAddress);
            callback(null, {
              receipt: {
                contractAddress: receipt.contractAddress
              }
            }); // TODO this will only work with JavaScriptV VM
          });
        }).on('error', function (err) {
          console.error(err);
          callback(err);
        });
      }).catch(err => {
        console.error(err);
        callback(err);
      });
    };

    async_1.default.eachOfLimit(contractsToDeploy, 1, function (contractName, index, nextEach) {
      const contract = compiledObject[contractName];

      const encodeDataFinalCallback = (error, contractDeployData) => {
        if (error) return nextEach(error);
        const contractObject = new web3.eth.Contract(contract.abi);
        const deployObject = contractObject.deploy({
          arguments: [],
          data: '0x' + contractDeployData.dataHex
        });
        deployRunner(deployObject, contractObject, contractName, contract.filename, error => {
          nextEach(error);
        });
      };

      const encodeDataStepCallback = msg => {
        console.dir(msg);
      };

      const encodeDataDeployLibraryCallback = (libData, callback) => {
        const abi = compiledObject[libData.data.contractName].abi;
        const code = compiledObject[libData.data.contractName].code;
        const libraryObject = new web3.eth.Contract(abi);
        const deployObject = libraryObject.deploy({
          arguments: [],
          data: '0x' + code
        });
        deployRunner(deployObject, libraryObject, libData.data.contractName, contract.filename, callback);
      };

      const funAbi = null; // no need to set the abi for encoding the constructor

      const params = ''; // we suppose that the test contract does not have any param in the constructor

      remix_lib_1.execution.txFormat.encodeConstructorCallAndDeployLibraries(contractName, contract.raw, compileResult, params, funAbi, encodeDataFinalCallback, encodeDataStepCallback, encodeDataDeployLibraryCallback);
    }, function (err) {
      if (err) return next(err);
      next(null, contracts);
    });
  }], callback);
}

exports.deployAll = deployAll;

/***/ }),
/* 1631 */,
/* 1632 */,
/* 1633 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.workspaceExists = exports.uploadFile = exports.switchToWorkspace = exports.setPlugin = exports.renameWorkspaceFromProvider = exports.renameWorkspace = exports.loadWorkspacePreset = exports.getWorkspaces = exports.getRepositoryTitle = exports.fetchWorkspaceDirectory = exports.deleteWorkspace = exports.createWorkspaceTemplate = exports.createWorkspace = exports.cloneRepository = exports.addInputField = void 0;

var _ethereumjsUtil = __webpack_require__(34);

var _axios = _interopRequireDefault(__webpack_require__(1332));

var _payload = __webpack_require__(1391);

var _helper = __webpack_require__(1121);

var _remixLib = __webpack_require__(311);

var templateWithContent = _interopRequireWildcard(__webpack_require__(2790));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const LOCALHOST = ' - connect to localhost - ';
const NO_WORKSPACE = ' - none - ';
const queryParams = new _remixLib.QueryParams();

const _paq = window._paq = window._paq || []; //eslint-disable-line


let plugin, dispatch;

const setPlugin = (filePanelPlugin, reducerDispatch) => {
  plugin = filePanelPlugin;
  dispatch = reducerDispatch;
};

exports.setPlugin = setPlugin;

const addInputField = async (type, path, cb) => {
  const provider = plugin.fileManager.currentFileProvider();
  const promise = new Promise((resolve, reject) => {
    provider.resolveDirectory(path, (error, fileTree) => {
      if (error) {
        cb && cb(error);
        return reject(error);
      }

      cb && cb(null, true);
      resolve(fileTree);
    });
  });
  promise.then(files => {
    dispatch((0, _payload.addInputFieldSuccess)(path, files, type));
  }).catch(error => {
    console.error(error);
  });
  return promise;
};

exports.addInputField = addInputField;

const createWorkspace = async (workspaceName, workspaceTemplateName, isEmpty = false, cb, isGitRepo = false) => {
  await plugin.fileManager.closeAllFiles();
  const promise = createWorkspaceTemplate(workspaceName, workspaceTemplateName);
  dispatch((0, _payload.createWorkspaceRequest)(promise));
  promise.then(async () => {
    dispatch((0, _payload.createWorkspaceSuccess)({
      name: workspaceName,
      isGitRepo
    }));
    await plugin.setWorkspace({
      name: workspaceName,
      isLocalhost: false
    });
    await plugin.setWorkspaces(await getWorkspaces());
    await plugin.workspaceCreated(workspaceName);
    if (!isEmpty) await loadWorkspacePreset(workspaceTemplateName);
    cb && cb(null, workspaceName);
  }).catch(error => {
    dispatch((0, _payload.createWorkspaceError)({
      error
    }));
    cb && cb(error);
  });
  return promise;
};

exports.createWorkspace = createWorkspace;

const createWorkspaceTemplate = async (workspaceName, template = 'remixDefault') => {
  if (!workspaceName) throw new Error('workspace name cannot be empty');
  if ((0, _helper.checkSpecialChars)(workspaceName) || (0, _helper.checkSlash)(workspaceName)) throw new Error('special characters are not allowed');
  if ((await workspaceExists(workspaceName)) && template === 'remixDefault') throw new Error('workspace already exists');else {
    const workspaceProvider = plugin.fileProviders.workspace;
    await workspaceProvider.createWorkspace(workspaceName);
  }
};

exports.createWorkspaceTemplate = createWorkspaceTemplate;

const loadWorkspacePreset = async (template = 'remixDefault') => {
  const workspaceProvider = plugin.fileProviders.workspace;
  const params = queryParams.get();

  switch (template) {
    case 'code-template':
      // creates a new workspace code-sample and loads code from url params.
      try {
        let path = '';
        let content;

        if (params.code) {
          const hash = (0, _ethereumjsUtil.bufferToHex)((0, _ethereumjsUtil.keccakFromString)(params.code));
          path = 'contract-' + hash.replace('0x', '').substring(0, 10) + (params.language && params.language.toLowerCase() === 'yul' ? '.yul' : '.sol');
          content = atob(params.code);
          await workspaceProvider.set(path, content);
        }

        if (params.url) {
          const data = await plugin.call('contentImport', 'resolve', params.url);
          path = data.cleanUrl;
          content = data.content;

          try {
            content = JSON.parse(content);

            if (content.language && content.language === "Solidity" && content.sources) {
              const standardInput = content;

              for (const [fname, source] of Object.entries(standardInput.sources)) {
                await workspaceProvider.set(fname, source.content);
              }

              return Object.keys(standardInput.sources)[0];
            } else {
              await workspaceProvider.set(path, JSON.stringify(content));
            }
          } catch (e) {
            console.log(e);
            await workspaceProvider.set(path, content);
          }
        }

        return path;
      } catch (e) {
        console.error(e);
      }

      break;

    case 'gist-template':
      // creates a new workspace gist-sample and get the file from gist
      try {
        const gistId = params.gist;
        const response = await _axios.default.get(`https://api.github.com/gists/${gistId}`);
        const data = response.data;

        if (!data.files) {
          return dispatch((0, _payload.displayNotification)('Gist load error', 'No files found', 'OK', null, () => {
            dispatch((0, _payload.hideNotification)());
          }, null));
        }

        const obj = {};
        Object.keys(data.files).forEach(element => {
          const path = element.replace(/\.\.\./g, '/');
          obj['/' + 'gist-' + gistId + '/' + path] = data.files[element];
        });
        plugin.fileManager.setBatchFiles(obj, 'workspace', true, errorLoadingFile => {
          if (errorLoadingFile) {
            dispatch((0, _payload.displayNotification)('', errorLoadingFile.message || errorLoadingFile, 'OK', null, () => {}, null));
          }
        });
      } catch (e) {
        dispatch((0, _payload.displayNotification)('Gist load error', e.message, 'OK', null, () => {
          dispatch((0, _payload.hideNotification)());
        }, null));
        console.error(e);
      }

      break;

    default:
      try {
        const templateList = Object.keys(templateWithContent);
        if (!templateList.includes(template)) break;

        _paq.push(['trackEvent', 'workspace', 'template', template]); // @ts-ignore


        const files = await templateWithContent[template]();

        for (const file in files) {
          try {
            await workspaceProvider.set(file, files[file]);
          } catch (error) {
            console.error(error);
          }
        }
      } catch (e) {
        dispatch((0, _payload.displayNotification)('Workspace load error', e.message, 'OK', null, () => {
          dispatch((0, _payload.hideNotification)());
        }, null));
        console.error(e);
      }

      break;
  }
};

exports.loadWorkspacePreset = loadWorkspacePreset;

const workspaceExists = async name => {
  const workspaceProvider = plugin.fileProviders.workspace;
  const browserProvider = plugin.fileProviders.browser;
  const workspacePath = 'browser/' + workspaceProvider.workspacesPath + '/' + name;
  return await browserProvider.exists(workspacePath);
};

exports.workspaceExists = workspaceExists;

const fetchWorkspaceDirectory = async path => {
  if (!path) return;
  const provider = plugin.fileManager.currentFileProvider();
  const promise = new Promise(resolve => {
    provider.resolveDirectory(path, (error, fileTree) => {
      if (error) console.error(error);
      resolve(fileTree);
    });
  });
  dispatch((0, _payload.fetchWorkspaceDirectoryRequest)(promise));
  promise.then(fileTree => {
    dispatch((0, _payload.fetchWorkspaceDirectorySuccess)(path, fileTree));
  }).catch(error => {
    dispatch((0, _payload.fetchWorkspaceDirectoryError)({
      error
    }));
  });
  return promise;
};

exports.fetchWorkspaceDirectory = fetchWorkspaceDirectory;

const renameWorkspace = async (oldName, workspaceName, cb) => {
  await renameWorkspaceFromProvider(oldName, workspaceName);
  await dispatch((0, _payload.setRenameWorkspace)(oldName, workspaceName));
  await plugin.setWorkspace({
    name: workspaceName,
    isLocalhost: false
  });
  await plugin.workspaceRenamed(oldName, workspaceName);
  cb && cb(null, workspaceName);
};

exports.renameWorkspace = renameWorkspace;

const renameWorkspaceFromProvider = async (oldName, workspaceName) => {
  if (!workspaceName) throw new Error('name cannot be empty');
  if ((0, _helper.checkSpecialChars)(workspaceName) || (0, _helper.checkSlash)(workspaceName)) throw new Error('special characters are not allowed');
  if (await workspaceExists(workspaceName)) throw new Error('workspace already exists');
  const browserProvider = plugin.fileProviders.browser;
  const workspaceProvider = plugin.fileProviders.workspace;
  const workspacesPath = workspaceProvider.workspacesPath;
  await browserProvider.rename('browser/' + workspacesPath + '/' + oldName, 'browser/' + workspacesPath + '/' + workspaceName, true);
  await workspaceProvider.setWorkspace(workspaceName);
  await plugin.setWorkspaces(await getWorkspaces());
};

exports.renameWorkspaceFromProvider = renameWorkspaceFromProvider;

const deleteWorkspace = async (workspaceName, cb) => {
  await deleteWorkspaceFromProvider(workspaceName);
  await dispatch((0, _payload.setDeleteWorkspace)(workspaceName));
  plugin.workspaceDeleted(workspaceName);
  cb && cb(null, workspaceName);
};

exports.deleteWorkspace = deleteWorkspace;

const deleteWorkspaceFromProvider = async workspaceName => {
  const workspacesPath = plugin.fileProviders.workspace.workspacesPath;
  await plugin.fileManager.closeAllFiles();
  await plugin.fileProviders.browser.remove(workspacesPath + '/' + workspaceName);
  await plugin.setWorkspaces(await getWorkspaces());
};

const switchToWorkspace = async name => {
  await plugin.fileManager.closeAllFiles();

  if (name === LOCALHOST) {
    const isActive = await plugin.call('manager', 'isActive', 'remixd');
    if (!isActive) await plugin.call('manager', 'activatePlugin', 'remixd');
    dispatch((0, _payload.setMode)('localhost'));
    plugin.emit('setWorkspace', {
      name: null,
      isLocalhost: true
    });
  } else if (name === NO_WORKSPACE) {
    // if there is no other workspace, create remix default workspace
    plugin.call('notification', 'toast', `No workspace found! Creating default workspace ....`);
    await createWorkspace('default_workspace', 'remixDefault');
  } else {
    const isActive = await plugin.call('manager', 'isActive', 'remixd');
    if (isActive) await plugin.call('manager', 'deactivatePlugin', 'remixd');
    await plugin.fileProviders.workspace.setWorkspace(name);
    await plugin.setWorkspace({
      name,
      isLocalhost: false
    });
    const isGitRepo = await plugin.fileManager.isGitRepo();
    dispatch((0, _payload.setMode)('browser'));
    dispatch((0, _payload.setCurrentWorkspace)({
      name,
      isGitRepo
    }));
    dispatch((0, _payload.setReadOnlyMode)(false));
  }
};

exports.switchToWorkspace = switchToWorkspace;

const uploadFile = async (target, targetFolder, cb) => {
  // TODO The file explorer is merely a view on the current state of
  // the files module. Please ask the user here if they want to overwrite
  // a file and then just use `files.add`. The file explorer will
  // pick that up via the 'fileAdded' event from the files module.
  [...target.files].forEach(async file => {
    const workspaceProvider = plugin.fileProviders.workspace;

    const loadFile = name => {
      const fileReader = new FileReader();

      fileReader.onload = async function (event) {
        if ((0, _helper.checkSpecialChars)(file.name)) {
          return dispatch((0, _payload.displayNotification)('File Upload Failed', 'Special characters are not allowed', 'Close', null, async () => {}));
        }

        try {
          await workspaceProvider.set(name, event.target.result);
        } catch (error) {
          return dispatch((0, _payload.displayNotification)('File Upload Failed', 'Failed to create file ' + name, 'Close', null, async () => {}));
        }

        const config = plugin.registry.get('config').api;
        const editor = plugin.registry.get('editor').api;

        if (config.get('currentFile') === name && editor.currentContent() !== event.target.result) {
          editor.setText(event.target.result);
        }
      };

      fileReader.readAsText(file);
      cb && cb(null, true);
    };

    const name = targetFolder === '/' ? file.name : `${targetFolder}/${file.name}`;

    if (!(await workspaceProvider.exists(name))) {
      loadFile(name);
    } else {
      dispatch((0, _payload.displayNotification)('Confirm overwrite', `The file ${name} already exists! Would you like to overwrite it?`, 'OK', null, () => {
        loadFile(name);
      }, () => {}));
    }
  });
};

exports.uploadFile = uploadFile;

const getWorkspaces = async () => {
  try {
    const workspaces = await new Promise((resolve, reject) => {
      const workspacesPath = plugin.fileProviders.workspace.workspacesPath;
      plugin.fileProviders.browser.resolveDirectory('/' + workspacesPath, (error, items) => {
        if (error) {
          return reject(error);
        }

        Promise.all(Object.keys(items).filter(item => items[item].isDirectory).map(async folder => {
          const isGitRepo = await plugin.fileProviders.browser.exists('/' + folder + '/.git');
          return {
            name: folder.replace(workspacesPath + '/', ''),
            isGitRepo
          };
        })).then(workspacesList => resolve(workspacesList));
      });
    });
    await plugin.setWorkspaces(workspaces);
    return workspaces;
  } catch (e) {}
};

exports.getWorkspaces = getWorkspaces;

const cloneRepository = async url => {
  const config = plugin.registry.get('config').api;
  const token = config.get('settings/gist-access-token');
  const repoConfig = {
    url,
    token
  };

  try {
    const repoName = await getRepositoryTitle(url);
    await createWorkspace(repoName, 'blank', true, null, true);
    const promise = plugin.call('dGitProvider', 'clone', repoConfig, repoName, true);
    dispatch((0, _payload.cloneRepositoryRequest)());
    promise.then(async () => {
      const isActive = await plugin.call('manager', 'isActive', 'dgit');
      if (!isActive) await plugin.call('manager', 'activatePlugin', 'dgit');
      await fetchWorkspaceDirectory(repoName);
      dispatch((0, _payload.cloneRepositorySuccess)());
    }).catch(() => {
      const cloneModal = {
        id: 'cloneGitRepository',
        title: 'Clone Git Repository',
        message: 'An error occurred: Please check that you have the correct URL for the repo. If the repo is private, you need to add your github credentials (with the valid token permissions) in Settings plugin',
        modalType: 'modal',
        okLabel: 'OK',
        okFn: async () => {
          await deleteWorkspace(repoName);
          dispatch((0, _payload.cloneRepositoryFailed)());
        },
        hideFn: async () => {
          await deleteWorkspace(repoName);
          dispatch((0, _payload.cloneRepositoryFailed)());
        }
      };
      plugin.call('notification', 'modal', cloneModal);
    });
  } catch (e) {
    dispatch((0, _payload.displayPopUp)('An error occured: ' + e));
  }
};

exports.cloneRepository = cloneRepository;

const getRepositoryTitle = async url => {
  const urlArray = url.split('/');
  let name = urlArray.length > 0 ? urlArray[urlArray.length - 1] : '';
  if (!name) name = 'Undefined';

  let _counter;

  let exist = true;

  do {
    const isDuplicate = await workspaceExists(name + (_counter || ''));
    if (isDuplicate) _counter = (_counter || 0) + 1;else exist = false;
  } while (exist);

  const counter = _counter || '';
  return name + counter;
};

exports.getRepositoryTitle = getRepositoryTitle;

/***/ }),
/* 1634 */,
/* 1635 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _helper = __webpack_require__(1121);

var _remixLib = __webpack_require__(311);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
const typeConversion = _remixLib.execution.typeConversion;

const Context = ({
  opts,
  provider
}) => {
  const data = opts.tx || '';
  const from = opts.from ? (0, _helper.shortenHexData)(opts.from) : '';
  let to = opts.to;
  if (data.to) to = to + ' ' + (0, _helper.shortenHexData)(data.to);
  const val = data.value;
  let hash = data.hash ? (0, _helper.shortenHexData)(data.hash) : '';
  const input = data.input ? (0, _helper.shortenHexData)(data.input) : '';
  const logs = opts.logs && opts.logs.decoded && opts.logs.decoded.length ? opts.logs.decoded.length : 0;
  const block = data.receipt ? data.receipt.blockNumber : data.blockNumber || '';
  const i = data.receipt ? data.transactionIndex : data.transactionIndex;
  const value = val ? typeConversion.toInt(val) : 0;

  if (provider === 'vm') {
    return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("span", null, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_tx"
    }, "[vm]"), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "from:"), " ", from), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "to:"), " ", to), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "value:"), " ", value, " wei"), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "data:"), " ", input), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "logs:"), " ", logs), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "hash:"), " ", hash)));
  } else if (provider !== 'vm' && data.resolvedData) {
    return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("span", null, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_tx"
    }, "[block:", block, " txIndex:", i, "]"), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "from:"), " ", from), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "to:"), " ", to), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "value:"), " ", value, " wei"), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "data:"), " ", input), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "logs:"), " ", logs), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "hash:"), " ", hash)));
  } else {
    hash = (0, _helper.shortenHexData)(data.blockHash);
    return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("span", null, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_tx"
    }, "[block:", block, " txIndex:", i, "]"), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "from:"), " ", from), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "to:"), " ", to), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "value:"), " ", value, " wei"), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "data:"), " ", input), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "logs:"), " ", logs), /*#__PURE__*/_react.default.createElement("div", {
      className: "remix_ui_terminal_txItem"
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "remix_ui_terminal_txItemTitle"
    }, "hash:"), " ", hash)));
  }
};

var _default = Context;
exports.default = _default;

/***/ }),
/* 1636 */,
/* 1637 */,
/* 1638 */,
/* 1639 */,
/* 1640 */,
/* 1641 */,
/* 1642 */,
/* 1643 */,
/* 1644 */,
/* 1645 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _runTab = __webpack_require__(1646);

Object.keys(_runTab).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _runTab[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _runTab[key];
    }
  });
});

var _makeUdapp = __webpack_require__(2102);

Object.keys(_makeUdapp).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _makeUdapp[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _makeUdapp[key];
    }
  });
});

/***/ }),
/* 1646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RunTab = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _runTab = __webpack_require__(1647);

var _engineWeb = __webpack_require__(1133);

var _helper = __webpack_require__(1121);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var EventManager = __webpack_require__(1196);

var Recorder = __webpack_require__(2101);

var _paq = window._paq = window._paq || [];

var profile = {
  name: 'udapp',
  displayName: 'Deploy & run transactions',
  icon: 'assets/img/deployAndRun.webp',
  description: 'Execute, save and replay transactions',
  kind: 'udapp',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/run.html',
  version: packageJson.version,
  maintainedBy: 'Remix',
  permission: true,
  events: ['newTransaction'],
  methods: ['createVMAccount', 'sendTransaction', 'getAccounts', 'pendingTransactionsCount', 'getSettings', 'setEnvironmentMode', 'clearAllInstances', 'addInstance', 'resolveContractAndAddInstance']
};

var RunTab = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(RunTab, _ViewPlugin);

  var _super = _createSuper(RunTab);

  function RunTab(blockchain, config, fileManager, editor, filePanel, compilersArtefacts, networkModule, fileProvider) {
    var _this;

    (0, _classCallCheck2["default"])(this, RunTab);
    _this = _super.call(this, profile);
    _this.event = new EventManager();
    _this.config = config;
    _this.blockchain = blockchain;
    _this.fileManager = fileManager;
    _this.editor = editor;
    _this.filePanel = filePanel;
    _this.compilersArtefacts = compilersArtefacts;
    _this.networkModule = networkModule;
    _this.fileProvider = fileProvider;
    _this.recorder = new Recorder(blockchain);
    _this.REACT_API = {};

    _this.setupEvents();

    _this.el = document.createElement('div');
    return _this;
  }

  (0, _createClass2["default"])(RunTab, [{
    key: "setupEvents",
    value: function setupEvents() {
      var _this2 = this;

      this.blockchain.events.on('newTransaction', function (tx, receipt) {
        _this2.emit('newTransaction', tx, receipt);
      });
    }
  }, {
    key: "getSettings",
    value: function getSettings() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        resolve({
          selectedAccount: _this3.REACT_API.accounts.selectedAccount,
          selectedEnvMode: _this3.REACT_API.selectExEnv,
          networkEnvironment: _this3.REACT_API.networkName
        });
      });
    }
  }, {
    key: "setEnvironmentMode",
    value: function () {
      var _setEnvironmentMode = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(env) {
        var canCall;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.askUserPermission('setEnvironmentMode', 'change the environment used');

              case 2:
                canCall = _context.sent;

                if (canCall) {
                  env = typeof env === 'string' ? {
                    context: env
                  } : env;
                  this.emit('setEnvironmentModeReducer', env, this.currentRequest.from);
                }

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setEnvironmentMode(_x) {
        return _setEnvironmentMode.apply(this, arguments);
      }

      return setEnvironmentMode;
    }()
  }, {
    key: "clearAllInstances",
    value: function clearAllInstances() {
      this.emit('clearAllInstancesReducer');
    }
  }, {
    key: "addInstance",
    value: function addInstance(address, abi, name) {
      this.emit('addInstanceReducer', address, abi, name);
    }
  }, {
    key: "createVMAccount",
    value: function createVMAccount(newAccount) {
      return this.blockchain.createVMAccount(newAccount);
    }
  }, {
    key: "sendTransaction",
    value: function sendTransaction(tx) {
      _paq.push(['trackEvent', 'udapp', 'sendTx']);

      return this.blockchain.sendTransaction(tx);
    }
  }, {
    key: "getAccounts",
    value: function getAccounts(cb) {
      return this.blockchain.getAccounts(cb);
    }
  }, {
    key: "pendingTransactionsCount",
    value: function pendingTransactionsCount() {
      return this.blockchain.pendingTransactionsCount();
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement(_runTab.RunTabUI, {
        plugin: this
      }));
    }
  }, {
    key: "onReady",
    value: function onReady(api) {
      this.REACT_API = api;
    }
  }, {
    key: "onInitDone",
    value: function () {
      var _onInitDone = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
        var udapp;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                udapp = this; // eslint-disable-line

                _context9.next = 3;
                return this.call('blockchain', 'addProvider', {
                  name: 'Hardhat Provider',
                  isInjected: false,
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
                        var result;
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                _context2.prev = 0;
                                _context2.next = 3;
                                return udapp.call('hardhat-provider', 'sendAsync', payload);

                              case 3:
                                result = _context2.sent;
                                callback(null, result);
                                _context2.next = 10;
                                break;

                              case 7:
                                _context2.prev = 7;
                                _context2.t0 = _context2["catch"](0);
                                callback(_context2.t0);

                              case 10:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 3:
                _context9.next = 5;
                return this.call('blockchain', 'addProvider', {
                  name: 'Ganache Provider',
                  isInjected: false,
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
                        var result;
                        return _regenerator["default"].wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                _context3.prev = 0;
                                _context3.next = 3;
                                return udapp.call('ganache-provider', 'sendAsync', payload);

                              case 3:
                                result = _context3.sent;
                                callback(null, result);
                                _context3.next = 10;
                                break;

                              case 7:
                                _context3.prev = 7;
                                _context3.t0 = _context3["catch"](0);
                                callback(_context3.t0);

                              case 10:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 5:
                _context9.next = 7;
                return this.call('blockchain', 'addProvider', {
                  name: 'Foundry Provider',
                  isInjected: false,
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
                        var result;
                        return _regenerator["default"].wrap(function _callee4$(_context4) {
                          while (1) {
                            switch (_context4.prev = _context4.next) {
                              case 0:
                                _context4.prev = 0;
                                _context4.next = 3;
                                return udapp.call('foundry-provider', 'sendAsync', payload);

                              case 3:
                                result = _context4.sent;
                                callback(null, result);
                                _context4.next = 10;
                                break;

                              case 7:
                                _context4.prev = 7;
                                _context4.t0 = _context4["catch"](0);
                                callback(_context4.t0);

                              case 10:
                              case "end":
                                return _context4.stop();
                            }
                          }
                        }, _callee4, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 7:
                _context9.next = 9;
                return this.call('blockchain', 'addProvider', {
                  name: 'Wallet Connect',
                  isInjected: false,
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
                        var result;
                        return _regenerator["default"].wrap(function _callee5$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                                _context5.prev = 0;
                                _context5.next = 3;
                                return udapp.call('walletconnect', 'sendAsync', payload);

                              case 3:
                                result = _context5.sent;
                                callback(null, result);
                                _context5.next = 10;
                                break;

                              case 7:
                                _context5.prev = 7;
                                _context5.t0 = _context5["catch"](0);
                                callback(_context5.t0);

                              case 10:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee5, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 9:
                _context9.next = 11;
                return this.call('blockchain', 'addProvider', {
                  name: 'External Http Provider',
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
                        var result;
                        return _regenerator["default"].wrap(function _callee6$(_context6) {
                          while (1) {
                            switch (_context6.prev = _context6.next) {
                              case 0:
                                _context6.prev = 0;
                                _context6.next = 3;
                                return udapp.call('basic-http-provider', 'sendAsync', payload);

                              case 3:
                                result = _context6.sent;
                                callback(null, result);
                                _context6.next = 10;
                                break;

                              case 7:
                                _context6.prev = 7;
                                _context6.t0 = _context6["catch"](0);
                                callback(_context6.t0);

                              case 10:
                              case "end":
                                return _context6.stop();
                            }
                          }
                        }, _callee6, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 11:
                _context9.next = 13;
                return this.call('blockchain', 'addProvider', {
                  name: 'Optimism Provider',
                  isInjected: true,
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
                        var result;
                        return _regenerator["default"].wrap(function _callee7$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                _context7.prev = 0;
                                _context7.next = 3;
                                return udapp.call('injected-optimism-provider', 'sendAsync', payload);

                              case 3:
                                result = _context7.sent;
                                callback(null, result);
                                _context7.next = 10;
                                break;

                              case 7:
                                _context7.prev = 7;
                                _context7.t0 = _context7["catch"](0);
                                callback(_context7.t0);

                              case 10:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee7, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 13:
                _context9.next = 15;
                return this.call('blockchain', 'addProvider', {
                  name: 'Arbitrum One Provider',
                  isInjected: true,
                  provider: {
                    sendAsync: function sendAsync(payload, callback) {
                      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
                        var result;
                        return _regenerator["default"].wrap(function _callee8$(_context8) {
                          while (1) {
                            switch (_context8.prev = _context8.next) {
                              case 0:
                                _context8.prev = 0;
                                _context8.next = 3;
                                return udapp.call('injected-arbitrum-one-provider', 'sendAsync', payload);

                              case 3:
                                result = _context8.sent;
                                callback(null, result);
                                _context8.next = 10;
                                break;

                              case 7:
                                _context8.prev = 7;
                                _context8.t0 = _context8["catch"](0);
                                callback(_context8.t0);

                              case 10:
                              case "end":
                                return _context8.stop();
                            }
                          }
                        }, _callee8, null, [[0, 7]]);
                      }))();
                    }
                  }
                });

              case 15:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function onInitDone() {
        return _onInitDone.apply(this, arguments);
      }

      return onInitDone;
    }()
  }, {
    key: "writeFile",
    value: function writeFile(fileName, content) {
      return this.call('fileManager', 'writeFile', fileName, content);
    }
  }, {
    key: "readFile",
    value: function readFile(fileName) {
      return this.call('fileManager', 'readFile', fileName);
    }
  }, {
    key: "resolveContractAndAddInstance",
    value: function resolveContractAndAddInstance(contractObject, address) {
      var data = this.compilersArtefacts.getCompilerAbstract(contractObject.contract.file);
      this.compilersArtefacts.addResolvedContract((0, _helper.addressToString)(address), data);
      this.addInstance(address, contractObject.abi, contractObject.name);
    }
  }]);
  return RunTab;
}(_engineWeb.ViewPlugin);

exports.RunTab = RunTab;

/***/ }),
/* 1647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _runTab = __webpack_require__(1648);

Object.keys(_runTab).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _runTab[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _runTab[key];
    }
  });
});

/***/ }),
/* 1648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RunTabUI = RunTabUI;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _modalDialog = __webpack_require__(316);

var _toaster = __webpack_require__(479);

var _contractDropdownUI = __webpack_require__(1649);

var _instanceContainerUI = __webpack_require__(1660);

var _recorderCardUI = __webpack_require__(1668);

var _settingsUI = __webpack_require__(1669);

var _runTab = __webpack_require__(1675);

var _actions = __webpack_require__(1676);

__webpack_require__(1832);

var _publishToStorage = __webpack_require__(1440);

var _passphrase = __webpack_require__(1400);

var _mainnet = __webpack_require__(2092);

var _scenario = __webpack_require__(2093);

var _payload = __webpack_require__(1188);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RunTabUI(props) {
  const {
    plugin
  } = props;
  const [focusModal, setFocusModal] = (0, _react.useState)({
    hide: true,
    title: '',
    message: '',
    okLabel: '',
    okFn: () => {},
    cancelLabel: '',
    cancelFn: () => {}
  });
  const [modals, setModals] = (0, _react.useState)([]);
  const [focusToaster, setFocusToaster] = (0, _react.useState)('');
  const [toasters, setToasters] = (0, _react.useState)([]);
  const [publishData, setPublishData] = (0, _react.useState)({
    storage: null,
    contract: null
  });
  _runTab.runTabInitialState.selectExEnv = plugin.blockchain.getProvider();
  _runTab.runTabInitialState.selectExEnv = _runTab.runTabInitialState.selectExEnv === 'vm' ? 'vm-london' : _runTab.runTabInitialState.selectExEnv;
  const [runTab, dispatch] = (0, _react.useReducer)(_runTab.runTabReducer, _runTab.runTabInitialState);
  const REACT_API = {
    runTab
  };
  const currentfile = plugin.config.get('currentFile');
  (0, _react.useEffect)(() => {
    (0, _actions.initRunTab)(plugin)(dispatch);
    plugin.onInitDone();
  }, [plugin]);
  (0, _react.useEffect)(() => {
    plugin.onReady(runTab);
  }, [REACT_API]);
  (0, _react.useEffect)(() => {
    if (modals.length > 0) {
      setFocusModal(() => {
        const focusModal = {
          hide: false,
          title: modals[0].title,
          message: modals[0].message,
          okLabel: modals[0].okLabel,
          okFn: modals[0].okFn,
          cancelLabel: modals[0].cancelLabel,
          cancelFn: modals[0].cancelFn
        };
        return focusModal;
      });
      const modalList = modals.slice();
      modalList.shift();
      setModals(modalList);
    }
  }, [modals]);
  (0, _react.useEffect)(() => {
    if (runTab.notification.title) {
      modal(runTab.notification.title, runTab.notification.message, runTab.notification.labelOk, runTab.notification.actionOk, runTab.notification.labelCancel, runTab.notification.actionCancel);
    }
  }, [runTab.notification]);
  (0, _react.useEffect)(() => {
    if (toasters.length > 0) {
      setFocusToaster(() => {
        return toasters[0];
      });
      const toasterList = toasters.slice();
      toasterList.shift();
      setToasters(toasterList);
    }
  }, [toasters]);
  (0, _react.useEffect)(() => {
    if (runTab.popup) {
      toast(runTab.popup);
    }
  }, [runTab.popup]);

  const setCheckIpfs = value => {
    dispatch((0, _payload.setIpfsCheckedState)(value));
  };

  const modal = (title, message, okLabel, okFn, cancelLabel, cancelFn) => {
    setModals(modals => {
      modals.push({
        message,
        title,
        okLabel,
        okFn,
        cancelLabel,
        cancelFn
      });
      return [...modals];
    });
  };

  const handleHideModal = () => {
    setFocusModal(modal => {
      return _objectSpread(_objectSpread({}, modal), {}, {
        hide: true,
        message: null
      });
    });
  };

  const handleToaster = () => {
    setFocusToaster('');
    (0, _actions.hideToaster)();
  };

  const toast = toasterMsg => {
    setToasters(messages => {
      messages.push(toasterMsg);
      return [...messages];
    });
  };

  const resetStorage = () => {
    setPublishData({
      storage: null,
      contract: null
    });
  };

  const publishToStorage = (storage, contract) => {
    setPublishData({
      storage,
      contract
    });
  };

  const gasEstimationPrompt = msg => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: ["Gas estimation errored with the following message (see below). The transaction execution will likely fail. Do you want to force sending? ", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), msg]
    });
  };

  const passphrasePrompt = message => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_passphrase.PassphrasePrompt, {
      message: message,
      setPassphrase: _actions.setPassphraseModal,
      defaultValue: runTab.passphrase
    });
  };

  const scenarioPrompt = (message, defaultValue) => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_scenario.ScenarioPrompt, {
      message: message,
      setScenarioPath: _actions.setScenarioPath,
      defaultValue: defaultValue
    });
  };

  const mainnetPrompt = (tx, network, amount, gasEstimation, gasFees, determineGasPrice) => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_mainnet.MainnetPrompt, {
      init: determineGasPrice,
      network: network,
      tx: tx,
      amount: amount,
      gasEstimation: gasEstimation,
      setNewGasPrice: gasFees,
      updateBaseFeePerGas: _actions.setBaseFeePerGas,
      updateConfirmSettings: _actions.setConfirmSettings,
      updateGasPrice: _actions.setGasPrice,
      updateGasPriceStatus: _actions.setGasPriceStatus,
      updateMaxFee: _actions.setMaxFee,
      updateMaxPriorityFee: _actions.setMaxPriorityFee,
      setTxFeeContent: _actions.setTxFeeContent,
      txFeeContent: runTab.txFeeContent,
      maxFee: runTab.maxFee,
      maxPriorityFee: runTab.maxPriorityFee
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "udapp_runTabView run-tab",
      id: "runTabView",
      "data-id": "runTabView",
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "list-group list-group-flush",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_settingsUI.SettingsUI, {
          networkName: runTab.networkName,
          personalMode: runTab.personalMode,
          selectExEnv: runTab.selectExEnv,
          accounts: runTab.accounts,
          setAccount: _actions.setAccountAddress,
          setUnit: _actions.setUnitValue,
          sendValue: runTab.sendValue,
          setSendValue: _actions.setSendValue,
          sendUnit: runTab.sendUnit,
          gasLimit: runTab.gasLimit,
          setGasFee: _actions.setGasFeeAmount,
          providers: runTab.providers,
          setExecutionContext: _actions.setExecutionEnvironment,
          createNewBlockchainAccount: _actions.createNewAddress,
          setPassphrase: _actions.setPassphraseModal,
          setMatchPassphrase: _actions.setMatchPassphraseModal,
          modal: modal,
          tooltip: toast,
          signMessageWithAddress: _actions.signMessage,
          passphrase: runTab.passphrase
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_contractDropdownUI.ContractDropdownUI, {
          exEnvironment: runTab.selectExEnv,
          contracts: runTab.contracts,
          getSelectedContract: _actions.fetchSelectedContract,
          modal: modal,
          passphrase: runTab.passphrase,
          setPassphrase: _actions.setPassphraseModal,
          createInstance: _actions.createNewInstance,
          ipfsCheckedState: runTab.ipfsChecked,
          setIpfsCheckedState: setCheckIpfs,
          publishToStorage: publishToStorage,
          gasEstimationPrompt: gasEstimationPrompt,
          passphrasePrompt: passphrasePrompt,
          mainnetPrompt: mainnetPrompt,
          tooltip: toast,
          loadAddress: _actions.loadFromAddress,
          networkName: runTab.networkName,
          setNetworkName: _actions.setNetworkName,
          setSelectedContract: _actions.updateSelectedContract
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_recorderCardUI.RecorderUI, {
          gasEstimationPrompt: gasEstimationPrompt,
          passphrasePrompt: passphrasePrompt,
          mainnetPrompt: mainnetPrompt,
          storeScenario: _actions.storeNewScenario,
          runCurrentScenario: _actions.runScenario,
          scenarioPrompt: scenarioPrompt,
          count: runTab.recorder.transactionCount,
          currentFile: currentfile
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_instanceContainerUI.InstanceContainerUI, {
          instances: runTab.instances,
          clearInstances: _actions.removeInstances,
          removeInstance: _actions.removeSingleInstance,
          getContext: _actions.getExecutionContext,
          gasEstimationPrompt: gasEstimationPrompt,
          passphrasePrompt: passphrasePrompt,
          mainnetPrompt: mainnetPrompt,
          runTransactions: _actions.executeTransactions,
          sendValue: runTab.sendValue,
          getFuncABIInputs: _actions.getFuncABIValues
        })]
      })
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_modalDialog.ModalDialog, _objectSpread(_objectSpread({
      id: "udappNotify"
    }, focusModal), {}, {
      handleHide: handleHideModal
    })), /*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: focusToaster,
      handleHide: handleToaster
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_publishToStorage.PublishToStorage, {
      id: "udapp",
      api: plugin,
      resetStorage: resetStorage,
      storage: publishData.storage,
      contract: publishData.contract
    })]
  });
}

/***/ }),
/* 1649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContractDropdownUI = ContractDropdownUI;

var _react = _interopRequireWildcard(__webpack_require__(29));

var ethJSUtil = _interopRequireWildcard(__webpack_require__(34));

var _contractGUI = __webpack_require__(1399);

var _helper = __webpack_require__(1121);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
function ContractDropdownUI(props) {
  const [abiLabel, setAbiLabel] = (0, _react.useState)({
    display: '',
    content: ''
  });
  const [atAddressOptions, setAtAddressOptions] = (0, _react.useState)({
    title: 'address of contract',
    disabled: true
  });
  const [loadedAddress, setLoadedAddress] = (0, _react.useState)('');
  const [contractOptions, setContractOptions] = (0, _react.useState)({
    title: 'Please compile *.sol file to deploy or access a contract',
    disabled: true
  });
  const [compFails, setCompFails] = (0, _react.useState)('none');
  const [loadedContractData, setLoadedContractData] = (0, _react.useState)(null);
  const [constructorInterface, setConstructorInterface] = (0, _react.useState)(null);
  const [constructorInputs, setConstructorInputs] = (0, _react.useState)(null);
  const contractsRef = (0, _react.useRef)(null);
  const {
    contractList,
    loadType,
    currentFile,
    currentContract,
    compilationCount,
    deployOptions,
    proxyKey
  } = props.contracts;
  (0, _react.useEffect)(() => {
    enableAtAddress(false);
    setAbiLabel({
      display: 'none',
      content: 'ABI file selected'
    });
  }, []);
  (0, _react.useEffect)(() => {
    if (props.exEnvironment && props.networkName) {
      const savedConfig = window.localStorage.getItem(`ipfs/${props.exEnvironment}/${props.networkName}`);
      const isCheckedIPFS = savedConfig === 'true' ? true : false; // eslint-disable-line

      props.setIpfsCheckedState(isCheckedIPFS);
    }
  }, [props.exEnvironment, props.networkName]);
  (0, _react.useEffect)(() => {
    if (!loadFromAddress || !ethJSUtil.isValidAddress(loadedAddress)) enableAtAddress(false);
  }, [loadedAddress]);
  (0, _react.useEffect)(() => {
    if (/.(.abi)$/.exec(currentFile)) {
      setAbiLabel({
        display: 'block',
        content: currentFile
      });
      enableAtAddress(true);
    } else if (isContractFile(currentFile)) {
      setAbiLabel({
        display: 'none',
        content: ''
      });
      if (!currentContract) enableAtAddress(false);
    } else {
      setAbiLabel({
        display: 'none',
        content: ''
      });
      if (!currentContract) enableAtAddress(false);
    }

    if (currentFile) {
      enableContractNames(true);
      setCompFails('none');
    } else {
      enableContractNames(false);
      setCompFails('block');
    }

    initSelectedContract();
  }, [loadType, currentFile, compilationCount]);
  (0, _react.useEffect)(() => {
    if (currentContract && contractList[currentFile]) {
      const contract = contractList[currentFile].find(contract => contract.alias === currentContract);

      if (contract) {
        const loadedContractData = props.getSelectedContract(currentContract, contract.compiler);

        if (loadedContractData) {
          setLoadedContractData(loadedContractData);
          setConstructorInterface(loadedContractData.getConstructorInterface());
          setConstructorInputs(loadedContractData.getConstructorInputs());
        }
      }
    }
  }, [currentContract, compilationCount]);
  (0, _react.useEffect)(() => {
    initSelectedContract();
  }, [contractList]);

  const initSelectedContract = () => {
    const contracts = contractList[currentFile];

    if (contracts && contracts.length > 0) {
      const contract = contracts.find(contract => contract.alias === currentContract);
      if (!currentContract) props.setSelectedContract(contracts[0].alias);else if (!contract) props.setSelectedContract(currentContract); // TODO highlight contractlist box with css.
    }
  };

  const isContractFile = file => {
    return /.(.sol)$/.exec(file) || /.(.vy)$/.exec(file) || // vyper
    /.(.lex)$/.exec(file) || // lexon
    /.(.contract)$/.exec(file);
  };

  const enableAtAddress = enable => {
    if (enable) {
      setAtAddressOptions({
        disabled: false,
        title: 'Interact with the deployed contract - requires the .abi file or compiled .sol file to be selected in the editor (with the same compiler configuration)'
      });
    } else {
      setAtAddressOptions({
        disabled: true,
        title: loadedAddress ? 'Compile a *.sol file or select a *.abi file.' : 'To interact with a deployed contract, enter its address and compile its source *.sol file (with the same compiler settings) or select its .abi file in the editor. '
      });
    }
  };

  const enableContractNames = enable => {
    if (enable) {
      setContractOptions({
        disabled: false,
        title: 'Select a compiled contract to deploy or to use with At Address.'
      });
    } else {
      setContractOptions({
        disabled: true,
        title: loadType === 'sol' ? 'Select and compile *.sol file to deploy or access a contract.' : 'When there is a compiled .sol file, the choice of contracts to deploy or to use with AtAddress is made here.'
      });
    }
  };

  const clickCallback = (inputs, value, deployMode) => {
    createInstance(loadedContractData, value, deployMode);
  };

  const createInstance = (selectedContract, args, deployMode) => {
    if (selectedContract.bytecodeObject.length === 0) {
      return props.modal('Alert', 'This contract may be abstract, it may not implement an abstract parent\'s methods completely or it may not invoke an inherited contract\'s constructor correctly.', 'OK', () => {});
    }

    if (selectedContract.name !== currentContract && selectedContract.name === 'ERC1967Proxy') selectedContract.name = currentContract;
    const isProxyDeployment = (deployMode || []).find(mode => mode === 'Deploy with Proxy');
    const isContractUpgrade = (deployMode || []).find(mode => mode === 'Upgrade with Proxy');

    if (isProxyDeployment) {
      props.modal('Deploy Implementation & Proxy (ERC1967)', (0, _helper.deployWithProxyMsg)(), 'Proceed', () => {
        props.createInstance(loadedContractData, props.gasEstimationPrompt, props.passphrasePrompt, props.publishToStorage, props.mainnetPrompt, isOverSizePrompt, args, deployMode);
      }, 'Cancel', () => {});
    } else if (isContractUpgrade) {
      props.modal('Deploy Implementation & Update Proxy', (0, _helper.upgradeWithProxyMsg)(), 'Proceed', () => {
        props.createInstance(loadedContractData, props.gasEstimationPrompt, props.passphrasePrompt, props.publishToStorage, props.mainnetPrompt, isOverSizePrompt, args, deployMode);
      }, 'Cancel', () => {});
    } else {
      props.createInstance(loadedContractData, props.gasEstimationPrompt, props.passphrasePrompt, props.publishToStorage, props.mainnetPrompt, isOverSizePrompt, args, deployMode);
    }
  };

  const atAddressChanged = event => {
    const value = event.target.value;

    if (!value) {
      enableAtAddress(false);
    } else {
      if (loadType === 'sol' || loadType === 'abi') {
        enableAtAddress(true);
      } else {
        enableAtAddress(false);
      }
    }

    setLoadedAddress(value);
  };

  const loadFromAddress = () => {
    let address = loadedAddress;

    if (!ethJSUtil.isValidChecksumAddress(address)) {
      props.tooltip(checkSumWarning());
      address = ethJSUtil.toChecksumAddress(address);
    }

    props.loadAddress(loadedContractData, address);
  };

  const handleCheckedIPFS = () => {
    const checkedState = !props.ipfsCheckedState;
    props.setIpfsCheckedState(checkedState);
    window.localStorage.setItem(`ipfs/${props.exEnvironment}/${props.networkName}`, checkedState.toString());
  };

  const handleContractChange = e => {
    const value = e.target.value;
    props.setSelectedContract(value);
  };

  const checkSumWarning = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
      children: ["It seems you are not using a checksumed address.", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "A checksummed address is an address that contains uppercase letters, as specified in ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        href: "https://eips.ethereum.org/EIPS/eip-55",
        target: "_blank",
        rel: "noreferrer",
        children: "EIP-55"
      }), ".", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "Checksummed addresses are meant to help prevent users from sending transactions to the wrong address."]
    });
  };

  const isOverSizePrompt = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: ["Contract creation initialization returns data with length of more than 24576 bytes. The deployment will likely fails. ", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "More info: ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        href: "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md",
        target: "_blank",
        rel: "noreferrer",
        children: "eip-170"
      })]
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_container",
    "data-id": "contractDropdownContainer",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
      className: "udapp_settingsLabel",
      children: "Contract"
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_subcontainer",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("select", {
        ref: contractsRef,
        value: currentContract,
        onChange: handleContractChange,
        className: "udapp_contractNames custom-select",
        disabled: contractOptions.disabled,
        title: contractOptions.title,
        style: {
          display: loadType === 'abi' && !isContractFile(currentFile) ? 'none' : 'block'
        },
        children: (contractList[currentFile] || []).map((contract, index) => {
          return /*#__PURE__*/(0, _jsxRuntime.jsxs)("option", {
            value: contract.alias,
            children: [contract.alias, " - ", contract.file]
          }, index);
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "py-1",
        style: {
          display: abiLabel.display
        },
        children: abiLabel.content
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "udapp_deployDropdown",
        children: (contractList[currentFile] && contractList[currentFile].filter(contract => contract) || []).length <= 0 ? 'No compiled contracts' : loadedContractData ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_contractGUI.ContractGUI, {
            title: "Deploy",
            isDeploy: true,
            deployOption: deployOptions[currentFile] && deployOptions[currentFile][currentContract] ? deployOptions[currentFile][currentContract].options : null,
            initializerOptions: deployOptions[currentFile] && deployOptions[currentFile][currentContract] ? deployOptions[currentFile][currentContract].initializeOptions : null,
            funcABI: constructorInterface,
            clickCallBack: clickCallback,
            inputs: constructorInputs,
            widthClass: "w-50",
            evmBC: loadedContractData.bytecodeObject,
            lookupOnly: false,
            savedProxyAddress: proxyKey
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex py-1 align-items-center custom-control custom-checkbox",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              id: "deployAndRunPublishToIPFS",
              "data-id": "contractDropdownIpfsCheckbox",
              className: "form-check-input custom-control-input",
              type: "checkbox",
              onChange: handleCheckedIPFS,
              checked: props.ipfsCheckedState
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              htmlFor: "deployAndRunPublishToIPFS",
              "data-id": "contractDropdownIpfsCheckboxLabel",
              className: "m-0 form-check-label custom-control-label udapp_checkboxAlign",
              title: "Publishing the source code and metadata to IPFS facilitates source code verification using Sourcify and will greatly foster contract adoption (auditing, debugging, calling it, etc...)",
              children: "Publish to IPFS"
            })]
          })]
        }) : ''
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "udapp_orLabel mt-2",
        style: {
          display: loadType === 'abi' && !isContractFile(currentFile) ? 'none' : 'block'
        },
        children: "or"
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "udapp_button udapp_atAddressSect",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
          className: "udapp_atAddress btn btn-sm btn-info",
          id: "runAndDeployAtAdressButton",
          disabled: atAddressOptions.disabled,
          title: atAddressOptions.title,
          onClick: loadFromAddress,
          children: "At Address"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          className: "udapp_input udapp_ataddressinput ataddressinput form-control",
          placeholder: "Load contract from Address",
          title: "address of contract",
          onChange: atAddressChanged
        })]
      })]
    })]
  });
}

/***/ }),
/* 1650 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CopyToClipboard = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(1227));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _copyToClipboard = _interopRequireDefault(__webpack_require__(1651));

var _reactBootstrap = __webpack_require__(1209);

__webpack_require__(1654);

var _jsxRuntime = __webpack_require__(46);

const _excluded = ["tip", "icon", "direction", "getContent", "children"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const CopyToClipboard = props => {
  const {
    tip = 'Copy',
    icon = 'fa-copy',
    direction = 'right',
    getContent,
    children
  } = props,
        otherProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  let {
    content
  } = props;
  const [message, setMessage] = (0, _react.useState)(tip);

  const copyData = () => {
    try {
      if (content === '') {
        setMessage('Cannot copy empty content!');
        return;
      }

      if (typeof content !== 'string') {
        content = JSON.stringify(content, null, '\t');
      }

      (0, _copyToClipboard.default)(content);
      setMessage('Copied');
    } catch (e) {
      console.error(e);
    }
  };

  const handleClick = e => {
    if (content) {
      // module `copy` keeps last copied thing in the memory, so don't show tooltip if nothing is copied, because nothing was added to memory
      copyData();
    } else {
      content = getContent && getContent();
      copyData();
    }

    e.preventDefault();
  };

  const reset = () => {
    setTimeout(() => setMessage(tip), 500);
  };

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-is-valid
    (0, _jsxRuntime.jsx)("a", {
      href: "#",
      onClick: handleClick,
      onMouseLeave: reset,
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
        placement: direction,
        overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
          id: "overlay-tooltip",
          children: message
        }),
        children: children || /*#__PURE__*/(0, _jsxRuntime.jsx)("i", _objectSpread({
          className: `far ${icon} ml-1 p-2`,
          "aria-hidden": "true"
        }, otherProps))
      })
    })
  );
};

exports.CopyToClipboard = CopyToClipboard;
var _default = CopyToClipboard;
exports.default = _default;

/***/ }),
/* 1651 */,
/* 1652 */,
/* 1653 */,
/* 1654 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(1655);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 1655 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".copyIcon {\n    margin-left: 5px;\n    cursor: pointer;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvcHktdG8tY2xpcGJvYXJkLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLGdCQUFnQjtJQUNoQixlQUFlO0FBQ25CIiwiZmlsZSI6ImNvcHktdG8tY2xpcGJvYXJkLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5jb3B5SWNvbiB7XG4gICAgbWFyZ2luLWxlZnQ6IDVweDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG59Il19 */", '', '']]

/***/ }),
/* 1656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shortenHexData = exports.shortenAddress = exports.joinPath = exports.isValidHash = exports.isNumeric = exports.isHexadecimal = exports.is0XPrefixed = exports.getPathIcon = exports.extractParentFromKey = exports.extractNameFromKey = exports.createNonClashingTitle = exports.createNonClashingNameAsync = exports.checkSpecialChars = exports.checkSlash = exports.addressToString = void 0;

var ethJSUtil = _interopRequireWildcard(__webpack_require__(34));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const extractNameFromKey = key => {
  if (!key) return;
  const keyPath = key.split('/');
  return keyPath[keyPath.length - 1];
};

exports.extractNameFromKey = extractNameFromKey;

const extractParentFromKey = key => {
  if (!key) return;
  const keyPath = key.split('/');
  keyPath.pop();
  return keyPath.join('/');
};

exports.extractParentFromKey = extractParentFromKey;

const checkSpecialChars = name => {
  return name.match(/[:*?"<>\\'|]/) != null;
};

exports.checkSpecialChars = checkSpecialChars;

const checkSlash = name => {
  return name.match(/\//) != null;
};

exports.checkSlash = checkSlash;

const createNonClashingNameAsync = async (name, fileManager, prefix = '') => {
  if (!name) name = 'Undefined';

  let _counter;

  let ext = 'sol';
  const reg = /(.*)\.([^.]+)/g;
  const split = reg.exec(name);

  if (split) {
    name = split[1];
    ext = split[2];
  }

  let exist = true;

  do {
    const isDuplicate = await fileManager.exists(name + (_counter || '') + prefix + '.' + ext);
    if (isDuplicate) _counter = (_counter || 0) + 1;else exist = false;
  } while (exist);

  const counter = _counter || '';
  return name + counter + prefix + '.' + ext;
};

exports.createNonClashingNameAsync = createNonClashingNameAsync;

const createNonClashingTitle = async (name, fileManager) => {
  if (!name) name = 'Undefined';

  let _counter;

  let exist = true;

  do {
    const isDuplicate = await fileManager.exists(name + (_counter || ''));
    if (isDuplicate) _counter = (_counter || 0) + 1;else exist = false;
  } while (exist);

  const counter = _counter || '';
  return name + counter;
};

exports.createNonClashingTitle = createNonClashingTitle;

const joinPath = (...paths) => {
  paths = paths.filter(value => value !== '').map(path => path.replace(/^\/|\/$/g, '')); // remove first and last slash)

  if (paths.length === 1) return paths[0];
  return paths.join('/');
};

exports.joinPath = joinPath;

const getPathIcon = path => {
  return path.endsWith('.txt') ? 'far fa-file-alt' : path.endsWith('.md') ? 'fab fa-markdown' : path.endsWith('.sol') ? 'fak fa-solidity-mono' : path.endsWith('.js') ? 'fab fa-js' : path.endsWith('.json') ? 'small fas fa-brackets-curly' : path.endsWith('.vy') ? 'small fak fa-vyper2' : path.endsWith('.lex') ? 'fak fa-lexon' : path.endsWith('ts') ? 'small fak fa-ts-logo' : path.endsWith('.tsc') ? 'fad fa-brackets-curly' : path.endsWith('.cairo') ? 'small fak fa-cairo' : 'far fa-file';
};

exports.getPathIcon = getPathIcon;

const isNumeric = value => {
  return /^\+?(0|[1-9]\d*)$/.test(value);
};

exports.isNumeric = isNumeric;

const shortenAddress = (address, etherBalance) => {
  const len = address.length;
  return address.slice(0, 5) + '...' + address.slice(len - 5, len) + (etherBalance ? ' (' + etherBalance.toString() + ' ether)' : '');
};

exports.shortenAddress = shortenAddress;

const addressToString = address => {
  if (!address) return null;

  if (typeof address !== 'string') {
    address = address.toString('hex');
  }

  if (address.indexOf('0x') === -1) {
    address = '0x' + address;
  }

  return ethJSUtil.toChecksumAddress(address);
};

exports.addressToString = addressToString;

const is0XPrefixed = value => {
  return value.substr(0, 2) === '0x';
};

exports.is0XPrefixed = is0XPrefixed;

const isHexadecimal = value => {
  return /^[0-9a-fA-F]+$/.test(value) && value.length % 2 === 0;
};

exports.isHexadecimal = isHexadecimal;

const isValidHash = hash => {
  // 0x prefixed, hexadecimal, 64digit
  const hexValue = hash.slice(2, hash.length);
  return is0XPrefixed(hash) && /^[0-9a-fA-F]{64}$/.test(hexValue);
};

exports.isValidHash = isValidHash;

const shortenHexData = data => {
  if (!data) return '';
  if (data.length < 5) return data;
  const len = data.length;
  return data.slice(0, 5) + '...' + data.slice(len - 5, len);
};

exports.shortenHexData = shortenHexData;

/***/ }),
/* 1657 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.upgradeWithProxyMsg = exports.storageFullMessage = exports.sourceVerificationNotAvailableToastMsg = exports.recursivePasteToastMsg = exports.notFoundToastMsg = exports.logBuilder = exports.localCompilationToastMsg = exports.fileChangedToastMsg = exports.envChangeNotification = exports.deployWithProxyMsg = exports.compilingToastMsg = exports.compilerConfigChangedToastMsg = exports.compileToastMsg = exports.compilationFinishedToastMsg = exports.cancelUpgradeMsg = exports.cancelProxyMsg = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fileChangedToastMsg = (from, path) => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("i", {
  className: "fas fa-exclamation-triangle text-danger mr-1"
}), /*#__PURE__*/_react.default.createElement("span", null, from, " ", /*#__PURE__*/_react.default.createElement("span", {
  className: "font-weight-bold text-warning"
}, "is modifying"), " ", path));

exports.fileChangedToastMsg = fileChangedToastMsg;

const compilerConfigChangedToastMsg = (from, value) => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, from), " is updating the ", /*#__PURE__*/_react.default.createElement("b", null, "Solidity compiler configuration"), ".", /*#__PURE__*/_react.default.createElement("pre", {
  className: "text-left"
}, value));

exports.compilerConfigChangedToastMsg = compilerConfigChangedToastMsg;

const compileToastMsg = (from, fileName) => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, from), " is requiring to compile ", /*#__PURE__*/_react.default.createElement("b", null, fileName));

exports.compileToastMsg = compileToastMsg;

const compilingToastMsg = settings => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Recompiling and debugging with params"), /*#__PURE__*/_react.default.createElement("pre", {
  className: "text-left"
}, settings));

exports.compilingToastMsg = compilingToastMsg;

const compilationFinishedToastMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Compilation failed..."), " continuing ", /*#__PURE__*/_react.default.createElement("i", null, "without"), " source code debugging.");

exports.compilationFinishedToastMsg = compilationFinishedToastMsg;

const notFoundToastMsg = address => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Contract ", address, " not found in source code repository"), " continuing ", /*#__PURE__*/_react.default.createElement("i", null, "without"), " source code debugging.");

exports.notFoundToastMsg = notFoundToastMsg;

const localCompilationToastMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Using compilation result from Solidity module"));

exports.localCompilationToastMsg = localCompilationToastMsg;

const sourceVerificationNotAvailableToastMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Source verification plugin not activated or not available."), " continuing ", /*#__PURE__*/_react.default.createElement("i", null, "without"), " source code debugging.");

exports.sourceVerificationNotAvailableToastMsg = sourceVerificationNotAvailableToastMsg;

const envChangeNotification = (env, from) => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("i", {
  className: "fas fa-exclamation-triangle text-danger mr-1"
}), /*#__PURE__*/_react.default.createElement("span", null, from + ' ', /*#__PURE__*/_react.default.createElement("span", {
  className: "font-weight-bold text-warning"
}, "set your environment to"), " ", env && env.context));

exports.envChangeNotification = envChangeNotification;

const storageFullMessage = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("i", {
  className: "fas fa-exclamation-triangle text-danger mr-1"
}), /*#__PURE__*/_react.default.createElement("span", {
  className: "font-weight-bold"
}, /*#__PURE__*/_react.default.createElement("span", null, "Cannot save this file due to full LocalStorage. Backup existing files and free up some space.")));

exports.storageFullMessage = storageFullMessage;

const recursivePasteToastMsg = () => /*#__PURE__*/_react.default.createElement("div", null, "File(s) to paste is an ancestor of the destination folder");

exports.recursivePasteToastMsg = recursivePasteToastMsg;

const logBuilder = msg => {
  return /*#__PURE__*/_react.default.createElement("pre", null, msg);
};

exports.logBuilder = logBuilder;

const cancelProxyMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Proxy deployment cancelled."));

exports.cancelProxyMsg = cancelProxyMsg;

const cancelUpgradeMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Upgrade with proxy cancelled."));

exports.cancelUpgradeMsg = cancelUpgradeMsg;

const deployWithProxyMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Deploy with Proxy"), " will initiate two (2) transactions:", /*#__PURE__*/_react.default.createElement("ol", {
  className: "pl-3"
}, /*#__PURE__*/_react.default.createElement("li", null, "Deploying the implementation contract"), /*#__PURE__*/_react.default.createElement("li", null, "Deploying an ERC1967 proxy contract")));

exports.deployWithProxyMsg = deployWithProxyMsg;

const upgradeWithProxyMsg = () => /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("b", null, "Upgrade with Proxy"), " will initiate two (2) transactions:", /*#__PURE__*/_react.default.createElement("ol", {
  className: "pl-3"
}, /*#__PURE__*/_react.default.createElement("li", null, "Deploying the new implementation contract"), /*#__PURE__*/_react.default.createElement("li", null, "Updating the proxy contract with the address of the new implementation contract")));

exports.upgradeWithProxyMsg = upgradeWithProxyMsg;

/***/ }),
/* 1658 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PluginViewWrapper = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const PluginViewWrapper = props => {
  const [state, setState] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    if (props.plugin.setDispatch) {
      props.plugin.setDispatch(setState);
    }
  }, []);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, state ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, props.plugin.updateComponent(state)) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null));
};

exports.PluginViewWrapper = PluginViewWrapper;

/***/ }),
/* 1659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomToggle = exports.CustomMenu = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The forwardRef is important!!
// Dropdown needs access to the DOM node in order to position the Menu
const CustomToggle = _react.default.forwardRef(({
  children,
  onClick,
  icon,
  className = ''
}, ref) => /*#__PURE__*/_react.default.createElement("button", {
  ref: ref,
  onClick: e => {
    e.preventDefault();
    onClick(e);
  },
  className: className.replace('dropdown-toggle', '')
}, /*#__PURE__*/_react.default.createElement("div", {
  className: "d-flex"
}, /*#__PURE__*/_react.default.createElement("div", {
  className: "mr-auto"
}, children), icon && /*#__PURE__*/_react.default.createElement("div", {
  className: "pr-1"
}, /*#__PURE__*/_react.default.createElement("i", {
  className: `${icon} pr-1`
})), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("i", {
  className: "fad fa-sort-circle"
}))))); // forwardRef again here!
// Dropdown needs access to the DOM of the Menu to measure it


exports.CustomToggle = CustomToggle;

const CustomMenu = _react.default.forwardRef(({
  children,
  style,
  className,
  'aria-labelledby': labeledBy
}, ref) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    ref: ref,
    style: style,
    className: className,
    "aria-labelledby": labeledBy
  }, /*#__PURE__*/_react.default.createElement("ul", {
    className: "list-unstyled mb-0"
  }, children));
});

exports.CustomMenu = CustomMenu;

/***/ }),
/* 1660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InstanceContainerUI = InstanceContainerUI;

var _react = _interopRequireDefault(__webpack_require__(29));

var _universalDappUI = __webpack_require__(1661);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
function InstanceContainerUI(props) {
  const {
    instanceList
  } = props.instances;

  const clearInstance = () => {
    props.clearInstances();
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_instanceContainer mt-3 border-0 list-group-item",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
      className: "udapp_deployedContracts d-flex justify-content-between align-items-center pl-2 mb-2",
      title: "Autogenerated generic user interfaces for interaction with deployed contracts",
      children: ["Deployed Contracts", instanceList.length > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: "mr-2 udapp_icon far fa-trash-alt",
        "data-id": "deployAndRunClearInstances",
        onClick: clearInstance,
        title: "Clear instances list and reset recorder",
        "aria-hidden": "true"
      }) : null]
    }), instanceList.length > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [" ", props.instances.instanceList.map((instance, index) => {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_universalDappUI.UniversalDappUI, {
          instance: instance,
          context: props.getContext(),
          removeInstance: props.removeInstance,
          index: index,
          gasEstimationPrompt: props.gasEstimationPrompt,
          passphrasePrompt: props.passphrasePrompt,
          mainnetPrompt: props.mainnetPrompt,
          runTransactions: props.runTransactions,
          sendValue: props.sendValue,
          getFuncABIInputs: props.getFuncABIInputs
        }, index);
      })]
    }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      className: "mx-2 mt-3 alert alert-warning",
      "data-id": "deployAndRunNoInstanceText",
      role: "alert",
      children: "Currently you have no contract instances to interact with."
    })]
  });
}

/***/ }),
/* 1661 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UniversalDappUI = UniversalDappUI;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _clipboard = __webpack_require__(1154);

var remixLib = _interopRequireWildcard(__webpack_require__(311));

var ethJSUtil = _interopRequireWildcard(__webpack_require__(34));

var _contractGUI = __webpack_require__(1399);

var _treeView = __webpack_require__(1187);

var _helper = __webpack_require__(1121);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
const txHelper = remixLib.execution.txHelper;

function UniversalDappUI(props) {
  const [toggleExpander, setToggleExpander] = (0, _react.useState)(true);
  const [contractABI, setContractABI] = (0, _react.useState)(null);
  const [address, setAddress] = (0, _react.useState)('');
  const [expandPath, setExpandPath] = (0, _react.useState)([]);
  const [llIError, setLlIError] = (0, _react.useState)('');
  const [calldataValue, setCalldataValue] = (0, _react.useState)('');
  const [evmBC, setEvmBC] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    if (!props.instance.abi) {
      const abi = txHelper.sortAbiFunction(props.instance.contractData.abi);
      setContractABI(abi);
    } else {
      setContractABI(props.instance.abi);
    }
  }, [props.instance.abi]);
  (0, _react.useEffect)(() => {
    if (props.instance.address) {
      // @ts-ignore
      let address = (props.instance.address.slice(0, 2) === '0x' ? '' : '0x') + props.instance.address.toString('hex');
      address = ethJSUtil.toChecksumAddress(address);
      setAddress(address);
    }
  }, [props.instance.address]);
  (0, _react.useEffect)(() => {
    if (props.instance.contractData) {
      setEvmBC(props.instance.contractData.bytecodeObject);
    }
  }, [props.instance.contractData]);

  const sendData = () => {
    setLlIError('');
    const fallback = txHelper.getFallbackInterface(contractABI);
    const receive = txHelper.getReceiveInterface(contractABI);
    const args = {
      funcABI: fallback || receive,
      address: address,
      contractName: props.instance.name,
      contractABI: contractABI
    };
    const amount = props.sendValue;

    if (amount !== '0') {
      // check for numeric and receive/fallback
      if (!(0, _helper.isNumeric)(amount)) {
        return setLlIError('Value to send should be a number');
      } else if (!receive && !(fallback && fallback.stateMutability === 'payable')) {
        return setLlIError("In order to receive Ether transfer the contract should have either 'receive' or payable 'fallback' function");
      }
    }

    let calldata = calldataValue;

    if (calldata) {
      if (calldata.length < 4 && (0, _helper.is0XPrefixed)(calldata)) {
        return setLlIError('The calldata should be a valid hexadecimal value with size of at least one byte.');
      } else {
        if ((0, _helper.is0XPrefixed)(calldata)) {
          calldata = calldata.substr(2, calldata.length);
        }

        if (!(0, _helper.isHexadecimal)(calldata)) {
          return setLlIError('The calldata should be a valid hexadecimal value.');
        }
      }

      if (!fallback) {
        return setLlIError("'Fallback' function is not defined");
      }
    }

    if (!receive && !fallback) return setLlIError('Both \'receive\' and \'fallback\' functions are not defined'); // we have to put the right function ABI:
    // if receive is defined and that there is no calldata => receive function is called
    // if fallback is defined => fallback function is called

    if (receive && !calldata) args.funcABI = receive;else if (fallback) args.funcABI = fallback;
    if (!args.funcABI) return setLlIError('Please define a \'Fallback\' function to send calldata and a either \'Receive\' or payable \'Fallback\' to send ethers');
    runTransaction(false, args.funcABI, null, calldataValue);
  };

  const toggleClass = () => {
    setToggleExpander(!toggleExpander);
  };

  const remove = () => {
    props.removeInstance(props.index);
  };

  const runTransaction = (lookupOnly, funcABI, valArr, inputsValues, funcIndex) => {
    const functionName = funcABI.type === 'function' ? funcABI.name : `(${funcABI.type})`;
    const logMsg = `${lookupOnly ? 'call' : 'transact'} to ${props.instance.name}.${functionName}`;
    props.runTransactions(props.index, lookupOnly, funcABI, inputsValues, props.instance.name, contractABI, props.instance.contractData, address, logMsg, props.mainnetPrompt, props.gasEstimationPrompt, props.passphrasePrompt, funcIndex);
  };

  const extractDataDefault = (item, parent) => {
    const ret = {};

    if (ethJSUtil.BN.isBN(item)) {
      ret.self = item.toString(10);
      ret.children = [];
    } else {
      if (item instanceof Array) {
        ret.children = item.map((item, index) => {
          return {
            key: index,
            value: item
          };
        });
        ret.self = 'Array';
        ret.isNode = true;
        ret.isLeaf = false;
      } else if (item instanceof Object) {
        ret.children = Object.keys(item).map(key => {
          return {
            key: key,
            value: item[key]
          };
        });
        ret.self = 'Object';
        ret.isNode = true;
        ret.isLeaf = false;
      } else {
        ret.self = item;
        ret.children = null;
        ret.isNode = false;
        ret.isLeaf = true;
      }
    }

    return ret;
  };

  const handleExpand = path => {
    if (expandPath.includes(path)) {
      const filteredPath = expandPath.filter(value => value !== path);
      setExpandPath(filteredPath);
    } else {
      setExpandPath([...expandPath, path]);
    }
  };

  const handleCalldataChange = e => {
    const value = e.target.value;
    setCalldataValue(value);
  };

  const label = (key, value) => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "d-flex mt-2 flex-row label_item",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
        className: "small font-weight-bold mb-0 pr-1 label_key",
        children: [key, ":"]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "m-0 label_value",
        children: value
      })]
    });
  };

  const renderData = (item, parent, key, keyPath) => {
    const data = extractDataDefault(item, parent);
    const children = (data.children || []).map((child, index) => {
      return renderData(child.value, data, child.key, keyPath + '/' + child.key);
    });

    if (children && children.length > 0) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: `treeViewItem${key}`,
        label: label(key, data.self),
        onClick: () => handleExpand(keyPath),
        expand: expandPath.includes(keyPath),
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
          id: `treeView${key}`,
          children: children
        }, keyPath)
      }, keyPath);
    } else {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: key.toString(),
        label: label(key, data.self),
        onClick: () => handleExpand(keyPath),
        expand: expandPath.includes(keyPath)
      }, keyPath);
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: `instance udapp_instance udapp_run-instance border-dark ${toggleExpander ? 'udapp_hidesub' : 'bg-light'}`,
    id: `instance${address}`,
    "data-shared": "universalDappUiInstance",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_title pb-0 alert alert-secondary",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        "data-id": `universalDappUiTitleExpander${props.index}`,
        className: "btn udapp_titleExpander",
        onClick: toggleClass,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: `fas ${toggleExpander ? 'fa-angle-right' : 'fa-angle-down'}`,
          "aria-hidden": "true"
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "input-group udapp_nameNbuts",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "udapp_titleText input-group-prepend",
          children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            className: "input-group-text udapp_spanTitleText",
            children: [props.instance.name, " at ", (0, _helper.shortenAddress)(address), " (", props.context, ")"]
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "btn-group",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            className: "btn p-1 btn-secondary",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
              content: address,
              direction: 'top'
            })
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        className: "udapp_udappClose mr-1 p-1 btn btn-secondary align-items-center",
        "data-id": "universalDappUiUdappClose",
        onClick: remove,
        title: "Remove from the list",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "udapp_closeIcon fas fa-times",
          "aria-hidden": "true"
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_cActionsWrapper",
      "data-id": "universalDappUiContractActionWrapper",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "udapp_contractActionsContainer",
        children: contractABI && contractABI.map((funcABI, index) => {
          if (funcABI.type !== 'function') return null;
          const isConstant = funcABI.constant !== undefined ? funcABI.constant : false;
          const lookupOnly = funcABI.stateMutability === 'view' || funcABI.stateMutability === 'pure' || isConstant;
          const inputs = props.getFuncABIInputs(funcABI);
          return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_contractGUI.ContractGUI, {
              funcABI: funcABI,
              clickCallBack: (valArray, inputsValues) => {
                runTransaction(lookupOnly, funcABI, valArray, inputsValues, index);
              },
              inputs: inputs,
              evmBC: evmBC,
              lookupOnly: lookupOnly
            }, index), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "udapp_value",
              "data-id": "udapp_value",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
                id: "treeView",
                children: Object.keys(props.instance.decodedResponse || {}).map(key => {
                  const funcIndex = index.toString();
                  const response = props.instance.decodedResponse[key];
                  return key === funcIndex ? Object.keys(response || {}).map((innerkey, index) => {
                    return renderData(props.instance.decodedResponse[key][innerkey], response, innerkey, innerkey);
                  }) : null;
                })
              })
            })]
          }, index);
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex flex-column",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex flex-row justify-content-between mt-2",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "py-2 border-top d-flex justify-content-start flex-grow-1",
            children: "Low level interactions"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            href: "https://solidity.readthedocs.io/en/v0.6.2/contracts.html#receive-ether-function",
            title: "check out docs for using 'receive'/'fallback'",
            target: "_blank",
            rel: "noreferrer",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              "aria-hidden": "true",
              className: "fas fa-info my-2 mr-1"
            })
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex flex-column align-items-start",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "",
            children: "CALLDATA"
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex justify-content-end w-100 align-items-center",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              id: "deployAndRunLLTxCalldata",
              onChange: handleCalldataChange,
              className: "udapp_calldataInput form-control",
              title: "The Calldata to send to fallback function of the contract."
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
              id: "deployAndRunLLTxSendTransaction",
              "data-id": "pluginManagerSettingsDeployAndRunLLTxSendTransaction",
              className: "udapp_instanceButton p-0 w-50 btn border-warning text-warning",
              title: "Send data to contract.",
              onClick: sendData,
              children: "Transact"
            })]
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            id: "deployAndRunLLTxError",
            className: "text-danger my-2",
            children: llIError
          })
        })]
      })]
    })]
  });
}

/***/ }),
/* 1662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TreeViewItem = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(1227));

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(1663);

var _jsxRuntime = __webpack_require__(46);

const _excluded = ["id", "children", "label", "labelClass", "expand", "iconX", "iconY", "icon", "controlBehaviour", "innerRef", "showIcon"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const TreeViewItem = props => {
  const {
    id,
    children,
    label,
    labelClass,
    expand,
    iconX = 'fas fa-caret-right',
    iconY = 'fas fa-caret-down',
    icon,
    controlBehaviour = false,
    innerRef,
    showIcon = true
  } = props,
        otherProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  const [isExpanded, setIsExpanded] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    setIsExpanded(expand);
  }, [expand]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("li", _objectSpread(_objectSpread({
    ref: innerRef,
    "data-id": `treeViewLi${id}`,
    className: "li_tv"
  }, otherProps), {}, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      "data-id": `treeViewDiv${id}`,
      className: `d-flex flex-row align-items-center ${labelClass}`,
      onClick: () => !controlBehaviour && setIsExpanded(!isExpanded),
      children: [children && showIcon ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: isExpanded ? `px-1 ${iconY} caret caret_tv` : `px-1 ${iconX} caret caret_tv`,
        style: {
          visibility: children ? 'visible' : 'hidden'
        }
      }) : icon ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: `pr-3 pl-1 ${icon} caret caret_tv`
      }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "w-100 pl-1",
        children: label
      })]
    }, `treeViewDiv${id}`), isExpanded ? children : null]
  }), `treeViewLi${id}`);
};

exports.TreeViewItem = TreeViewItem;
var _default = TreeViewItem;
exports.default = _default;

/***/ }),
/* 1663 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(1664);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 1664 */
/***/ (function(module, exports) {

module.exports = [[module.i, "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJ0cmVlLXZpZXctaXRlbS5jc3MifQ== */", '', '']]

/***/ }),
/* 1665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TreeView = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(1227));

var _react = _interopRequireDefault(__webpack_require__(29));

__webpack_require__(1666);

var _jsxRuntime = __webpack_require__(46);

const _excluded = ["children", "id"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const TreeView = props => {
  const {
    children,
    id
  } = props,
        otherProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("ul", _objectSpread(_objectSpread({
    "data-id": `treeViewUl${id}`,
    className: "ul_tv ml-0 pl-2"
  }, otherProps), {}, {
    children: children
  }));
};

exports.TreeView = TreeView;
var _default = TreeView;
exports.default = _default;

/***/ }),
/* 1666 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(1667);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 1667 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".li_tv {\n    list-style-type: none;\n    -webkit-margin-before: 0px;\n    -webkit-margin-after: 0px;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0px;\n  }\n  .ul_tv {\n    list-style-type: none;\n    -webkit-margin-before: 0px;\n    -webkit-margin-after: 0px;\n    -webkit-margin-start: 0px;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0px;\n  }\n  .caret_tv {\n    width: 10px;\n    flex-shrink: 0;\n    padding-right: 5px;\n  }\n  .label_item {\n    word-break: break-all;\n  }\n  .label_key {\n    min-width: -webkit-max-content;\n    min-width: -moz-max-content;\n    min-width: max-content;\n    max-width: 80%;\n    word-break: break-word;\n  }\n  .label_value {\n    min-width: 10%;\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLXRyZWUtdmlldy5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7SUFDSSxxQkFBcUI7SUFDckIsMEJBQTBCO0lBQzFCLHlCQUF5QjtJQUN6Qix5QkFBeUI7SUFDekIsdUJBQXVCO0lBQ3ZCLDBCQUEwQjtFQUM1QjtFQUNBO0lBQ0UscUJBQXFCO0lBQ3JCLDBCQUEwQjtJQUMxQix5QkFBeUI7SUFDekIseUJBQXlCO0lBQ3pCLHVCQUF1QjtJQUN2QiwwQkFBMEI7RUFDNUI7RUFDQTtJQUNFLFdBQVc7SUFDWCxjQUFjO0lBQ2Qsa0JBQWtCO0VBQ3BCO0VBQ0E7SUFDRSxxQkFBcUI7RUFDdkI7RUFDQTtJQUNFLDhCQUFzQjtJQUF0QiwyQkFBc0I7SUFBdEIsc0JBQXNCO0lBQ3RCLGNBQWM7SUFDZCxzQkFBc0I7RUFDeEI7RUFDQTtJQUNFLGNBQWM7RUFDaEIiLCJmaWxlIjoicmVtaXgtdWktdHJlZS12aWV3LmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5saV90diB7XG4gICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICAgIC13ZWJraXQtbWFyZ2luLWJlZm9yZTogMHB4O1xuICAgIC13ZWJraXQtbWFyZ2luLWFmdGVyOiAwcHg7XG4gICAgLXdlYmtpdC1tYXJnaW4tc3RhcnQ6IDBweDtcbiAgICAtd2Via2l0LW1hcmdpbi1lbmQ6IDBweDtcbiAgICAtd2Via2l0LXBhZGRpbmctc3RhcnQ6IDBweDtcbiAgfVxuICAudWxfdHYge1xuICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgICAtd2Via2l0LW1hcmdpbi1iZWZvcmU6IDBweDtcbiAgICAtd2Via2l0LW1hcmdpbi1hZnRlcjogMHB4O1xuICAgIC13ZWJraXQtbWFyZ2luLXN0YXJ0OiAwcHg7XG4gICAgLXdlYmtpdC1tYXJnaW4tZW5kOiAwcHg7XG4gICAgLXdlYmtpdC1wYWRkaW5nLXN0YXJ0OiAwcHg7XG4gIH1cbiAgLmNhcmV0X3R2IHtcbiAgICB3aWR0aDogMTBweDtcbiAgICBmbGV4LXNocmluazogMDtcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XG4gIH1cbiAgLmxhYmVsX2l0ZW0ge1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDtcbiAgfVxuICAubGFiZWxfa2V5IHtcbiAgICBtaW4td2lkdGg6IG1heC1jb250ZW50O1xuICAgIG1heC13aWR0aDogODAlO1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gIH1cbiAgLmxhYmVsX3ZhbHVlIHtcbiAgICBtaW4td2lkdGg6IDEwJTtcbiAgfSJdfQ== */", '', '']]

/***/ }),
/* 1668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RecorderUI = RecorderUI;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _reactBootstrap = __webpack_require__(1209);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
// eslint-disable-line
function RecorderUI(props) {
  const inputLive = (0, _react.useRef)();
  const [toggleExpander, setToggleExpander] = (0, _react.useState)(false);
  const [enableRunButton, setEnableRunButton] = (0, _react.useState)(true);

  const triggerRecordButton = () => {
    props.storeScenario(props.scenarioPrompt);
  };

  const handleClickRunButton = () => {
    const liveMode = inputLive.current ? inputLive.current.checked : false;
    props.runCurrentScenario(liveMode, props.gasEstimationPrompt, props.passphrasePrompt, props.mainnetPrompt);
  };

  (0, _react.useEffect)(() => {
    if (props.currentFile && props.currentFile.endsWith('.json')) setEnableRunButton(false);else setEnableRunButton(true);
  }, [props.currentFile]);

  const toggleClass = () => {
    setToggleExpander(!toggleExpander);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_cardContainer list-group-item border border-bottom",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_recorderSection d-flex justify-content-between",
      onClick: toggleClass,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "mt-1 udapp_recorderSectionLabel",
          children: "Transactions recorded"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "ml-2 mb-2 badge badge-pill badge-primary",
          title: "The number of recorded transactions",
          children: props.count
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
          placement: 'right',
          overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
            className: "text-nowrap",
            id: "info-recorder",
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              children: ["Save transactions (deployed contracts and function executions) and replay them in another environment. ", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), " e.g Transactions created in Remix VM can be replayed in the Injected Provider."]
            })
          }),
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            style: {
              fontSize: 'medium'
            },
            className: 'ml-2 fal fa-info-circle',
            "aria-hidden": "true"
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          "data-id": "udappRecorderTitleExpander",
          onClick: toggleClass,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            className: !toggleExpander ? 'fas fa-angle-right' : 'fas fa-angle-down',
            "aria-hidden": "true"
          })
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: `flex-column ${toggleExpander ? "d-flex" : "d-none"}`,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "mb-1 mt-1 fmt-2 custom-control custom-checkbox mb-1",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          ref: inputLive,
          type: "checkbox",
          id: "livemode-recorder",
          className: "custom-control-input custom-select",
          name: "input-livemode"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
          placement: 'right',
          overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
            className: "text-nowrap",
            id: "tooltip-livemode-recorder",
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              children: ["If contracts are updated after recording transactions, checking this box", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "will run recorded transactions with the latest copy of the compiled contracts"]
            })
          }),
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            "data-id": "runtabLivemodeInput",
            htmlFor: "livemode-recorder",
            children: "Run transactions using the latest compilation result"
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "mb-1 mt-1 udapp_transactionActions",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
          placement: 'right',
          overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
            className: "text-nowrap",
            id: "tooltip-save-recorder",
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              children: ["Save ", props.count, " transaction", props.count === 1 ? '' : 's', " as scenario file"]
            })
          }),
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            className: "btn btn-sm btn-info savetransaction udapp_recorder",
            title: props.count === 0 ? 'No transactions to save' : '',
            disabled: props.count === 0 ? true : false,
            onClick: triggerRecordButton,
            children: "Save"
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
          placement: 'right',
          overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
            className: "text-nowrap",
            id: "tooltip-run-recorder",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "Run transaction(s) from the current scenario file"
            })
          }),
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            className: "btn btn-sm btn-info runtransaction udapp_runTxs",
            "data-id": "runtransaction",
            title: enableRunButton ? 'No scenario file selected' : '',
            disabled: enableRunButton,
            onClick: handleClickRunButton,
            children: "Run"
          })
        })]
      })]
    })]
  });
}

/***/ }),
/* 1669 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SettingsUI = SettingsUI;

var _react = _interopRequireDefault(__webpack_require__(29));

var _environment = __webpack_require__(1670);

var _network = __webpack_require__(1671);

var _account = __webpack_require__(1672);

var _gasPrice = __webpack_require__(1673);

var _value = __webpack_require__(1674);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
function SettingsUI(props) {
  //   this._deps.config.events.on('settings/personal-mode_changed', this.onPersonalChange.bind(this))
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_settings",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_environment.EnvironmentUI, {
      selectedEnv: props.selectExEnv,
      providers: props.providers,
      setExecutionContext: props.setExecutionContext
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_network.NetworkUI, {
      networkName: props.networkName
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_account.AccountUI, {
      personalMode: props.personalMode,
      selectExEnv: props.selectExEnv,
      accounts: props.accounts,
      setAccount: props.setAccount,
      createNewBlockchainAccount: props.createNewBlockchainAccount,
      setPassphrase: props.setPassphrase,
      setMatchPassphrase: props.setMatchPassphrase,
      tooltip: props.tooltip,
      modal: props.modal,
      signMessageWithAddress: props.signMessageWithAddress,
      passphrase: props.passphrase
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_gasPrice.GasPriceUI, {
      gasLimit: props.gasLimit,
      setGasFee: props.setGasFee
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_value.ValueUI, {
      setUnit: props.setUnit,
      sendValue: props.sendValue,
      sendUnit: props.sendUnit,
      setSendValue: props.setSendValue
    })]
  });
}

/***/ }),
/* 1670 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnvironmentUI = EnvironmentUI;

var _react = _interopRequireDefault(__webpack_require__(29));

var _reactBootstrap = __webpack_require__(1209);

var _helper = __webpack_require__(1121);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
// eslint-disable-line
function EnvironmentUI(props) {
  const handleChangeExEnv = env => {
    const provider = props.providers.providerList.find(exEnv => exEnv.value === env);
    const fork = provider.fork; // can be undefined if connected to an external source (External Http Provider / injected)

    let context = provider.value;
    context = context.startsWith('vm') ? 'vm' : context;
    props.setExecutionContext({
      context,
      fork
    });
  };

  const currentProvider = props.providers.providerList.find(exEnv => exEnv.value === props.selectedEnv);
  const bridges = {
    'Optimism Provider': 'https://www.optimism.io/apps/bridges',
    'Arbitrum One Provider': 'https://bridge.arbitrum.io/'
  };

  const isL2 = provider => provider && (provider.value === 'Optimism Provider' || provider.value === 'Arbitrum One Provider');

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_crow",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
      id: "selectExEnv",
      className: "udapp_settingsLabel",
      children: ["Environment ", /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
        placement: 'right',
        overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
          className: "text-nowrap",
          id: "info-recorder",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            children: "Open chainlist and add a new provider for the chain you want to interact to."
          })
        }),
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
          href: "https://chainlist.org/",
          target: "_blank",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            style: {
              fontSize: 'medium'
            },
            className: 'ml-2 fad fa-plug',
            "aria-hidden": "true"
          })
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_environment",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactBootstrap.Dropdown, {
        id: "selectExEnvOptions",
        "data-id": "settingsSelectEnvOptions",
        className: "udapp_selectExEnvOptions",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactBootstrap.Dropdown.Toggle, {
          as: _helper.CustomToggle,
          id: "dropdown-custom-components",
          className: "btn btn-light btn-block w-100 d-inline-block border border-dark form-control",
          icon: null,
          children: [isL2(currentProvider) && 'L2 - ', currentProvider && currentProvider.content, currentProvider && bridges[currentProvider.value] && /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
            placement: 'right',
            overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
              className: "text-nowrap",
              id: "info-recorder",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                children: "Click to open a bridge for converting L1 mainnet ETH to the selected network currency."
              })
            }),
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              style: {
                fontSize: 'medium'
              },
              className: 'ml-2 fal fa-plug',
              "aria-hidden": "true",
              onClick: () => {
                window.open(bridges[currentProvider.value], '_blank');
              }
            })
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Dropdown.Menu, {
          as: _helper.CustomMenu,
          className: "w-100 custom-dropdown-items",
          "data-id": "custom-dropdown-items",
          children: props.providers.providerList.map(({
            content,
            value
          }, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Dropdown.Item, {
            onClick: () => {
              handleChangeExEnv(value);
            },
            "data-id": `dropdown-item-${value}`,
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              className: "pl-3",
              children: [isL2({
                value
              }) && 'L2 - ', content]
            })
          }, index))
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        href: "https://remix-ide.readthedocs.io/en/latest/run.html#environment",
        target: "_blank",
        rel: "noreferrer",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "udapp_infoDeployAction ml-2 fas fa-info",
          title: "Click for docs about Environment"
        })
      })]
    })]
  });
}

/***/ }),
/* 1671 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NetworkUI = NetworkUI;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
function NetworkUI(props) {
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_crow",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "udapp_settingsLabel"
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "udapp_environment",
      "data-id": "settingsNetworkEnv",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "udapp_network badge badge-secondary",
        children: props.networkName
      })
    })]
  });
}

/***/ }),
/* 1672 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccountUI = AccountUI;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _clipboard = __webpack_require__(1154);

var _passphrase = __webpack_require__(1400);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
function AccountUI(props) {
  const {
    selectedAccount,
    loadedAccounts
  } = props.accounts;
  const accounts = Object.keys(loadedAccounts);
  const [plusOpt, setPlusOpt] = (0, _react.useState)({
    classList: '',
    title: ''
  });
  const messageRef = (0, _react.useRef)('');
  (0, _react.useEffect)(() => {
    if (!selectedAccount && accounts.length > 0) props.setAccount(accounts[0]);
  }, [accounts, selectedAccount]);
  (0, _react.useEffect)(() => {
    switch (props.selectExEnv) {
      case 'injected':
        setPlusOpt({
          classList: 'udapp_disableMouseEvents',
          title: "Unfortunately it's not possible to create an account using injected provider. Please create the account directly from your provider (i.e metamask or other of the same type)."
        });
        break;

      case 'vm-london':
        setPlusOpt({
          classList: '',
          title: 'Create a new account'
        });
        break;

      case 'vm-berlin':
        setPlusOpt({
          classList: '',
          title: 'Create a new account'
        });
        break;

      case 'web3':
        if (!props.personalMode) {
          setPlusOpt({
            classList: 'disableMouseEvents',
            title: 'Creating an account is possible only in Personal mode. Please go to Settings to enable it.'
          });
        } else {
          setPlusOpt({
            classList: '',
            title: 'Create a new account'
          });
        }

        break;

      default:
        setPlusOpt({
          classList: 'disableMouseEvents',
          title: `Unfortunately it's not possible to create an account using an external wallet (${props.selectExEnv}).`
        });
    } // this._deps.config.get('settings/personal-mode')

  }, [props.selectExEnv, props.personalMode]);

  const newAccount = () => {
    props.createNewBlockchainAccount(passphraseCreationPrompt());
  };

  const signMessage = () => {
    if (!accounts[0]) {
      return props.tooltip('Account list is empty, please make sure the current provider is properly connected to remix');
    }

    if (props.selectExEnv !== 'vm-london' && props.selectExEnv !== 'vm-berlin' && props.selectExEnv !== 'injected') {
      return props.modal('Passphrase to sign a message', /*#__PURE__*/(0, _jsxRuntime.jsx)(_passphrase.PassphrasePrompt, {
        message: "Enter your passphrase for this account to sign the message",
        setPassphrase: props.setPassphrase
      }), 'OK', () => {
        props.modal('Sign a message', signMessagePrompt(), 'OK', () => {
          props.signMessageWithAddress(selectedAccount, messageRef.current, signedMessagePrompt, props.passphrase);
          props.setPassphrase('');
        }, 'Cancel', null);
      }, 'Cancel', () => {
        props.setPassphrase('');
      });
    }

    props.modal('Sign a message', signMessagePrompt(), 'OK', () => {
      props.signMessageWithAddress(selectedAccount, messageRef.current, signedMessagePrompt);
    }, 'Cancel', null);
  };

  const handlePassphrase = e => {
    props.setPassphrase(e.target.value);
  };

  const handleMatchPassphrase = e => {
    props.setMatchPassphrase(e.target.value);
  };

  const handleMessageInput = e => {
    messageRef.current = e.target.value;
  };

  const passphraseCreationPrompt = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [" Please provide a Passphrase for the account creation", /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          id: "prompt1",
          type: "password",
          name: "prompt_text",
          style: {
            width: '100%'
          },
          onInput: handlePassphrase
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          id: "prompt2",
          type: "password",
          name: "prompt_text",
          style: {
            width: '100%'
          },
          onInput: handleMatchPassphrase
        })]
      })]
    });
  };

  const signMessagePrompt = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [" Enter a message to sign", /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("textarea", {
          id: "prompt_text",
          "data-id": "signMessageTextarea",
          style: {
            width: '100%'
          },
          rows: 4,
          cols: 50,
          onInput: handleMessageInput,
          defaultValue: messageRef.current
        })
      })]
    });
  };

  const signedMessagePrompt = (msgHash, signedData) => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("b", {
        children: "hash:"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        id: "remixRunSignMsgHash",
        "data-id": "settingsRemixRunSignMsgHash",
        children: msgHash
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("b", {
        children: "signature:"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        id: "remixRunSignMsgSignature",
        "data-id": "settingsRemixRunSignMsgSignature",
        children: signedData
      })]
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_crow",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
      className: "udapp_settingsLabel",
      children: ["Account", /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        id: "remixRunPlusWraper",
        title: plusOpt.title,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          id: "remixRunPlus",
          className: `fas fa-plus-circle udapp_icon ${plusOpt.classList}`,
          "aria-hidden": "true",
          onClick: newAccount
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_account",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("select", {
        id: "txorigin",
        "data-id": "runTabSelectAccount",
        name: "txorigin",
        className: "form-control udapp_select custom-select pr-4",
        value: selectedAccount,
        onChange: e => {
          props.setAccount(e.target.value);
        },
        children: accounts.map((value, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          value: value,
          children: loadedAccounts[value]
        }, index))
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        style: {
          marginLeft: -5
        },
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
          tip: "Copy account to clipboard",
          content: selectedAccount,
          direction: "top"
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        id: "remixRunSignMsg",
        "data-id": "settingsRemixRunSignMsg",
        className: "mx-1 fas fa-edit udapp_icon",
        "aria-hidden": "true",
        onClick: signMessage,
        title: "Sign a message using this account"
      })]
    })]
  });
}

/***/ }),
/* 1673 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GasPriceUI = GasPriceUI;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
function GasPriceUI(props) {
  const handleGasLimit = e => {
    props.setGasFee(e.target.value);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_crow",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
      className: "udapp_settingsLabel",
      children: "Gas limit"
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
      type: "number",
      className: "form-control udapp_gasNval udapp_col2",
      title: "The default gas limit is 3M. Adjust as needed.",
      id: "gasLimit",
      value: props.gasLimit,
      onChange: handleGasLimit
    })]
  });
}

/***/ }),
/* 1674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ValueUI = ValueUI;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _ethereumjsUtil = __webpack_require__(34);

var _helper = __webpack_require__(1121);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
function ValueUI(props) {
  const [sendValue, setSendValue] = (0, _react.useState)(props.sendValue);
  const inputValue = (0, _react.useRef)({});
  (0, _react.useEffect)(() => {
    sendValue !== props.sendValue && props.setSendValue(sendValue);
  }, [sendValue]);

  const validateInputKey = e => {
    // preventing not numeric keys
    // preventing 000 case
    if (!(0, _helper.isNumeric)(e.key) || e.key === '0' && !parseInt(inputValue.current.value) && inputValue.current.value.length > 0) {
      e.preventDefault();
    }
  };

  const validateValue = e => {
    const value = e.target.value;

    if (!value) {
      // assign 0 if given value is
      // - empty
      return setSendValue('0');
    }

    let v;

    try {
      v = new _ethereumjsUtil.BN(value, 10);
      setSendValue(v.toString(10));
    } catch (e) {
      // assign 0 if given value is
      // - not valid (for ex 4345-54)
      // - contains only '0's (for ex 0000) copy past or edit
      setSendValue('0');
    } // if giveen value is negative(possible with copy-pasting) set to 0


    if (v.lt(0)) setSendValue('0');
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "udapp_crow",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
      className: "udapp_settingsLabel",
      "data-id": "remixDRValueLabel",
      children: "Value"
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "udapp_gasValueContainer",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        ref: inputValue,
        type: "number",
        min: "0",
        pattern: "^[0-9]",
        step: "1",
        className: "form-control udapp_gasNval udapp_col2",
        id: "value",
        "data-id": "dandrValue",
        title: "Enter an amount and choose its unit",
        onKeyPress: validateInputKey,
        onChange: validateValue,
        value: props.sendValue
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("select", {
        name: "unit",
        value: props.sendUnit,
        className: "form-control p-1 udapp_gasNvalUnit udapp_col2_2 custom-select",
        id: "unit",
        onChange: e => {
          props.setUnit(e.target.value);
        },
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          "data-unit": "wei",
          value: "wei",
          children: "Wei"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          "data-unit": "gwei",
          value: "gwei",
          children: "Gwei"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          "data-unit": "finney",
          value: "finney",
          children: "Finney"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          "data-unit": "ether",
          value: "ether",
          children: "Ether"
        })]
      })]
    })]
  });
}

/***/ }),
/* 1675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runTabReducer = exports.runTabInitialState = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _constants = __webpack_require__(1401);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const runTabInitialState = {
  accounts: {
    loadedAccounts: {},
    isRequesting: false,
    isSuccessful: false,
    error: null,
    selectedAccount: ''
  },
  sendValue: '0',
  sendUnit: 'wei',
  gasLimit: 3000000,
  selectExEnv: 'vm-london',
  personalMode: false,
  networkName: 'VM',
  providers: {
    providerList: [{
      id: 'vm-mode-london',
      dataId: 'settingsVMLondonMode',
      title: 'Execution environment is local to Remix.  Data is only saved to browser memory and will vanish upon reload.',
      value: 'vm-london',
      fork: 'london',
      content: 'Remix VM (London)'
    }, {
      id: 'vm-mode-berlin',
      dataId: 'settingsVMBerlinMode',
      title: 'Execution environment is local to Remix.  Data is only saved to browser memory and will vanish upon reload.',
      value: 'vm-berlin',
      fork: 'berlin',
      content: 'Remix VM (Berlin)'
    }, {
      id: 'injected-mode',
      dataId: 'settingsInjectedMode',
      title: 'Execution environment has been provided by Metamask or similar provider.',
      value: 'injected',
      content: `Injected Provider${window && window.ethereum && window.ethereum.isMetaMask ? ' - Metamask' : ''}`
    }],
    isRequesting: false,
    isSuccessful: false,
    error: null
  },
  notification: {
    title: '',
    message: '',
    actionOk: () => {},
    actionCancel: () => {},
    labelOk: '',
    labelCancel: ''
  },
  externalEndpoint: 'http://127.0.0.1:8545',
  popup: '',
  passphrase: '',
  matchPassphrase: '',
  contracts: {
    contractList: {},
    deployOptions: {},
    proxyKey: '',
    loadType: 'other',
    currentFile: '',
    currentContract: '',
    compilationCount: 0,
    isRequesting: false,
    isSuccessful: false,
    error: null
  },
  ipfsChecked: false,
  gasPriceStatus: false,
  confirmSettings: false,
  maxFee: '',
  maxPriorityFee: '1',
  baseFeePerGas: '',
  txFeeContent: '',
  gasPrice: '',
  instances: {
    instanceList: [],
    error: null
  },
  recorder: {
    pathToScenario: 'scenario.json',
    transactionCount: 0
  }
};
exports.runTabInitialState = runTabInitialState;

const runTabReducer = (state = runTabInitialState, action) => {
  switch (action.type) {
    case _constants.FETCH_ACCOUNTS_LIST_REQUEST:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          accounts: _objectSpread(_objectSpread({}, state.accounts), {}, {
            isRequesting: true,
            isSuccessful: false,
            error: null
          })
        });
      }

    case _constants.FETCH_ACCOUNTS_LIST_SUCCESS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          accounts: _objectSpread(_objectSpread({}, state.accounts), {}, {
            loadedAccounts: payload,
            isSuccessful: true,
            isRequesting: false,
            error: null
          })
        });
      }

    case _constants.FETCH_ACCOUNTS_LIST_FAILED:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          accounts: _objectSpread(_objectSpread({}, state.accounts), {}, {
            isRequesting: false,
            isSuccessful: false,
            error: payload
          })
        });
      }

    case _constants.SET_SEND_VALUE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          sendValue: payload
        });
      }

    case _constants.SET_SELECTED_ACCOUNT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          accounts: _objectSpread(_objectSpread({}, state.accounts), {}, {
            selectedAccount: payload
          })
        });
      }

    case _constants.SET_SEND_UNIT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          sendUnit: payload
        });
      }

    case _constants.SET_GAS_LIMIT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          gasLimit: payload
        });
      }

    case _constants.SET_EXECUTION_ENVIRONMENT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          selectExEnv: payload,
          networkName: state.selectExEnv === 'vm-london' || state.selectExEnv === 'vm-berlin' ? 'VM' : state.networkName,
          accounts: _objectSpread(_objectSpread({}, state.accounts), {}, {
            selectedAccount: '',
            loadedAccounts: {}
          })
        });
      }

    case _constants.SET_PERSONAL_MODE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          personalMode: payload
        });
      }

    case _constants.SET_NETWORK_NAME:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          networkName: payload
        });
      }

    case _constants.FETCH_PROVIDER_LIST_REQUEST:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          providers: _objectSpread(_objectSpread({}, state.providers), {}, {
            isRequesting: true,
            isSuccessful: false,
            error: null
          })
        });
      }

    case _constants.FETCH_PROVIDER_LIST_SUCCESS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          providers: _objectSpread(_objectSpread({}, state.providers), {}, {
            providerList: payload,
            isSuccessful: true,
            isRequesting: false,
            error: null
          })
        });
      }

    case _constants.FETCH_PROVIDER_LIST_FAILED:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          providers: _objectSpread(_objectSpread({}, state.providers), {}, {
            isRequesting: false,
            isSuccessful: false,
            error: payload
          })
        });
      }

    case _constants.ADD_PROVIDER:
      {
        const payload = action.payload;
        const id = action.payload.name;
        state.providers.providerList.push({
          content: payload.name,
          dataId: id,
          id,
          title: payload.name,
          value: id
        });
        return _objectSpread(_objectSpread({}, state), {}, {
          providers: _objectSpread(_objectSpread({}, state.providers), {}, {
            providerList: state.providers.providerList
          })
        });
      }

    case _constants.REMOVE_PROVIDER:
      {
        const id = action.payload;
        const providers = state.providers.providerList.filter(el => el.id !== id);
        return _objectSpread(_objectSpread({}, state), {}, {
          providers: _objectSpread(_objectSpread({}, state.providers), {}, {
            providerList: providers
          })
        });
      }

    case _constants.DISPLAY_NOTIFICATION:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          notification: {
            title: payload.title,
            message: payload.message,
            actionOk: payload.actionOk || runTabInitialState.notification.actionOk,
            actionCancel: payload.actionCancel || runTabInitialState.notification.actionCancel,
            labelOk: payload.labelOk,
            labelCancel: payload.labelCancel
          }
        });
      }

    case _constants.HIDE_NOTIFICATION:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          notification: runTabInitialState.notification
        });
      }

    case _constants.SET_EXTERNAL_WEB3_ENDPOINT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          externalEndpoint: payload
        });
      }

    case _constants.DISPLAY_POPUP_MESSAGE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          popup: payload
        });
      }

    case _constants.HIDE_POPUP_MESSAGE:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          popup: ''
        });
      }

    case _constants.SET_PASSPHRASE:
      {
        const passphrase = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          passphrase
        });
      }

    case _constants.SET_MATCH_PASSPHRASE:
      {
        const passphrase = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          matchPassphrase: passphrase
        });
      }

    case _constants.FETCH_CONTRACT_LIST_REQUEST:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            isRequesting: true,
            isSuccessful: false,
            error: null
          })
        });
      }

    case _constants.FETCH_CONTRACT_LIST_SUCCESS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            contractList: _objectSpread(_objectSpread({}, state.contracts.contractList), payload),
            isSuccessful: true,
            isRequesting: false,
            error: null
          })
        });
      }

    case _constants.FETCH_CONTRACT_LIST_FAILED:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            isRequesting: false,
            isSuccessful: false,
            error: payload
          })
        });
      }

    case _constants.SET_CURRENT_CONTRACT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            currentContract: payload
          })
        });
      }

    case _constants.SET_LOAD_TYPE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            loadType: payload
          })
        });
      }

    case _constants.SET_CURRENT_FILE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            currentFile: payload,
            compilationCount: state.contracts.compilationCount + 1
          })
        });
      }

    case _constants.SET_IPFS_CHECKED_STATE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          ipfsChecked: payload
        });
      }

    case _constants.SET_GAS_PRICE_STATUS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          gasPriceStatus: payload
        });
      }

    case _constants.SET_CONFIRM_SETTINGS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          confirmSettings: payload
        });
      }

    case _constants.SET_MAX_FEE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          maxFee: payload
        });
      }

    case _constants.SET_MAX_PRIORITY_FEE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          maxPriorityFee: payload
        });
      }

    case _constants.SET_BASE_FEE_PER_GAS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          baseFeePerGas: payload
        });
      }

    case _constants.SET_GAS_PRICE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          gasPrice: payload
        });
      }

    case _constants.SET_TX_FEE_CONTENT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          txFeeContent: payload
        });
      }

    case _constants.ADD_INSTANCE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          instances: _objectSpread(_objectSpread({}, state.instances), {}, {
            instanceList: [...state.instances.instanceList, payload]
          })
        });
      }

    case _constants.REMOVE_INSTANCE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          instances: _objectSpread(_objectSpread({}, state.instances), {}, {
            instanceList: state.instances.instanceList.filter((_, index) => index !== payload)
          })
        });
      }

    case _constants.CLEAR_INSTANCES:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          instances: {
            instanceList: [],
            error: null
          }
        });
      }

    case _constants.SET_DECODED_RESPONSE:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          instances: _objectSpread(_objectSpread({}, state.instances), {}, {
            instanceList: state.instances.instanceList.map((instance, index) => {
              if (payload.instanceIndex === index) instance.decodedResponse[payload.funcIndex] = payload.response;
              return instance;
            })
          })
        });
      }

    case _constants.SET_PATH_TO_SCENARIO:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          recorder: _objectSpread(_objectSpread({}, state.recorder), {}, {
            pathToScenario: payload
          })
        });
      }

    case _constants.SET_RECORDER_COUNT:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          recorder: _objectSpread(_objectSpread({}, state.recorder), {}, {
            transactionCount: payload
          })
        });
      }

    case _constants.CLEAR_RECORDER_COUNT:
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          recorder: _objectSpread(_objectSpread({}, state.recorder), {}, {
            transactionCount: 0
          })
        });
      }

    case _constants.RESET_STATE:
      {
        return _objectSpread(_objectSpread({}, runTabInitialState), {}, {
          ipfsChecked: state.ipfsChecked
        });
      }

    case _constants.ADD_DEPLOY_OPTION:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            deployOptions: _objectSpread(_objectSpread({}, state.contracts.deployOptions), payload)
          })
        });
      }

    case _constants.REMOVE_DEPLOY_OPTION:
      {
        const payload = action.payload;
        const options = state.contracts.deployOptions;
        delete options[payload];
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            deployOptions: options
          })
        });
      }

    case _constants.SET_DEPLOY_OPTIONS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            deployOptions: payload
          })
        });
      }

    case _constants.SET_PROXY_ENV_ADDRESS:
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          contracts: _objectSpread(_objectSpread({}, state.contracts), {}, {
            proxyKey: payload
          })
        });
      }

    default:
      return state;
  }
};

exports.runTabReducer = runTabReducer;

/***/ }),
/* 1676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateSelectedContract = exports.storeNewScenario = exports.signMessage = exports.setUnitValue = exports.setTxFeeContent = exports.setSendValue = exports.setScenarioPath = exports.setPassphraseModal = exports.setNetworkName = exports.setMaxPriorityFee = exports.setMaxFee = exports.setMatchPassphraseModal = exports.setGasPriceStatus = exports.setGasPrice = exports.setGasFeeAmount = exports.setExecutionEnvironment = exports.setConfirmSettings = exports.setBaseFeePerGas = exports.setAccountAddress = exports.runScenario = exports.removeSingleInstance = exports.removeInstances = exports.loadFromAddress = exports.initRunTab = exports.hideToaster = exports.getFuncABIValues = exports.getExecutionContext = exports.fetchSelectedContract = exports.executeTransactions = exports.createNewInstance = exports.createNewAddress = void 0;

var _events = __webpack_require__(1677);

var _account = __webpack_require__(1402);

var _actions = __webpack_require__(1211);

var _deploy = __webpack_require__(1439);

var _recorder = __webpack_require__(1831);

// eslint-disable-next-line no-unused-vars
const _paq = window._paq = window._paq || []; //eslint-disable-line


let plugin, dispatch;

const initRunTab = udapp => async reducerDispatch => {
  plugin = udapp;
  dispatch = reducerDispatch;
  (0, _events.resetAndInit)(plugin);
  (0, _events.setupEvents)(plugin, dispatch);
  setInterval(() => {
    (0, _account.fillAccountsList)(plugin, dispatch);
  }, 1000);
};

exports.initRunTab = initRunTab;

const setAccountAddress = account => (0, _actions.setAccount)(dispatch, account);

exports.setAccountAddress = setAccountAddress;

const setUnitValue = unit => (0, _actions.setUnit)(dispatch, unit);

exports.setUnitValue = setUnitValue;

const setGasFeeAmount = value => (0, _actions.setGasFee)(dispatch, value);

exports.setGasFeeAmount = setGasFeeAmount;

const setExecutionEnvironment = executionContext => (0, _account.setExecutionContext)(plugin, dispatch, executionContext);

exports.setExecutionEnvironment = setExecutionEnvironment;

const hideToaster = () => (0, _actions.clearPopUp)(dispatch);

exports.hideToaster = hideToaster;

const createNewAddress = cbMessage => (0, _account.createNewBlockchainAccount)(plugin, dispatch, cbMessage);

exports.createNewAddress = createNewAddress;

const setPassphraseModal = passphrase => (0, _actions.setPassphrasePrompt)(dispatch, passphrase);

exports.setPassphraseModal = setPassphraseModal;

const setMatchPassphraseModal = passphrase => (0, _actions.setMatchPassphrasePrompt)(dispatch, passphrase);

exports.setMatchPassphraseModal = setMatchPassphraseModal;

const signMessage = (account, message, modalContent, passphrase) => (0, _account.signMessageWithAddress)(plugin, dispatch, account, message, modalContent, passphrase);

exports.signMessage = signMessage;

const fetchSelectedContract = (contractName, compiler) => (0, _deploy.getSelectedContract)(contractName, compiler);

exports.fetchSelectedContract = fetchSelectedContract;

const createNewInstance = async (selectedContract, gasEstimationPrompt, passphrasePrompt, publishToStorage, mainnetPrompt, isOverSizePrompt, args, deployMode) => (0, _deploy.createInstance)(plugin, dispatch, selectedContract, gasEstimationPrompt, passphrasePrompt, publishToStorage, mainnetPrompt, isOverSizePrompt, args, deployMode);

exports.createNewInstance = createNewInstance;

const setSendValue = value => (0, _actions.setSendTransactionValue)(dispatch, value);

exports.setSendValue = setSendValue;

const setBaseFeePerGas = baseFee => (0, _actions.updateBaseFeePerGas)(dispatch, baseFee);

exports.setBaseFeePerGas = setBaseFeePerGas;

const setConfirmSettings = confirmation => (0, _actions.updateConfirmSettings)(dispatch, confirmation);

exports.setConfirmSettings = setConfirmSettings;

const setGasPrice = price => (0, _actions.updateGasPrice)(dispatch, price);

exports.setGasPrice = setGasPrice;

const setGasPriceStatus = status => (0, _actions.updateGasPriceStatus)(dispatch, status);

exports.setGasPriceStatus = setGasPriceStatus;

const setMaxFee = fee => (0, _actions.updateMaxFee)(dispatch, fee);

exports.setMaxFee = setMaxFee;

const setMaxPriorityFee = fee => (0, _actions.updateMaxPriorityFee)(dispatch, fee);

exports.setMaxPriorityFee = setMaxPriorityFee;

const setTxFeeContent = content => (0, _actions.updateTxFeeContent)(dispatch, content);

exports.setTxFeeContent = setTxFeeContent;

const removeInstances = () => (0, _actions.clearInstances)(dispatch);

exports.removeInstances = removeInstances;

const removeSingleInstance = index => (0, _actions.removeInstance)(dispatch, index);

exports.removeSingleInstance = removeSingleInstance;

const getExecutionContext = () => (0, _deploy.getContext)(plugin);

exports.getExecutionContext = getExecutionContext;

const executeTransactions = (instanceIndex, lookupOnly, funcABI, inputsValues, contractName, contractABI, contract, address, logMsg, mainnetPrompt, gasEstimationPrompt, passphrasePrompt, funcIndex) => (0, _deploy.runTransactions)(plugin, dispatch, instanceIndex, lookupOnly, funcABI, inputsValues, contractName, contractABI, contract, address, logMsg, mainnetPrompt, gasEstimationPrompt, passphrasePrompt, funcIndex);

exports.executeTransactions = executeTransactions;

const loadFromAddress = (contract, address) => (0, _deploy.loadAddress)(plugin, dispatch, contract, address);

exports.loadFromAddress = loadFromAddress;

const storeNewScenario = async prompt => (0, _recorder.storeScenario)(plugin, dispatch, prompt);

exports.storeNewScenario = storeNewScenario;

const runScenario = (liveMode, gasEstimationPrompt, passphrasePrompt, confirmDialogContent) => (0, _recorder.runCurrentScenario)(liveMode, plugin, dispatch, gasEstimationPrompt, passphrasePrompt, confirmDialogContent);

exports.runScenario = runScenario;

const setScenarioPath = path => (0, _actions.updateScenarioPath)(dispatch, path);

exports.setScenarioPath = setScenarioPath;

const getFuncABIValues = funcABI => (0, _deploy.getFuncABIInputs)(plugin, funcABI);

exports.getFuncABIValues = getFuncABIValues;

const setNetworkName = networkName => (0, _actions.setNetworkNameFromProvider)(dispatch, networkName);

exports.setNetworkName = setNetworkName;

const updateSelectedContract = contractName => (0, _actions.setSelectedContract)(dispatch, contractName);

exports.updateSelectedContract = updateSelectedContract;

/***/ }),
/* 1677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupEvents = exports.resetAndInit = void 0;

var _helper = __webpack_require__(1121);

var _account = __webpack_require__(1402);

var _actions = __webpack_require__(1211);

var _payload = __webpack_require__(1188);

var _remixSolidity = __webpack_require__(1149);

var ethJSUtil = _interopRequireWildcard(__webpack_require__(34));

var _web = _interopRequireDefault(__webpack_require__(1125));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const setupEvents = (plugin, dispatch) => {
  plugin.blockchain.events.on('newTransaction', (tx, receipt) => {
    plugin.emit('newTransaction', tx, receipt);
  });
  plugin.blockchain.event.register('transactionExecuted', (error, from, to, data, lookupOnly, txResult) => {
    if (!lookupOnly) dispatch((0, _payload.setSendValue)('0'));
    if (error) return;
    (0, _account.updateAccountBalances)(plugin, dispatch);
  });
  plugin.blockchain.event.register('contextChanged', (context, silent) => {
    (0, _account.setFinalContext)(plugin, dispatch);
  });
  plugin.blockchain.event.register('networkStatus', ({
    error,
    network
  }) => {
    if (error) {
      const _netUI = 'can\'t detect network';
      (0, _actions.setNetworkNameFromProvider)(dispatch, _netUI);
      return;
    }

    const networkProvider = plugin.networkModule.getNetworkProvider.bind(plugin.networkModule);
    const netUI = networkProvider() !== 'vm' ? `${network.name} (${network.id || '-'}) network` : 'VM';
    (0, _actions.setNetworkNameFromProvider)(dispatch, netUI);
    if (network.name === 'VM') dispatch((0, _payload.setProxyEnvAddress)(plugin.config.get('vm/proxy')));else dispatch((0, _payload.setProxyEnvAddress)(plugin.config.get(`${network.name}/${network.currentFork}/${network.id}/proxy`)));
  });
  plugin.blockchain.event.register('addProvider', provider => (0, _actions.addExternalProvider)(dispatch, provider));
  plugin.blockchain.event.register('removeProvider', name => (0, _actions.removeExternalProvider)(dispatch, name));
  plugin.on('solidity', 'compilationFinished', (file, source, languageVersion, data, input, version) => broadcastCompilationResult(plugin, dispatch, file, source, languageVersion, data, input));
  plugin.on('vyper', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(plugin, dispatch, file, source, languageVersion, data));
  plugin.on('lexon', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(plugin, dispatch, file, source, languageVersion, data));
  plugin.on('yulp', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(plugin, dispatch, file, source, languageVersion, data));
  plugin.on('nahmii-compiler', 'compilationFinished', (file, source, languageVersion, data) => broadcastCompilationResult(plugin, dispatch, file, source, languageVersion, data));
  plugin.on('udapp', 'setEnvironmentModeReducer', (env, from) => {
    plugin.call('notification', 'toast', (0, _helper.envChangeNotification)(env, from));
    (0, _account.setExecutionContext)(plugin, dispatch, env);
  });
  plugin.on('udapp', 'clearAllInstancesReducer', () => {
    dispatch((0, _payload.clearAllInstances)());
  });
  plugin.on('udapp', 'addInstanceReducer', (address, abi, name) => {
    (0, _actions.addInstance)(dispatch, {
      abi,
      address,
      name
    });
  });
  plugin.on('filePanel', 'setWorkspace', () => {
    dispatch((0, _payload.resetUdapp)());
    resetAndInit(plugin);
  });
  plugin.fileManager.events.on('currentFileChanged', currentFile => {
    if (/.(.abi)$/.exec(currentFile)) {
      dispatch((0, _payload.setLoadType)('abi'));
    } else if (/.(.sol)$/.exec(currentFile) || /.(.vy)$/.exec(currentFile) || // vyper
    /.(.lex)$/.exec(currentFile) || // lexon
    /.(.contract)$/.exec(currentFile)) {
      dispatch((0, _payload.setLoadType)('sol'));
    } else {
      dispatch((0, _payload.setLoadType)('other'));
    }

    dispatch((0, _payload.setCurrentFile)(currentFile));
  });
  plugin.recorder.event.register('recorderCountChange', count => {
    dispatch((0, _payload.setRecorderCount)(count));
  });
  plugin.event.register('cleared', () => {
    dispatch((0, _payload.clearRecorderCount)());
  });
};

exports.setupEvents = setupEvents;

const broadcastCompilationResult = async (plugin, dispatch, file, source, languageVersion, data, input) => {
  // TODO check whether the tab is configured
  const compiler = new _remixSolidity.CompilerAbstract(languageVersion, data, source, input);
  plugin.compilersArtefacts[languageVersion] = compiler;
  plugin.compilersArtefacts.__last = compiler;
  const contracts = getCompiledContracts(compiler).map(contract => {
    return {
      name: languageVersion,
      alias: contract.name,
      file: contract.file,
      compiler
    };
  });
  const index = contracts.findIndex(contract => contract.alias === plugin.REACT_API.contracts.currentContract);
  if (index < 0 && contracts.length > 0) dispatch((0, _payload.setCurrentContract)(contracts[0].alias));
  const isUpgradeable = await plugin.call('openzeppelin-proxy', 'isConcerned', data.sources && data.sources[file] ? data.sources[file].ast : {});

  if (isUpgradeable) {
    const options = await plugin.call('openzeppelin-proxy', 'getProxyOptions', data, file);
    dispatch((0, _payload.addDeployOption)({
      [file]: options
    }));
  } else {
    dispatch((0, _payload.addDeployOption)({
      [file]: {}
    }));
  }

  dispatch((0, _payload.fetchContractListSuccess)({
    [file]: contracts
  }));
  dispatch((0, _payload.setCurrentFile)(file)); // TODO: set current contract
};

const getCompiledContracts = compiler => {
  const contracts = [];
  compiler.visitContracts(contract => {
    contracts.push(contract);
  });
  return contracts;
};

const resetAndInit = plugin => {
  plugin.blockchain.resetAndInit(plugin.config, {
    getAddress: cb => {
      cb(null, plugin.REACT_API.accounts.selectedAccount);
    },
    getValue: cb => {
      try {
        const number = plugin.REACT_API.sendValue;
        const unit = plugin.REACT_API.sendUnit;
        cb(null, _web.default.utils.toWei(number, unit));
      } catch (e) {
        cb(e);
      }
    },
    getGasLimit: cb => {
      try {
        const gasLimit = '0x' + new ethJSUtil.BN(plugin.REACT_API.gasLimit, 10).toString(16);
        cb(null, gasLimit);
      } catch (e) {
        cb(e.message);
      }
    }
  });
};

exports.resetAndInit = resetAndInit;

/***/ }),
/* 1678 */,
/* 1679 */,
/* 1680 */,
/* 1681 */,
/* 1682 */,
/* 1683 */,
/* 1684 */,
/* 1685 */,
/* 1686 */,
/* 1687 */,
/* 1688 */,
/* 1689 */,
/* 1690 */,
/* 1691 */,
/* 1692 */,
/* 1693 */,
/* 1694 */,
/* 1695 */,
/* 1696 */,
/* 1697 */,
/* 1698 */,
/* 1699 */,
/* 1700 */,
/* 1701 */,
/* 1702 */,
/* 1703 */,
/* 1704 */,
/* 1705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

class EventManager {
  constructor() {
    this.registered = {}; // eslint-disable-line

    this.anonymous = {}; // eslint-disable-line
  }
  /*
   * Unregister a listener.
   * Note that if obj is a function. the unregistration will be applied to the dummy obj {}.
   *
   * @param {String} eventName  - the event name
   * @param {Object or Func} obj - object that will listen on this event
   * @param {Func} func         - function of the listeners that will be executed
  */


  unregister(eventName, obj, func) {
    if (!this.registered[eventName]) {
      return;
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    for (const reg in this.registered[eventName]) {
      if (this.registered[eventName][reg].obj === obj && this.registered[eventName][reg].func.toString() === func.toString()) {
        this.registered[eventName].splice(reg, 1);
      }
    }
  }
  /*
   * Register a new listener.
   * Note that if obj is a function, the function registration will be associated with the dummy object {}
   *
   * @param {String} eventName  - the event name
   * @param {Object or Func} obj - object that will listen on this event
   * @param {Func} func         - function of the listeners that will be executed
  */


  register(eventName, obj, func) {
    if (!this.registered[eventName]) {
      this.registered[eventName] = [];
    }

    if (obj instanceof Function) {
      func = obj;
      obj = this.anonymous;
    }

    this.registered[eventName].push({
      obj: obj,
      func: func
    });
  }
  /*
   * trigger event.
   * Every listener have their associated function executed
   *
   * @param {String} eventName  - the event name
   * @param {Array}j - argument that will be passed to the executed function.
  */


  trigger(eventName, args) {
    if (!this.registered[eventName]) {
      return;
    }

    for (const listener in this.registered[eventName]) {
      const l = this.registered[eventName][listener];
      if (l.func) l.func.apply(l.obj === this.anonymous ? {} : l.obj, args);
    }
  }

}

exports.default = EventManager;

/***/ }),
/* 1706 */,
/* 1707 */,
/* 1708 */,
/* 1709 */,
/* 1710 */,
/* 1711 */,
/* 1712 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1713 */,
/* 1714 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1715 */,
/* 1716 */,
/* 1717 */,
/* 1718 */,
/* 1719 */,
/* 1720 */,
/* 1721 */,
/* 1722 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const solc = __webpack_require__(1280);

let compileJSON = input => {
  return '';
};

const missingInputs = []; // 'DedicatedWorkerGlobalScope' object (the Worker global scope) is accessible through the self keyword
// 'dom' and 'webworker' library files can't be included together https://github.com/microsoft/TypeScript/issues/20595

function default_1(self) {
  self.addEventListener('message', e => {
    const data = e.data;

    switch (data.cmd) {
      case 'loadVersion':
        {
          delete self.Module; // NOTE: workaround some browsers?

          self.Module = undefined;
          compileJSON = null; // importScripts() method of synchronously imports one or more scripts into the worker's scope

          self.importScripts(data.data);
          const compiler = solc(self.Module);

          compileJSON = input => {
            try {
              const missingInputsCallback = path => {
                missingInputs.push(path);
                return {
                  error: 'Deferred import'
                };
              };

              return compiler.compile(input, {
                import: missingInputsCallback
              });
            } catch (exception) {
              return JSON.stringify({
                error: 'Uncaught JavaScript exception:\n' + exception
              });
            }
          };

          self.postMessage({
            cmd: 'versionLoaded',
            data: compiler.version()
          });
          break;
        }

      case 'compile':
        missingInputs.length = 0;

        if (data.input && compileJSON) {
          self.postMessage({
            cmd: 'compiled',
            job: data.job,
            data: compileJSON(data.input),
            input: data.input,
            missingInputs: missingInputs
          });
        }

        break;
    }
  }, false);
}

exports.default = default_1;

/***/ }),
/* 1723 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compile = void 0;

const tslib_1 = __webpack_require__(23);

const compiler_utils_1 = __webpack_require__(1420);

const compiler_abstract_1 = __webpack_require__(1421);

const compiler_1 = __webpack_require__(1403);

const compile = (compilationTargets, settings, contentResolverCallback) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
  const res = yield (() => {
    return new Promise((resolve, reject) => {
      const compiler = new compiler_1.Compiler(contentResolverCallback);
      compiler.set('evmVersion', settings.evmVersion);
      compiler.set('optimize', settings.optimize);
      compiler.set('language', settings.language);
      compiler.set('runs', settings.runs);
      compiler.loadVersion((0, compiler_utils_1.canUseWorker)(settings.version), (0, compiler_utils_1.urlFromVersion)(settings.version));
      compiler.event.register('compilationFinished', (success, compilationData, source, input, version) => {
        resolve(new compiler_abstract_1.CompilerAbstract(settings.version, compilationData, source, input));
      });
      compiler.event.register('compilerLoaded', _ => compiler.compile(compilationTargets, ''));
    });
  })();
  return res;
});

exports.compile = compile;

/***/ }),
/* 1724 */,
/* 1725 */,
/* 1726 */,
/* 1727 */,
/* 1728 */,
/* 1729 */,
/* 1730 */,
/* 1731 */,
/* 1732 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1733 */,
/* 1734 */,
/* 1735 */,
/* 1736 */,
/* 1737 */,
/* 1738 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1739 */,
/* 1740 */,
/* 1741 */,
/* 1742 */,
/* 1743 */,
/* 1744 */,
/* 1745 */,
/* 1746 */,
/* 1747 */,
/* 1748 */,
/* 1749 */,
/* 1750 */,
/* 1751 */,
/* 1752 */,
/* 1753 */,
/* 1754 */,
/* 1755 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1756 */,
/* 1757 */,
/* 1758 */,
/* 1759 */,
/* 1760 */,
/* 1761 */,
/* 1762 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1763 */,
/* 1764 */,
/* 1765 */,
/* 1766 */,
/* 1767 */,
/* 1768 */,
/* 1769 */,
/* 1770 */,
/* 1771 */,
/* 1772 */,
/* 1773 */,
/* 1774 */,
/* 1775 */,
/* 1776 */,
/* 1777 */,
/* 1778 */,
/* 1779 */,
/* 1780 */,
/* 1781 */,
/* 1782 */,
/* 1783 */,
/* 1784 */,
/* 1785 */,
/* 1786 */,
/* 1787 */,
/* 1788 */,
/* 1789 */,
/* 1790 */,
/* 1791 */,
/* 1792 */,
/* 1793 */,
/* 1794 */,
/* 1795 */,
/* 1796 */,
/* 1797 */,
/* 1798 */,
/* 1799 */,
/* 1800 */,
/* 1801 */,
/* 1802 */,
/* 1803 */,
/* 1804 */,
/* 1805 */,
/* 1806 */,
/* 1807 */,
/* 1808 */,
/* 1809 */,
/* 1810 */,
/* 1811 */,
/* 1812 */,
/* 1813 */,
/* 1814 */,
/* 1815 */,
/* 1816 */,
/* 1817 */,
/* 1818 */,
/* 1819 */,
/* 1820 */,
/* 1821 */,
/* 1822 */,
/* 1823 */,
/* 1824 */,
/* 1825 */,
/* 1826 */,
/* 1827 */,
/* 1828 */,
/* 1829 */,
/* 1830 */,
/* 1831 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.storeScenario = exports.runCurrentScenario = void 0;

var _helper = __webpack_require__(1121);

var _actions = __webpack_require__(1211);

var _deploy = __webpack_require__(1439);

var _payload = __webpack_require__(1188);

const saveScenario = async (plugin, newPath, provider, promptCb, cb) => {
  const txJSON = JSON.stringify(plugin.recorder.getAll(), null, 2);
  promptCb(async () => {
    try {
      await provider.set(newPath, txJSON);
      await plugin.fileManager.open(newPath);
    } catch (error) {
      if (error) return cb('Failed to create file. ' + newPath + ' ' + error);
    }
  });
};

const storeScenario = async (plugin, dispatch, prompt) => {
  const path = plugin.fileManager.currentPath();
  const fileProvider = await plugin.fileManager.fileProviderOf(path);
  if (!fileProvider) return (0, _payload.displayNotification)('Alert', 'Invalid File Provider', 'OK', null);
  const newPath = await (0, _helper.createNonClashingNameAsync)(path + '/' + plugin.REACT_API.recorder.pathToScenario, plugin.fileManager);
  const newName = (0, _helper.extractNameFromKey)(newPath);
  saveScenario(plugin, newPath, fileProvider, cb => {
    dispatch((0, _payload.displayNotification)('Save transactions as scenario', prompt('Transactions will be saved in a file under ' + path, newName), 'OK', 'Cancel', cb, null));
  }, error => {
    if (error) return dispatch((0, _payload.displayNotification)('Alert', error, 'OK', null));
  });
};

exports.storeScenario = storeScenario;

const runScenario = (liveMode, plugin, dispatch, file, gasEstimationPrompt, passphrasePrompt, confirmDialogContent) => {
  if (!file) return dispatch((0, _payload.displayNotification)('Alert', 'Unable to run scenerio, no specified scenario file', 'OK', null));
  plugin.fileManager.readFile(file).then(json => {
    // TODO: there is still a UI dependency to remove here, it's still too coupled at this point to remove easily
    plugin.recorder.runScenario(liveMode, json, (error, continueTxExecution, cancelCb) => {
      (0, _deploy.continueHandler)(dispatch, gasEstimationPrompt, error, continueTxExecution, cancelCb);
    }, (okCb, cancelCb) => {
      (0, _deploy.promptHandler)(dispatch, passphrasePrompt, okCb, cancelCb);
    }, msg => {
      dispatch((0, _payload.displayNotification)('Alert', msg, 'OK', null));
    }, (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      (0, _deploy.confirmationHandler)(plugin, dispatch, confirmDialogContent, network, tx, gasEstimation, continueTxExecution, cancelCb);
    }, msg => {
      const log = (0, _helper.logBuilder)(msg);
      return (0, _deploy.terminalLogger)(plugin, log);
    }, (error, abi, address, contractName) => {
      if (error) {
        return dispatch((0, _payload.displayNotification)('Alert', error, 'OK', null));
      }

      (0, _actions.addInstance)(dispatch, {
        name: contractName,
        address,
        abi
      });
    });
  }).catch(error => dispatch((0, _payload.displayNotification)('Alert', error, 'OK', null)));
};

const runCurrentScenario = (liveMode, plugin, dispatch, gasEstimationPrompt, passphrasePrompt, confirmDialogContent) => {
  const file = plugin.config.get('currentFile');
  if (!file) return dispatch((0, _payload.displayNotification)('Alert', 'A scenario file has to be selected', 'Ok', null));
  runScenario(liveMode, plugin, dispatch, file, gasEstimationPrompt, passphrasePrompt, confirmDialogContent);
};

exports.runCurrentScenario = runCurrentScenario;

/***/ }),
/* 1832 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(1833);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 1833 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".udapp_runTabView {\n  display: flex;\n  flex-direction: column;\n}\n.udapp_runTabView::-webkit-scrollbar {\n  display: none;\n}\n.udapp_settings {\n  padding: 0 24px 16px;\n}\n.udapp_crow {\n  display: block;\n  margin-top: 8px;\n}\n.udapp_col1 {\n  width: 30%;\n  float: left;\n  align-self: center;\n}\n.udapp_settingsLabel {\n  font-size: 11px;\n  margin-bottom: 4px;\n  text-transform: uppercase;\n}\n.udapp_environment {\n  display: flex;\n  align-items: center;\n  position: relative;\n  width: 100%;\n}\n.udapp_environment a {\n  margin-left: 7px;\n}\n.udapp_account {\n  display: flex;\n  align-items: center;\n}\n.udapp_account i {\n  margin-left: 12px;\n}\n.udapp_col2 {\n  border-radius: 3px;\n}\n.udapp_col2_1 {\n  width: 164px;\n  min-width: 164px;\n}\n.udapp_col2_2 {\n}\n.udapp_select {\n  font-weight: normal;\n  width: 100%;\n  overflow: hidden;\n}\n.udapp_instanceContainer {\n  display: flex;\n  flex-direction: column;\n  margin-bottom: 2%;\n  border: none;\n  text-align: center;\n  padding: 0 14px 16px;\n}\n.udapp_deployedContracts {\n  font-size: 1rem;\n}\n.udapp_pendingTxsContainer  {\n  display: flex;\n  flex-direction: column;\n  margin-top: 2%;\n  border: none;\n  text-align: center;\n}\n.udapp_container {\n  padding: 0 24px 16px;\n}\n.udapp_contractNames {\n  width: 100%;\n  border: 1px solid\n}\n.udapp_subcontainer {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  margin-bottom: 8px;\n}\n.udapp_subcontainer i {\n  width: 16px;\n  display: flex;\n  justify-content: center;\n  margin-left: 1px;\n}\n.udapp_button button{\n  flex: none;\n}\n.udapp_button {\n  display: flex;\n  align-items: center;\n  margin-top: 13px;\n}\n.udapp_transaction {\n}\n.udapp_atAddress {\n  margin: 0;\n  min-width: 100px;\n  width: 100px;\n  height: 100%;\n  word-break: inherit;\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right: 0;\n}\n.udapp_atAddressSect {\n  margin-top: 8px;\n  height: 32px;\n}\n.udapp_atAddressSect input {\n  height: 32px;\n  border-top-left-radius: 0 !important;\n  border-bottom-left-radius: 0 !important;\n}\n.udapp_ataddressinput {\n  padding: .25rem;\n}\n.udapp_recorderSection:hover {\n  cursor: pointer;\n}\n.udapp_recorderSectionLabel:hover {\n  cursor: pointer;\n}\n.udapp_recorderSectionLabel {\n  cursor: pointer;\n  font-size: 1rem;\n}\n.udapp_input {\n  font-size: 10px !important;\n}\n.udapp_noInstancesText {\n  font-style: italic;\n  text-align: left;\n  padding-left: 15px;\n}\n.udapp_pendingTxsText {\n  font-style: italic;\n  display: flex;\n  justify-content: space-evenly;\n  align-items: center;\n  flex-wrap: wrap;\n}\n.udapp_item {\n  margin-right: 1em;\n  display: flex;\n  align-items: center;\n}\n.udapp_pendingContainer {\n  display: flex;\n  align-items: baseline;\n}\n.udapp_pending {\n  height: 25px;\n  text-align: center;\n  padding-left: 10px;\n  border-radius: 3px;\n  margin-left: 5px;\n}\n.udapp_disableMouseEvents {\n  pointer-events: none;\n}\n.udapp_icon {\n  cursor: pointer;\n  font-size: 12px;\n  cursor: pointer;\n  margin-left: 5px;\n}\n.udapp_icon:hover {\n  font-size: 12px;\n  color: var(--warning);\n}\n.udapp_errorIcon {\n  color: var(--warning);\n  margin-left: 15px;\n}\n.udapp_failDesc {\n  color: var(--warning);\n  padding-left: 10px;\n  display: inline;\n}\n.udapp_network {\n  margin-left: 8px;\n  pointer-events: none;\n}\n.udapp_networkItem {\n  margin-right: 5px;\n}\n.udapp_transactionActions {\n  display: flex;\n  justify-content: space-evenly;\n  width: 145px;\n}\n.udapp_orLabel {\n  text-align: center;\n  text-transform: uppercase;\n}\n.udapp_infoDeployAction {\n  margin-left: 1px;\n  font-size: 13px;\n  color: var(--info);\n}\n.udapp_gasValueContainer {\n  flex-direction: row;\n  display: flex;\n}\n.udapp_gasNval {\n  width: 55%;\n  font-size: 0.8rem;\n}\n.udapp_gasNvalUnit {\n  width: 41%;\n  margin-left: 10px;\n  font-size: 0.8rem;\n}\n.udapp_deployDropdown {\n  text-align: center;\n  text-transform: uppercase;\n}\n.udapp_checkboxAlign {\n  padding-top: 2px;\n}\n.udapp_instanceTitleContainer {\n  display: flex;\n  align-items: center;\n}\n.udapp_calldataInput{\n  height: 32px;\n}\n.udapp_title {\n  display: flex;\n  justify-content: space-between;\n  font-size: 11px;\n  width: 100%;\n  overflow: hidden;\n  word-break: break-word;\n  line-height: initial;\n  overflow: visible;\n  padding: 0 0 8px;\n  margin: 0;\n  background: none;\n  border: none;\n}\n.udapp_title button {\n  background: none;\n  border: none;\n}\n.udapp_titleLine {\n  display: flex;\n  align-items: baseline;\n}\n.udapp_titleText {\n  word-break: break-word;\n  width: 100%;\n  border: none;\n  overflow: hidden;\n}\n.udapp_spanTitleText {\n  line-height: 12px;\n  padding: 0;\n  font-size: 11px;\n  width:100%;\n  border: none;\n  background: none;\n  text-transform: uppercase;\n  overflow: hidden;\n}\n.udapp_inputGroupText {\n  width: 100%;\n}\n.udapp_title .udapp_copy {\n  color: var(--primary);\n}\n.udapp_titleExpander {\n  margin-top: 2px;\n}\n.udapp_nameNbuts {\n  display: contents;\n  flex-wrap: nowrap;\n  width: 100%;\n}\n.udapp_instance {\n  display: block;\n  flex-direction: column;\n  background: none;\n  border-radius: 2px;\n}\n.udapp_instance.udapp_hidesub {\n  border-bottom: 1px solid;\n}\n.udapp_instance.udapp_hidesub .udapp_title {\n    display: flex;\n}\n.udapp_instance.udapp_hidesub .udapp_udappClose {\n    display: flex;\n}\n.udapp_instance.udapp_hidesub > * {\n  display: none;\n}\n.udapp_methCaret {\n  min-width: 12px;\n  width: 12px;\n  margin-left: 4px;\n  cursor: pointer;\n  font-size: 16px;\n  line-height: 0.6;\n  vertical-align: middle;\n  padding: 0;\n}\n.udapp_cActionsWrapper {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0.25rem;\n  border-top-rightt-radius: 0;\n  border-bottom-right-radius: 0.25rem;\n  padding: 8px 10px 7px;\n}\n.udapp_group:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n.udapp_buttonsContainer {\n  margin-top: 2%;\n  display: flex;\n  overflow: hidden;\n}\n.udapp_instanceButton {\n  height: 32px;\n  border-radius: 3px;\n  white-space: nowrap;\n  font-size: 11px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.udapp_closeIcon {\n  font-size: 12px;\n  cursor: pointer;\n  margin-left: 5px;\n}\n.udapp_udappClose {\n  display: flex;\n  justify-content: flex-end;\n}\n.udapp_contractProperty {\n  width:100%;\n}\n.udapp_contractProperty.udapp_hasArgs input {\n  padding: .36em;\n  border-radius: 5px;\n}\n.udapp_contractProperty .udapp_contractActionsContainerSingle input{\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.udapp_contractProperty button {\n  min-width: 100px;\n  width: 100px;\n  margin:0;\n  word-break: inherit;\n}\n.udapp_contractProperty button:disabled {\n  cursor: not-allowed;\n  background-color: white;\n  border-color: lightgray;\n}\n.udapp_contractProperty.udapp_constant button {\n  min-width: 100px;\n  width: 100px;\n  margin:0;\n  word-break: inherit;\n  outline: none;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.udapp_contractProperty > .udapp_value {\n  box-sizing: border-box;\n  float: left;\n  align-self: center;\n  margin-left: 4px;\n}\n.udapp_contractActionsContainer {\n  width: 100%;\n  margin-bottom: 8px;\n}\n.udapp_contractActionsContainerSingle {\n  display: flex;\n  width: 100%;\n}\n.udapp_contractActionsContainerSingle i {\n  line-height: 2;\n}\n.udapp_contractActionsContainerMulti {\n  display:none;\n  width: 100%;\n}\n.udapp_contractActionsContainerMultiInner {\n  width: 100%;\n  border-radius: 3px;\n  margin-bottom: 8px;\n}\n.udapp_multiHeader {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 8px;\n  text-align: left;\n  font-size: 10px;\n  font-weight: bold;\n}\n.udapp_contractActionsContainerMultiInner .udapp_multiTitle {\n  padding-left: 10px;\n}\n.udapp_contractProperty .udapp_multiTitle {\n  padding: 0;\n  line-height: 16px;\n  display: inline-block;\n  font-size: 12px;\n  font-weight: bold;\n  cursor: default;\n}\n.udapp_contractProperty .udapp_contractActionsContainerMultiInner .udapp_multiArg label{\n  text-align: right;\n}\n.udapp_multiHeader .udapp_methCaret {\n  float: right;\n  margin-right: 0;\n}\n.udapp_contractProperty.udapp_constant .udapp_multiTitle {\n  display: inline-block;\n  width: 90%;\n  /* font-size: 10px; */\n  height: 25px;\n  padding-left: 20px;\n  font-weight: bold;\n  line-height: 25px;\n  cursor: default;\n}\n.udapp_multiArg {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  margin-top: 4px;\n}\n.udapp_multiArg input{\n  padding: 5px;\n}\n.udapp_multiArg label {\n  width: auto;\n  padding: 0;\n  margin: 0 4px 0 0;\n  font-size: 10px;\n  line-height: 12px;\n  text-align: right;\n  word-break: initial;\n}\n.udapp_multiArg button {\n  max-width: 100px;\n  border-radius: 3px;\n  border-width: 1px;\n  width: inherit;\n}\n.udapp_multiHeader button {\n  display: inline-block;\n  width: 94%;\n}\n.udapp_hasArgs .udapp_multiArg input {\n  border-left: 1px solid #dddddd;\n  width: 67%;\n}\n.udapp_hasArgs input {\n  display: block;\n  height: 32px;\n  border: 1px solid #dddddd;\n  padding: .36em;\n  border-left: none;\n  padding: 8px 8px 8px 10px;\n  font-size: 10px !important;\n}\n.udapp_hasArgs button {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right: 0;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 11px;\n}\n.udapp_hasArgs .udapp_contractActionsContainerMulti button {\n  border-radius: 3px;\n}\n.udapp_contractActionsContainerMultiInner .udapp_multiArg i {\n  padding-right: 10px;\n}\n.udapp_hideWarningsContainer {\n  display: flex;\n  align-items: center;\n  margin-left: 2%\n}\n#confirmsetting {\n  z-index: 1;\n}\n.udapp_wrapword {\n  white-space: pre-wrap;       /* Since CSS 2.1 */\n  white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n  white-space: -pre-wrap;      /* Opera 4-6 */\n  white-space: -o-pre-wrap;    /* Opera 7 */\n  word-wrap: break-word;       /* Internet Explorer 5.5+ */\n}\n.deploy-items {\n  padding: 0.25rem 0.25rem;\n  border-radius: .25rem;\n}\n.deploy-items a {\n  border-radius: .25rem;\n  text-transform: none;\n  text-decoration: none;\n  font-weight: normal;\n  font-size: .8rem;\n  padding: 0.25rem 0.25rem;\n  width:auto;\n}\n.dropdown-item.hover, .dropdown-item:hover {\n  color: #fff;\n  text-decoration: none;\n  background-color: #007aa6;\n}\n.udapp_selectExEnvOptions {\n  width: 100%;\n}\n\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ1bi10YWIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsYUFBYTtFQUNiLHNCQUFzQjtBQUN4QjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxvQkFBb0I7QUFDdEI7QUFDQTtFQUNFLGNBQWM7RUFDZCxlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxVQUFVO0VBQ1YsV0FBVztFQUNYLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQix5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLFdBQVc7QUFDYjtBQUNBO0VBQ0UsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UsWUFBWTtFQUNaLGdCQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtFQUNFLG1CQUFtQjtFQUNuQixXQUFXO0VBQ1gsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLGlCQUFpQjtFQUNqQixZQUFZO0VBQ1osa0JBQWtCO0VBQ2xCLG9CQUFvQjtBQUN0QjtBQUNBO0VBQ0UsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixjQUFjO0VBQ2QsWUFBWTtFQUNaLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0Usb0JBQW9CO0FBQ3RCO0FBQ0E7RUFDRSxXQUFXO0VBQ1g7QUFDRjtBQUNBO0VBQ0UsYUFBYTtFQUNiLG1CQUFtQjtFQUNuQixtQkFBbUI7RUFDbkIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsYUFBYTtFQUNiLHVCQUF1QjtFQUN2QixnQkFBZ0I7QUFDbEI7QUFDQTtFQUNFLFVBQVU7QUFDWjtBQUNBO0VBQ0UsYUFBYTtFQUNiLG1CQUFtQjtFQUNuQixnQkFBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixZQUFZO0VBQ1osbUJBQW1CO0VBQ25CLDBCQUEwQjtFQUMxQiw2QkFBNkI7RUFDN0IsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsZUFBZTtFQUNmLFlBQVk7QUFDZDtBQUNBO0VBQ0UsWUFBWTtFQUNaLG9DQUFvQztFQUNwQyx1Q0FBdUM7QUFDekM7QUFDQTtFQUNFLGVBQWU7QUFDakI7QUFDQTtFQUNFLGVBQWU7QUFDakI7QUFBQztFQUNDLGVBQWU7QUFDakI7QUFDQTtFQUNFLGVBQWU7RUFDZixlQUFlO0FBQ2pCO0FBQ0E7RUFDRSwwQkFBMEI7QUFDNUI7QUFDQTtFQUNFLGtCQUFrQjtFQUNsQixnQkFBZ0I7RUFDaEIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxrQkFBa0I7RUFDbEIsYUFBYTtFQUNiLDZCQUE2QjtFQUM3QixtQkFBbUI7RUFDbkIsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsaUJBQWlCO0VBQ2pCLGFBQWE7RUFDYixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGFBQWE7RUFDYixxQkFBcUI7QUFDdkI7QUFDQTtFQUNFLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQixnQkFBZ0I7QUFDbEI7QUFDQTtFQUNFLG9CQUFvQjtBQUN0QjtBQUNBO0VBQ0UsZUFBZTtFQUNmLGVBQWU7RUFDZixlQUFlO0VBQ2YsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxlQUFlO0VBQ2YscUJBQXFCO0FBQ3ZCO0FBQ0E7RUFDRSxxQkFBcUI7RUFDckIsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxxQkFBcUI7RUFDckIsa0JBQWtCO0VBQ2xCLGVBQWU7QUFDakI7QUFDQTtFQUNFLGdCQUFnQjtFQUNoQixvQkFBb0I7QUFDdEI7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsYUFBYTtFQUNiLDZCQUE2QjtFQUM3QixZQUFZO0FBQ2Q7QUFDQTtFQUNFLGtCQUFrQjtFQUNsQix5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2Ysa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxtQkFBbUI7RUFDbkIsYUFBYTtBQUNmO0FBQ0E7RUFDRSxVQUFVO0VBQ1YsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxVQUFVO0VBQ1YsaUJBQWlCO0VBQ2pCLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLHlCQUF5QjtBQUMzQjtBQUNBO0VBQ0UsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxZQUFZO0FBQ2Q7QUFDQTtFQUNFLGFBQWE7RUFDYiw4QkFBOEI7RUFDOUIsZUFBZTtFQUNmLFdBQVc7RUFDWCxnQkFBZ0I7RUFDaEIsc0JBQXNCO0VBQ3RCLG9CQUFvQjtFQUNwQixpQkFBaUI7RUFDakIsZ0JBQWdCO0VBQ2hCLFNBQVM7RUFDVCxnQkFBZ0I7RUFDaEIsWUFBWTtBQUNkO0FBQ0E7RUFDRSxnQkFBZ0I7RUFDaEIsWUFBWTtBQUNkO0FBQ0E7RUFDRSxhQUFhO0VBQ2IscUJBQXFCO0FBQ3ZCO0FBQ0E7RUFDRSxzQkFBc0I7RUFDdEIsV0FBVztFQUNYLFlBQVk7RUFDWixnQkFBZ0I7QUFDbEI7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQixVQUFVO0VBQ1YsZUFBZTtFQUNmLFVBQVU7RUFDVixZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLHlCQUF5QjtFQUN6QixnQkFBZ0I7QUFDbEI7QUFDQTtFQUNFLFdBQVc7QUFDYjtBQUNBO0VBQ0UscUJBQXFCO0FBQ3ZCO0FBQ0E7RUFDRSxlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxpQkFBaUI7RUFDakIsaUJBQWlCO0VBQ2pCLFdBQVc7QUFDYjtBQUNBO0VBQ0UsY0FBYztFQUNkLHNCQUFzQjtFQUN0QixnQkFBZ0I7RUFDaEIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSx3QkFBd0I7QUFDMUI7QUFDQTtJQUNJLGFBQWE7QUFDakI7QUFDQTtJQUNJLGFBQWE7QUFDakI7QUFDQTtFQUNFLGFBQWE7QUFDZjtBQUNBO0VBQ0UsZUFBZTtFQUNmLFdBQVc7RUFDWCxnQkFBZ0I7RUFDaEIsZUFBZTtFQUNmLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsc0JBQXNCO0VBQ3RCLFVBQVU7QUFDWjtBQUNBO0VBQ0UseUJBQXlCO0VBQ3pCLGtDQUFrQztFQUNsQywyQkFBMkI7RUFDM0IsbUNBQW1DO0VBQ25DLHFCQUFxQjtBQUN2QjtBQUNBO0VBQ0UsV0FBVztFQUNYLGNBQWM7RUFDZCxXQUFXO0FBQ2I7QUFDQTtFQUNFLGNBQWM7RUFDZCxhQUFhO0VBQ2IsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxZQUFZO0VBQ1osa0JBQWtCO0VBQ2xCLG1CQUFtQjtFQUNuQixlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLHVCQUF1QjtBQUN6QjtBQUNBO0VBQ0UsZUFBZTtFQUNmLGVBQWU7RUFDZixnQkFBZ0I7QUFDbEI7QUFDQTtFQUNFLGFBQWE7RUFDYix5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLFVBQVU7QUFDWjtBQUNBO0VBQ0UsY0FBYztFQUNkLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UseUJBQXlCO0VBQ3pCLDRCQUE0QjtBQUM5QjtBQUNBO0VBQ0UsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixRQUFRO0VBQ1IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxtQkFBbUI7RUFDbkIsdUJBQXVCO0VBQ3ZCLHVCQUF1QjtBQUN6QjtBQUNBO0VBQ0UsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixRQUFRO0VBQ1IsbUJBQW1CO0VBQ25CLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsZ0JBQWdCO0VBQ2hCLHVCQUF1QjtBQUN6QjtBQUNBO0VBQ0Usc0JBQXNCO0VBQ3RCLFdBQVc7RUFDWCxrQkFBa0I7RUFDbEIsZ0JBQWdCO0FBQ2xCO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsV0FBVztBQUNiO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxZQUFZO0VBQ1osV0FBVztBQUNiO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsa0JBQWtCO0VBQ2xCLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UsYUFBYTtFQUNiLDhCQUE4QjtFQUM5QixtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLFVBQVU7RUFDVixpQkFBaUI7RUFDakIscUJBQXFCO0VBQ3JCLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxZQUFZO0VBQ1osZUFBZTtBQUNqQjtBQUNBO0VBQ0UscUJBQXFCO0VBQ3JCLFVBQVU7RUFDVixxQkFBcUI7RUFDckIsWUFBWTtFQUNaLGtCQUFrQjtFQUNsQixpQkFBaUI7RUFDakIsaUJBQWlCO0VBQ2pCLGVBQWU7QUFDakI7QUFDQTtFQUNFLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIseUJBQXlCO0VBQ3pCLGVBQWU7QUFDakI7QUFDQTtFQUNFLFlBQVk7QUFDZDtBQUNBO0VBQ0UsV0FBVztFQUNYLFVBQVU7RUFDVixpQkFBaUI7RUFDakIsZUFBZTtFQUNmLGlCQUFpQjtFQUNqQixpQkFBaUI7RUFDakIsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxnQkFBZ0I7RUFDaEIsa0JBQWtCO0VBQ2xCLGlCQUFpQjtFQUNqQixjQUFjO0FBQ2hCO0FBQ0E7RUFDRSxxQkFBcUI7RUFDckIsVUFBVTtBQUNaO0FBQ0E7RUFDRSw4QkFBOEI7RUFDOUIsVUFBVTtBQUNaO0FBQ0E7RUFDRSxjQUFjO0VBQ2QsWUFBWTtFQUNaLHlCQUF5QjtFQUN6QixjQUFjO0VBQ2QsaUJBQWlCO0VBQ2pCLHlCQUF5QjtFQUN6QiwwQkFBMEI7QUFDNUI7QUFDQTtFQUNFLDBCQUEwQjtFQUMxQiw2QkFBNkI7RUFDN0IsZUFBZTtFQUNmLG1CQUFtQjtFQUNuQixnQkFBZ0I7RUFDaEIsdUJBQXVCO0VBQ3ZCLGVBQWU7QUFDakI7QUFDQTtFQUNFLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CO0FBQ0Y7QUFDQTtFQUNFLFVBQVU7QUFDWjtBQUNBO0VBQ0UscUJBQXFCLFFBQVEsa0JBQWtCO0VBQy9DLDBCQUEwQixHQUFHLHdCQUF3QjtFQUNyRCxzQkFBc0IsT0FBTyxjQUFjO0VBQzNDLHdCQUF3QixLQUFLLFlBQVk7RUFDekMscUJBQXFCLFFBQVEsMkJBQTJCO0FBQzFEO0FBQ0E7RUFDRSx3QkFBd0I7RUFDeEIscUJBQXFCO0FBQ3ZCO0FBQ0E7RUFDRSxxQkFBcUI7RUFDckIsb0JBQW9CO0VBQ3BCLHFCQUFxQjtFQUNyQixtQkFBbUI7RUFDbkIsZ0JBQWdCO0VBQ2hCLHdCQUF3QjtFQUN4QixVQUFVO0FBQ1o7QUFDQTtFQUNFLFdBQVc7RUFDWCxxQkFBcUI7RUFDckIseUJBQXlCO0FBQzNCO0FBQ0E7RUFDRSxXQUFXO0FBQ2IiLCJmaWxlIjoicnVuLXRhYi5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIudWRhcHBfcnVuVGFiVmlldyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG4udWRhcHBfcnVuVGFiVmlldzo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICBkaXNwbGF5OiBub25lO1xufVxuLnVkYXBwX3NldHRpbmdzIHtcbiAgcGFkZGluZzogMCAyNHB4IDE2cHg7XG59XG4udWRhcHBfY3JvdyB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtYXJnaW4tdG9wOiA4cHg7XG59XG4udWRhcHBfY29sMSB7XG4gIHdpZHRoOiAzMCU7XG4gIGZsb2F0OiBsZWZ0O1xuICBhbGlnbi1zZWxmOiBjZW50ZXI7XG59XG4udWRhcHBfc2V0dGluZ3NMYWJlbCB7XG4gIGZvbnQtc2l6ZTogMTFweDtcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xufVxuLnVkYXBwX2Vudmlyb25tZW50IHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbn1cbi51ZGFwcF9lbnZpcm9ubWVudCBhIHtcbiAgbWFyZ2luLWxlZnQ6IDdweDtcbn1cbi51ZGFwcF9hY2NvdW50IHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi51ZGFwcF9hY2NvdW50IGkge1xuICBtYXJnaW4tbGVmdDogMTJweDtcbn1cbi51ZGFwcF9jb2wyIHtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xufVxuLnVkYXBwX2NvbDJfMSB7XG4gIHdpZHRoOiAxNjRweDtcbiAgbWluLXdpZHRoOiAxNjRweDtcbn1cbi51ZGFwcF9jb2wyXzIge1xufVxuLnVkYXBwX3NlbGVjdCB7XG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gIHdpZHRoOiAxMDAlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuLnVkYXBwX2luc3RhbmNlQ29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgbWFyZ2luLWJvdHRvbTogMiU7XG4gIGJvcmRlcjogbm9uZTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBwYWRkaW5nOiAwIDE0cHggMTZweDtcbn1cbi51ZGFwcF9kZXBsb3llZENvbnRyYWN0cyB7XG4gIGZvbnQtc2l6ZTogMXJlbTtcbn1cbi51ZGFwcF9wZW5kaW5nVHhzQ29udGFpbmVyICB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIG1hcmdpbi10b3A6IDIlO1xuICBib3JkZXI6IG5vbmU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cbi51ZGFwcF9jb250YWluZXIge1xuICBwYWRkaW5nOiAwIDI0cHggMTZweDtcbn1cbi51ZGFwcF9jb250cmFjdE5hbWVzIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGJvcmRlcjogMXB4IHNvbGlkXG59XG4udWRhcHBfc3ViY29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xufVxuLnVkYXBwX3N1YmNvbnRhaW5lciBpIHtcbiAgd2lkdGg6IDE2cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBtYXJnaW4tbGVmdDogMXB4O1xufVxuLnVkYXBwX2J1dHRvbiBidXR0b257XG4gIGZsZXg6IG5vbmU7XG59XG4udWRhcHBfYnV0dG9uIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgbWFyZ2luLXRvcDogMTNweDtcbn1cbi51ZGFwcF90cmFuc2FjdGlvbiB7XG59XG4udWRhcHBfYXRBZGRyZXNzIHtcbiAgbWFyZ2luOiAwO1xuICBtaW4td2lkdGg6IDEwMHB4O1xuICB3aWR0aDogMTAwcHg7XG4gIGhlaWdodDogMTAwJTtcbiAgd29yZC1icmVhazogaW5oZXJpdDtcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xuICBib3JkZXItcmlnaHQ6IDA7XG59XG4udWRhcHBfYXRBZGRyZXNzU2VjdCB7XG4gIG1hcmdpbi10b3A6IDhweDtcbiAgaGVpZ2h0OiAzMnB4O1xufVxuLnVkYXBwX2F0QWRkcmVzc1NlY3QgaW5wdXQge1xuICBoZWlnaHQ6IDMycHg7XG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDAgIWltcG9ydGFudDtcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMCAhaW1wb3J0YW50O1xufVxuLnVkYXBwX2F0YWRkcmVzc2lucHV0IHtcbiAgcGFkZGluZzogLjI1cmVtO1xufVxuLnVkYXBwX3JlY29yZGVyU2VjdGlvbjpob3ZlciB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn0udWRhcHBfcmVjb3JkZXJTZWN0aW9uTGFiZWw6aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4udWRhcHBfcmVjb3JkZXJTZWN0aW9uTGFiZWwge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGZvbnQtc2l6ZTogMXJlbTtcbn1cbi51ZGFwcF9pbnB1dCB7XG4gIGZvbnQtc2l6ZTogMTBweCAhaW1wb3J0YW50O1xufVxuLnVkYXBwX25vSW5zdGFuY2VzVGV4dCB7XG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcbiAgdGV4dC1hbGlnbjogbGVmdDtcbiAgcGFkZGluZy1sZWZ0OiAxNXB4O1xufVxuLnVkYXBwX3BlbmRpbmdUeHNUZXh0IHtcbiAgZm9udC1zdHlsZTogaXRhbGljO1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWV2ZW5seTtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgZmxleC13cmFwOiB3cmFwO1xufVxuLnVkYXBwX2l0ZW0ge1xuICBtYXJnaW4tcmlnaHQ6IDFlbTtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi51ZGFwcF9wZW5kaW5nQ29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xufVxuLnVkYXBwX3BlbmRpbmcge1xuICBoZWlnaHQ6IDI1cHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgcGFkZGluZy1sZWZ0OiAxMHB4O1xuICBib3JkZXItcmFkaXVzOiAzcHg7XG4gIG1hcmdpbi1sZWZ0OiA1cHg7XG59XG4udWRhcHBfZGlzYWJsZU1vdXNlRXZlbnRzIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG4udWRhcHBfaWNvbiB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG1hcmdpbi1sZWZ0OiA1cHg7XG59XG4udWRhcHBfaWNvbjpob3ZlciB7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgY29sb3I6IHZhcigtLXdhcm5pbmcpO1xufVxuLnVkYXBwX2Vycm9ySWNvbiB7XG4gIGNvbG9yOiB2YXIoLS13YXJuaW5nKTtcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XG59XG4udWRhcHBfZmFpbERlc2Mge1xuICBjb2xvcjogdmFyKC0td2FybmluZyk7XG4gIHBhZGRpbmctbGVmdDogMTBweDtcbiAgZGlzcGxheTogaW5saW5lO1xufVxuLnVkYXBwX25ldHdvcmsge1xuICBtYXJnaW4tbGVmdDogOHB4O1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cbi51ZGFwcF9uZXR3b3JrSXRlbSB7XG4gIG1hcmdpbi1yaWdodDogNXB4O1xufVxuLnVkYXBwX3RyYW5zYWN0aW9uQWN0aW9ucyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuICB3aWR0aDogMTQ1cHg7XG59XG4udWRhcHBfb3JMYWJlbCB7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbn1cbi51ZGFwcF9pbmZvRGVwbG95QWN0aW9uIHtcbiAgbWFyZ2luLWxlZnQ6IDFweDtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBjb2xvcjogdmFyKC0taW5mbyk7XG59XG4udWRhcHBfZ2FzVmFsdWVDb250YWluZXIge1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICBkaXNwbGF5OiBmbGV4O1xufVxuLnVkYXBwX2dhc052YWwge1xuICB3aWR0aDogNTUlO1xuICBmb250LXNpemU6IDAuOHJlbTtcbn1cbi51ZGFwcF9nYXNOdmFsVW5pdCB7XG4gIHdpZHRoOiA0MSU7XG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICBmb250LXNpemU6IDAuOHJlbTtcbn1cbi51ZGFwcF9kZXBsb3lEcm9wZG93biB7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbn1cbi51ZGFwcF9jaGVja2JveEFsaWduIHtcbiAgcGFkZGluZy10b3A6IDJweDtcbn1cbi51ZGFwcF9pbnN0YW5jZVRpdGxlQ29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi51ZGFwcF9jYWxsZGF0YUlucHV0e1xuICBoZWlnaHQ6IDMycHg7XG59XG4udWRhcHBfdGl0bGUge1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGZvbnQtc2l6ZTogMTFweDtcbiAgd2lkdGg6IDEwMCU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gIGxpbmUtaGVpZ2h0OiBpbml0aWFsO1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgcGFkZGluZzogMCAwIDhweDtcbiAgbWFyZ2luOiAwO1xuICBiYWNrZ3JvdW5kOiBub25lO1xuICBib3JkZXI6IG5vbmU7XG59XG4udWRhcHBfdGl0bGUgYnV0dG9uIHtcbiAgYmFja2dyb3VuZDogbm9uZTtcbiAgYm9yZGVyOiBub25lO1xufVxuLnVkYXBwX3RpdGxlTGluZSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcbn1cbi51ZGFwcF90aXRsZVRleHQge1xuICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICB3aWR0aDogMTAwJTtcbiAgYm9yZGVyOiBub25lO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuLnVkYXBwX3NwYW5UaXRsZVRleHQge1xuICBsaW5lLWhlaWdodDogMTJweDtcbiAgcGFkZGluZzogMDtcbiAgZm9udC1zaXplOiAxMXB4O1xuICB3aWR0aDoxMDAlO1xuICBib3JkZXI6IG5vbmU7XG4gIGJhY2tncm91bmQ6IG5vbmU7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG4udWRhcHBfaW5wdXRHcm91cFRleHQge1xuICB3aWR0aDogMTAwJTtcbn1cbi51ZGFwcF90aXRsZSAudWRhcHBfY29weSB7XG4gIGNvbG9yOiB2YXIoLS1wcmltYXJ5KTtcbn1cbi51ZGFwcF90aXRsZUV4cGFuZGVyIHtcbiAgbWFyZ2luLXRvcDogMnB4O1xufVxuLnVkYXBwX25hbWVOYnV0cyB7XG4gIGRpc3BsYXk6IGNvbnRlbnRzO1xuICBmbGV4LXdyYXA6IG5vd3JhcDtcbiAgd2lkdGg6IDEwMCU7XG59XG4udWRhcHBfaW5zdGFuY2Uge1xuICBkaXNwbGF5OiBibG9jaztcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgYmFja2dyb3VuZDogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xufVxuLnVkYXBwX2luc3RhbmNlLnVkYXBwX2hpZGVzdWIge1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQ7XG59XG4udWRhcHBfaW5zdGFuY2UudWRhcHBfaGlkZXN1YiAudWRhcHBfdGl0bGUge1xuICAgIGRpc3BsYXk6IGZsZXg7XG59XG4udWRhcHBfaW5zdGFuY2UudWRhcHBfaGlkZXN1YiAudWRhcHBfdWRhcHBDbG9zZSB7XG4gICAgZGlzcGxheTogZmxleDtcbn1cbi51ZGFwcF9pbnN0YW5jZS51ZGFwcF9oaWRlc3ViID4gKiB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG4udWRhcHBfbWV0aENhcmV0IHtcbiAgbWluLXdpZHRoOiAxMnB4O1xuICB3aWR0aDogMTJweDtcbiAgbWFyZ2luLWxlZnQ6IDRweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBmb250LXNpemU6IDE2cHg7XG4gIGxpbmUtaGVpZ2h0OiAwLjY7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIHBhZGRpbmc6IDA7XG59XG4udWRhcHBfY0FjdGlvbnNXcmFwcGVyIHtcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMC4yNXJlbTtcbiAgYm9yZGVyLXRvcC1yaWdodHQtcmFkaXVzOiAwO1xuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMC4yNXJlbTtcbiAgcGFkZGluZzogOHB4IDEwcHggN3B4O1xufVxuLnVkYXBwX2dyb3VwOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgZGlzcGxheTogdGFibGU7XG4gIGNsZWFyOiBib3RoO1xufVxuLnVkYXBwX2J1dHRvbnNDb250YWluZXIge1xuICBtYXJnaW4tdG9wOiAyJTtcbiAgZGlzcGxheTogZmxleDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbi51ZGFwcF9pbnN0YW5jZUJ1dHRvbiB7XG4gIGhlaWdodDogMzJweDtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICBmb250LXNpemU6IDExcHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xufVxuLnVkYXBwX2Nsb3NlSWNvbiB7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBtYXJnaW4tbGVmdDogNXB4O1xufVxuLnVkYXBwX3VkYXBwQ2xvc2Uge1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xufVxuLnVkYXBwX2NvbnRyYWN0UHJvcGVydHkge1xuICB3aWR0aDoxMDAlO1xufVxuLnVkYXBwX2NvbnRyYWN0UHJvcGVydHkudWRhcHBfaGFzQXJncyBpbnB1dCB7XG4gIHBhZGRpbmc6IC4zNmVtO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG59XG4udWRhcHBfY29udHJhY3RQcm9wZXJ0eSAudWRhcHBfY29udHJhY3RBY3Rpb25zQ29udGFpbmVyU2luZ2xlIGlucHV0e1xuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xufVxuLnVkYXBwX2NvbnRyYWN0UHJvcGVydHkgYnV0dG9uIHtcbiAgbWluLXdpZHRoOiAxMDBweDtcbiAgd2lkdGg6IDEwMHB4O1xuICBtYXJnaW46MDtcbiAgd29yZC1icmVhazogaW5oZXJpdDtcbn1cbi51ZGFwcF9jb250cmFjdFByb3BlcnR5IGJ1dHRvbjpkaXNhYmxlZCB7XG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICBib3JkZXItY29sb3I6IGxpZ2h0Z3JheTtcbn1cbi51ZGFwcF9jb250cmFjdFByb3BlcnR5LnVkYXBwX2NvbnN0YW50IGJ1dHRvbiB7XG4gIG1pbi13aWR0aDogMTAwcHg7XG4gIHdpZHRoOiAxMDBweDtcbiAgbWFyZ2luOjA7XG4gIHdvcmQtYnJlYWs6IGluaGVyaXQ7XG4gIG91dGxpbmU6IG5vbmU7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xufVxuLnVkYXBwX2NvbnRyYWN0UHJvcGVydHkgPiAudWRhcHBfdmFsdWUge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBmbG9hdDogbGVmdDtcbiAgYWxpZ24tc2VsZjogY2VudGVyO1xuICBtYXJnaW4tbGVmdDogNHB4O1xufVxuLnVkYXBwX2NvbnRyYWN0QWN0aW9uc0NvbnRhaW5lciB7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG59XG4udWRhcHBfY29udHJhY3RBY3Rpb25zQ29udGFpbmVyU2luZ2xlIHtcbiAgZGlzcGxheTogZmxleDtcbiAgd2lkdGg6IDEwMCU7XG59XG4udWRhcHBfY29udHJhY3RBY3Rpb25zQ29udGFpbmVyU2luZ2xlIGkge1xuICBsaW5lLWhlaWdodDogMjtcbn1cbi51ZGFwcF9jb250cmFjdEFjdGlvbnNDb250YWluZXJNdWx0aSB7XG4gIGRpc3BsYXk6bm9uZTtcbiAgd2lkdGg6IDEwMCU7XG59XG4udWRhcHBfY29udHJhY3RBY3Rpb25zQ29udGFpbmVyTXVsdGlJbm5lciB7XG4gIHdpZHRoOiAxMDAlO1xuICBib3JkZXItcmFkaXVzOiAzcHg7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbn1cbi51ZGFwcF9tdWx0aUhlYWRlciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xuICBmb250LXNpemU6IDEwcHg7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuLnVkYXBwX2NvbnRyYWN0QWN0aW9uc0NvbnRhaW5lck11bHRpSW5uZXIgLnVkYXBwX211bHRpVGl0bGUge1xuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XG59XG4udWRhcHBfY29udHJhY3RQcm9wZXJ0eSAudWRhcHBfbXVsdGlUaXRsZSB7XG4gIHBhZGRpbmc6IDA7XG4gIGxpbmUtaGVpZ2h0OiAxNnB4O1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIGN1cnNvcjogZGVmYXVsdDtcbn1cbi51ZGFwcF9jb250cmFjdFByb3BlcnR5IC51ZGFwcF9jb250cmFjdEFjdGlvbnNDb250YWluZXJNdWx0aUlubmVyIC51ZGFwcF9tdWx0aUFyZyBsYWJlbHtcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XG59XG4udWRhcHBfbXVsdGlIZWFkZXIgLnVkYXBwX21ldGhDYXJldCB7XG4gIGZsb2F0OiByaWdodDtcbiAgbWFyZ2luLXJpZ2h0OiAwO1xufVxuLnVkYXBwX2NvbnRyYWN0UHJvcGVydHkudWRhcHBfY29uc3RhbnQgLnVkYXBwX211bHRpVGl0bGUge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHdpZHRoOiA5MCU7XG4gIC8qIGZvbnQtc2l6ZTogMTBweDsgKi9cbiAgaGVpZ2h0OiAyNXB4O1xuICBwYWRkaW5nLWxlZnQ6IDIwcHg7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xuICBsaW5lLWhlaWdodDogMjVweDtcbiAgY3Vyc29yOiBkZWZhdWx0O1xufVxuLnVkYXBwX211bHRpQXJnIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgbWFyZ2luLXRvcDogNHB4O1xufVxuLnVkYXBwX211bHRpQXJnIGlucHV0e1xuICBwYWRkaW5nOiA1cHg7XG59XG4udWRhcHBfbXVsdGlBcmcgbGFiZWwge1xuICB3aWR0aDogYXV0bztcbiAgcGFkZGluZzogMDtcbiAgbWFyZ2luOiAwIDRweCAwIDA7XG4gIGZvbnQtc2l6ZTogMTBweDtcbiAgbGluZS1oZWlnaHQ6IDEycHg7XG4gIHRleHQtYWxpZ246IHJpZ2h0O1xuICB3b3JkLWJyZWFrOiBpbml0aWFsO1xufVxuLnVkYXBwX211bHRpQXJnIGJ1dHRvbiB7XG4gIG1heC13aWR0aDogMTAwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gIHdpZHRoOiBpbmhlcml0O1xufVxuLnVkYXBwX211bHRpSGVhZGVyIGJ1dHRvbiB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgd2lkdGg6IDk0JTtcbn1cbi51ZGFwcF9oYXNBcmdzIC51ZGFwcF9tdWx0aUFyZyBpbnB1dCB7XG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2RkZGRkZDtcbiAgd2lkdGg6IDY3JTtcbn1cbi51ZGFwcF9oYXNBcmdzIGlucHV0IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogMzJweDtcbiAgYm9yZGVyOiAxcHggc29saWQgI2RkZGRkZDtcbiAgcGFkZGluZzogLjM2ZW07XG4gIGJvcmRlci1sZWZ0OiBub25lO1xuICBwYWRkaW5nOiA4cHggOHB4IDhweCAxMHB4O1xuICBmb250LXNpemU6IDEwcHggIWltcG9ydGFudDtcbn1cbi51ZGFwcF9oYXNBcmdzIGJ1dHRvbiB7XG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcbiAgYm9yZGVyLXJpZ2h0OiAwO1xuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgZm9udC1zaXplOiAxMXB4O1xufVxuLnVkYXBwX2hhc0FyZ3MgLnVkYXBwX2NvbnRyYWN0QWN0aW9uc0NvbnRhaW5lck11bHRpIGJ1dHRvbiB7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbn1cbi51ZGFwcF9jb250cmFjdEFjdGlvbnNDb250YWluZXJNdWx0aUlubmVyIC51ZGFwcF9tdWx0aUFyZyBpIHtcbiAgcGFkZGluZy1yaWdodDogMTBweDtcbn1cbi51ZGFwcF9oaWRlV2FybmluZ3NDb250YWluZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBtYXJnaW4tbGVmdDogMiVcbn1cbiNjb25maXJtc2V0dGluZyB7XG4gIHotaW5kZXg6IDE7XG59XG4udWRhcHBfd3JhcHdvcmQge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7ICAgICAgIC8qIFNpbmNlIENTUyAyLjEgKi9cbiAgd2hpdGUtc3BhY2U6IC1tb3otcHJlLXdyYXA7ICAvKiBNb3ppbGxhLCBzaW5jZSAxOTk5ICovXG4gIHdoaXRlLXNwYWNlOiAtcHJlLXdyYXA7ICAgICAgLyogT3BlcmEgNC02ICovXG4gIHdoaXRlLXNwYWNlOiAtby1wcmUtd3JhcDsgICAgLyogT3BlcmEgNyAqL1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7ICAgICAgIC8qIEludGVybmV0IEV4cGxvcmVyIDUuNSsgKi9cbn1cbi5kZXBsb3ktaXRlbXMge1xuICBwYWRkaW5nOiAwLjI1cmVtIDAuMjVyZW07XG4gIGJvcmRlci1yYWRpdXM6IC4yNXJlbTtcbn1cbi5kZXBsb3ktaXRlbXMgYSB7XG4gIGJvcmRlci1yYWRpdXM6IC4yNXJlbTtcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgZm9udC1zaXplOiAuOHJlbTtcbiAgcGFkZGluZzogMC4yNXJlbSAwLjI1cmVtO1xuICB3aWR0aDphdXRvO1xufVxuLmRyb3Bkb3duLWl0ZW0uaG92ZXIsIC5kcm9wZG93bi1pdGVtOmhvdmVyIHtcbiAgY29sb3I6ICNmZmY7XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwN2FhNjtcbn1cbi51ZGFwcF9zZWxlY3RFeEVudk9wdGlvbnMge1xuICB3aWR0aDogMTAwJTtcbn1cblxuIl19 */", '', '']]

/***/ }),
/* 1834 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PublishToStorage = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _modalDialog = __webpack_require__(316);

var _publishToIPFS = __webpack_require__(1835);

var _publishOnSwarm = __webpack_require__(2090);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const PublishToStorage = props => {
  const {
    api,
    storage,
    contract,
    resetStorage
  } = props;
  const [modalShown, setModalShown] = (0, _react.useState)(false);
  const [state, setState] = (0, _react.useState)({
    modal: {
      title: '',
      message: null,
      hide: true,
      okLabel: '',
      okFn: null,
      cancelLabel: '',
      cancelFn: null
    }
  });
  (0, _react.useEffect)(() => {
    const storageService = async () => {
      if (contract.metadata === undefined || contract.metadata.length === 0) {
        modal('Publish To Storage', 'This contract may be abstract, it may not implement an abstract parent\'s methods completely or it may not invoke an inherited contract\'s constructor correctly.');
      } else {
        if (storage === 'swarm') {
          try {
            const result = await (0, _publishOnSwarm.publishToSwarm)(contract, api);
            modal(`Published ${contract.name}'s Metadata and Sources`, publishMessage(result.uploaded));
          } catch (err) {
            let parseError = err;

            try {
              parseError = JSON.stringify(err);
            } catch (e) {}

            modal('Swarm Publish Failed', publishMessageFailed(storage, parseError));
          }
        } else {
          if (!api.config.get('settings/ipfs-url') && !modalShown) {
            modal('IPFS Settings', /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              children: ["You have not set your own custom IPFS settings.", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "We won\u2019t be providing a public endpoint anymore for publishing your contracts to IPFS.", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "Instead of that, 4 options are now available:", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsxs)("ul", {
                className: "pl-3",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
                  children: "DEFAULT OPTION: Use the public INFURA node. This will not guarantee your data will persist."
                }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("li", {
                  children: ["Use your own INFURA IPFS node. This requires a subscription. ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
                    href: "https://infura.io/product/ipfs",
                    target: '_blank',
                    children: "Learn more"
                  })]
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
                  children: "Use any external IPFS which doesn\u2019t require any authentification."
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
                  children: "Use your own local ipfs node (which usually runs under http://localhost:5001)"
                })]
              }), "You can update your IPFS settings in the SETTINGS tab.", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "Now the default option will be used."]
            }), async () => await ipfs(contract, api));
          } else {
            await ipfs(contract, api);
          }
        }
      }
    };

    if (storage) {
      storageService();
    }
  }, [storage]);

  const ipfs = async (contract, api) => {
    try {
      const result = await (0, _publishToIPFS.publishToIPFS)(contract, api);
      modal(`Published ${contract.name}'s Metadata and Sources`, publishMessage(result.uploaded));
    } catch (err) {
      modal('IPFS Publish Failed', publishMessageFailed(storage, err));
    }

    setModalShown(true);
  };

  const publishMessage = uploaded => /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
    children: [" Metadata and sources of \"", contract.name.toLowerCase(), "\" were published successfully. ", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("pre", {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: uploaded.map((value, index) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("b", {
            children: value.filename
          }), " : ", /*#__PURE__*/(0, _jsxRuntime.jsx)("pre", {
            children: value.output.url
          })]
        }, index))
      })
    })]
  });

  const publishMessageFailed = (storage, err) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
    children: ["Failed to publish metadata file and sources to ", storage, ", please check the ", storage, " gateways is available. ", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), err]
  });

  const handleHideModal = () => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        modal: _objectSpread(_objectSpread({}, prevState.modal), {}, {
          hide: true,
          message: null
        })
      });
    });
    resetStorage();
  };

  const modal = async (title, message, okFn = () => {}) => {
    await setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        modal: _objectSpread(_objectSpread({}, prevState.modal), {}, {
          hide: false,
          message,
          title,
          okFn
        })
      });
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_modalDialog.ModalDialog, {
    id: props.id || 'publishToStorage',
    title: state.modal.title,
    message: state.modal.message,
    hide: state.modal.hide,
    okLabel: "OK",
    okFn: state.modal.okFn,
    handleHide: handleHideModal,
    children: typeof state.modal.message !== 'string' && state.modal.message
  });
};

exports.PublishToStorage = PublishToStorage;
var _default = PublishToStorage;
exports.default = _default;

/***/ }),
/* 1835 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishToIPFS = void 0;

var _ipfsHttpClient = _interopRequireDefault(__webpack_require__(1441));

let ipfsNodes = [];

const publishToIPFS = async (contract, api) => {
  ipfsNodes = [(0, _ipfsHttpClient.default)({
    host: 'ipfs.infura.io',
    port: 5001,
    protocol: 'https'
  })];

  if (api.config.get('settings/ipfs-url')) {
    const auth = api.config.get('settings/ipfs-project-id') ? 'Basic ' + Buffer.from(api.config.get('settings/ipfs-project-id') + ':' + api.config.get('settings/ipfs-project-secret')).toString('base64') : null;
    const ipfs = (0, _ipfsHttpClient.default)({
      host: api.config.get('settings/ipfs-url'),
      port: api.config.get('settings/ipfs-port'),
      protocol: api.config.get('settings/ipfs-protocol'),
      headers: {
        Authorization: auth
      }
    });
    ipfsNodes.push(ipfs);
  } // gather list of files to publish


  const sources = [];
  let metadata;
  const item = {
    content: null,
    hash: null
  };
  const uploaded = [];

  try {
    metadata = JSON.parse(contract.metadata);
  } catch (e) {
    throw new Error(e);
  }

  if (metadata === undefined) {
    throw new Error('No metadata');
  }

  await Promise.all(Object.keys(metadata.sources).map(fileName => {
    return new Promise((resolve, reject) => {
      // find hash
      let hash = null;

      try {
        // we try extract the hash defined in the metadata.json
        // in order to check if the hash that we get after publishing is the same as the one located in metadata.json
        // if it's not the same, we throw "hash mismatch between solidity bytecode and uploaded content"
        // if we don't find the hash in the metadata.json, the check is not done.
        //
        // TODO: refactor this with publishOnSwarm
        if (metadata.sources[fileName].urls) {
          metadata.sources[fileName].urls.forEach(url => {
            if (url.includes('ipfs')) hash = url.match('dweb:/ipfs/(.+)')[1];
          });
        }
      } catch (e) {
        return reject(new Error('Error while extracting the hash from metadata.json'));
      }

      api.readFile(fileName).then(content => {
        sources.push({
          content: content,
          hash: hash,
          filename: fileName
        });
        resolve({
          content: content,
          hash: hash,
          filename: fileName
        });
      }).catch(error => {
        console.log(error);
        reject(error);
      });
    });
  })); // publish the list of sources in order, fail if any failed

  await Promise.all(sources.map(async item => {
    try {
      const result = await ipfsVerifiedPublish(item.content, item.hash, api);

      try {
        item.hash = result.url.match('dweb:/ipfs/(.+)')[1];
      } catch (e) {
        item.hash = '<Metadata inconsistency> - ' + item.fileName;
      }

      item.output = result;
      uploaded.push(item);
    } catch (error) {
      throw new Error(error);
    }
  }));
  const metadataContent = JSON.stringify(metadata, null, '\t');

  try {
    const result = await ipfsVerifiedPublish(metadataContent, '', api);

    try {
      contract.metadataHash = result.url.match('dweb:/ipfs/(.+)')[1];
    } catch (e) {
      contract.metadataHash = '<Metadata inconsistency> - metadata.json';
    }

    item.content = metadataContent;
    item.hash = contract.metadataHash;
    uploaded.push({
      content: contract.metadata,
      hash: contract.metadataHash,
      filename: 'metadata.json',
      output: result
    });
  } catch (error) {
    throw new Error(error);
  }

  return {
    uploaded,
    item
  };
};

exports.publishToIPFS = publishToIPFS;

const ipfsVerifiedPublish = async (content, expectedHash, api) => {
  try {
    const results = await severalGatewaysPush(content);
    const hash = results.path;

    if (expectedHash && hash !== expectedHash) {
      return {
        message: 'hash mismatch between solidity bytecode and uploaded content.',
        url: 'dweb:/ipfs/' + hash,
        hash
      };
    } else {
      api.writeFile('ipfs/' + hash, content);
      return {
        message: 'ok',
        url: 'dweb:/ipfs/' + hash,
        hash
      };
    }
  } catch (error) {
    throw new Error(error);
  }
};

const severalGatewaysPush = content => {
  const invert = p => new Promise((resolve, reject) => p.then(reject).catch(resolve)); // Invert res and rej


  const promises = ipfsNodes.map(node => invert(node.add(content)));
  return invert(Promise.all(promises));
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 1836 */,
/* 1837 */,
/* 1838 */,
/* 1839 */,
/* 1840 */,
/* 1841 */,
/* 1842 */,
/* 1843 */,
/* 1844 */,
/* 1845 */,
/* 1846 */,
/* 1847 */,
/* 1848 */,
/* 1849 */,
/* 1850 */,
/* 1851 */,
/* 1852 */,
/* 1853 */,
/* 1854 */,
/* 1855 */,
/* 1856 */,
/* 1857 */,
/* 1858 */,
/* 1859 */,
/* 1860 */,
/* 1861 */,
/* 1862 */,
/* 1863 */,
/* 1864 */,
/* 1865 */,
/* 1866 */,
/* 1867 */,
/* 1868 */,
/* 1869 */,
/* 1870 */,
/* 1871 */,
/* 1872 */,
/* 1873 */,
/* 1874 */,
/* 1875 */,
/* 1876 */,
/* 1877 */,
/* 1878 */,
/* 1879 */,
/* 1880 */,
/* 1881 */,
/* 1882 */,
/* 1883 */,
/* 1884 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 1885 */,
/* 1886 */,
/* 1887 */,
/* 1888 */,
/* 1889 */,
/* 1890 */,
/* 1891 */,
/* 1892 */,
/* 1893 */,
/* 1894 */,
/* 1895 */,
/* 1896 */,
/* 1897 */,
/* 1898 */,
/* 1899 */,
/* 1900 */,
/* 1901 */,
/* 1902 */,
/* 1903 */,
/* 1904 */,
/* 1905 */,
/* 1906 */,
/* 1907 */,
/* 1908 */,
/* 1909 */,
/* 1910 */,
/* 1911 */,
/* 1912 */,
/* 1913 */,
/* 1914 */,
/* 1915 */,
/* 1916 */,
/* 1917 */,
/* 1918 */,
/* 1919 */,
/* 1920 */,
/* 1921 */,
/* 1922 */,
/* 1923 */,
/* 1924 */,
/* 1925 */,
/* 1926 */,
/* 1927 */,
/* 1928 */,
/* 1929 */,
/* 1930 */,
/* 1931 */,
/* 1932 */,
/* 1933 */,
/* 1934 */,
/* 1935 */,
/* 1936 */,
/* 1937 */,
/* 1938 */,
/* 1939 */,
/* 1940 */,
/* 1941 */,
/* 1942 */,
/* 1943 */,
/* 1944 */,
/* 1945 */,
/* 1946 */,
/* 1947 */,
/* 1948 */,
/* 1949 */,
/* 1950 */,
/* 1951 */,
/* 1952 */,
/* 1953 */,
/* 1954 */,
/* 1955 */,
/* 1956 */,
/* 1957 */,
/* 1958 */,
/* 1959 */,
/* 1960 */,
/* 1961 */,
/* 1962 */,
/* 1963 */,
/* 1964 */,
/* 1965 */,
/* 1966 */,
/* 1967 */,
/* 1968 */,
/* 1969 */,
/* 1970 */,
/* 1971 */,
/* 1972 */,
/* 1973 */,
/* 1974 */,
/* 1975 */,
/* 1976 */,
/* 1977 */,
/* 1978 */,
/* 1979 */,
/* 1980 */,
/* 1981 */,
/* 1982 */,
/* 1983 */,
/* 1984 */,
/* 1985 */,
/* 1986 */,
/* 1987 */,
/* 1988 */,
/* 1989 */,
/* 1990 */,
/* 1991 */,
/* 1992 */,
/* 1993 */,
/* 1994 */,
/* 1995 */,
/* 1996 */,
/* 1997 */,
/* 1998 */,
/* 1999 */,
/* 2000 */,
/* 2001 */,
/* 2002 */,
/* 2003 */,
/* 2004 */,
/* 2005 */,
/* 2006 */,
/* 2007 */,
/* 2008 */,
/* 2009 */,
/* 2010 */,
/* 2011 */,
/* 2012 */,
/* 2013 */,
/* 2014 */,
/* 2015 */,
/* 2016 */,
/* 2017 */,
/* 2018 */,
/* 2019 */,
/* 2020 */,
/* 2021 */,
/* 2022 */,
/* 2023 */,
/* 2024 */,
/* 2025 */,
/* 2026 */,
/* 2027 */,
/* 2028 */,
/* 2029 */,
/* 2030 */,
/* 2031 */,
/* 2032 */,
/* 2033 */,
/* 2034 */,
/* 2035 */,
/* 2036 */,
/* 2037 */,
/* 2038 */,
/* 2039 */,
/* 2040 */,
/* 2041 */,
/* 2042 */,
/* 2043 */,
/* 2044 */,
/* 2045 */,
/* 2046 */,
/* 2047 */,
/* 2048 */,
/* 2049 */,
/* 2050 */,
/* 2051 */,
/* 2052 */,
/* 2053 */,
/* 2054 */,
/* 2055 */,
/* 2056 */,
/* 2057 */,
/* 2058 */,
/* 2059 */,
/* 2060 */,
/* 2061 */,
/* 2062 */,
/* 2063 */,
/* 2064 */,
/* 2065 */,
/* 2066 */,
/* 2067 */,
/* 2068 */,
/* 2069 */,
/* 2070 */,
/* 2071 */,
/* 2072 */,
/* 2073 */,
/* 2074 */,
/* 2075 */,
/* 2076 */,
/* 2077 */,
/* 2078 */,
/* 2079 */,
/* 2080 */,
/* 2081 */,
/* 2082 */,
/* 2083 */,
/* 2084 */,
/* 2085 */,
/* 2086 */,
/* 2087 */,
/* 2088 */,
/* 2089 */,
/* 2090 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishToSwarm = void 0;

var _beeJs = __webpack_require__(2091);

// public gateway node address
const publicBeeNode = new _beeJs.Bee('https://api.gateway.ethswarm.org/'); // on the public gateway the postage stamp id is not relevant, so we use all zeroes

const defaultPostageStampId = '0000000000000000000000000000000000000000000000000000000000000000';

const publishToSwarm = async (contract, api) => {
  // gather list of files to publish
  const sources = [];
  let metadata;
  const item = {
    content: null,
    hash: null
  };
  const uploaded = [];

  try {
    metadata = JSON.parse(contract.metadata);
  } catch (e) {
    throw new Error(e);
  }

  if (metadata === undefined) {
    throw new Error('No metadata');
  }

  await Promise.all(Object.keys(metadata.sources).map(fileName => {
    return new Promise((resolve, reject) => {
      // find hash
      let hash = null;

      try {
        // we try extract the hash defined in the metadata.json
        // in order to check if the hash that we get after publishing is the same as the one located in metadata.json
        // if it's not the same, we throw "hash mismatch between solidity bytecode and uploaded content"
        // if we don't find the hash in the metadata.json, the check is not done.
        //
        // TODO: refactor this with publishOnIpfs
        if (metadata.sources[fileName].urls) {
          metadata.sources[fileName].urls.forEach(url => {
            if (url.includes('bzz')) hash = url.match('bzz-raw://(.+)')[1];
          });
        }
      } catch (e) {
        return reject(new Error('Error while extracting the hash from metadata.json'));
      }

      api.readFile(fileName).then(content => {
        sources.push({
          content: content,
          hash: hash,
          filename: fileName
        });
        resolve({
          content: content,
          hash: hash,
          filename: fileName
        });
      }).catch(error => {
        console.log(error);
        reject(error);
      });
    });
  })); // the list of nodes to publish to

  const beeNodes = [publicBeeNode]; // add custom private Bee node to the list

  const postageStampId = api.config.get('settings/swarm-postage-stamp-id') || defaultPostageStampId;
  const privateBeeAddress = api.config.get('settings/swarm-private-bee-address');

  if (privateBeeAddress) {
    const privateBee = new _beeJs.Bee(privateBeeAddress);
    beeNodes.push(privateBee);
  } // publish the list of sources in order, fail if any failed


  await Promise.all(sources.map(async item => {
    try {
      const result = await swarmVerifiedPublish(beeNodes, postageStampId, item.content, item.hash, api);

      try {
        item.hash = result.url.match('bzz-raw://(.+)')[1];
      } catch (e) {
        item.hash = '<Metadata inconsistency> - ' + item.fileName;
      }

      item.output = result;
      uploaded.push(item); // TODO this is a fix cause Solidity metadata does not contain the right swarm hash (poc 0.3)

      metadata.sources[item.filename].urls[0] = result.url;
    } catch (error) {
      console.error(error);
      throw new Error(error);
    }
  }));
  const metadataContent = JSON.stringify(metadata, null, '\t');

  try {
    const result = await swarmVerifiedPublish(beeNodes, postageStampId, metadataContent, '', api);

    try {
      contract.metadataHash = result.url.match('bzz-raw://(.+)')[1];
    } catch (e) {
      contract.metadataHash = '<Metadata inconsistency> - metadata.json';
    }

    item.content = metadataContent;
    item.hash = contract.metadataHash;
    uploaded.push({
      content: contract.metadata,
      hash: contract.metadataHash,
      filename: 'metadata.json',
      output: result
    });
  } catch (error) {
    console.error(error);
    throw new Error(error);
  }

  return {
    uploaded,
    item
  };
};

exports.publishToSwarm = publishToSwarm;

const swarmVerifiedPublish = async (beeNodes, postageStampId, content, expectedHash, api) => {
  try {
    const results = await uploadToBeeNodes(beeNodes, postageStampId, content);
    const hash = hashFromResults(results);

    if (expectedHash && hash !== expectedHash) {
      return {
        message: 'hash mismatch between solidity bytecode and uploaded content.',
        url: 'bzz-raw://' + hash,
        hash
      };
    } else {
      api.writeFile('swarm/' + hash, content);
      return {
        message: 'ok',
        url: 'bzz-raw://' + hash,
        hash
      };
    }
  } catch (error) {
    throw new Error(error);
  }
};

const hashFromResults = results => {
  for (const result of results) {
    if (result != null) {
      return result.reference;
    }
  }

  throw new Error('no result');
};

const uploadToBee = async (bee, postageStampId, content) => {
  try {
    if (bee.url === publicBeeNode.url) {
      postageStampId = defaultPostageStampId;
    }

    return await bee.uploadData(postageStampId, content);
  } catch (_unused) {
    // ignore errors for now
    return null;
  }
};

const uploadToBeeNodes = (beeNodes, postageBatchId, content) => {
  return Promise.all(beeNodes.map(node => uploadToBee(node, postageBatchId, content)));
};

/***/ }),
/* 2091 */,
/* 2092 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainnetPrompt = MainnetPrompt;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _clipboard = __webpack_require__(1154);

var _web = _interopRequireDefault(__webpack_require__(1125));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
function MainnetPrompt(props) {
  const [baseFee, setBaseFee] = (0, _react.useState)('');
  (0, _react.useEffect)(() => {
    props.init((txFeeText, gasPriceValue, gasPriceStatus) => {
      if (txFeeText) props.setTxFeeContent(txFeeText);
      if (gasPriceValue) onGasPriceChange(gasPriceValue);

      if (props.network && props.network.lastBlock && props.network.lastBlock.baseFeePerGas) {
        const baseFee = _web.default.utils.fromWei(_web.default.utils.toBN(parseInt(props.network.lastBlock.baseFeePerGas, 16)), 'Gwei');

        setBaseFee(baseFee);
        onMaxFeeChange(baseFee);
      }

      if (gasPriceStatus !== undefined) props.updateGasPriceStatus(gasPriceStatus);
    });
  }, []);

  const onMaxFeeChange = value => {
    const maxFee = value; // @ts-ignore

    if (parseInt(props.network.lastBlock.baseFeePerGas, 16) > _web.default.utils.toWei(maxFee, 'Gwei')) {
      props.setTxFeeContent('Transaction is invalid. Max fee should not be less than Base fee');
      props.updateGasPriceStatus(false);
      props.updateConfirmSettings(true);
      return;
    } else {
      props.updateGasPriceStatus(true);
      props.updateConfirmSettings(false);
    }

    props.setNewGasPrice(maxFee, (txFeeText, priceStatus) => {
      props.setTxFeeContent(txFeeText);

      if (priceStatus) {
        props.updateConfirmSettings(false);
      } else {
        props.updateConfirmSettings(true);
      }

      props.updateGasPriceStatus(priceStatus);
      props.updateMaxFee(maxFee);
      props.updateBaseFeePerGas(props.network.lastBlock.baseFeePerGas);
    });
  };

  const onGasPriceChange = value => {
    const gasPrice = value;
    props.setNewGasPrice(gasPrice, (txFeeText, priceStatus) => {
      props.setTxFeeContent(txFeeText);
      props.updateGasPriceStatus(priceStatus);
      props.updateGasPrice(gasPrice);
    });
  };

  const onMaxPriorityFeeChange = value => {
    props.updateMaxPriorityFee(value);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "text-dark",
      children: ["You are about to create a transaction on ", props.network.name, " Network. Confirm the details to send the info to your provider.", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "The provider for many users is MetaMask. The provider will ask you to sign the transaction before it is sent to ", props.network.name, " Network."]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "mt-3",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "From:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: props.tx.from
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "To:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: props.tx.to ? props.tx.to : '(Contract Creation)'
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex align-items-center",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "Data:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("pre", {
          className: "udapp_wrapword mb-0",
          children: [props.tx.data && props.tx.data.length > 50 ? props.tx.data.substring(0, 49) + '...' : props.tx.data, /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
            content: props.tx.data
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "mb-3",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "Amount:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: [props.amount, " Ether"]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "Gas estimation:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: props.gasEstimation
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "Gas limit:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: props.tx.gas
        })]
      }), props.network.lastBlock.baseFeePerGas ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "align-items-center my-1",
          title: "Represents the part of the tx fee that goes to the miner.",
          children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              className: "text-dark mr-2 text-nowrap",
              children: "Max Priority fee:"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-control mr-1 text-right",
              style: {
                height: '1.2rem',
                width: '6rem'
              },
              id: "maxpriorityfee",
              onInput: e => onMaxPriorityFeeChange(e.target.value),
              defaultValue: props.maxPriorityFee
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              title: "visit https://ethgasstation.info for current gas price info.",
              children: "Gwei"
            })]
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "align-items-center my-1",
          title: "Represents the maximum amount of fee that you will pay for this transaction. The minimun needs to be set to base fee.",
          children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              className: "text-dark mr-2 text-nowrap",
              children: ["Max fee (Not less than base fee ", _web.default.utils.fromWei(_web.default.utils.toBN(parseInt(props.network.lastBlock.baseFeePerGas, 16)), 'Gwei'), " Gwei):"]
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-control mr-1 text-right",
              style: {
                height: '1.2rem',
                width: '6rem'
              },
              id: "maxfee",
              onInput: e => onMaxFeeChange(e.target.value),
              defaultValue: baseFee
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "Gwei"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              className: "text-dark ml-2"
            })]
          })
        })]
      }) : /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex align-items-center my-1",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2 text-nowrap",
          children: "Gas price:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          className: "form-control mr-1 text-right",
          style: {
            width: '40px',
            height: '28px'
          },
          id: "gasprice",
          onInput: e => onGasPriceChange(e.target.value)
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: ["Gwei (visit ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            target: "_blank",
            href: "https://ethgasstation.info",
            rel: "noreferrer",
            children: "ethgasstation.info"
          }), " for current gas price info.)"]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "mb-3",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-dark mr-2",
          children: "Max transaction fee:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "text-warning",
          id: "txfee",
          children: props.txFeeContent
        })]
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "d-flex py-1 align-items-center custom-control custom-checkbox remixui_checkbox",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        className: "form-check-input custom-control-input",
        id: "confirmsetting",
        type: "checkbox"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "m-0 form-check-label custom-control-label",
        htmlFor: "confirmsetting",
        children: "Do not show this warning again."
      })]
    })]
  });
}

/***/ }),
/* 2093 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScenarioPrompt = ScenarioPrompt;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-use-before-define
function ScenarioPrompt(props) {
  const handleScenarioPath = e => {
    props.setScenarioPath(e.target.value);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [" ", props.message, /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        id: "prompt_text",
        type: "text",
        name: "prompt_text",
        className: "form-control",
        style: {
          width: '100%'
        },
        onInput: handleScenarioPath,
        "data-id": "modalDialogCustomPromptText",
        defaultValue: props.defaultValue
      })
    })]
  });
}

/***/ }),
/* 2094 */,
/* 2095 */,
/* 2096 */,
/* 2097 */,
/* 2098 */,
/* 2099 */,
/* 2100 */,
/* 2101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var async = __webpack_require__(222);

var ethutil = __webpack_require__(34);

var remixLib = __webpack_require__(311);

var EventManager = remixLib.EventManager;
var format = remixLib.execution.txFormat;
var txHelper = remixLib.execution.txHelper;

var helper = __webpack_require__(1310);

var _paq = window._paq = window._paq || []; //eslint-disable-line


var profile = {
  name: 'recorder',
  displayName: 'Recorder',
  description: 'Records transactions to save and run',
  version: packageJson.version,
  methods: []
};
/**
  * Record transaction as long as the user create them.
  */

var Recorder = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(Recorder, _Plugin);

  var _super = _createSuper(Recorder);

  function Recorder(blockchain) {
    var _this;

    (0, _classCallCheck2["default"])(this, Recorder);
    _this = _super.call(this, profile);
    _this.event = new EventManager();
    _this.blockchain = blockchain;
    _this.data = {
      _listen: true,
      _replay: false,
      journal: [],
      _createdContracts: {},
      _createdContractsReverse: {},
      _usedAccounts: {},
      _abis: {},
      _contractABIReferences: {},
      _linkReferences: {}
    };

    _this.blockchain.event.register('initiatingTransaction', function (timestamp, tx, payLoad) {
      if (tx.useCall) return;
      var from = tx.from,
          to = tx.to,
          value = tx.value; // convert to and from to tokens

      if (_this.data._listen) {
        var record = {
          value: value,
          inputs: txHelper.serializeInputs(payLoad.funAbi),
          parameters: payLoad.funArgs,
          name: payLoad.funAbi.name,
          type: payLoad.funAbi.type
        };

        if (!to) {
          var abi = payLoad.contractABI;
          var keccak = ethutil.bufferToHex(ethutil.keccakFromString(JSON.stringify(abi)));
          record.abi = keccak;
          record.contractName = payLoad.contractName;
          record.bytecode = payLoad.contractBytecode;
          record.linkReferences = payLoad.linkReferences;

          if (record.linkReferences && Object.keys(record.linkReferences).length) {
            for (var file in record.linkReferences) {
              for (var lib in record.linkReferences[file]) {
                _this.data._linkReferences[lib] = '<address>';
              }
            }
          }

          _this.data._abis[keccak] = abi;
          _this.data._contractABIReferences[timestamp] = keccak;
        } else {
          var creationTimestamp = _this.data._createdContracts[to];
          record.to = "created{".concat(creationTimestamp, "}");
          record.abi = _this.data._contractABIReferences[creationTimestamp];
        }

        for (var p in record.parameters) {
          var thisarg = record.parameters[p];
          var thistimestamp = _this.data._createdContracts[thisarg];
          if (thistimestamp) record.parameters[p] = "created{".concat(thistimestamp, "}");
        }

        _this.blockchain.getAccounts(function (error, accounts) {
          if (error) return console.log(error);
          record.from = "account{".concat(accounts.indexOf(from), "}");
          _this.data._usedAccounts[record.from] = from;

          _this.append(timestamp, record);
        });
      }
    });

    _this.blockchain.event.register('transactionExecuted', function (error, from, to, data, call, txResult, timestamp, _payload) {
      if (error) return console.log(error);
      if (call) return;
      var rawAddress = txResult.receipt.contractAddress;
      if (!rawAddress) return; // not a contract creation

      var address = helper.addressToString(rawAddress); // save back created addresses for the convertion from tokens to real adresses

      _this.data._createdContracts[address] = timestamp;
      _this.data._createdContractsReverse[timestamp] = address;
    });

    _this.blockchain.event.register('contextChanged', _this.clearAll.bind((0, _assertThisInitialized2["default"])(_this)));

    _this.event.register('newTxRecorded', function (count) {
      _this.event.trigger('recorderCountChange', [count]);
    });

    _this.event.register('cleared', function () {
      _this.event.trigger('recorderCountChange', [0]);
    });

    return _this;
  }
  /**
    * stop/start saving txs. If not listenning, is basically in replay mode
    *
    * @param {Bool} listen
    */


  (0, _createClass2["default"])(Recorder, [{
    key: "setListen",
    value: function setListen(listen) {
      this.data._listen = listen;
      this.data._replay = !listen;
    }
  }, {
    key: "extractTimestamp",
    value: function extractTimestamp(value) {
      var stamp = /created{(.*)}/g.exec(value);

      if (stamp) {
        return stamp[1];
      }

      return null;
    }
    /**
      * convert back from/to from tokens to real addresses
      *
      * @param {Object} record
      * @param {Object} accounts
      * @param {Object} options
      *
      */

  }, {
    key: "resolveAddress",
    value: function resolveAddress(record, accounts, options) {
      if (record.to) {
        var stamp = this.extractTimestamp(record.to);

        if (stamp) {
          record.to = this.data._createdContractsReverse[stamp];
        }
      }

      record.from = accounts[record.from]; // @TODO: writing browser test

      return record;
    }
    /**
      * save the given @arg record
      *
      * @param {Number/String} timestamp
      * @param {Object} record
      *
      */

  }, {
    key: "append",
    value: function append(timestamp, record) {
      this.data.journal.push({
        timestamp: timestamp,
        record: record
      });
      this.event.trigger('newTxRecorded', [this.data.journal.length]);
    }
    /**
      * basically return the records + associate values (like abis / accounts)
      *
      */

  }, {
    key: "getAll",
    value: function getAll() {
      var records = [].concat(this.data.journal);
      return {
        accounts: this.data._usedAccounts,
        linkReferences: this.data._linkReferences,
        transactions: records.sort(function (A, B) {
          var stampA = A.timestamp;
          var stampB = B.timestamp;
          return stampA - stampB;
        }),
        abis: this.data._abis
      };
    }
    /**
      * delete the seen transactions
      *
      */

  }, {
    key: "clearAll",
    value: function clearAll() {
      this.data._listen = true;
      this.data._replay = false;
      this.data.journal = [];
      this.data._createdContracts = {};
      this.data._createdContractsReverse = {};
      this.data._usedAccounts = {};
      this.data._abis = {};
      this.data._contractABIReferences = {};
      this.data._linkReferences = {};
      this.event.trigger('cleared', []);
    }
    /**
      * run the list of records
      *
      * @param {Object} records
      * @param {Object} accounts
      * @param {Object} options
      * @param {Object} abis
      * @param {Object} linkReferences
      * @param {Function} confirmationCb
      * @param {Function} continueCb
      * @param {Function} promptCb
      * @param {Function} alertCb
      * @param {Function} logCallBack
      * @param {Function} liveMode
      * @param {Function} newContractFn
      *
      */

  }, {
    key: "run",
    value: function run(records, accounts, options, abis, linkReferences, confirmationCb, continueCb, promptCb, alertCb, logCallBack, liveMode, newContractFn) {
      var _this2 = this;

      this.setListen(false);
      var liveMsg = liveMode ? ' with updated contracts' : '';
      logCallBack("Running ".concat(records.length, " transaction(s)").concat(liveMsg, " ..."));
      async.eachOfSeries(records, /*#__PURE__*/function () {
        var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(tx, index, cb) {
          var _data, updatedABIKeccak, record, abi, k, link, timestamp, fnABI, data;

          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(liveMode && tx.record.type === 'constructor')) {
                    _context.next = 8;
                    break;
                  }

                  _context.next = 3;
                  return _this2.call('compilerArtefacts', 'getArtefactsByContractName', tx.record.contractName);

                case 3:
                  _data = _context.sent;
                  tx.record.bytecode = _data.artefact.evm.bytecode.object;
                  updatedABIKeccak = ethutil.bufferToHex(ethutil.keccakFromString(JSON.stringify(_data.artefact.abi)));
                  abis[updatedABIKeccak] = _data.artefact.abi;
                  tx.record.abi = updatedABIKeccak;

                case 8:
                  record = _this2.resolveAddress(tx.record, accounts, options);
                  abi = abis[tx.record.abi];

                  if (abi) {
                    _context.next = 12;
                    break;
                  }

                  return _context.abrupt("return", alertCb('cannot find ABI for ' + tx.record.abi + '.  Execution stopped at ' + index));

                case 12:
                  /* Resolve Library */
                  if (record.linkReferences && Object.keys(record.linkReferences).length) {
                    for (k in linkReferences) {
                      link = linkReferences[k];
                      timestamp = _this2.extractTimestamp(link);

                      if (timestamp && _this2.data._createdContractsReverse[timestamp]) {
                        link = _this2.data._createdContractsReverse[timestamp];
                      }

                      tx.record.bytecode = format.linkLibraryStandardFromlinkReferences(k, link.replace('0x', ''), tx.record.bytecode, tx.record.linkReferences);
                    }
                  }
                  /* Encode params */


                  if (tx.record.type === 'constructor') {
                    fnABI = txHelper.getConstructorInterface(abi);
                  } else if (tx.record.type === 'fallback') {
                    fnABI = txHelper.getFallbackInterface(abi);
                  } else if (tx.record.type === 'receive') {
                    fnABI = txHelper.getReceiveInterface(abi);
                  } else {
                    fnABI = txHelper.getFunction(abi, record.name + record.inputs);
                  }

                  if (fnABI) {
                    _context.next = 17;
                    break;
                  }

                  alertCb('cannot resolve abi of ' + JSON.stringify(record, null, '\t') + '. Execution stopped at ' + index);
                  return _context.abrupt("return", cb('cannot resolve abi'));

                case 17:
                  if (!tx.record.parameters) {
                    _context.next = 25;
                    break;
                  }

                  _context.prev = 18;
                  tx.record.parameters.forEach(function (value, index) {
                    var isString = true;

                    if (typeof value !== 'string') {
                      isString = false;
                      value = JSON.stringify(value);
                    }

                    for (var timestamp in _this2.data._createdContractsReverse) {
                      value = value.replace(new RegExp('created\\{' + timestamp + '\\}', 'g'), _this2.data._createdContractsReverse[timestamp]);
                    }

                    if (!isString) value = JSON.parse(value);
                    tx.record.parameters[index] = value;
                  });
                  _context.next = 25;
                  break;

                case 22:
                  _context.prev = 22;
                  _context.t0 = _context["catch"](18);
                  return _context.abrupt("return", alertCb('cannot resolve input parameters ' + JSON.stringify(tx.record.parameters) + '. Execution stopped at ' + index));

                case 25:
                  data = format.encodeData(fnABI, tx.record.parameters, tx.record.bytecode);

                  if (!data.error) {
                    _context.next = 29;
                    break;
                  }

                  alertCb(data.error + '. Record:' + JSON.stringify(record, null, '\t') + '. Execution stopped at ' + index);
                  return _context.abrupt("return", cb(data.error));

                case 29:
                  logCallBack("(".concat(index, ") ").concat(JSON.stringify(record, null, '\t')));
                  logCallBack("(".concat(index, ") data: ").concat(data.data));
                  record.data = {
                    dataHex: data.data,
                    funArgs: tx.record.parameters,
                    funAbi: fnABI,
                    contractBytecode: tx.record.bytecode,
                    contractName: tx.record.contractName,
                    timestamp: tx.timestamp
                  };

                  _this2.blockchain.runTx(record, confirmationCb, continueCb, promptCb, function (err, txResult, rawAddress) {
                    if (err) {
                      console.error(err);
                      return logCallBack(err + '. Execution failed at ' + index);
                    }

                    if (rawAddress) {
                      var address = helper.addressToString(rawAddress); // save back created addresses for the convertion from tokens to real adresses

                      _this2.data._createdContracts[address] = tx.timestamp;
                      _this2.data._createdContractsReverse[tx.timestamp] = address;
                      newContractFn(abi, address, record.contractName);
                    }

                    cb(err);
                  });

                case 33:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[18, 22]]);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }(), function () {
        _this2.setListen(true);
      });
    }
  }, {
    key: "runScenario",
    value: function runScenario(liveMode, json, continueCb, promptCb, alertCb, confirmationCb, logCallBack, cb) {
      _paq.push(['trackEvent', 'run', 'recorder', 'start']);

      if (!json) {
        _paq.push(['trackEvent', 'run', 'recorder', 'wrong-json']);

        return cb('a json content must be provided');
      }

      if (typeof json === 'string') {
        try {
          json = JSON.parse(json);
        } catch (e) {
          return cb('A scenario file is required. It must be json formatted');
        }
      }

      var txArray;
      var accounts;
      var options;
      var abis;
      var linkReferences;

      try {
        txArray = json.transactions || [];
        accounts = json.accounts || [];
        options = json.options || {};
        abis = json.abis || {};
        linkReferences = json.linkReferences || {};
      } catch (e) {
        return cb('Invalid scenario file. Please try again');
      }

      if (!txArray.length) {
        return cb('No transactions found in scenario file');
      }

      this.run(txArray, accounts, options, abis, linkReferences, confirmationCb, continueCb, promptCb, alertCb, logCallBack, liveMode, function (abi, address, contractName) {
        cb(null, abi, address, contractName);
      });
    }
  }]);
  return Recorder;
}(_engine.Plugin);

module.exports = Recorder;

/***/ }),
/* 2102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeUdapp = makeUdapp;

var _registry = _interopRequireDefault(__webpack_require__(315));

var remixLib = __webpack_require__(311);

var EventsDecoder = remixLib.execution.EventsDecoder;

function makeUdapp(blockchain, compilersArtefacts, logHtmlCallback) {
  // ----------------- Tx listener -----------------
  var _transactionReceipts = {};

  var transactionReceiptResolver = function transactionReceiptResolver(tx, cb) {
    if (_transactionReceipts[tx.hash]) {
      return cb(null, _transactionReceipts[tx.hash]);
    }

    blockchain.web3().eth.getTransactionReceipt(tx.hash, function (error, receipt) {
      if (error) {
        return cb(error);
      }

      _transactionReceipts[tx.hash] = receipt;
      cb(null, receipt);
    });
  };

  var txlistener = blockchain.getTxListener({
    api: {
      contracts: function contracts() {
        if (compilersArtefacts.__last) return compilersArtefacts.getAllContractDatas();
        return null;
      },
      resolveReceipt: transactionReceiptResolver
    }
  });

  _registry["default"].getInstance().put({
    api: txlistener,
    name: 'txlistener'
  });

  blockchain.startListening(txlistener);
  var eventsDecoder = new EventsDecoder({
    resolveReceipt: transactionReceiptResolver
  });
  txlistener.startListening();

  _registry["default"].getInstance().put({
    api: eventsDecoder,
    name: 'eventsDecoder'
  });
}

/***/ }),
/* 2103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixEngine = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var _events = __webpack_require__(40);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var RemixEngine = /*#__PURE__*/function (_Engine) {
  (0, _inherits2["default"])(RemixEngine, _Engine);

  var _super = _createSuper(RemixEngine);

  function RemixEngine() {
    var _this;

    (0, _classCallCheck2["default"])(this, RemixEngine);
    _this = _super.call(this);
    _this.event = new _events.EventEmitter();
    return _this;
  }

  (0, _createClass2["default"])(RemixEngine, [{
    key: "setPluginOption",
    value: function setPluginOption(_ref) {
      var name = _ref.name,
          kind = _ref.kind;
      if (kind === 'provider') return {
        queueTimeout: 60000 * 2
      };
      if (name === 'LearnEth') return {
        queueTimeout: 60000
      };
      if (name === 'dGitProvider') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'slither') return {
        queueTimeout: 60000 * 4
      }; // Requires when a solc version is installed

      if (name === 'hardhat') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'truffle') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'localPlugin') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'notification') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'sourcify') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'fetchAndCompile') return {
        queueTimeout: 60000 * 4
      };
      if (name === 'walletconnect') return {
        queueTimeout: 60000 * 4
      };
      return {
        queueTimeout: 10000
      };
    }
  }, {
    key: "onRegistration",
    value: function onRegistration(plugin) {
      this.event.emit('onRegistration', plugin);
    }
  }]);
  return RemixEngine;
}(_engine.Engine);

exports.RemixEngine = RemixEngine;

/***/ }),
/* 2104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixAppManager = void 0;
exports.canActivate = canActivate;
exports.isNative = isNative;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var _events = __webpack_require__(40);

var _remixLib = __webpack_require__(311);

var _engineWeb = __webpack_require__(1133);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _paq = window._paq = window._paq || []; // requiredModule removes the plugin from the plugin manager list on UI


var requiredModules = [// services + layout views + system views
'manager', 'config', 'compilerArtefacts', 'compilerMetadata', 'contextualListener', 'editor', 'offsetToLineColumnConverter', 'network', 'theme', 'fileManager', 'contentImport', 'blockchain', 'web3Provider', 'scriptRunner', 'fetchAndCompile', 'mainPanel', 'hiddenPanel', 'sidePanel', 'menuicons', 'filePanel', 'terminal', 'settings', 'pluginManager', 'tabs', 'udapp', 'dGitProvider', 'solidity', 'solidity-logic', 'gistHandler', 'layout', 'notification', 'permissionhandler', 'walkthrough', 'storage', 'restorebackupzip', 'link-libraries', 'deploy-libraries', 'openzeppelin-proxy', 'hardhat-provider', 'ganache-provider', 'foundry-provider', 'basic-http-provider', 'injected-optimism-provider', 'injected-arbitrum-one-provider', 'compileAndRun', 'search', 'recorder']; // dependentModules shouldn't be manually activated (e.g hardhat is activated by remixd)

var dependentModules = ['hardhat', 'truffle', 'slither'];
var sensitiveCalls = {
  'fileManager': ['writeFile', 'copyFile', 'rename', 'copyDir'],
  'contentImport': ['resolveAndSave'],
  'web3Provider': ['sendAsync']
};

function isNative(name) {
  // nativePlugin allows to bypass the permission request
  var nativePlugins = ['vyper', 'workshops', 'debugger', 'remixd', 'menuicons', 'solidity', 'solidity-logic', 'solidityStaticAnalysis', 'solidityUnitTesting', 'layout', 'notification', 'hardhat-provider', 'ganache-provider', 'foundry-provider', 'basic-http-provider', 'injected-optimism-provider', 'injected-arbitrum-one-provider'];
  return nativePlugins.includes(name) || requiredModules.includes(name);
}
/**
 * Checks if plugin caller 'from' is allowed to activate plugin 'to'
 * The caller can have 'canActivate' as a optional property in the plugin profile.
 * This is an array containing the 'name' property of the plugin it wants to call.
 * canActivate = ['plugin1-to-call','plugin2-to-call',....]
 * or the plugin is allowed by default because it is native
 *
 * @param {any, any}
 * @returns {boolean}
 */


function canActivate(from, to) {
  return ['ethdoc'].includes(from.name) || isNative(from.name) || to && from && from.canActivate && from.canActivate.includes(to.name);
}

var RemixAppManager = /*#__PURE__*/function (_PluginManager) {
  (0, _inherits2["default"])(RemixAppManager, _PluginManager);

  var _super = _createSuper(RemixAppManager);

  function RemixAppManager() {
    var _this;

    (0, _classCallCheck2["default"])(this, RemixAppManager);
    _this = _super.call(this);
    _this.event = new _events.EventEmitter();
    _this.pluginsDirectory = 'https://raw.githubusercontent.com/ethereum/remix-plugins-directory/master/build/metadata.json';
    _this.pluginLoader = new PluginLoader();
    return _this;
  }

  (0, _createClass2["default"])(RemixAppManager, [{
    key: "canActivatePlugin",
    value: function () {
      var _canActivatePlugin = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(from, to) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", canActivate(from, to));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function canActivatePlugin(_x, _x2) {
        return _canActivatePlugin.apply(this, arguments);
      }

      return canActivatePlugin;
    }()
  }, {
    key: "canDeactivatePlugin",
    value: function () {
      var _canDeactivatePlugin = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(from, to) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!requiredModules.includes(to.name)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", false);

              case 2:
                return _context2.abrupt("return", isNative(from.name));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function canDeactivatePlugin(_x3, _x4) {
        return _canDeactivatePlugin.apply(this, arguments);
      }

      return canDeactivatePlugin;
    }()
  }, {
    key: "canDeactivate",
    value: function () {
      var _canDeactivate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(from, to) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.canDeactivatePlugin(from, to));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function canDeactivate(_x5, _x6) {
        return _canDeactivate.apply(this, arguments);
      }

      return canDeactivate;
    }()
  }, {
    key: "deactivatePlugin",
    value: function () {
      var _deactivatePlugin = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(name) {
        var to, from;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getProfile(name);

              case 2:
                to = _context4.sent;
                _context4.next = 5;
                return this.getProfile(this.requestFrom);

              case 5:
                from = _context4.sent;

                if (!this.canDeactivatePlugin(from, to)) {
                  _context4.next = 9;
                  break;
                }

                _context4.next = 9;
                return this.toggleActive(name);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function deactivatePlugin(_x7) {
        return _deactivatePlugin.apply(this, arguments);
      }

      return deactivatePlugin;
    }()
  }, {
    key: "canCall",
    value: function () {
      var _canCall = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(from, to, method, message) {
        var isSensitiveCall;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                isSensitiveCall = sensitiveCalls[to] && sensitiveCalls[to].includes(method); // Make sure the caller of this methods is the target plugin

                if (!(to !== this.currentRequest.from)) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return", false);

              case 3:
                if (!isNative(from)) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", true);

              case 5:
                _context5.next = 7;
                return this.call('permissionhandler', 'askPermission', this.profiles[from], this.profiles[to], method, message, isSensitiveCall);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function canCall(_x8, _x9, _x10, _x11) {
        return _canCall.apply(this, arguments);
      }

      return canCall;
    }()
  }, {
    key: "onPluginActivated",
    value: function onPluginActivated(plugin) {
      this.pluginLoader.set(plugin, this.actives);
      this.event.emit('activate', plugin);
      this.emit('activate', plugin);
      if (!requiredModules.includes(plugin.name)) _paq.push(['trackEvent', 'pluginManager', 'activate', plugin.name]);
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var _this2 = this;

      return Object.keys(this.profiles).map(function (p) {
        return _this2.profiles[p];
      });
    }
  }, {
    key: "getIds",
    value: function getIds() {
      return Object.keys(this.profiles);
    }
  }, {
    key: "onPluginDeactivated",
    value: function onPluginDeactivated(plugin) {
      this.pluginLoader.set(plugin, this.actives);
      this.event.emit('deactivate', plugin);

      _paq.push(['trackEvent', 'pluginManager', 'deactivate', plugin.name]);
    }
  }, {
    key: "isDependent",
    value: function isDependent(name) {
      return dependentModules.includes(name);
    }
  }, {
    key: "isRequired",
    value: function isRequired(name) {
      // excluding internal use plugins
      return requiredModules.includes(name);
    }
  }, {
    key: "registeredPlugins",
    value: function () {
      var _registeredPlugins = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        var plugins, res, savedPlugins;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return fetch(this.pluginsDirectory);

              case 3:
                res = _context6.sent;
                _context6.next = 6;
                return res.json();

              case 6:
                plugins = _context6.sent;
                plugins = plugins.filter(function (plugin) {
                  if (plugin.targets && Array.isArray(plugin.targets) && plugin.targets.length > 0) {
                    return plugin.targets.includes('remix');
                  }

                  return true;
                });
                localStorage.setItem('plugins-directory', JSON.stringify(plugins));
                _context6.next = 16;
                break;

              case 11:
                _context6.prev = 11;
                _context6.t0 = _context6["catch"](0);
                console.log('getting plugins list from localstorage...');
                savedPlugins = localStorage.getItem('plugins-directory');

                if (savedPlugins) {
                  try {
                    plugins = JSON.parse(savedPlugins);
                  } catch (e) {
                    console.error(e);
                  }
                }

              case 16:
                return _context6.abrupt("return", plugins.map(function (plugin) {
                  return new _engineWeb.IframePlugin(plugin); // return new IframeReactPlugin(plugin)
                }));

              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 11]]);
      }));

      function registeredPlugins() {
        return _registeredPlugins.apply(this, arguments);
      }

      return registeredPlugins;
    }()
  }, {
    key: "registerContextMenuItems",
    value: function () {
      var _registerContextMenuItems = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.call('filePanel', 'registerContextMenuItem', {
                  id: 'flattener',
                  name: 'flattenFileCustomAction',
                  label: 'Flatten',
                  type: [],
                  extension: ['.sol'],
                  path: [],
                  pattern: [],
                  sticky: true
                });

              case 2:
                _context7.next = 4;
                return this.call('filePanel', 'registerContextMenuItem', {
                  id: 'nahmii-compiler',
                  name: 'compileCustomAction',
                  label: 'Compile for Nahmii',
                  type: [],
                  extension: ['.sol'],
                  path: [],
                  pattern: [],
                  sticky: true
                });

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function registerContextMenuItems() {
        return _registerContextMenuItems.apply(this, arguments);
      }

      return registerContextMenuItems;
    }()
  }]);
  return RemixAppManager;
}(_engine.PluginManager);
/** @class Reference loaders.
 *  A loader is a get,set based object which load a workspace from a defined sources.
 *  (localStorage, queryParams)
 **/


exports.RemixAppManager = RemixAppManager;

var PluginLoader = /*#__PURE__*/function () {
  function PluginLoader() {
    var _this3 = this;

    (0, _classCallCheck2["default"])(this, PluginLoader);
    var queryParams = new _remixLib.QueryParams();
    this.donotAutoReload = ['remixd', 'git']; // that would be a bad practice to force loading some plugins at page load.

    this.loaders = {};
    this.loaders.localStorage = {
      set: function set(plugin, actives) {
        var saved = actives.filter(function (name) {
          return !_this3.donotAutoReload.includes(name);
        });
        localStorage.setItem('workspace', JSON.stringify(saved));
      },
      get: function get() {
        return JSON.parse(localStorage.getItem('workspace'));
      }
    };
    this.loaders.queryParams = {
      set: function set() {
        /* Do nothing. */
      },
      get: function get() {
        var _queryParams$get = queryParams.get(),
            activate = _queryParams$get.activate;

        if (!activate) return [];
        return activate.split(',');
      }
    };
    this.current = queryParams.get().activate ? 'queryParams' : 'localStorage';
  }

  (0, _createClass2["default"])(PluginLoader, [{
    key: "currentLoader",
    get: function get() {
      return this.loaders[this.current];
    }
  }, {
    key: "set",
    value: function set(plugin, actives) {
      this.currentLoader.set(plugin, actives);
    }
  }, {
    key: "get",
    value: function get() {
      return this.currentLoader.get();
    }
  }]);
  return PluginLoader;
}();

/***/ }),
/* 2105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.profile = exports.NetworkModule = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _web = __webpack_require__(1125);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'network',
  description: 'Manage the network (mainnet, ropsten, goerli...) and the provider (web3, vm, injected)',
  methods: ['getNetworkProvider', 'getEndpoint', 'detectNetwork', 'addNetwork', 'removeNetwork'],
  version: packageJson.version,
  kind: 'network'
}; // Network API has :
// - events: ['providerChanged']
// - methods: ['getNetworkProvider', 'getEndpoint', 'detectNetwork', 'addNetwork', 'removeNetwork']

exports.profile = profile;

var NetworkModule = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(NetworkModule, _Plugin);

  var _super = _createSuper(NetworkModule);

  function NetworkModule(blockchain) {
    var _this;

    (0, _classCallCheck2["default"])(this, NetworkModule);
    _this = _super.call(this, profile);
    _this.blockchain = blockchain; // TODO: See with remix-lib to make sementic coherent

    _this.blockchain.event.register('contextChanged', function (provider) {
      _this.emit('providerChanged', provider);
    });

    return _this;
  }
  /** Return the current network provider (web3, vm, injected) */


  (0, _createClass2["default"])(NetworkModule, [{
    key: "getNetworkProvider",
    value: function getNetworkProvider() {
      return this.blockchain.getProvider();
    }
    /** Return the current network */

  }, {
    key: "detectNetwork",
    value: function detectNetwork() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.blockchain.detectNetwork(function (error, network) {
          error ? reject(error) : resolve(network);
        });
      });
    }
    /** Return the url only if network provider is 'web3' */

  }, {
    key: "getEndpoint",
    value: function getEndpoint() {
      var provider = this.blockchain.getProvider();

      if (provider !== 'web3') {
        throw new Error('no endpoint: current provider is either injected or vm');
      }

      return this.blockchain.web3().currentProvider.host;
    }
    /** Add a custom network to the list of available networks */

  }, {
    key: "addNetwork",
    value: function addNetwork(network) {
      // { name, url }
      var provider = network.url === 'ipc' ? new _web.Web3.providers.IpcProvider() : new _web.Web3.providers.HttpProvider(network.url);
      this.blockchain.addProvider({
        name: network.name,
        provider: provider
      });
    }
    /** Remove a network to the list of availble networks */

  }, {
    key: "removeNetwork",
    value: function removeNetwork(name) {
      this.blockchain.removeProvider(name);
    }
  }]);
  return NetworkModule;
}(_engine.Plugin);

exports.NetworkModule = NetworkModule;

/***/ }),
/* 2106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.profile = exports.Web3ProviderModule = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'web3Provider',
  displayName: 'Global Web3 Provider',
  description: 'Represent the current web3 provider used by the app at global scope',
  methods: ['sendAsync'],
  version: packageJson.version,
  kind: 'provider'
};
exports.profile = profile;

var Web3ProviderModule = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(Web3ProviderModule, _Plugin);

  var _super = _createSuper(Web3ProviderModule);

  function Web3ProviderModule(blockchain) {
    var _this;

    (0, _classCallCheck2["default"])(this, Web3ProviderModule);
    _this = _super.call(this, profile);
    _this.blockchain = blockchain;
    return _this;
  }
  /*
    that is used by plugins to call the current ethereum provider.
    Should be taken carefully and probably not be release as it is now.
  */


  (0, _createClass2["default"])(Web3ProviderModule, [{
    key: "sendAsync",
    value: function sendAsync(payload) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.askUserPermission('sendAsync', "Calling ".concat(payload.method, " with parameters ").concat(JSON.stringify(payload.params, null, '\t'))).then( /*#__PURE__*/function () {
          var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(result) {
            var provider;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (result) {
                      provider = _this2.blockchain.web3().currentProvider; // see https://github.com/ethereum/web3.js/pull/1018/files#diff-d25786686c1053b786cc2626dc6e048675050593c0ebaafbf0814e1996f22022R129

                      provider[provider.sendAsync ? 'sendAsync' : 'send'](payload, /*#__PURE__*/function () {
                        var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(error, message) {
                          return _regenerator["default"].wrap(function _callee2$(_context2) {
                            while (1) {
                              switch (_context2.prev = _context2.next) {
                                case 0:
                                  if (!error) {
                                    _context2.next = 2;
                                    break;
                                  }

                                  return _context2.abrupt("return", reject(error));

                                case 2:
                                  if (payload.method === 'eth_sendTransaction') {
                                    if (payload.params.length && !payload.params[0].to && message.result) {
                                      setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
                                        var receipt, contractData;
                                        return _regenerator["default"].wrap(function _callee$(_context) {
                                          while (1) {
                                            switch (_context.prev = _context.next) {
                                              case 0:
                                                _context.next = 2;
                                                return _this2.tryTillReceiptAvailable(message.result);

                                              case 2:
                                                receipt = _context.sent;

                                                if (receipt.contractAddress) {
                                                  _context.next = 6;
                                                  break;
                                                }

                                                console.log('receipt available but contract address not present', receipt);
                                                return _context.abrupt("return");

                                              case 6:
                                                _context.next = 8;
                                                return _this2.call('compilerArtefacts', 'getContractDataFromAddress', receipt.contractAddress);

                                              case 8:
                                                contractData = _context.sent;
                                                if (contractData) _this2.call('udapp', 'addInstance', receipt.contractAddress, contractData.contract.abi, contractData.name);

                                              case 10:
                                              case "end":
                                                return _context.stop();
                                            }
                                          }
                                        }, _callee);
                                      })), 50);
                                    }
                                  }

                                  resolve(message);

                                case 4:
                                case "end":
                                  return _context2.stop();
                              }
                            }
                          }, _callee2);
                        }));

                        return function (_x2, _x3) {
                          return _ref2.apply(this, arguments);
                        };
                      }());
                    } else {
                      reject(new Error('User denied permission'));
                    }

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }())["catch"](function (e) {
          reject(e);
        });
      });
    }
  }, {
    key: "tryTillReceiptAvailable",
    value: function () {
      var _tryTillReceiptAvailable = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(txhash) {
        var receipt;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this.call('blockchain', 'getTransactionReceipt', txhash);

              case 3:
                receipt = _context4.sent;

                if (!receipt) {
                  _context4.next = 6;
                  break;
                }

                return _context4.abrupt("return", receipt);

              case 6:
                _context4.next = 10;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](0);

              case 10:
                _context4.next = 12;
                return this.pause();

              case 12:
                _context4.next = 14;
                return this.tryTillReceiptAvailable(txhash);

              case 14:
                return _context4.abrupt("return", _context4.sent);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 8]]);
      }));

      function tryTillReceiptAvailable(_x4) {
        return _tryTillReceiptAvailable.apply(this, arguments);
      }

      return tryTillReceiptAvailable;
    }()
  }, {
    key: "pause",
    value: function () {
      var _pause = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", new Promise(function (resolve, reject) {
                  setTimeout(resolve, 500);
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function pause() {
        return _pause.apply(this, arguments);
      }

      return pause;
    }()
  }]);
  return Web3ProviderModule;
}(_engine.Plugin);

exports.Web3ProviderModule = Web3ProviderModule;

/***/ }),
/* 2107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.profile = exports.CompileAndRun = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _paq = window._paq = window._paq || [];

var profile = {
  name: 'compileAndRun',
  displayName: 'Compile and Run',
  description: 'After each compilation, run the script defined in Natspec.',
  methods: ['runScriptAfterCompilation'],
  version: packageJson.version,
  kind: 'none'
};
exports.profile = profile;

var CompileAndRun = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(CompileAndRun, _Plugin);

  var _super = _createSuper(CompileAndRun);

  function CompileAndRun() {
    var _this;

    (0, _classCallCheck2["default"])(this, CompileAndRun);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "executionListener", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "targetFileName", void 0);

    _this.executionListener = /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(e) {
        var file;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!((e.metaKey || e.ctrlKey) && e.shiftKey && e.keyCode === 83)) {
                  _context.next = 14;
                  break;
                }

                _context.next = 3;
                return _this.call('fileManager', 'file');

              case 3:
                file = _context.sent;

                if (!file) {
                  _context.next = 14;
                  break;
                }

                if (!file.endsWith('.sol')) {
                  _context.next = 13;
                  break;
                }

                e.preventDefault();
                _this.targetFileName = file;
                _context.next = 10;
                return _this.call('solidity', 'compile', file);

              case 10:
                _paq.push(['trackEvent', 'ScriptExecutor', 'CompileAndRun', 'compile_solidity']);

                _context.next = 14;
                break;

              case 13:
                if (file.endsWith('.js') || file.endsWith('.ts')) {
                  e.preventDefault();

                  _this.runScript(file, false);

                  _paq.push(['trackEvent', 'ScriptExecutor', 'CompileAndRun', 'run_script']);
                }

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    return _this;
  }

  (0, _createClass2["default"])(CompileAndRun, [{
    key: "runScriptAfterCompilation",
    value: function runScriptAfterCompilation(fileName) {
      this.targetFileName = fileName;

      _paq.push(['trackEvent', 'ScriptExecutor', 'CompileAndRun', 'request_run_script']);
    }
  }, {
    key: "runScript",
    value: function () {
      var _runScript = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(fileName, clearAllInstances) {
        var exists, content;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.call('terminal', 'log', "running ".concat(fileName, " ..."));

              case 2:
                _context2.prev = 2;
                _context2.next = 5;
                return this.call('fileManager', 'exists', fileName);

              case 5:
                exists = _context2.sent;

                if (exists) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 9;
                return this.call('terminal', 'log', "".concat(fileName, " does not exist."));

              case 9:
                return _context2.abrupt("return");

              case 10:
                _context2.next = 12;
                return this.call('fileManager', 'readFile', fileName);

              case 12:
                content = _context2.sent;

                if (!clearAllInstances) {
                  _context2.next = 16;
                  break;
                }

                _context2.next = 16;
                return this.call('udapp', 'clearAllInstances');

              case 16:
                _context2.next = 18;
                return this.call('scriptRunner', 'execute', content);

              case 18:
                _context2.next = 23;
                break;

              case 20:
                _context2.prev = 20;
                _context2.t0 = _context2["catch"](2);
                this.call('notification', 'toast', _context2.t0.message || _context2.t0);

              case 23:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 20]]);
      }));

      function runScript(_x2, _x3) {
        return _runScript.apply(this, arguments);
      }

      return runScript;
    }()
  }, {
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      window.document.addEventListener('keydown', this.executionListener);
      this.on('compilerMetadata', 'artefactsUpdated', /*#__PURE__*/function () {
        var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(fileName, contract) {
          var file;
          return _regenerator["default"].wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (_this2.targetFileName === contract.file) {
                    if (contract.object && contract.object.devdoc['custom:dev-run-script']) {
                      _this2.targetFileName = null;
                      file = contract.object.devdoc['custom:dev-run-script'];

                      if (file) {
                        _this2.runScript(file, true);

                        _paq.push(['trackEvent', 'ScriptExecutor', 'CompileAndRun', 'run_script_after_compile']);
                      } else {
                        _this2.call('notification', 'toast', 'You have not set a script to run. Set it with @custom:dev-run-script NatSpec tag.');
                      }
                    } else {
                      _this2.call('notification', 'toast', 'You have not set a script to run. Set it with @custom:dev-run-script NatSpec tag.');
                    }
                  }

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x4, _x5) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      window.document.removeEventListener('keydown', this.executionListener);
      this.off('compilerMetadata', 'artefactsUpdated');
    }
  }]);
  return CompileAndRun;
}(_engine.Plugin);

exports.CompileAndRun = CompileAndRun;

/***/ }),
/* 2108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SidePanel = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _get2 = _interopRequireDefault(__webpack_require__(1197));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _panel = __webpack_require__(1311);

var _panel2 = __webpack_require__(485);

var _package = _interopRequireDefault(__webpack_require__(312));

var _panelHeader = _interopRequireDefault(__webpack_require__(2110));

var _helper = __webpack_require__(1121);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// const csjs = require('csjs-inject')
var sidePanel = {
  name: 'sidePanel',
  displayName: 'Side Panel',
  description: 'Remix IDE side panel',
  version: _package["default"].version,
  methods: ['addView', 'removeView']
};

var SidePanel = /*#__PURE__*/function (_AbstractPanel) {
  (0, _inherits2["default"])(SidePanel, _AbstractPanel);

  var _super = _createSuper(SidePanel);

  function SidePanel() {
    var _this;

    (0, _classCallCheck2["default"])(this, SidePanel);
    _this = _super.call(this, sidePanel);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "sideelement", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dispatch", function () {});
    _this.sideelement = document.createElement('section');

    _this.sideelement.setAttribute('class', 'panel plugin-manager');

    return _this;
  }

  (0, _createClass2["default"])(SidePanel, [{
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      this.renderComponent(); // Toggle content

      this.on('menuicons', 'toggleContent', function (name) {
        if (!_this2.plugins[name]) return;

        if (_this2.plugins[name].active) {
          // TODO: Only keep `this.emit` (issue#2210)
          _this2.emit('toggle', name);

          _this2.events.emit('toggle', name);

          return;
        }

        _this2.showContent(name); // TODO: Only keep `this.emit` (issue#2210)


        _this2.emit('showing', name);

        _this2.events.emit('showing', name);
      }); // Force opening

      this.on('menuicons', 'showContent', function (name) {
        if (!_this2.plugins[name]) return;

        _this2.showContent(name); // TODO: Only keep `this.emit` (issue#2210)


        _this2.emit('showing', name);

        _this2.events.emit('showing', name);
      });
    }
  }, {
    key: "focus",
    value: function focus(name) {
      this.emit('focusChanged', name);
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(SidePanel.prototype), "focus", this).call(this, name);
    }
  }, {
    key: "removeView",
    value: function removeView(profile) {
      if (this.plugins[profile.name].active) this.call('menuicons', 'select', 'filePanel');
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(SidePanel.prototype), "removeView", this).call(this, profile);
      this.emit('pluginDisabled', profile.name);
      this.call('menuicons', 'unlinkContent', profile);
      this.renderComponent();
    }
  }, {
    key: "addView",
    value: function addView(profile, view) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(SidePanel.prototype), "addView", this).call(this, profile, view);
      this.call('menuicons', 'linkContent', profile);
      this.renderComponent();
    }
    /**
     * Display content and update the header
     * @param {String} name The name of the plugin to display
     */

  }, {
    key: "showContent",
    value: function () {
      var _showContent = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(name) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (0, _get2["default"])((0, _getPrototypeOf2["default"])(SidePanel.prototype), "showContent", this).call(this, name);
                this.emit('focusChanged', name);
                this.renderComponent();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function showContent(_x) {
        return _showContent.apply(this, arguments);
      }

      return showContent;
    }()
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("section", {
        className: "panel plugin-manager"
      }, " ", /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_panel2.RemixPluginPanel, {
        header: /*#__PURE__*/_react["default"].createElement(_panelHeader["default"], {
          plugins: state.plugins
        }),
        plugins: state.plugins
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      this.dispatch({
        plugins: this.plugins
      });
    }
  }]);
  return SidePanel;
}(_panel.AbstractPanel);

exports.SidePanel = SidePanel;

/***/ }),
/* 2109 */,
/* 2110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(319);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable jsx-a11y/anchor-has-content */
const RemixUIPanelHeader = props => {
  var _plugin$profile, _plugin$profile$maint, _plugin$profile2, _plugin$profile3, _plugin$profile4, _plugin$profile5, _plugin$profile6, _plugin$profile7, _plugin$profile8;

  const [plugin, setPlugin] = (0, _react.useState)();
  const [toggleExpander, setToggleExpander] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    setToggleExpander(false);

    if (props.plugins) {
      const p = Object.values(props.plugins).find(pluginRecord => {
        return pluginRecord.active === true;
      });
      setPlugin(p);
    }
  }, [props]);

  const toggleClass = () => {
    setToggleExpander(!toggleExpander);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("header", {
    className: "d-flex flex-column",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "swapitHeader px-3 pt-2 pb-0 d-flex flex-row",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        className: "mb-2",
        "data-id": "sidePanelSwapitTitle",
        children: (plugin === null || plugin === void 0 ? void 0 : plugin.profile.displayName) || (plugin === null || plugin === void 0 ? void 0 : plugin.profile.name)
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "mt-2 d-flex flex-row",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "d-flex flex-row",
          children: (plugin === null || plugin === void 0 ? void 0 : (_plugin$profile = plugin.profile) === null || _plugin$profile === void 0 ? void 0 : (_plugin$profile$maint = _plugin$profile.maintainedBy) === null || _plugin$profile$maint === void 0 ? void 0 : _plugin$profile$maint.toLowerCase()) === "remix" && /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            "aria-hidden": "true",
            className: "text-success mt-1 px-1 fas fa-check",
            title: "Maintained by Remix"
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "swapitHeaderInfoSection d-flex justify-content-between",
          "data-id": "swapitHeaderInfoSectionId",
          onClick: toggleClass,
          title: "Plugin info",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            className: `px-2 ml-2 pt-1 pb-4 ${!toggleExpander ? 'fas fa-angle-right' : 'fas fa-angle-down bg-light'}`,
            "aria-hidden": "true"
          })
        })]
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: `bg-light mx-3 mb-2 p-3 pt-1 border-bottom flex-column ${toggleExpander ? "d-flex" : "d-none"}`,
      children: [(plugin === null || plugin === void 0 ? void 0 : (_plugin$profile2 = plugin.profile) === null || _plugin$profile2 === void 0 ? void 0 : _plugin$profile2.author) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        className: "d-flex flex-row align-items-center",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "mb-0 pr-2",
          children: "Author:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: [" ", plugin === null || plugin === void 0 ? void 0 : plugin.profile.author, " "]
        })]
      }), (plugin === null || plugin === void 0 ? void 0 : (_plugin$profile3 = plugin.profile) === null || _plugin$profile3 === void 0 ? void 0 : _plugin$profile3.maintainedBy) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        className: "d-flex flex-row align-items-center",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "mb-0 pr-2",
          children: "Maintained by:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: [" ", plugin === null || plugin === void 0 ? void 0 : plugin.profile.maintainedBy, " "]
        })]
      }), (plugin === null || plugin === void 0 ? void 0 : (_plugin$profile4 = plugin.profile) === null || _plugin$profile4 === void 0 ? void 0 : _plugin$profile4.documentation) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        className: "d-flex flex-row align-items-center",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "mb-0 pr-2",
          children: "Documentation:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            href: plugin === null || plugin === void 0 ? void 0 : (_plugin$profile5 = plugin.profile) === null || _plugin$profile5 === void 0 ? void 0 : _plugin$profile5.documentation,
            className: "titleInfo p-0 mb-2",
            title: "link to documentation",
            target: "_blank",
            rel: "noreferrer",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              "aria-hidden": "true",
              className: "fas fa-book"
            })
          })
        })]
      }), (plugin === null || plugin === void 0 ? void 0 : (_plugin$profile6 = plugin.profile) === null || _plugin$profile6 === void 0 ? void 0 : _plugin$profile6.description) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        className: "d-flex flex-row align-items-baseline",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "mb-0 pr-2",
          children: "Description:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: [" ", plugin === null || plugin === void 0 ? void 0 : plugin.profile.description, " "]
        })]
      }), (plugin === null || plugin === void 0 ? void 0 : (_plugin$profile7 = plugin.profile) === null || _plugin$profile7 === void 0 ? void 0 : _plugin$profile7.repo) && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "d-flex flex-row align-items-center",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
          href: plugin === null || plugin === void 0 ? void 0 : (_plugin$profile8 = plugin.profile) === null || _plugin$profile8 === void 0 ? void 0 : _plugin$profile8.repo,
          target: "_blank",
          rel: "noreferrer",
          children: "Make an issue"
        })
      })]
    })]
  });
};

var _default = RemixUIPanelHeader;
exports.default = _default;

/***/ }),
/* 2111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HiddenPanel = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _get2 = _interopRequireDefault(__webpack_require__(1197));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _panel = __webpack_require__(1311);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _panel2 = __webpack_require__(485);

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'hiddenPanel',
  displayName: 'Hidden Panel',
  description: 'Remix IDE hidden panel',
  version: packageJson.version,
  methods: ['addView', 'removeView']
};

var HiddenPanel = /*#__PURE__*/function (_AbstractPanel) {
  (0, _inherits2["default"])(HiddenPanel, _AbstractPanel);

  var _super = _createSuper(HiddenPanel);

  function HiddenPanel() {
    var _this;

    (0, _classCallCheck2["default"])(this, HiddenPanel);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "el", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dispatch", function () {});
    _this.el = document.createElement('div');

    _this.el.setAttribute('class', 'pluginsContainer');

    return _this;
  }

  (0, _createClass2["default"])(HiddenPanel, [{
    key: "addView",
    value: function addView(profile, view) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(HiddenPanel.prototype), "removeView", this).call(this, profile);
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(HiddenPanel.prototype), "addView", this).call(this, profile, view);
      this.renderComponent();
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_panel2.RemixPluginPanel, {
        header: /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null),
        plugins: state.plugins
      });
    }
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        className: "pluginsContainer"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      this.dispatch({
        plugins: this.plugins
      });
    }
  }]);
  return HiddenPanel;
}(_panel.AbstractPanel);

exports.HiddenPanel = HiddenPanel;

/***/ }),
/* 2112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerticalIcons = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _package = _interopRequireDefault(__webpack_require__(312));

var _engine = __webpack_require__(477);

var _events = __webpack_require__(40);

var _verticalIconsPanel = __webpack_require__(2113);

var _helper = __webpack_require__(1121);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'menuicons',
  displayName: 'Vertical Icons',
  description: 'Remix IDE vertical icons',
  version: _package["default"].version,
  methods: ['select', 'unlinkContent', 'linkContent'],
  events: ['toggleContent', 'showContent']
};

var VerticalIcons = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(VerticalIcons, _Plugin);

  var _super = _createSuper(VerticalIcons);

  function VerticalIcons() {
    var _this;

    (0, _classCallCheck2["default"])(this, VerticalIcons);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "events", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "htmlElement", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "icons", {});
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dispatch", function () {});
    _this.events = new _events.EventEmitter();
    _this.htmlElement = document.createElement('div');

    _this.htmlElement.setAttribute('id', 'icon-panel');

    return _this;
  }

  (0, _createClass2["default"])(VerticalIcons, [{
    key: "renderComponent",
    value: function renderComponent() {
      var fixedOrder = ['filePanel', 'search', 'solidity', 'udapp', 'debugger', 'solidityStaticAnalysis', 'solidityUnitTesting', 'pluginManager'];
      var divived = Object.values(this.icons).map(function (value) {
        return _objectSpread(_objectSpread({}, value), {}, {
          isRequired: fixedOrder.indexOf(value.profile.name) > -1
        });
      }).sort(function (a, b) {
        return a.timestamp - b.timestamp;
      });
      var required = divived.filter(function (value) {
        return value.isRequired;
      }).sort(function (a, b) {
        return fixedOrder.indexOf(a.profile.name) - fixedOrder.indexOf(b.profile.name);
      });
      var sorted = [].concat((0, _toConsumableArray2["default"])(required), (0, _toConsumableArray2["default"])(divived.filter(function (value) {
        return !value.isRequired;
      })));
      this.dispatch({
        verticalIconsPlugin: this,
        icons: sorted
      });
    }
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "onActivation",
    value: function onActivation() {
      var _this2 = this;

      this.renderComponent();
      this.on('sidePanel', 'focusChanged', function (name) {
        Object.keys(_this2.icons).map(function (o) {
          _this2.icons[o].active = false;
        });
        _this2.icons[name].active = true;

        _this2.renderComponent();
      });
    }
  }, {
    key: "linkContent",
    value: function () {
      var _linkContent = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(profile) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (profile.icon) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                if (!profile.kind) profile.kind = 'none';
                _context.t0 = profile;
                _context.next = 6;
                return this.call('manager', 'canDeactivate', this.profile, profile);

              case 6:
                _context.t1 = _context.sent;
                _context.t2 = Date.now();
                this.icons[profile.name] = {
                  profile: _context.t0,
                  active: false,
                  canbeDeactivated: _context.t1,
                  timestamp: _context.t2
                };
                this.renderComponent();

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function linkContent(_x) {
        return _linkContent.apply(this, arguments);
      }

      return linkContent;
    }()
  }, {
    key: "unlinkContent",
    value: function unlinkContent(profile) {
      delete this.icons[profile.name];
      this.renderComponent();
    }
  }, {
    key: "activateHome",
    value: function () {
      var _activateHome = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.call('manager', 'activatePlugin', 'home');

              case 2:
                _context2.next = 4;
                return this.call('tabs', 'focus', 'home');

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function activateHome() {
        return _activateHome.apply(this, arguments);
      }

      return activateHome;
    }()
    /**
     * Set an icon as active
     * @param {string} name Name of profile of the module to activate
     */

  }, {
    key: "select",
    value: function select(name) {
      // TODO: Only keep `this.emit` (issue#2210)
      this.emit('showContent', name);
      this.events.emit('showContent', name);
    }
    /**
     * Toggles the side panel for plugin
     * @param {string} name Name of profile of the module to activate
     */

  }, {
    key: "toggle",
    value: function toggle(name) {
      // TODO: Only keep `this.emit` (issue#2210)
      this.emit('toggleContent', name);
      this.events.emit('toggleContent', name);
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_verticalIconsPanel.RemixUiVerticalIconsPanel, {
        verticalIconsPlugin: state.verticalIconsPlugin,
        icons: state.icons
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "icon-panel"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }]);
  return VerticalIcons;
}(_engine.Plugin);

exports.VerticalIcons = VerticalIcons;

/***/ }),
/* 2113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "IconRecord", {
  enumerable: true,
  get: function () {
    return _types.IconRecord;
  }
});
Object.defineProperty(exports, "RemixUiVerticalIconsPanel", {
  enumerable: true,
  get: function () {
    return _remixUiVerticalIconsPanel.default;
  }
});

var _remixUiVerticalIconsPanel = _interopRequireDefault(__webpack_require__(2114));

var _types = __webpack_require__(2126);

/***/ }),
/* 2114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2115);

var _IconList = _interopRequireDefault(__webpack_require__(2117));

var _Home = _interopRequireDefault(__webpack_require__(2122));

var _verticalScrollReducer = __webpack_require__(2124);

var _Chevron = __webpack_require__(2125);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const initialState = {
  scrollHeight: 0,
  clientHeight: 0,
  scrollState: false
};

const RemixUiVerticalIconsPanel = ({
  verticalIconsPlugin,
  icons
}) => {
  const scrollableRef = (0, _react.useRef)();
  const iconPanelRef = (0, _react.useRef)();
  const [activateScroll, dispatchScrollAction] = (0, _react.useReducer)(_verticalScrollReducer.verticalScrollReducer, initialState);
  const [theme, setTheme] = (0, _react.useState)('dark');

  const evaluateScrollability = () => {
    var _scrollableRef$curren, _scrollableRef$curren2;

    dispatchScrollAction({
      type: 'resize',
      payload: {
        scrollHeight: (_scrollableRef$curren = scrollableRef.current) === null || _scrollableRef$curren === void 0 ? void 0 : _scrollableRef$curren.scrollHeight,
        clientHeight: (_scrollableRef$curren2 = scrollableRef.current) === null || _scrollableRef$curren2 === void 0 ? void 0 : _scrollableRef$curren2.clientHeight,
        scrollState: false
      }
    });
  };

  (0, _react.useEffect)(() => {
    window.addEventListener('resize', evaluateScrollability);
    evaluateScrollability();
    return () => {
      window.removeEventListener('resize', evaluateScrollability);
    };
  }, []);
  (0, _react.useEffect)(() => {
    evaluateScrollability();
  }, [icons, theme]);
  (0, _react.useEffect)(() => {
    verticalIconsPlugin.call('theme', 'currentTheme').then(th => {
      setTheme(th.quality);
    });
    verticalIconsPlugin.on('theme', 'themeChanged', th => {
      setTheme(th.quality);
    });
    return () => {
      verticalIconsPlugin.off('theme', 'themeChanged');
    };
  }, []);

  async function itemContextAction(e, name, documentation) {
    verticalIconsPlugin.call('manager', 'deactivatePlugin', name);
  }

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "iconsP",
    className: "h-100",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "remixui_icons d-flex flex-column vh-100",
      ref: iconPanelRef,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Home.default, {
        verticalIconPlugin: verticalIconsPlugin
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: scrollableRef.current && scrollableRef.current.scrollHeight > scrollableRef.current.clientHeight ? 'remixui_default-icons-container remixui_requiredSection' : activateScroll && activateScroll.scrollState ? 'remixui_default-icons-container remixui_requiredSection' : 'remixui_requiredSection',
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_IconList.default, {
          theme: theme,
          icons: icons.filter(p => p.isRequired && p.profile.name !== 'pluginManager'),
          verticalIconsPlugin: verticalIconsPlugin,
          itemContextAction: itemContextAction
        }), scrollableRef.current && scrollableRef.current.scrollHeight > scrollableRef.current.clientHeight ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Chevron.Chevron, {
          direction: "up",
          divElementRef: scrollableRef,
          cssRule: 'fa fa-chevron-up remixui_icon-chevron my-0'
        }) : null]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        id: "remixuiScrollable",
        className: scrollableRef.current && scrollableRef.current.scrollHeight > scrollableRef.current.clientHeight ? 'remixui_default-icons-container remixui_scrollable-container remixui_scrollbar remixui_hide-scroll' : activateScroll && activateScroll.scrollState ? 'remixui_default-icons-container remixui_scrollable-container remixui_scrollbar remixui_hide-scroll' : 'remixui_scrollable-container remixui_scrollbar remixui_hide-scroll',
        ref: scrollableRef,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_IconList.default, {
          theme: theme,
          icons: icons.filter(p => {
            return !p.isRequired && p.profile.name !== 'settings';
          }),
          verticalIconsPlugin: verticalIconsPlugin,
          itemContextAction: itemContextAction
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "remixui_default-icons-container border-0",
        children: [scrollableRef.current && scrollableRef.current.scrollHeight > scrollableRef.current.clientHeight ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Chevron.Chevron, {
          divElementRef: scrollableRef,
          direction: "down",
          cssRule: 'fa fa-chevron-down remixui_icon-chevron my-0'
        }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(_IconList.default, {
          theme: theme,
          icons: icons.filter(p => p.profile.name === 'settings' || p.profile.name === 'pluginManager'),
          verticalIconsPlugin: verticalIconsPlugin,
          itemContextAction: itemContextAction
        })]
      })]
    })
  });
};

var _default = RemixUiVerticalIconsPanel;
exports.default = _default;

/***/ }),
/* 2115 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2116);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2116 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_homeIcon {\n    /* display: block; */\n    width: 42px;\n    height: 42px;\n    cursor: pointer;\n  }\n  .remixui_homeIcon:hover {\n    box-shadow: 0px 0px 14px -7px;\n  }\n  .remixui_homeIcon svg path {\n    fill: var(--primary);\n  }\n  .remixui_homeIcon svg polygon {\n    fill: var(--primary);\n  }\n  .remixui_icons {\n    display: flex;\n    flex-flow: column nowrap;\n    justify-content: space-between;\n    align-items: center;\n  }\n  .remixui_icon:hover {\n    box-shadow: 0px 0px 14px -7px;\n  }\n  .remixui_icon {\n    cursor: pointer;\n    width: 36px;\n    height: 36px;\n    border-radius: 8px;\n    align-items: center;\n  }\n  .remixui_icon img {\n    width: 28px;\n    height: 28px;\n    padding: 4px;\n    filter: invert(0.5);\n  }\n  .remixui_icon .selected-dark {\n    filter: invert(1) grayscale(1);\n  }\n  .remixui_icon .selected-light {\n    filter: invert(0) grayscale(1);\n  }\n  .remixui_icon svg {\n    width: 28px;\n    height: 28px;\n    padding: 4px;\n  }\n  .remixui_icon[title='Settings'] {\n    order: 5;\n    align-self: center;\n    bottom: 0;\n  }\n  .remixui_status {\n    position: relative;\n    bottom: 0;\n    right: 0;\n    left: 12px;\n    top: -13px;\n  }\n  .remixui_statusCheck {\n    font-size: 1.2em;\n  }\n  .remixui_statusWithBG {\n    border-radius: 8px;\n    background-color: var(--danger);\n    color: var(--light);\n    font-size: 12px;\n    height: 15px;\n    text-align: center;\n    font-weight: bold;\n    padding-left: 5px;\n    padding-right: 5px;\n  }\n  .remixui_verticalIconContextcontainer {\n    display: block;\n    position: fixed;\n    border-radius: 2px;\n    z-index: 1000;\n    box-shadow: 0 0 4px var(--dark);\n  }\n  .remixui_verticalIconContextcontainer:focus {\n    outline: 0;\n  }\n  .remixui_liitem {\n    padding: 2px;\n    padding-left: 6px;\n    cursor: pointer;\n    color: var(--text-dark);\n    background-color: var(--light);\n  }\n  .remixui_liitem:hover {\n    background-color: var(--secondary);\n  }\n  .remixui_scrollbar {\n    overflow-y: scroll;\n    scrollbar-width: none; /* Firefox hide scrollbar */\n    -ms-overflow-style: none;\n  }\n  .remixui_requiredSection {\n    text-align: center;\n  }\n  .remixui_scrollable-container {\n    flex-basis: 510px;\n    flex-grow: 2;\n    text-align: center;\n    margin-top: -6px;\n    /* border-bottom: 3px solid #3f4455; */\n  }\n  .remixui_scrollbar::-webkit-scrollbar { /* Chrome, Safari and other Webkit browsers*/\n    display: none;\n  }\n  .remixui_hide-scroll {\n    overflow-x: 'hidden';\n  }\n  .remixui_default-icons-container {\n    border-bottom: 2px solid #3f4455;\n    text-align: center;\n  }\n  .remixui_icon-chevron {\n    z-index: 1000;\n    cursor: pointer;\n    align-items: center;\n  }\n  .remixui_settings {\n    flex-basis: 50px;\n  }\n  #menuitems {\n    list-style: none;\n    margin: 0px;\n  }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLXZlcnRpY2FsLWljb25zLXBhbmVsLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLG9CQUFvQjtJQUNwQixXQUFXO0lBQ1gsWUFBWTtJQUNaLGVBQWU7RUFDakI7RUFDQTtJQUNFLDZCQUE2QjtFQUMvQjtFQUVBO0lBQ0Usb0JBQW9CO0VBQ3RCO0VBQ0E7SUFDRSxvQkFBb0I7RUFDdEI7RUFDQTtJQUNFLGFBQWE7SUFDYix3QkFBd0I7SUFDeEIsOEJBQThCO0lBQzlCLG1CQUFtQjtFQUNyQjtFQUNBO0lBQ0UsNkJBQTZCO0VBQy9CO0VBRUE7SUFDRSxlQUFlO0lBQ2YsV0FBVztJQUNYLFlBQVk7SUFDWixrQkFBa0I7SUFDbEIsbUJBQW1CO0VBQ3JCO0VBQ0E7SUFDRSxXQUFXO0lBQ1gsWUFBWTtJQUNaLFlBQVk7SUFDWixtQkFBbUI7RUFDckI7RUFFQTtJQUNFLDhCQUE4QjtFQUNoQztFQUVBO0lBQ0UsOEJBQThCO0VBQ2hDO0VBRUE7SUFDRSxXQUFXO0lBQ1gsWUFBWTtJQUNaLFlBQVk7RUFDZDtFQUNBO0lBQ0UsUUFBUTtJQUNSLGtCQUFrQjtJQUNsQixTQUFTO0VBQ1g7RUFDQTtJQUNFLGtCQUFrQjtJQUNsQixTQUFTO0lBQ1QsUUFBUTtJQUNSLFVBQVU7SUFDVixVQUFVO0VBQ1o7RUFDQTtJQUNFLGdCQUFnQjtFQUNsQjtFQUNBO0lBQ0Usa0JBQWtCO0lBQ2xCLCtCQUErQjtJQUMvQixtQkFBbUI7SUFDbkIsZUFBZTtJQUNmLFlBQVk7SUFDWixrQkFBa0I7SUFDbEIsaUJBQWlCO0lBQ2pCLGlCQUFpQjtJQUNqQixrQkFBa0I7RUFDcEI7RUFFQTtJQUNFLGNBQWM7SUFDZCxlQUFlO0lBQ2Ysa0JBQWtCO0lBQ2xCLGFBQWE7SUFDYiwrQkFBK0I7RUFDakM7RUFDQTtJQUNFLFVBQVU7RUFDWjtFQUNBO0lBQ0UsWUFBWTtJQUNaLGlCQUFpQjtJQUNqQixlQUFlO0lBQ2YsdUJBQXVCO0lBQ3ZCLDhCQUE4QjtFQUNoQztFQUNBO0lBQ0Usa0NBQWtDO0VBQ3BDO0VBRUE7SUFDRSxrQkFBa0I7SUFDbEIscUJBQXFCLEVBQUUsMkJBQTJCO0lBQ2xELHdCQUF3QjtFQUMxQjtFQUNBO0lBQ0Usa0JBQWtCO0VBQ3BCO0VBQ0E7SUFDRSxpQkFBaUI7SUFDakIsWUFBWTtJQUNaLGtCQUFrQjtJQUNsQixnQkFBZ0I7SUFDaEIsc0NBQXNDO0VBQ3hDO0VBQ0Esd0NBQXdDLDRDQUE0QztJQUNsRixhQUFhO0VBQ2Y7RUFDQTtJQUNFLG9CQUFvQjtFQUN0QjtFQUNBO0lBQ0UsZ0NBQWdDO0lBQ2hDLGtCQUFrQjtFQUNwQjtFQUNBO0lBQ0UsYUFBYTtJQUNiLGVBQWU7SUFDZixtQkFBbUI7RUFDckI7RUFFQTtJQUNFLGdCQUFnQjtFQUNsQjtFQUVBO0lBQ0UsZ0JBQWdCO0lBQ2hCLFdBQVc7RUFDYiIsImZpbGUiOiJyZW1peC11aS12ZXJ0aWNhbC1pY29ucy1wYW5lbC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXh1aV9ob21lSWNvbiB7XG4gICAgLyogZGlzcGxheTogYmxvY2s7ICovXG4gICAgd2lkdGg6IDQycHg7XG4gICAgaGVpZ2h0OiA0MnB4O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxuICAucmVtaXh1aV9ob21lSWNvbjpob3ZlciB7XG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAxNHB4IC03cHg7XG4gIH1cblxuICAucmVtaXh1aV9ob21lSWNvbiBzdmcgcGF0aCB7XG4gICAgZmlsbDogdmFyKC0tcHJpbWFyeSk7XG4gIH1cbiAgLnJlbWl4dWlfaG9tZUljb24gc3ZnIHBvbHlnb24ge1xuICAgIGZpbGw6IHZhcigtLXByaW1hcnkpO1xuICB9XG4gIC5yZW1peHVpX2ljb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZmxvdzogY29sdW1uIG5vd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuICAucmVtaXh1aV9pY29uOmhvdmVyIHtcbiAgICBib3gtc2hhZG93OiAwcHggMHB4IDE0cHggLTdweDtcbiAgfVxuXG4gIC5yZW1peHVpX2ljb24ge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB3aWR0aDogMzZweDtcbiAgICBoZWlnaHQ6IDM2cHg7XG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgLnJlbWl4dWlfaWNvbiBpbWcge1xuICAgIHdpZHRoOiAyOHB4O1xuICAgIGhlaWdodDogMjhweDtcbiAgICBwYWRkaW5nOiA0cHg7XG4gICAgZmlsdGVyOiBpbnZlcnQoMC41KTtcbiAgfVxuXG4gIC5yZW1peHVpX2ljb24gLnNlbGVjdGVkLWRhcmsge1xuICAgIGZpbHRlcjogaW52ZXJ0KDEpIGdyYXlzY2FsZSgxKTtcbiAgfVxuXG4gIC5yZW1peHVpX2ljb24gLnNlbGVjdGVkLWxpZ2h0IHtcbiAgICBmaWx0ZXI6IGludmVydCgwKSBncmF5c2NhbGUoMSk7XG4gIH1cblxuICAucmVtaXh1aV9pY29uIHN2ZyB7XG4gICAgd2lkdGg6IDI4cHg7XG4gICAgaGVpZ2h0OiAyOHB4O1xuICAgIHBhZGRpbmc6IDRweDtcbiAgfVxuICAucmVtaXh1aV9pY29uW3RpdGxlPSdTZXR0aW5ncyddIHtcbiAgICBvcmRlcjogNTtcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgYm90dG9tOiAwO1xuICB9XG4gIC5yZW1peHVpX3N0YXR1cyB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJvdHRvbTogMDtcbiAgICByaWdodDogMDtcbiAgICBsZWZ0OiAxMnB4O1xuICAgIHRvcDogLTEzcHg7XG4gIH1cbiAgLnJlbWl4dWlfc3RhdHVzQ2hlY2sge1xuICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gIH1cbiAgLnJlbWl4dWlfc3RhdHVzV2l0aEJHIHtcbiAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGFuZ2VyKTtcbiAgICBjb2xvcjogdmFyKC0tbGlnaHQpO1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICBoZWlnaHQ6IDE1cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHBhZGRpbmctbGVmdDogNXB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDVweDtcbiAgfVxuICBcbiAgLnJlbWl4dWlfdmVydGljYWxJY29uQ29udGV4dGNvbnRhaW5lciB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICB6LWluZGV4OiAxMDAwO1xuICAgIGJveC1zaGFkb3c6IDAgMCA0cHggdmFyKC0tZGFyayk7XG4gIH1cbiAgLnJlbWl4dWlfdmVydGljYWxJY29uQ29udGV4dGNvbnRhaW5lcjpmb2N1cyB7XG4gICAgb3V0bGluZTogMDtcbiAgfVxuICAucmVtaXh1aV9saWl0ZW0ge1xuICAgIHBhZGRpbmc6IDJweDtcbiAgICBwYWRkaW5nLWxlZnQ6IDZweDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgY29sb3I6IHZhcigtLXRleHQtZGFyayk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xuICB9XG4gIC5yZW1peHVpX2xpaXRlbTpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kYXJ5KTtcbiAgfVxuICBcbiAgLnJlbWl4dWlfc2Nyb2xsYmFyIHtcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAvKiBGaXJlZm94IGhpZGUgc2Nyb2xsYmFyICovXG4gICAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lO1xuICB9XG4gIC5yZW1peHVpX3JlcXVpcmVkU2VjdGlvbiB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG4gIC5yZW1peHVpX3Njcm9sbGFibGUtY29udGFpbmVyIHtcbiAgICBmbGV4LWJhc2lzOiA1MTBweDtcbiAgICBmbGV4LWdyb3c6IDI7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi10b3A6IC02cHg7XG4gICAgLyogYm9yZGVyLWJvdHRvbTogM3B4IHNvbGlkICMzZjQ0NTU7ICovXG4gIH1cbiAgLnJlbWl4dWlfc2Nyb2xsYmFyOjotd2Via2l0LXNjcm9sbGJhciB7IC8qIENocm9tZSwgU2FmYXJpIGFuZCBvdGhlciBXZWJraXQgYnJvd3NlcnMqL1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbiAgLnJlbWl4dWlfaGlkZS1zY3JvbGwge1xuICAgIG92ZXJmbG93LXg6ICdoaWRkZW4nO1xuICB9XG4gIC5yZW1peHVpX2RlZmF1bHQtaWNvbnMtY29udGFpbmVyIHtcbiAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgIzNmNDQ1NTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIH1cbiAgLnJlbWl4dWlfaWNvbi1jaGV2cm9uIHtcbiAgICB6LWluZGV4OiAxMDAwO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgLnJlbWl4dWlfc2V0dGluZ3Mge1xuICAgIGZsZXgtYmFzaXM6IDUwcHg7XG4gIH1cblxuICAjbWVudWl0ZW1zIHtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIG1hcmdpbjogMHB4O1xuICB9XG4iXX0= */", '', '']]

/***/ }),
/* 2117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _Icon = _interopRequireDefault(__webpack_require__(2118));

var _jsxRuntime = __webpack_require__(46);

/* eslint-disable no-use-before-define */

/* eslint-disable @typescript-eslint/no-unused-vars */
function IconList({
  verticalIconsPlugin,
  itemContextAction,
  icons,
  theme
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "otherIcons",
    children: icons.map(p => /*#__PURE__*/(0, _jsxRuntime.jsx)(_Icon.default, {
      theme: theme,
      iconRecord: p,
      verticalIconPlugin: verticalIconsPlugin,
      contextMenuAction: itemContextAction
    }, p.profile.name))
  });
}

var _default = IconList;
exports.default = _default;

/***/ }),
/* 2118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _verticalIconsContextMenu = _interopRequireDefault(__webpack_require__(2119));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _Badge = _interopRequireDefault(__webpack_require__(2120));

var _iconBadgeReducer = __webpack_require__(2121);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
const initialState = {
  text: '',
  key: '',
  title: '',
  type: '',
  pluginName: ''
};

const Icon = ({
  iconRecord,
  verticalIconPlugin,
  contextMenuAction,
  theme
}) => {
  const {
    displayName,
    name,
    icon,
    documentation
  } = iconRecord.profile;
  const [title] = (0, _react.useState)(() => {
    const temp =  false || displayName || name;
    return temp.replace(/^\w/, word => word.toUpperCase());
  });
  const [links, setLinks] = (0, _react.useState)({});
  const [badgeStatus, dispatchStatusUpdate] = (0, _react.useReducer)(_iconBadgeReducer.iconBadgeReducer, initialState); // @ts-ignore

  const [pageX, setPageX] = (0, _react.useState)(null); // @ts-ignore

  const [pageY, setPageY] = (0, _react.useState)(null);
  const [showContext, setShowContext] = (0, _react.useState)(false);
  const [canDeactivate] = (0, _react.useState)(false);
  const iconRef = (0, _react.useRef)(null);

  const handleContextMenu = e => {
    const deactivationState = iconRecord.canbeDeactivated;

    if (documentation && documentation.length > 0 && deactivationState) {
      setLinks({
        Documentation: documentation,
        CanDeactivate: deactivationState
      });
    } else {
      setLinks({
        Documentation: documentation,
        CanDeactivate: deactivationState
      });
    }

    setShowContext(false);
    setPageX(e.pageX);
    setPageY(e.pageY);
    setShowContext(true);
  };

  function closeContextMenu() {
    setShowContext(false);
  }

  (0, _react.useEffect)(() => {
    verticalIconPlugin.on(name, 'statusChanged', iconStatus => {
      iconStatus.pluginName = name;
      const action = {
        type: name,
        payload: {
          status: iconStatus,
          verticalIconPlugin: verticalIconPlugin
        }
      };
      dispatchStatusUpdate(action);
    });
    return () => {
      verticalIconPlugin.off(name, 'statusChanged');
    };
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: `remixui_icon m-2  pt-1`,
      onClick: () => {
        verticalIconPlugin.toggle(name);
      },
      plugin: name,
      title: title,
      onContextMenu: e => {
        e.preventDefault();
        e.stopPropagation();
        handleContextMenu(e);
      },
      "data-id": `verticalIconsKind${name}`,
      id: `verticalIconsKind${name}`,
      ref: iconRef,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
        "data-id": iconRecord.active ? `selected` : '',
        className: `${theme === 'dark' ? 'invert' : ''} ${theme} remixui_image ${iconRecord.active ? `selected-${theme}` : ''}`,
        src: icon,
        alt: name
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Badge.default, {
        badgeStatus: badgeStatus
      })]
    }), showContext ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_verticalIconsContextMenu.default, {
      pageX: pageX,
      pageY: pageY,
      links: links,
      profileName: name,
      hideContextMenu: closeContextMenu,
      canBeDeactivated: canDeactivate,
      verticalIconPlugin: verticalIconPlugin,
      contextMenuAction: contextMenuAction
    }) : null]
  });
};

var _default = Icon;
exports.default = _default;

/***/ }),
/* 2119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const VerticalIconsContextMenu = props => {
  const menuRef = (0, _react.useRef)(null);
  ClickOutside(menuRef, props.hideContextMenu);
  (0, _react.useEffect)(() => {
    // @ts-ignore
    menuRef.current.focus();
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "menuItemsContainer",
    className: "p-1 remixui_verticalIconContextcontainer bg-light shadow border",
    style: {
      left: props.pageX,
      top: props.pageY,
      display: 'block'
    },
    ref: menuRef,
    tabIndex: 1,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("ul", {
      id: "menuitems",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(MenuForLinks, {
        hide: props.hideContextMenu,
        listItems: props.links,
        profileName: props.profileName,
        canBeDeactivated: props.canBeDeactivated,
        verticalIconPlugin: props.verticalIconPlugin,
        toggle: props.verticalIconPlugin.toggle,
        contextMenuAction: props.contextMenuAction
      })
    })
  });
}; // eslint-disable-next-line @typescript-eslint/no-unused-vars


const MenuForLinks = ({
  listItems,
  hide,
  profileName,
  contextMenuAction
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.Fragment, {
    children: [listItems.CanDeactivate ? /*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
      id: "menuitemdeactivate",
      onClick: evt => {
        contextMenuAction(evt, profileName, listItems.Documentation);
        hide();
      },
      className: "remixui_liitem",
      children: "Deactivate"
    }) : null, listItems.Documentation && listItems.Documentation.length > 0 && /*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
      id: "menuitemdocumentation",
      className: "remixui_liitem",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        onClick: hide,
        href: listItems.Documentation,
        target: "_blank",
        children: "Documentation"
      })
    })]
  });
};

function ClickOutside(ref, hideFn) {
  (0, _react.useEffect)(() => {
    function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        hideFn();
      }
    }

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [ref]);
}

var _default = VerticalIconsContextMenu;
exports.default = _default;

/***/ }),
/* 2120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line no-undef
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function Badge({
  badgeStatus
}) {
  /**
   * resolve a classes list for @arg key
   * @param {Object} key
   * @param {Object} type
   */
  function resolveClasses(key, type) {
    let classes = 'remixui_status';

    switch (key) {
      case 'succeed':
        classes += ' fas fa-check-circle text-' + type + ' ' + 'remixui_statusCheck';
        break;

      case 'edited':
        classes += ' fas fa-sync text-' + type + ' ' + 'remixui_statusCheck';
        break;

      case 'loading':
        classes += ' fas fa-spinner text-' + type + ' ' + 'remixui_statusCheck';
        break;

      case 'failed':
        classes += ' fas fa-exclamation-triangle text-' + type + ' ' + 'remixui_statusCheck';
        break;

      default:
        {
          classes += ' badge badge-pill badge-' + type;
        }
    }

    return classes;
  }

  function checkStatusKeyValue(value, type) {
    if (value === 'succeed' || value === 'edited' || value === 'loading' || value === 'failed' || typeof value === 'number' || type === 'warning' || type === 'error' || type === 'success' || type === 'info' || type === 'danger') {
      return true;
    }

    return false;
  }

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: badgeStatus && checkStatusKeyValue(badgeStatus.key, badgeStatus.type) ? /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
      title: badgeStatus.title,
      className: resolveClasses(badgeStatus.key, badgeStatus.type),
      "aria-hidden": "true",
      children: badgeStatus.text
    }) : null
  });
}

var _default = Badge;
exports.default = _default;

/***/ }),
/* 2121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iconBadgeReducer = iconBadgeReducer;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _helper = __webpack_require__(1121);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
   * Set a new status for the @arg name
   * @param {String} name
   * @param {Object} status
   */
function setIconStatus(name, status) {
  if (status.key === 'none') return _objectSpread(_objectSpread({}, status), {}, {
    text: ''
  }); // remove status

  let text = '';
  let key = '';

  if (typeof status.key === 'number') {
    key = status.key;
    text = key;
  } else key = (0, _helper.checkSpecialChars)(status.key) ? '' : status.key;

  let thisType = '';

  if (status.type === 'error') {
    thisType = 'danger'; // to use with bootstrap
  } else thisType = (0, _helper.checkSpecialChars)(status.type) ? '' : status.type;

  const title = (0, _helper.checkSpecialChars)(status.title) ? '' : status.title;
  const pluginName = status.pluginName;
  return {
    title,
    type: thisType,
    key,
    text,
    pluginName
  };
}

function iconBadgeReducer(state, action) {
  const {
    status
  } = action.payload;
  const setStatus = setIconStatus(action.type, status);
  return setStatus;
}

/***/ }),
/* 2122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _BasicLogo = _interopRequireDefault(__webpack_require__(2123));

var _jsxRuntime = __webpack_require__(46);

function Home({
  verticalIconPlugin
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "mt-2 my-1 remixui_homeIcon",
    onClick: async () => await verticalIconPlugin.activateHome(),
    plugin: 'home',
    title: "Home",
    "data-id": "verticalIconsHomeIcon",
    id: "verticalIconsHomeIcon",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_BasicLogo.default, {})
  });
}

var _default = Home;
exports.default = _default;

/***/ }),
/* 2123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

function BasicLogo() {
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("svg", {
    id: "Ebene_2",
    "data-name": "Ebene 2",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 105 100",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
      d: "M91.84,35a.09.09,0,0,1-.1-.07,41,41,0,0,0-79.48,0,.09.09,0,0,1-.1.07C9.45,35,1,35.35,1,42.53c0,8.56,1,16,6,20.32,2.16,1.85,5.81,2.3,9.27,2.22a44.4,44.4,0,0,0,6.45-.68.09.09,0,0,0,.06-.15A34.81,34.81,0,0,1,17,45c0-.1,0-.21,0-.31a35,35,0,0,1,70,0c0,.1,0,.21,0,.31a34.81,34.81,0,0,1-5.78,19.24.09.09,0,0,0,.06.15,44.4,44.4,0,0,0,6.45.68c3.46.08,7.11-.37,9.27-2.22,5-4.27,6-11.76,6-20.32C103,35.35,94.55,35,91.84,35Z"
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
      d: "M52,74,25.4,65.13a.1.1,0,0,0-.1.17L51.93,91.93a.1.1,0,0,0,.14,0L78.7,65.3a.1.1,0,0,0-.1-.17L52,74A.06.06,0,0,1,52,74Z"
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
      d: "M75.68,46.9,82,45a.09.09,0,0,0,.08-.09,29.91,29.91,0,0,0-.87-6.94.11.11,0,0,0-.09-.08l-6.43-.58a.1.1,0,0,1-.06-.18l4.78-4.18a.13.13,0,0,0,0-.12,30.19,30.19,0,0,0-3.65-6.07.09.09,0,0,0-.11,0l-5.91,2a.1.1,0,0,1-.12-.14L72.19,23a.11.11,0,0,0,0-.12,29.86,29.86,0,0,0-5.84-4.13.09.09,0,0,0-.11,0l-4.47,4.13a.1.1,0,0,1-.17-.07l.09-6a.1.1,0,0,0-.07-.1,30.54,30.54,0,0,0-7-1.47.1.1,0,0,0-.1.07l-2.38,5.54a.1.1,0,0,1-.18,0l-2.37-5.54a.11.11,0,0,0-.11-.06,30,30,0,0,0-7,1.48.12.12,0,0,0-.07.1l.08,6.05a.09.09,0,0,1-.16.07L37.8,18.76a.11.11,0,0,0-.12,0,29.75,29.75,0,0,0-5.83,4.13.11.11,0,0,0,0,.12l2.59,5.6a.11.11,0,0,1-.13.14l-5.9-2a.11.11,0,0,0-.12,0,30.23,30.23,0,0,0-3.62,6.08.11.11,0,0,0,0,.12l4.79,4.19a.1.1,0,0,1-.06.17L23,37.91a.1.1,0,0,0-.09.07A29.9,29.9,0,0,0,22,44.92a.1.1,0,0,0,.07.1L28.4,47a.1.1,0,0,1,0,.18l-5.84,3.26a.16.16,0,0,0,0,.11,30.17,30.17,0,0,0,2.1,6.76c.32.71.67,1.4,1,2.08a.1.1,0,0,0,.06,0L52,68.16H52l26.34-8.78a.1.1,0,0,0,.06-.05,30.48,30.48,0,0,0,3.11-8.88.1.1,0,0,0-.05-.11l-5.83-3.26A.1.1,0,0,1,75.68,46.9Z"
    })]
  });
}

var _default = BasicLogo;
exports.default = _default;

/***/ }),
/* 2124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verticalScrollReducer = verticalScrollReducer;

function verticalScrollReducer(prevState, actionPayload) {
  if (actionPayload.type === 'resize') {
    const {
      scrollHeight,
      clientHeight
    } = actionPayload.payload;
    let {
      scrollState
    } = actionPayload.payload;
    if (scrollHeight > clientHeight) scrollState = true;
    return {
      scrollHeight,
      clientHeight,
      scrollState
    };
  }

  return prevState;
}

/***/ }),
/* 2125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chevron = Chevron;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

/* eslint-disable no-use-before-define */
function Chevron(props) {
  const click = () => {
    if (props.direction === 'down') {
      props.divElementRef.current.scrollBy({
        top: 40,
        behavior: 'smooth'
      });
    } else {
      props.divElementRef.current.scrollBy({
        top: -40,
        behavior: 'smooth'
      });
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: props.divElementRef.current && props.divElementRef.current.scrollHeight > props.divElementRef.current.clientHeight ? /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
      onClick: click,
      className: props.cssRule
    }) : null
  });
}

/***/ }),
/* 2126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 2127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LandingPage = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _engineWeb = __webpack_require__(1133);

var _homeTab = __webpack_require__(2128);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// eslint-disable-line
var profile = {
  name: 'home',
  displayName: 'Home',
  methods: [],
  events: [],
  description: 'Remix home tab ',
  icon: 'assets/img/remixLogo.webp',
  location: 'mainPanel',
  version: packageJson.version
};

var LandingPage = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(LandingPage, _ViewPlugin);

  var _super = _createSuper(LandingPage);

  function LandingPage(appManager, verticalIcons, fileManager, filePanel, contentImport) {
    var _this;

    (0, _classCallCheck2["default"])(this, LandingPage);
    _this = _super.call(this, profile);
    _this.profile = profile;
    _this.fileManager = fileManager;
    _this.filePanel = filePanel;
    _this.contentImport = contentImport;
    _this.appManager = appManager;
    _this.verticalIcons = verticalIcons;
    _this.el = document.createElement('div');

    _this.el.setAttribute('id', 'landingPageHomeContainer');

    _this.el.setAttribute('class', 'remixui_homeContainer justify-content-between bg-light d-flex');

    _this.el.setAttribute('data-id', 'landingPageHomeContainer');

    return _this;
  }

  (0, _createClass2["default"])(LandingPage, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "landingPageHomeContainer",
        className: "remixui_homeContainer justify-content-between bg-light d-flex",
        "data-id": "landingPageHomeContainer"
      }, /*#__PURE__*/_react["default"].createElement(_homeTab.RemixUiHomeTab, {
        plugin: this
      }));
    }
  }]);
  return LandingPage;
}(_engineWeb.ViewPlugin);

exports.LandingPage = LandingPage;

/***/ }),
/* 2128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiHomeTab = __webpack_require__(2129);

Object.keys(_remixUiHomeTab).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiHomeTab[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiHomeTab[key];
    }
  });
});

/***/ }),
/* 2129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RemixUiHomeTab = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2130);

var _modalDialog = __webpack_require__(316);

var _toaster = __webpack_require__(479);

var _pluginButton = _interopRequireDefault(__webpack_require__(2132));

var _themeContext = __webpack_require__(1497);

var _rssFeed = __webpack_require__(2133);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const _paq = window._paq = window._paq || []; //eslint-disable-line

/* eslint-disable-next-line */


const loadingInitialState = {
  tooltip: '',
  showModalDialog: false,
  importSource: ''
};

const loadingReducer = (state = loadingInitialState, action) => {
  return _objectSpread(_objectSpread({}, state), {}, {
    tooltip: action.tooltip,
    showModalDialog: false,
    importSource: ''
  });
};

const RemixUiHomeTab = props => {
  const {
    plugin
  } = props;
  const fileManager = plugin.fileManager;
  const [state, setState] = (0, _react.useState)({
    themeQuality: _themeContext.themes.light,
    showMediaPanel: 'none',
    showModalDialog: false,
    modalInfo: {
      title: '',
      loadItem: '',
      examples: []
    },
    importSource: '',
    toasterMsg: ''
  });

  const processLoading = () => {
    const contentImport = plugin.contentImport;
    const workspace = fileManager.getProvider('workspace');
    contentImport.import(state.importSource, loadingMsg => dispatch({
      tooltip: loadingMsg
    }), async (error, content, cleanUrl, type, url) => {
      if (error) {
        toast(error.message || error);
      } else {
        try {
          if (await workspace.exists(type + '/' + cleanUrl)) toast('File already exists in workspace');else {
            workspace.addExternal(type + '/' + cleanUrl, content, url);
            plugin.call('menuicons', 'select', 'filePanel');
          }
        } catch (e) {
          toast(e.message);
        }
      }
    });
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        showModalDialog: false,
        importSource: ''
      });
    });
  };

  const [, dispatch] = (0, _react.useReducer)(loadingReducer, loadingInitialState);

  const playRemi = async () => {
    remiAudioEl.current.play();
  };

  const remiAudioEl = (0, _react.useRef)(null);
  const inputValue = (0, _react.useRef)(null);
  const rightPanel = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    plugin.call('theme', 'currentTheme').then(theme => {
      // update theme quality. To be used for for images
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          themeQuality: theme.quality === 'dark' ? _themeContext.themes.dark : _themeContext.themes.light
        });
      });
    });
    plugin.on('theme', 'themeChanged', theme => {
      // update theme quality. To be used for for images
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          themeQuality: theme.quality === 'dark' ? _themeContext.themes.dark : _themeContext.themes.light
        });
      });
    });
    window.addEventListener('click', event => {
      const target = event.target;
      const id = target.id;

      if (id !== 'remixIDEHomeTwitterbtn' && id !== 'remixIDEHomeMediumbtn' && !rightPanel.current.contains(event.target)) {
        // todo check event.target
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            showMediaPanel: 'none'
          });
        });
      }
    }); // to retrieve twitter feed

    const scriptTwitter = document.createElement('script');
    scriptTwitter.src = 'https://platform.twitter.com/widgets.js';
    scriptTwitter.async = true;
    document.body.appendChild(scriptTwitter);
    return () => {
      document.body.removeChild(scriptTwitter);
    };
  }, []);

  const toast = message => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        toasterMsg: message
      });
    });
  };

  const createNewFile = async () => {
    plugin.verticalIcons.select('filePanel');
    await plugin.call('filePanel', 'createNewFile');
  };

  const uploadFile = async target => {
    await plugin.call('filePanel', 'uploadFile', target);
  };

  const connectToLocalhost = () => {
    plugin.appManager.activatePlugin('remixd');
  };

  const importFromGist = () => {
    plugin.call('gistHandler', 'load', '');
    plugin.verticalIcons.select('filePanel');
  };

  const startSolidity = async () => {
    await plugin.appManager.activatePlugin(['solidity', 'udapp', 'solidityStaticAnalysis', 'solidityUnitTesting']);
    plugin.verticalIcons.select('solidity');

    _paq.push(['trackEvent', 'pluginManager', 'userActivate', 'solidity']);
  };

  const startStarkNet = async () => {
    await plugin.appManager.activatePlugin('starkNet_compiler');
    plugin.verticalIcons.select('starkNet_compiler');

    _paq.push(['trackEvent', 'pluginManager', 'userActivate', 'starkNet_compiler']);
  };

  const startSolhint = async () => {
    await plugin.appManager.activatePlugin(['solidity', 'solhint']);
    plugin.verticalIcons.select('solhint');

    _paq.push(['trackEvent', 'pluginManager', 'userActivate', 'solhint']);
  };

  const startLearnEth = async () => {
    await plugin.appManager.activatePlugin(['solidity', 'LearnEth', 'solidityUnitTesting']);
    plugin.verticalIcons.select('LearnEth');

    _paq.push(['trackEvent', 'pluginManager', 'userActivate', 'learnEth']);
  };

  const startSourceVerify = async () => {
    await plugin.appManager.activatePlugin(['solidity', 'sourcify']);
    plugin.verticalIcons.select('sourcify');

    _paq.push(['trackEvent', 'pluginManager', 'userActivate', 'sourcify']);
  };

  const startPluginManager = async () => {
    plugin.verticalIcons.select('pluginManager');
  };

  const showFullMessage = (title, loadItem, examples) => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        showModalDialog: true,
        modalInfo: {
          title: title,
          loadItem: loadItem,
          examples: examples
        }
      });
    });
  };

  const hideFullMessage = () => {
    //eslint-disable-line
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        showModalDialog: false,
        importSource: ''
      });
    });
  };

  const maxHeight = Math.max(window.innerHeight - 150, 250) + 'px';
  const examples = state.modalInfo.examples.map((urlEl, key) => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "p-1 user-select-auto",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
      children: urlEl
    })
  }, key));
  const elHeight = '4000px';
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_modalDialog.ModalDialog, {
      id: "homeTab",
      title: 'Import from ' + state.modalInfo.title,
      okLabel: "Import",
      hide: !state.showModalDialog,
      handleHide: () => hideFullMessage(),
      okFn: () => processLoading(),
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "p-2 user-select-auto",
        children: [state.modalInfo.loadItem !== '' && /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: ["Enter the ", state.modalInfo.loadItem, " you would like to load."]
        }), state.modalInfo.examples.length !== 0 && /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            children: "e.g"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            children: examples
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          ref: inputValue,
          type: "text",
          name: "prompt_text",
          id: "inputPrompt_text",
          className: "w-100 mt-1 form-control",
          "data-id": "homeTabModalDialogCustomPromptText",
          value: state.importSource,
          onInput: e => {
            setState(prevState => {
              return _objectSpread(_objectSpread({}, prevState), {}, {
                importSource: inputValue.current.value
              });
            });
          }
        })]
      })
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: state.toasterMsg
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "d-flex flex-column ml-4",
      id: "remixUiRightPanel",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "border-bottom d-flex flex-column mr-4 pb-3 mb-3",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex justify-content-between ",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "mx-4 my-4 d-flex",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              style: {
                fontSize: 'xxx-large',
                height: 'auto',
                alignSelf: 'flex-end'
              },
              children: "Remix IDE"
            })
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "mr-4 d-flex",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
              className: "mt-4 mb-2 remixui_home_logoImg",
              src: "assets/img/guitarRemiCroped.webp",
              onClick: () => playRemi(),
              alt: ""
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("audio", {
              id: "remiAudio",
              muted: false,
              src: "assets/audio/remiGuitar-single-power-chord-A-minor.wav",
              ref: remiAudioEl
            })]
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            className: "pl-4 text-danger fas fa-exclamation-triangle"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "px-2 remixui_home_text text-danger mt-4 pt-4",
            children: "Scam Alert: There are video tutorials going around that provide urls other than remix.ethereum.org, and could be scams. Also, beware of online videos promoting \"liquidity front runner bots\"."
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            className: "remixui_home_text",
            target: "__blank",
            href: "https://medium.com/remix-ide/remix-in-youtube-crypto-scams-71c338da32d",
            children: "Learn more"
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "row mx-2 mr-4",
        "data-id": "landingPageHpSections",
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "ml-3",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "mb-3",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h4", {
              children: "Featured Plugins"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "d-flex flex-row pt-2",
              children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_themeContext.ThemeContext.Provider, {
                value: state.themeQuality,
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_pluginButton.default, {
                  imgPath: "assets/img/solidityLogo.webp",
                  envID: "solidityLogo",
                  envText: "Solidity",
                  callback: () => startSolidity()
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_pluginButton.default, {
                  imgPath: "assets/img/starkNetLogo.webp",
                  envID: "starkNetLogo",
                  envText: "StarkNet",
                  l2: true,
                  callback: () => startStarkNet()
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_pluginButton.default, {
                  imgPath: "assets/img/solhintLogo.webp",
                  envID: "solhintLogo",
                  envText: "Solhint linter",
                  callback: () => startSolhint()
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_pluginButton.default, {
                  imgPath: "assets/img/learnEthLogo.webp",
                  envID: "learnEthLogo",
                  envText: "LearnEth",
                  callback: () => startLearnEth()
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_pluginButton.default, {
                  imgPath: "assets/img/sourcifyNewLogo.webp",
                  envID: "sourcifyLogo",
                  envText: "Sourcify",
                  callback: () => startSourceVerify()
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_pluginButton.default, {
                  imgPath: "assets/img/moreLogo.webp",
                  envID: "moreLogo",
                  envText: "More",
                  callback: startPluginManager
                })]
              })
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "file",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h4", {
                children: "File"
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
                className: "mb-1",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                  className: "mr-2 far fa-file"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
                  className: "ml-1 mb-1 remixui_home_text",
                  onClick: () => createNewFile(),
                  children: "New File"
                })]
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
                className: "mb-1",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                  className: "mr-2 far fa-file-alt"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
                  className: "ml-1 remixui_home_labelIt remixui_home_bigLabelSize remixui_home_text",
                  htmlFor: "openFileInput",
                  children: "Open Files"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
                  title: "open file",
                  type: "file",
                  id: "openFileInput",
                  onChange: event => {
                    event.stopPropagation();
                    plugin.verticalIcons.select('filePanel');
                    uploadFile(event.target);
                  },
                  multiple: true
                })]
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
                className: "mb-1",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                  className: "mr-1 far fa-hdd"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
                  className: "ml-1 remixui_home_text",
                  onClick: () => connectToLocalhost(),
                  children: "Connect to Localhost"
                })]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
                className: "mt-3 mb-0",
                children: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
                  children: "LOAD FROM:"
                })
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "btn-group",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
                  className: "btn mr-1 btn-secondary",
                  "data-id": "landingPageImportFromGistButton",
                  onClick: () => importFromGist(),
                  children: "Gist"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
                  className: "btn mx-1 btn-secondary",
                  "data-id": "landingPageImportFromGitHubButton",
                  onClick: () => showFullMessage('GitHub', 'github URL', ['https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token-metadata.sol', 'https://github.com/OpenZeppelin/openzeppelin-solidity/blob/67bca857eedf99bf44a4b6a0fc5b5ed553135316/contracts/access/Roles.sol']),
                  children: "GitHub"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
                  className: "btn mx-1 btn-secondary",
                  onClick: () => showFullMessage('Ipfs', 'ipfs URL', ['ipfs://<ipfs-hash>']),
                  children: "Ipfs"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
                  className: "btn mx-1 btn-secondary",
                  onClick: () => showFullMessage('Https', 'http/https raw content', ['https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/master/contracts/token/ERC20/ERC20.sol']),
                  children: "https"
                })]
              })]
            }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "ml-4 pl-4",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h4", {
                children: "Resources"
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
                className: "mb-1",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                  className: "mr-2 fas fa-book"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
                  className: "remixui_home_text",
                  target: "__blank",
                  href: "https://remix-ide.readthedocs.io/en/latest/#",
                  children: "Documentation"
                })]
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
                className: "mb-1",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                  className: "mr-2 fab fa-gitter"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
                  className: "remixui_home_text",
                  target: "__blank",
                  href: "https://gitter.im/ethereum/remix",
                  children: "Gitter channel"
                })]
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
                className: "mb-1",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
                  id: "remixHhomeWebsite",
                  className: "mr-2 remixui_home_image",
                  src: plugin.profile.icon,
                  style: {
                    filter: state.themeQuality.filter
                  },
                  alt: ""
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
                  className: "remixui_home_text",
                  target: "__blank",
                  href: "https://remix-project.org",
                  children: "Featuring website"
                })]
              })]
            })]
          })]
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex flex-column remixui_home_rightPanel",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex pr-3 py-2 align-self-end",
          id: "remixIDEMediaPanelsTitle",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            className: "btn-info p-2 m-1 border rounded-circle remixui_home_mediaBadge fab fa-twitter",
            id: "remixIDEHomeTwitterbtn",
            title: "Twitter",
            onClick: e => {
              setState(prevState => {
                return _objectSpread(_objectSpread({}, prevState), {}, {
                  showMediaPanel: state.showMediaPanel === 'twitter' ? 'none' : 'twitter'
                });
              });

              _paq.push(['trackEvent', 'pluginManager', 'media', 'twitter']);
            }
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            className: "btn-danger p-2 m-1 border rounded-circle remixui_home_mediaBadge fab fa-medium",
            id: "remixIDEHomeMediumbtn",
            title: "Medium blogs",
            onClick: e => {
              setState(prevState => {
                return _objectSpread(_objectSpread({}, prevState), {}, {
                  showMediaPanel: state.showMediaPanel === 'medium' ? 'none' : 'medium'
                });
              });

              _paq.push(['trackEvent', 'pluginManager', 'media', 'medium']);
            }
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mr-3 d-flex bg-light remixui_home_panels",
          style: {
            visibility: state.showMediaPanel === 'none' ? 'hidden' : 'visible'
          },
          id: "remixIDEMediaPanels",
          ref: rightPanel,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            id: "remixIDE_MediumBlock",
            className: "p-2 mx-1 mt-3 mb-0 remixui_home_remixHomeMedia",
            style: {
              maxHeight: maxHeight
            },
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              id: "medium-widget",
              className: "px-3 remixui_home_media",
              hidden: state.showMediaPanel !== 'medium',
              style: {
                maxHeight: '10000px'
              },
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_rssFeed.RSSFeed, {
                feedUrl: "https://rss.remixproject.org/",
                maxItems: 10
              })
            })
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            id: "remixIDE_TwitterBlock",
            className: "p-2 mx-1 mt-3 mb-0 remixui_home_remixHomeMedia",
            hidden: state.showMediaPanel !== 'twitter',
            style: {
              maxHeight: maxHeight,
              marginRight: '28px'
            },
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "remixui_home_media",
              style: {
                minHeight: elHeight
              },
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
                className: "twitter-timeline",
                "data-width": "375",
                "data-theme": state.themeQuality.name,
                "data-chrome": "nofooter noheader transparent",
                "data-tweet-limit": "18",
                href: "https://twitter.com/EthereumRemix"
              })
            })
          })]
        })]
      })]
    })]
  });
};

exports.RemixUiHomeTab = RemixUiHomeTab;
var _default = RemixUiHomeTab;
exports.default = _default;

/***/ }),
/* 2130 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2131);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2131 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_home_text {\n  cursor: pointer;\n  font-size: 0.8rem;\n  font-weight: normal;\n  max-width: 300px;\n}\n.remixui_home_text:hover {\n  cursor: pointer;\n  text-decoration: underline;\n}\n.remixui_home_homeContainer {\n  overflow-y: hidden;\n  overflow-y: auto;\n  flex-grow: 3;\n}\n.remixui_home_hpLogoContainer {\n  margin: 30px;\n  padding-right: 90px;\n}\n.remixui_home_mediaBadge {\n  font-size: 2em;\n  height: 2em;\n  width: 2em;\n}\n.remixui_home_mediaBadge:focus {\n  outline: none;\n}\n.remixui_home_image {\n  height: 1em;\n  width: 1em;\n  text-align: center;\n}\n.remixui_home_logoImg {\n  height: 10em;\n}\n.remixui_home_rightPanel {\n  right: 0;\n  position: absolute;\n  z-index: 3000;\n}\n.remixui_home_remixHomeMedia {\n  overflow-y: auto;\n  overflow-x: hidden;\n}\n.remixui_home_panels {\n  box-shadow: 0px 0px 13px -7px;\n}\n.remixui_home_labelIt {\n  margin-bottom: 0;\n}\n.remixui_home_bigLabelSize {\n  font-size: 13px;\n}\n.remixui_home_seeAll {\n  margin-top: 7px;\n  white-space: nowrap;\n}\n.remixui_home_importFrom p {\n  margin-right: 10px;\n}\n.remixui_home_logoContainer img{\n  height: 150px;\n  opacity: 0.7;\n}\n.remixui_home_envLogo {\n  height: 16px;\n}\n.remixui_home_cursorStyle {\n  cursor: pointer;\n}\n.remixui_home_envButton {\n  width: 120px;\n  height: 70px;\n}\n.remixui_home_media {\n  overflow: hidden;\n  max-width: 400px;\n  transition: .5s ease-out;\n  z-index: 1000;\n}\n.remixui_home_migrationBtn {\n  width: 100px;\n}\n.remixui_home_l2Label {\n  bottom: 10px;\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLWhvbWUtdGFiLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsbUJBQW1CO0VBQ25CLGdCQUFnQjtBQUNsQjtBQUNBO0VBQ0UsZUFBZTtFQUNmLDBCQUEwQjtBQUM1QjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLGdCQUFnQjtFQUNoQixZQUFZO0FBQ2Q7QUFDQTtFQUNFLFlBQVk7RUFDWixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGNBQWM7RUFDZCxXQUFXO0VBQ1gsVUFBVTtBQUNaO0FBQ0E7RUFDRSxhQUFhO0FBQ2Y7QUFDQTtFQUNFLFdBQVc7RUFDWCxVQUFVO0VBQ1Ysa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxZQUFZO0FBQ2Q7QUFDQTtFQUNFLFFBQVE7RUFDUixrQkFBa0I7RUFDbEIsYUFBYTtBQUNmO0FBQ0E7RUFDRSxnQkFBZ0I7RUFDaEIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSw2QkFBNkI7QUFDL0I7QUFDQTtFQUNFLGdCQUFnQjtBQUNsQjtBQUNBO0VBQ0UsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsZUFBZTtFQUNmLG1CQUFtQjtBQUNyQjtBQUNBO0VBQ0Usa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsWUFBWTtBQUNkO0FBQ0E7RUFDRSxZQUFZO0FBQ2Q7QUFDQTtFQUNFLGVBQWU7QUFDakI7QUFDQTtFQUNFLFlBQVk7RUFDWixZQUFZO0FBQ2Q7QUFDQTtFQUNFLGdCQUFnQjtFQUNoQixnQkFBZ0I7RUFDaEIsd0JBQXdCO0VBQ3hCLGFBQWE7QUFDZjtBQUNBO0VBQ0UsWUFBWTtBQUNkO0FBQ0E7RUFDRSxZQUFZO0FBQ2QiLCJmaWxlIjoicmVtaXgtdWktaG9tZS10YWIuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnJlbWl4dWlfaG9tZV90ZXh0IHtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBmb250LXNpemU6IDAuOHJlbTtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgbWF4LXdpZHRoOiAzMDBweDtcbn1cbi5yZW1peHVpX2hvbWVfdGV4dDpob3ZlciB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG59XG4ucmVtaXh1aV9ob21lX2hvbWVDb250YWluZXIge1xuICBvdmVyZmxvdy15OiBoaWRkZW47XG4gIG92ZXJmbG93LXk6IGF1dG87XG4gIGZsZXgtZ3JvdzogMztcbn1cbi5yZW1peHVpX2hvbWVfaHBMb2dvQ29udGFpbmVyIHtcbiAgbWFyZ2luOiAzMHB4O1xuICBwYWRkaW5nLXJpZ2h0OiA5MHB4O1xufVxuLnJlbWl4dWlfaG9tZV9tZWRpYUJhZGdlIHtcbiAgZm9udC1zaXplOiAyZW07XG4gIGhlaWdodDogMmVtO1xuICB3aWR0aDogMmVtO1xufVxuLnJlbWl4dWlfaG9tZV9tZWRpYUJhZGdlOmZvY3VzIHtcbiAgb3V0bGluZTogbm9uZTtcbn1cbi5yZW1peHVpX2hvbWVfaW1hZ2Uge1xuICBoZWlnaHQ6IDFlbTtcbiAgd2lkdGg6IDFlbTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuLnJlbWl4dWlfaG9tZV9sb2dvSW1nIHtcbiAgaGVpZ2h0OiAxMGVtO1xufVxuLnJlbWl4dWlfaG9tZV9yaWdodFBhbmVsIHtcbiAgcmlnaHQ6IDA7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMzAwMDtcbn1cbi5yZW1peHVpX2hvbWVfcmVtaXhIb21lTWVkaWEge1xuICBvdmVyZmxvdy15OiBhdXRvO1xuICBvdmVyZmxvdy14OiBoaWRkZW47XG59XG4ucmVtaXh1aV9ob21lX3BhbmVscyB7XG4gIGJveC1zaGFkb3c6IDBweCAwcHggMTNweCAtN3B4O1xufVxuLnJlbWl4dWlfaG9tZV9sYWJlbEl0IHtcbiAgbWFyZ2luLWJvdHRvbTogMDtcbn1cbi5yZW1peHVpX2hvbWVfYmlnTGFiZWxTaXplIHtcbiAgZm9udC1zaXplOiAxM3B4O1xufVxuLnJlbWl4dWlfaG9tZV9zZWVBbGwge1xuICBtYXJnaW4tdG9wOiA3cHg7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG59XG4ucmVtaXh1aV9ob21lX2ltcG9ydEZyb20gcCB7XG4gIG1hcmdpbi1yaWdodDogMTBweDtcbn1cbi5yZW1peHVpX2hvbWVfbG9nb0NvbnRhaW5lciBpbWd7XG4gIGhlaWdodDogMTUwcHg7XG4gIG9wYWNpdHk6IDAuNztcbn1cbi5yZW1peHVpX2hvbWVfZW52TG9nbyB7XG4gIGhlaWdodDogMTZweDtcbn1cbi5yZW1peHVpX2hvbWVfY3Vyc29yU3R5bGUge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4ucmVtaXh1aV9ob21lX2VudkJ1dHRvbiB7XG4gIHdpZHRoOiAxMjBweDtcbiAgaGVpZ2h0OiA3MHB4O1xufVxuLnJlbWl4dWlfaG9tZV9tZWRpYSB7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIG1heC13aWR0aDogNDAwcHg7XG4gIHRyYW5zaXRpb246IC41cyBlYXNlLW91dDtcbiAgei1pbmRleDogMTAwMDtcbn1cbi5yZW1peHVpX2hvbWVfbWlncmF0aW9uQnRuIHtcbiAgd2lkdGg6IDEwMHB4O1xufVxuLnJlbWl4dWlfaG9tZV9sMkxhYmVsIHtcbiAgYm90dG9tOiAxMHB4O1xufVxuIl19 */", '', '']]

/***/ }),
/* 2132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _themeContext = __webpack_require__(1497);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-unused-vars */
function PluginButton({
  imgPath,
  envID,
  envText,
  callback,
  l2
}) {
  const themeFilter = (0, _react.useContext)(_themeContext.ThemeContext);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
      className: "btn border-secondary d-flex mr-3 text-nowrap justify-content-center flex-column align-items-center remixui_home_envButton",
      "data-id": 'landingPageStart' + envText,
      onClick: () => callback(),
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
        className: "m-2 align-self-center remixui_home_envLogo",
        id: envID,
        src: imgPath,
        alt: "",
        style: {
          filter: themeFilter.filter
        }
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "text-uppercase text-dark remixui_home_cursorStyle",
        children: envText
      })]
    }), l2 && /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
      className: "bg-light mx-1 px-1 mb-0 mx-2 position-relative remixui_home_l2Label",
      children: "L2"
    })]
  });
}

var _default = PluginButton;
exports.default = _default;

/***/ }),
/* 2133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RSSFeed = RSSFeed;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _rssParser = _interopRequireDefault(__webpack_require__(2134));

__webpack_require__(2154);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function RSSFeed({
  feedUrl,
  maxItems
}) {
  const [feed, setFeed] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    const fetchData = async () => {
      const parser = new _rssParser.default();
      const feed = await parser.parseURL(feedUrl);

      for (const item of feed.items) {
        item.content = item['content:encoded'];
        item.date = new Date(item.pubDate).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric'
        });
      }

      setFeed(feed);
    };

    fetchData();
  }, [feedUrl]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: feed && feed.items.slice(0, maxItems).map((item, index) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "RSSFeed-item",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        target: "_blank",
        href: item.link,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("h3", {
          children: item.title
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
        children: ["Author: ", item.creator]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("h4", {
        children: item.date
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "truncate",
        dangerouslySetInnerHTML: {
          __html: item.content
        }
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        className: "more-button btn mb-3",
        target: "_blank",
        href: item.link,
        children: "READ MORE"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("hr", {})]
    }, index))
  });
}

/***/ }),
/* 2134 */,
/* 2135 */,
/* 2136 */,
/* 2137 */,
/* 2138 */,
/* 2139 */,
/* 2140 */,
/* 2141 */,
/* 2142 */,
/* 2143 */,
/* 2144 */,
/* 2145 */,
/* 2146 */,
/* 2147 */,
/* 2148 */,
/* 2149 */,
/* 2150 */,
/* 2151 */,
/* 2152 */,
/* 2153 */,
/* 2154 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2155);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2155 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".RSSFeed-item img  {\n    width: 100%;\n}\n\n.RSSFeed-item .truncate {\n    max-height: 500px;\n    overflow: hidden;\n}\n\n.RSSFeed-item .more-button {\n\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJzc0ZlZWQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksV0FBVztBQUNmOztBQUVBO0lBQ0ksaUJBQWlCO0lBQ2pCLGdCQUFnQjtBQUNwQjs7QUFFQTs7QUFFQSIsImZpbGUiOiJyc3NGZWVkLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5SU1NGZWVkLWl0ZW0gaW1nICB7XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbi5SU1NGZWVkLWl0ZW0gLnRydW5jYXRlIHtcbiAgICBtYXgtaGVpZ2h0OiA1MDBweDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uUlNTRmVlZC1pdGVtIC5tb3JlLWJ1dHRvbiB7XG5cbn0iXX0= */", '', '']]

/***/ }),
/* 2156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MainPanel = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _get2 = _interopRequireDefault(__webpack_require__(1197));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _panel = __webpack_require__(1311);

var _panel2 = __webpack_require__(485);

var _package = _interopRequireDefault(__webpack_require__(312));

var _helper = __webpack_require__(1121);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'mainPanel',
  displayName: 'Main Panel',
  description: 'Remix IDE main panel',
  version: _package["default"].version,
  methods: ['addView', 'removeView', 'showContent']
};

var MainPanel = /*#__PURE__*/function (_AbstractPanel) {
  (0, _inherits2["default"])(MainPanel, _AbstractPanel);

  var _super = _createSuper(MainPanel);

  function MainPanel(config) {
    var _this;

    (0, _classCallCheck2["default"])(this, MainPanel);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "element", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dispatch", function () {});
    _this.element = document.createElement('div');

    _this.element.setAttribute('data-id', 'mainPanelPluginsContainer');

    _this.element.setAttribute('style', 'height: 100%; width: 100%;'); // this.config = config


    return _this;
  }

  (0, _createClass2["default"])(MainPanel, [{
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "onActivation",
    value: function onActivation() {
      this.renderComponent();
    }
  }, {
    key: "focus",
    value: function focus(name) {
      this.emit('focusChanged', name);
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(MainPanel.prototype), "focus", this).call(this, name);
      this.renderComponent();
    }
  }, {
    key: "addView",
    value: function addView(profile, view) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(MainPanel.prototype), "addView", this).call(this, profile, view);
      this.renderComponent();
    }
  }, {
    key: "removeView",
    value: function removeView(profile) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(MainPanel.prototype), "removeView", this).call(this, profile);
      this.renderComponent();
    }
  }, {
    key: "showContent",
    value: function () {
      var _showContent = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(name) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (0, _get2["default"])((0, _getPrototypeOf2["default"])(MainPanel.prototype), "showContent", this).call(this, name);
                this.renderComponent();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function showContent(_x) {
        return _showContent.apply(this, arguments);
      }

      return showContent;
    }()
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      this.dispatch({
        plugins: this.plugins
      });
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        style: {
          height: '100%',
          width: '100%'
        },
        "data-id": "mainPanelPluginsContainer"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_panel2.RemixPluginPanel, {
        header: /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null),
        plugins: state.plugins
      });
    }
  }]);
  return MainPanel;
}(_panel.AbstractPanel);

exports.MainPanel = MainPanel;

/***/ }),
/* 2157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PermissionHandlerPlugin = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _engine = __webpack_require__(477);

var _src = __webpack_require__(2158);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'permissionhandler',
  displayName: 'permissionhandler',
  description: 'Plugin to handle permissions',
  methods: ['askPermission']
};

var PermissionHandlerPlugin = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(PermissionHandlerPlugin, _Plugin);

  var _super = _createSuper(PermissionHandlerPlugin);

  function PermissionHandlerPlugin() {
    var _this;

    (0, _classCallCheck2["default"])(this, PermissionHandlerPlugin);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "permissions", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "currentVersion", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "fallbackMemory", void 0);
    _this.fallbackMemory = false;
    _this.permissions = _this._getFromLocal();
    _this.currentVersion = 1; // here we remove the old permissions saved before adding 'permissionVersion'
    // since with v1 the structure has been changed because of new engine ^0.2.0-alpha.6 changes

    if (!localStorage.getItem('permissionVersion')) {
      localStorage.setItem('plugins/permissions', '');
      localStorage.setItem('permissionVersion', _this.currentVersion.toString());
    }

    return _this;
  }

  (0, _createClass2["default"])(PermissionHandlerPlugin, [{
    key: "_getFromLocal",
    value: function _getFromLocal() {
      if (this.fallbackMemory) return this.permissions;
      var permission = localStorage.getItem('plugins/permissions');
      return permission ? JSON.parse(permission) : {};
    }
  }, {
    key: "persistPermissions",
    value: function persistPermissions() {
      var permissions = JSON.stringify(this.permissions);

      try {
        localStorage.setItem('plugins/permissions', permissions);
      } catch (e) {
        this.fallbackMemory = true;
        console.log(e);
      }
    }
  }, {
    key: "switchMode",
    value: function switchMode(from, to, method, set) {
      set ? this.permissions[to.name][method][from.name] = {} : delete this.permissions[to.name][method][from.name];
    }
  }, {
    key: "clear",
    value: function clear() {
      localStorage.removeItem('plugins/permissions');
    }
  }, {
    key: "notAllowWarning",
    value: function notAllowWarning(from, to, method) {
      return "".concat(from.displayName || from.name, " is not allowed to call ").concat(method, " method of ").concat(to.displayName || to.name, ".");
    }
  }, {
    key: "getTheme",
    value: function () {
      var _getTheme = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.call('theme', 'currentTheme');

              case 2:
                return _context.abrupt("return", _context.sent.quality);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getTheme() {
        return _getTheme.apply(this, arguments);
      }

      return getTheme;
    }()
    /**
     * Check if a plugin has the permission to call another plugin and askPermission if needed
     * @param {PluginProfile} from the profile of the plugin that make the call
     * @param {ModuleProfile} to The profile of the module that receive the call
     * @param {string} method The name of the function to be called
     * @param {string} message from the caller plugin to add more details if needed
     * @returns {Promise<boolean>}
     */

  }, {
    key: "askPermission",
    value: function () {
      var _askPermission = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(from, to, method, message, sensitiveCall) {
        var _this$permissions$to$, allow, hash, warning;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                this.permissions = this._getFromLocal();
                if (!this.permissions[to.name]) this.permissions[to.name] = {};
                if (!this.permissions[to.name][method]) this.permissions[to.name][method] = {};

                if (this.permissions[to.name][method][from.name]) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", this.openPermission(from, to, method, message, sensitiveCall));

              case 6:
                _this$permissions$to$ = this.permissions[to.name][method][from.name], allow = _this$permissions$to$.allow, hash = _this$permissions$to$.hash;

                if (allow) {
                  _context2.next = 11;
                  break;
                }

                warning = this.notAllowWarning(from, to, method);
                this.call('notification', 'toast', warning);
                return _context2.abrupt("return", false);

              case 11:
                if (!(hash === from.hash)) {
                  _context2.next = 15;
                  break;
                }

                _context2.t0 = true // Allow
                ;
                _context2.next = 18;
                break;

              case 15:
                _context2.next = 17;
                return this.openPermission(from, to, method, message, sensitiveCall);

              case 17:
                _context2.t0 = _context2.sent;

              case 18:
                return _context2.abrupt("return", _context2.t0);

              case 21:
                _context2.prev = 21;
                _context2.t1 = _context2["catch"](0);
                throw new Error(_context2.t1);

              case 24:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 21]]);
      }));

      function askPermission(_x, _x2, _x3, _x4, _x5) {
        return _askPermission.apply(this, arguments);
      }

      return askPermission;
    }()
  }, {
    key: "openPermission",
    value: function () {
      var _openPermission = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(from, to, method, message, sensitiveCall) {
        var _this2 = this;

        var remember, value, modal, result;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                remember = this.permissions[to.name][method][from.name];
                value = {
                  from: from,
                  to: to,
                  method: method,
                  message: message,
                  remember: remember,
                  sensitiveCall: sensitiveCall
                };
                _context3.t0 = "Permission needed for ".concat(to.displayName || to.name);
                _context3.t1 = _react["default"];
                _context3.t2 = _src.PermissionHandlerDialog;
                _context3.t3 = this;
                _context3.next = 8;
                return this.getTheme();

              case 8:
                _context3.t4 = _context3.sent;
                _context3.t5 = value;
                _context3.t6 = {
                  plugin: _context3.t3,
                  theme: _context3.t4,
                  value: _context3.t5
                };
                _context3.t7 = _context3.t1.createElement.call(_context3.t1, _context3.t2, _context3.t6);
                modal = {
                  id: 'PermissionHandler',
                  title: _context3.t0,
                  message: _context3.t7,
                  okLabel: 'Accept',
                  cancelLabel: 'Decline'
                };
                _context3.next = 15;
                return this.call('notification', 'modal', modal);

              case 15:
                result = _context3.sent;
                return _context3.abrupt("return", new Promise(function (resolve, reject) {
                  if (result) {
                    if (_this2.permissions[to.name][method][from.name]) {
                      _this2.permissions[to.name][method][from.name] = {
                        allow: true,
                        hash: from.hash
                      };

                      _this2.persistPermissions();
                    }

                    resolve(true);
                  } else {
                    if (_this2.permissions[to.name][method][from.name]) {
                      _this2.permissions[to.name][method][from.name] = {
                        allow: false,
                        hash: from.hash
                      };

                      _this2.persistPermissions();
                    }

                    reject(_this2.notAllowWarning(from, to, method));
                  }
                }));

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function openPermission(_x6, _x7, _x8, _x9, _x10) {
        return _openPermission.apply(this, arguments);
      }

      return openPermission;
    }()
  }]);
  return PermissionHandlerPlugin;
}(_engine.Plugin);

exports.PermissionHandlerPlugin = PermissionHandlerPlugin;

/***/ }),
/* 2158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "PermissionHandlerDialog", {
  enumerable: true,
  get: function () {
    return _permissionDialog.default;
  }
});
Object.defineProperty(exports, "PermissionHandlerProps", {
  enumerable: true,
  get: function () {
    return _index.PermissionHandlerProps;
  }
});
Object.defineProperty(exports, "PermissionHandlerValue", {
  enumerable: true,
  get: function () {
    return _index.PermissionHandlerValue;
  }
});

var _permissionDialog = _interopRequireDefault(__webpack_require__(2159));

var _index = __webpack_require__(2162);

/***/ }),
/* 2159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2160);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const PermissionHandlerDialog = props => {
  const {
    from,
    to,
    remember,
    method,
    message,
    sensitiveCall
  } = props.value;
  const [feedback, setFeedback] = (0, _react.useState)('');
  const theme = props.theme;

  const switchMode = e => {
    props.plugin.switchMode(from, to, method, e.target.checked);
  };

  const rememberSwitch = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
      type: "checkbox",
      onChange: switchMode,
      className: "form-check-input",
      id: "remember",
      "data-id": remember ? 'permissionHandlerRememberChecked' : 'permissionHandlerRememberUnchecked'
    });
  };

  const reset = () => {
    props.plugin.clear();
    setFeedback('All permisssions have been reset.');
  };

  const imgFrom = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
      className: `${theme === 'dark' ? 'invert' : ''}`,
      alt: "",
      id: "permissionModalImagesFrom",
      src: from.icon
    });
  };

  const imgTo = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
      className: `${theme === 'dark' ? 'invert' : ''}`,
      alt: "",
      id: "permissionModalImagesTo",
      src: to.icon
    });
  };

  const pluginsImages = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
      className: "images",
      children: [imgFrom(), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: "fas fa-arrow-right"
      }), imgTo()]
    });
  };

  const text = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: ["\"", from.displayName, "\" ", remember ? 'has changed and' : '', " would like to access to \"", method, "\" of \"", to.displayName, "\"`"]
    });
  };

  const pluginMessage = () => {
    return message ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        children: "Description"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        children: message
      })]
    }) : null;
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("section", {
    className: "permission",
    children: [pluginsImages(), /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("h4", {
        "data-id": "permissionHandlerMessage",
        children: [text(), " :"]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        children: from.displayName
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
        children: [" ", from.description || /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          children: "No description Provided"
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("h6", {
        children: [to.displayName, " :"]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
        children: [" ", to.description || /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          children: "No description Provided"
        })]
      }), pluginMessage(), sensitiveCall ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("p", {
        className: "text-warning",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "fas fa-exclamation-triangle mr-2",
          "aria-hidden": "true"
        }), "You are going to process a sensitive call. Please make sure you trust this plugin."]
      }) : '']
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
      className: "remember",
      children: [!sensitiveCall && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "form-check",
        children: [rememberSwitch(), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          htmlFor: "remember",
          className: "form-check-label",
          "data-id": "permissionHandlerRememberChoice",
          children: "Remember this choice"
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        className: "btn btn-sm",
        onClick: reset,
        children: "Reset all Permissions"
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      children: feedback
    })]
  });
};

var _default = PermissionHandlerDialog;
exports.default = _default;

/***/ }),
/* 2160 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2161);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2161 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".permission h4 {\n    text-transform: uppercase;\n    text-align: center;\n  }\n  .permission h6 {\n    text-transform: uppercase;\n  }\n  .remember {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n  .images {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding: 10px;\n  }\n  .images img {\n    width: 40px;\n    height: 40px;\n  }\n  .images i {\n    margin: 0 20px;\n  }\n  .invert {\n    filter: invert(1);\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBlcm1pc3Npb24tZGlhbG9nLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLHlCQUF5QjtJQUN6QixrQkFBa0I7RUFDcEI7RUFDQTtJQUNFLHlCQUF5QjtFQUMzQjtFQUNBO0lBQ0UsYUFBYTtJQUNiLDhCQUE4QjtJQUM5QixtQkFBbUI7RUFDckI7RUFDQTtJQUNFLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLGFBQWE7RUFDZjtFQUNBO0lBQ0UsV0FBVztJQUNYLFlBQVk7RUFDZDtFQUNBO0lBQ0UsY0FBYztFQUNoQjtFQUVBO0lBQ0UsaUJBQWlCO0VBQ25CIiwiZmlsZSI6InBlcm1pc3Npb24tZGlhbG9nLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5wZXJtaXNzaW9uIGg0IHtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuICAucGVybWlzc2lvbiBoNiB7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgfVxuICAucmVtZW1iZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgLmltYWdlcyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gIH1cbiAgLmltYWdlcyBpbWcge1xuICAgIHdpZHRoOiA0MHB4O1xuICAgIGhlaWdodDogNDBweDtcbiAgfVxuICAuaW1hZ2VzIGkge1xuICAgIG1hcmdpbjogMCAyMHB4O1xuICB9XG5cbiAgLmludmVydCB7XG4gICAgZmlsdGVyOiBpbnZlcnQoMSk7XG4gIH0iXX0= */", '', '']]

/***/ }),
/* 2162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 2163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),
/* 2164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SourceMappings = exports.sourceLocationFromSrc = exports.sourceLocationFromAstNode = exports.lineColPositionFromOffset = void 0;

const astWalker_1 = __webpack_require__(1510);

const remix_lib_1 = __webpack_require__(311);
/**
 * Turn an character offset into a "LineColPosition".
 *
 * @param offset  The character offset to convert.
 */


function lineColPositionFromOffset(offset, lineBreaks) {
  let line = remix_lib_1.util.findLowerBound(offset, lineBreaks);

  if (lineBreaks[line] !== offset) {
    line += 1;
  }

  const beginColumn = line === 0 ? 0 : lineBreaks[line - 1] + 1;
  return {
    line: line + 1,
    character: offset - beginColumn + 1
  };
}

exports.lineColPositionFromOffset = lineColPositionFromOffset;
/**
 * Turn a solc AST's "src" attribute string (s:l:f)
 * into a Location
 *
 * @param astNode  The object to convert.
 */

function sourceLocationFromAstNode(astNode) {
  if ((0, astWalker_1.isAstNode)(astNode) && (0, astWalker_1.isYulAstNode)(astNode) && astNode.src) {
    return sourceLocationFromSrc(astNode.src);
  }

  return null;
}

exports.sourceLocationFromAstNode = sourceLocationFromAstNode;
/**
 * Break out fields of solc AST's "src" attribute string (s:l:f)
 * into its "start", "length", and "file index" components
 * and return that as a Location
 *
 * @param src  A solc "src" field.
 * @returns {Location}
 */

function sourceLocationFromSrc(src) {
  const split = src.split(':');
  return {
    start: parseInt(split[0], 10),
    length: parseInt(split[1], 10),
    file: parseInt(split[2], 10)
  };
}

exports.sourceLocationFromSrc = sourceLocationFromSrc;
/**
 * Routines for retrieving solc AST object(s) using some criteria, usually
 * includng "src' information.
 */
// eslint-disable-next-line no-redeclare

class SourceMappings {
  constructor(source) {
    this.source = source; // Create a list of line offsets which will be used to map between
    // character offset and line/column positions.

    const lineBreaks = [];

    for (let pos = source.indexOf('\n'); pos >= 0; pos = source.indexOf('\n', pos + 1)) {
      lineBreaks.push(pos);
    }

    this.lineBreaks = lineBreaks;
  }
  /**
   * Get a list of nodes that are at the given "position".
   *
   * @param astNodeType  Type of node to return or null.
   * @param position     Character offset where AST node should be located.
   */


  nodesAtPosition(astNodeType, position, ast) {
    const astWalker = new astWalker_1.AstWalker();
    const found = [];

    const callback = function (node) {
      const nodeLocation = sourceLocationFromAstNode(node);

      if (nodeLocation && nodeLocation.start === position.start && nodeLocation.length === position.length) {
        if (!astNodeType || astNodeType === node.nodeType) {
          found.push(node);
        }
      }

      return true;
    };

    astWalker.walkFull(ast, callback);
    return found;
  }
  /**
   * Retrieve the first "astNodeType" that includes the source map at arg instIndex, or "null" if none found.
   *
   * @param astNodeType   nodeType that a found ASTNode must be. Use "null" if any ASTNode can match.
   * @param sourceLocation "src" location that the AST node must match.
   */


  findNodeAtSourceLocation(astNodeType, sourceLocation, ast) {
    const astWalker = new astWalker_1.AstWalker();
    let found = null;
    /* FIXME: Looking at AST walker code,
       I don't understand a need to return a boolean. */

    const callback = function (node) {
      const nodeLocation = sourceLocationFromAstNode(node);

      if (nodeLocation && nodeLocation.start === sourceLocation.start && nodeLocation.length === sourceLocation.length) {
        if (astNodeType === undefined || astNodeType === node.nodeType) {
          found = node;
        }
      }

      return true;
    };

    astWalker.walkFull(ast, callback);
    return found;
  }
  /**
   * Retrieve the line/column range position for the given source-mapping string.
   *
   * @param src  Solc "src" object containing attributes {source} and {length}.
   */


  srcToLineColumnRange(src) {
    const sourceLocation = sourceLocationFromSrc(src);

    if (sourceLocation.start >= 0 && sourceLocation.length >= 0) {
      return {
        start: lineColPositionFromOffset(sourceLocation.start, this.lineBreaks),
        end: lineColPositionFromOffset(sourceLocation.start + sourceLocation.length, this.lineBreaks)
      };
    } else {
      return {
        start: null,
        end: null
      };
    }
  }

}

exports.SourceMappings = SourceMappings;

/***/ }),
/* 2165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OffsetToLineColumnConverter = void 0;

var _engine = __webpack_require__(477);

var _remixDebug = __webpack_require__(1217);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const profile = {
  name: 'offsetToLineColumnConverter',
  methods: ['offsetToLineColumn'],
  events: [],
  version: '0.0.1'
};

class OffsetToLineColumnConverter extends _engine.Plugin {
  constructor() {
    super(profile);

    _defineProperty(this, "lineBreakPositionsByContent", void 0);

    _defineProperty(this, "sourceMappingDecoder", void 0);

    this.lineBreakPositionsByContent = {};
    this.sourceMappingDecoder = _remixDebug.sourceMappingDecoder;
  }
  /**
   * Convert offset representation with line/column representation.
   * This is also used to resolve the content:
   * @arg file is the index of the file in the content sources array and content sources array does have filename as key and not index.
   * So we use the asts (which references both index and filename) to look up the actual content targeted by the @arg file index.
   * @param {{start, length}} rawLocation - offset location
   * @param {number} file - The index where to find the source in the sources parameters
   * @param {Object.<string, {content}>} sources - Map of content sources
   * @param {Object.<string, {ast, id}>} asts - Map of content sources
   */


  offsetToLineColumn(rawLocation, file, sources, asts) {
    if (!this.lineBreakPositionsByContent[file]) {
      const sourcesArray = Object.keys(sources);

      if (!asts || file === 0 && sourcesArray.length === 1) {
        // if we don't have ast, we process the only one available content (applicable also for compiler older than 0.4.12)
        this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[sourcesArray[0]].content);
      } else {
        for (const filename in asts) {
          const source = asts[filename];

          if (source.id === file) {
            this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(sources[filename].content);
            break;
          }
        }
      }
    }

    return this.sourceMappingDecoder.convertOffsetToLineColumn(rawLocation, this.lineBreakPositionsByContent[file]);
  }
  /**
   * Convert offset representation with line/column representation.
   * @param {{start, length}} rawLocation - offset location
   * @param {number} file - The index where to find the source in the sources parameters
   * @param {string} content - source
   */


  offsetToLineColumnWithContent(rawLocation, file, content) {
    this.lineBreakPositionsByContent[file] = this.sourceMappingDecoder.getLinebreakPositions(content);
    return this.sourceMappingDecoder.convertOffsetToLineColumn(rawLocation, this.lineBreakPositionsByContent[file]);
  }
  /**
   * Clear the cache
   */


  clear() {
    this.lineBreakPositionsByContent = {};
  }
  /**
   * called by plugin API
   */


  activate() {
    this.on('solidity', 'compilationFinished', (success, data, source, input, version) => {
      this.clear();
    });
  }

}

exports.OffsetToLineColumnConverter = OffsetToLineColumnConverter;

/***/ }),
/* 2166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extend = exports.web3DebugNode = exports.setProvider = exports.extendWeb3 = exports.loadWeb3 = void 0;

const tslib_1 = __webpack_require__(23);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

function loadWeb3(url) {
  if (!url) url = 'http://localhost:8545';
  const web3 = new web3_1.default();
  web3.setProvider(new web3_1.default.providers.HttpProvider(url));
  extend(web3);
  return web3;
}

exports.loadWeb3 = loadWeb3;

function extendWeb3(web3) {
  extend(web3);
}

exports.extendWeb3 = extendWeb3;

function setProvider(web3, url) {
  web3.setProvider(new web3.providers.HttpProvider(url));
}

exports.setProvider = setProvider;

function web3DebugNode(network) {
  const web3DebugNodes = {
    Main: 'https://rpc.archivenode.io/e50zmkroshle2e2e50zm0044i7ao04ym',
    Rinkeby: 'https://remix-rinkeby.ethdevops.io',
    Ropsten: 'https://remix-ropsten.ethdevops.io',
    Goerli: 'https://remix-goerli.ethdevops.io'
  };

  if (web3DebugNodes[network]) {
    return loadWeb3(web3DebugNodes[network]);
  }

  return null;
}

exports.web3DebugNode = web3DebugNode;

function extend(web3) {
  if (!web3.extend) {
    return;
  } // DEBUG


  const methods = [];

  if (!(web3.debug && web3.debug.preimage)) {
    methods.push(new web3.extend.Method({
      name: 'preimage',
      call: 'debug_preimage',
      inputFormatter: [null],
      params: 1
    }));
  }

  if (!(web3.debug && web3.debug.traceTransaction)) {
    methods.push(new web3.extend.Method({
      name: 'traceTransaction',
      call: 'debug_traceTransaction',
      inputFormatter: [null, null],
      params: 2
    }));
  }

  if (!(web3.debug && web3.debug.storageRangeAt)) {
    methods.push(new web3.extend.Method({
      name: 'storageRangeAt',
      call: 'debug_storageRangeAt',
      inputFormatter: [null, null, null, null, null],
      params: 5
    }));
  }

  if (methods.length > 0) {
    web3.extend({
      property: 'debug',
      methods: methods,
      properties: []
    });
  }
}

exports.extend = extend;

/***/ }),
/* 2167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceManager = void 0;

const tslib_1 = __webpack_require__(23);

const remix_lib_1 = __webpack_require__(311);

const traceAnalyser_1 = __webpack_require__(2168);

const traceCache_1 = __webpack_require__(2169);

const traceStepManager_1 = __webpack_require__(2170);

const traceHelper_1 = __webpack_require__(1146);

class TraceManager {
  constructor(options) {
    this.web3 = options.web3;
    this.isLoading = false;
    this.trace = null;
    this.traceCache = new traceCache_1.TraceCache();
    this.traceAnalyser = new traceAnalyser_1.TraceAnalyser(this.traceCache);
    this.traceStepManager = new traceStepManager_1.TraceStepManager(this.traceAnalyser);
  } // init section


  resolveTrace(tx) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.tx = tx;
      this.init();
      if (!this.web3) throw new Error('web3 not loaded');
      this.isLoading = true;
      const result = yield this.getTrace(tx.hash);

      try {
        if (result['structLogs'].length > 0) {
          this.trace = result['structLogs'];

          try {
            const networkId = yield this.web3.eth.net.getId();
            this.fork = remix_lib_1.execution.forkAt(networkId, tx.blockNumber);
          } catch (e) {
            this.fork = 'london';
            console.log(`unable to detect fork, defaulting to ${this.fork}..`);
            console.error(e);
          }

          this.traceAnalyser.analyse(result['structLogs'], tx);
          this.isLoading = false;
          return true;
        }

        const mes = tx.hash + ' is not a contract invocation or contract creation.';
        console.log(mes);
        this.isLoading = false;
        throw new Error(mes);
      } catch (error) {
        console.log(error);
        this.isLoading = false;
        throw new Error(error);
      }
    });
  }

  getTrace(txHash) {
    return new Promise((resolve, reject) => {
      const options = {
        disableStorage: true,
        enableMemory: true,
        disableStack: false,
        fullStorage: false
      };
      this.web3.debug.traceTransaction(txHash, options, function (error, result) {
        if (error) return reject(error);
        resolve(result);
      });
    });
  }

  init() {
    this.trace = null;
    this.traceCache.init();
  }

  getCurrentFork() {
    return this.fork;
  } // API section


  inRange(step) {
    return this.isLoaded() && step >= 0 && step < this.trace.length;
  }

  isLoaded() {
    return !this.isLoading && this.trace !== null;
  }

  getLength(callback) {
    if (!this.trace) {
      callback(new Error('no trace available'), null);
    } else {
      callback(null, this.trace.length);
    }
  }

  accumulateStorageChanges(index, address, storageOrigin) {
    return this.traceCache.accumulateStorageChanges(index, address, storageOrigin);
  }

  getAddresses() {
    return this.traceCache.addresses;
  }

  getCallDataAt(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    const callDataChange = remix_lib_1.util.findLowerBoundValue(stepIndex, this.traceCache.callDataChanges);

    if (callDataChange === null) {
      throw new Error('no calldata found');
    }

    return [this.traceCache.callsData[callDataChange]];
  }

  buildCallPath(stepIndex) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        this.checkRequestedStep(stepIndex);
      } catch (check) {
        throw new Error(check);
      }

      const callsPath = remix_lib_1.util.buildCallPath(stepIndex, this.traceCache.callsTree.call);
      if (callsPath === null) throw new Error('no call path built');
      return callsPath;
    });
  }

  getCallStackAt(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    const call = remix_lib_1.util.findCall(stepIndex, this.traceCache.callsTree.call);

    if (call === null) {
      throw new Error('no callstack found');
    }

    return call.callStack;
  }

  getStackAt(stepIndex) {
    this.checkRequestedStep(stepIndex);

    if (this.trace[stepIndex] && this.trace[stepIndex].stack) {
      // there's always a stack
      const stack = this.trace[stepIndex].stack.slice(0);
      stack.reverse();
      return stack.map(el => el.startsWith('0x') ? el : '0x' + el);
    } else {
      throw new Error('no stack found');
    }
  }

  getLastCallChangeSince(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    const callChange = remix_lib_1.util.findCall(stepIndex, this.traceCache.callsTree.call);

    if (callChange === null) {
      return 0;
    }

    return callChange;
  }

  getCurrentCalledAddressAt(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
      const resp = this.getLastCallChangeSince(stepIndex);

      if (!resp) {
        throw new Error('unable to get current called address. ' + stepIndex + ' does not match with a CALL');
      }

      return resp.address;
    } catch (error) {
      throw new Error(error);
    }
  }

  getContractCreationCode(token) {
    if (!this.traceCache.contractCreation[token]) {
      throw new Error('no contract creation named ' + token);
    }

    return this.traceCache.contractCreation[token];
  }

  getMemoryAt(stepIndex) {
    this.checkRequestedStep(stepIndex);
    const lastChanges = remix_lib_1.util.findLowerBoundValue(stepIndex, this.traceCache.memoryChanges);

    if (lastChanges === null) {
      throw new Error('no memory found');
    }

    return this.trace[lastChanges].memory;
  }

  getCurrentPC(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    return this.trace[stepIndex].pc;
  }

  getAllStopIndexes() {
    return this.traceCache.stopIndexes;
  }

  getAllOutofGasIndexes() {
    return this.traceCache.outofgasIndexes;
  }

  getReturnValue(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    if (!this.traceCache.returnValues[stepIndex]) {
      throw new Error('current step is not a return step');
    }

    return this.traceCache.returnValues[stepIndex];
  }

  getCurrentStep(stepIndex) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    return this.traceCache.steps[stepIndex];
  }

  getMemExpand(stepIndex) {
    return this.getStepProperty(stepIndex, 'memexpand') || '';
  }

  getStepCost(stepIndex) {
    return this.getStepProperty(stepIndex, 'gasCost');
  }

  getRemainingGas(stepIndex) {
    return this.getStepProperty(stepIndex, 'gas');
  }

  getStepProperty(stepIndex, property) {
    try {
      this.checkRequestedStep(stepIndex);
    } catch (check) {
      throw new Error(check);
    }

    return this.trace[stepIndex][property];
  }

  isCreationStep(stepIndex) {
    return (0, traceHelper_1.isCreateInstruction)(this.trace[stepIndex]);
  } // step section


  findStepOverBack(currentStep) {
    return this.traceStepManager.findStepOverBack(currentStep);
  }

  findStepOverForward(currentStep) {
    return this.traceStepManager.findStepOverForward(currentStep);
  }

  findNextCall(currentStep) {
    return this.traceStepManager.findNextCall(currentStep);
  }

  findStepOut(currentStep) {
    return this.traceStepManager.findStepOut(currentStep);
  }

  checkRequestedStep(stepIndex) {
    if (!this.trace) {
      throw new Error('trace not loaded');
    } else if (stepIndex >= this.trace.length) {
      throw new Error('trace smaller than requested');
    }
  }

  waterfall(calls, stepindex, cb) {
    const ret = [];
    let retError = null;

    for (const call in calls) {
      calls[call].apply(this, [stepindex, function (error, result) {
        retError = error;
        ret.push({
          error: error,
          value: result
        });
      }]);
    }

    cb(retError, ret);
  }

}

exports.TraceManager = TraceManager;

/***/ }),
/* 2168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceAnalyser = void 0;

const tslib_1 = __webpack_require__(23);

const traceHelper = (0, tslib_1.__importStar)(__webpack_require__(1146));

class TraceAnalyser {
  constructor(_cache) {
    this.traceCache = _cache;
    this.trace = null;
  }

  analyse(trace, tx) {
    this.trace = trace;
    this.traceCache.pushStoreChanges(0, tx.to);
    let context = {
      storageContext: [tx.to],
      currentCallIndex: 0,
      lastCallIndex: 0
    };
    const callStack = [tx.to];
    this.traceCache.pushCall(trace[0], 0, callStack[0], callStack.slice(0));

    if (traceHelper.isContractCreation(tx.to)) {
      this.traceCache.pushContractCreation(tx.to, tx.input);
    }

    this.buildCalldata(0, this.trace[0], tx, true);

    for (let k = 0; k < this.trace.length; k++) {
      const step = this.trace[k];
      this.buildMemory(k, step);
      context = this.buildDepth(k, step, tx, callStack, context);
      context = this.buildStorage(k, step, context);
      this.buildReturnValues(k, step);
    }

    return true;
  }

  buildReturnValues(index, step) {
    if (traceHelper.isReturnInstruction(step)) {
      let offset = 2 * parseInt(step.stack[step.stack.length - 1], 16);
      const size = 2 * parseInt(step.stack[step.stack.length - 2], 16);
      const memory = this.trace[this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1]].memory;
      const noOfReturnParams = size / 64;
      const memoryInString = memory.join('');
      const returnParamsObj = [];

      for (let i = 0; i < noOfReturnParams; i++) {
        returnParamsObj.push('0x' + memoryInString.substring(offset, offset + 64));
        offset += 64;
      }

      this.traceCache.pushReturnValue(index, returnParamsObj);
    }

    if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step) || traceHelper.isRevertInstruction(step)) {
      this.traceCache.pushStopIndex(index, this.traceCache.currentCall.call.address);
    }

    try {
      if (parseInt(step.gas) - parseInt(step.gasCost) <= 0 || step.error === 'OutOfGas') {
        this.traceCache.pushOutOfGasIndex(index, this.traceCache.currentCall.call.address);
      }
    } catch (e) {
      console.error(e);
    }
  }

  buildCalldata(index, step, tx, newContext) {
    let calldata = '';

    if (index === 0) {
      calldata = tx.input;
      this.traceCache.pushCallDataChanges(index, calldata);
    } else if (!newContext) {
      const lastCall = this.traceCache.callsData[this.traceCache.callDataChanges[this.traceCache.callDataChanges.length - 2]];
      this.traceCache.pushCallDataChanges(index + 1, lastCall);
    } else {
      const memory = this.trace[this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1]].memory;
      const callStep = this.trace[index];
      const stack = callStep.stack;
      let offset = 0;
      let size = 0;

      if (callStep.op === 'DELEGATECALL') {
        offset = 2 * parseInt(stack[stack.length - 3], 16);
        size = 2 * parseInt(stack[stack.length - 4], 16);
      } else {
        offset = 2 * parseInt(stack[stack.length - 4], 16);
        size = 2 * parseInt(stack[stack.length - 5], 16);
      }

      calldata = '0x' + memory.join('').substr(offset, size);
      this.traceCache.pushCallDataChanges(index + 1, calldata);
    }
  }

  buildMemory(index, step) {
    if (step.memory) {
      this.traceCache.pushMemoryChanges(index);
    }
  }

  buildStorage(index, step, context) {
    if (traceHelper.newContextStorage(step) && !traceHelper.isCallToPrecompiledContract(index, this.trace)) {
      const calledAddress = traceHelper.resolveCalledAddress(index, this.trace);

      if (calledAddress) {
        context.storageContext.push(calledAddress);
      } else {
        console.log('unable to build storage changes. ' + index + ' does not match with a CALL. storage changes will be corrupted');
      }

      this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1]);
    } else if (traceHelper.isSSTOREInstruction(step)) {
      this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1], step.stack[step.stack.length - 1], step.stack[step.stack.length - 2]);
    } else if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step)) {
      context.storageContext.pop();
      this.traceCache.pushStoreChanges(index + 1, context.storageContext[context.storageContext.length - 1]);
    } else if (traceHelper.isRevertInstruction(step)) {
      context.storageContext.pop();
      this.traceCache.resetStoreChanges();
    }

    return context;
  }

  buildDepth(index, step, tx, callStack, context) {
    if (traceHelper.isCallInstruction(step) && !traceHelper.isCallToPrecompiledContract(index, this.trace)) {
      let newAddress;

      if (traceHelper.isCreateInstruction(step)) {
        newAddress = traceHelper.contractCreationToken(index);
        callStack.push(newAddress);
        const lastMemoryChange = this.traceCache.memoryChanges[this.traceCache.memoryChanges.length - 1];
        this.traceCache.pushContractCreationFromMemory(index, newAddress, this.trace, lastMemoryChange);
      } else {
        newAddress = traceHelper.resolveCalledAddress(index, this.trace);

        if (newAddress) {
          callStack.push(newAddress);
        } else {
          console.log('unable to build depth changes. ' + index + ' does not match with a CALL. depth changes will be corrupted');
        }
      }

      this.traceCache.pushCall(step, index + 1, newAddress, callStack.slice(0));
      this.buildCalldata(index, step, tx, true);
      this.traceCache.pushSteps(index, context.currentCallIndex);
      context.lastCallIndex = context.currentCallIndex;
      context.currentCallIndex = 0;
    } else if (traceHelper.isReturnInstruction(step) || traceHelper.isStopInstruction(step) || step.error || step.invalidDepthChange) {
      if (index < this.trace.length) {
        callStack.pop();
        this.traceCache.pushCall(step, index + 1, null, callStack.slice(0), step.error || step.invalidDepthChange);
        this.buildCalldata(index, step, tx, false);
        this.traceCache.pushSteps(index, context.currentCallIndex);
        context.currentCallIndex = context.lastCallIndex + 1;
      }
    } else {
      this.traceCache.pushSteps(index, context.currentCallIndex);
      context.currentCallIndex++;
    }

    return context;
  }

}

exports.TraceAnalyser = TraceAnalyser;

/***/ }),
/* 2169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceCache = void 0;

const remix_lib_1 = __webpack_require__(311); // eslint-disable-next-line camelcase


const {
  sha3_256
} = remix_lib_1.util;

class TraceCache {
  constructor() {
    this.init();
  }

  init() {
    // ...Changes contains index in the vmtrace of the corresponding changes
    this.returnValues = {};
    this.stopIndexes = [];
    this.outofgasIndexes = [];
    this.currentCall = null;
    this.callsTree = null;
    this.callsData = {};
    this.contractCreation = {};
    this.steps = {};
    this.addresses = [];
    this.callDataChanges = [];
    this.memoryChanges = [];
    this.storageChanges = [];
    this.sstore = {}; // all sstore occurence in the trace
  }

  pushSteps(index, currentCallIndex) {
    this.steps[index] = currentCallIndex;
  }

  pushCallDataChanges(value, calldata) {
    this.callDataChanges.push(value);
    this.callsData[value] = calldata;
  }

  pushMemoryChanges(value) {
    this.memoryChanges.push(value);
  } // outOfGas has been removed because gas left logging is apparently made differently
  // in the vm/geth/eth. TODO add the error property (with about the error in all clients)


  pushCall(step, index, address, callStack, reverted) {
    const validReturnStep = step.op === 'RETURN' || step.op === 'STOP';

    if ((validReturnStep || reverted) && this.currentCall) {
      this.currentCall.call.return = index - 1;

      if (!validReturnStep) {
        this.currentCall.call.reverted = reverted;
      }

      const parent = this.currentCall.parent;
      if (parent) this.currentCall = {
        call: parent.call,
        parent: parent.parent
      };
      return;
    }

    const call = {
      op: step.op,
      address: address,
      callStack: callStack,
      calls: {},
      start: index
    };
    this.addresses.push(address);

    if (this.currentCall) {
      this.currentCall.call.calls[index] = call;
    } else {
      this.callsTree = {
        call: call
      };
    }

    this.currentCall = {
      call: call,
      parent: this.currentCall
    };
  }

  pushOutOfGasIndex(index, address) {
    this.outofgasIndexes.push({
      index,
      address
    });
  }

  pushStopIndex(index, address) {
    this.stopIndexes.push({
      index,
      address
    });
  }

  pushReturnValue(step, value) {
    this.returnValues[step] = value;
  }

  pushContractCreationFromMemory(index, token, trace, lastMemoryChange) {
    const memory = trace[lastMemoryChange].memory;
    const stack = trace[index].stack;
    const offset = 2 * parseInt(stack[stack.length - 2], 16);
    const size = 2 * parseInt(stack[stack.length - 3], 16);
    this.contractCreation[token] = '0x' + memory.join('').substr(offset, size);
  }

  pushContractCreation(token, code) {
    this.contractCreation[token] = code;
  }

  resetStoreChanges(index, address, key, value) {
    this.sstore = {};
    this.storageChanges = [];
  }

  pushStoreChanges(index, address, key, value) {
    this.sstore[index] = {
      address: address,
      key: key,
      value: value,
      hashedKey: key && sha3_256(key)
    };
    this.storageChanges.push(index);
  }

  accumulateStorageChanges(index, address, storage) {
    const ret = Object.assign({}, storage);

    for (const k in this.storageChanges) {
      const changesIndex = this.storageChanges[k];

      if (changesIndex > index) {
        return ret;
      }

      const sstore = this.sstore[changesIndex];

      if (sstore.address === address && sstore.key) {
        ret[sstore.hashedKey] = {
          key: sstore.key,
          value: sstore.value
        };
      }
    }

    return ret;
  }

}

exports.TraceCache = TraceCache;

/***/ }),
/* 2170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceStepManager = void 0;

const traceHelper_1 = __webpack_require__(1146);

const remix_lib_1 = __webpack_require__(311);

class TraceStepManager {
  constructor(_traceAnalyser) {
    this.traceAnalyser = _traceAnalyser;
  }

  isCallInstruction(index) {
    const state = this.traceAnalyser.trace[index];
    return (0, traceHelper_1.isCallInstruction)(state) && !(0, traceHelper_1.isCallToPrecompiledContract)(index, this.traceAnalyser.trace);
  }

  isReturnInstruction(index) {
    const state = this.traceAnalyser.trace[index];
    return (0, traceHelper_1.isReturnInstruction)(state);
  }

  findStepOverBack(currentStep) {
    if (this.isReturnInstruction(currentStep)) {
      const call = remix_lib_1.util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
      return call.start > 0 ? call.start - 1 : 0;
    }

    return currentStep > 0 ? currentStep - 1 : 0;
  }

  findStepOverForward(currentStep) {
    if (this.isCallInstruction(currentStep)) {
      const call = remix_lib_1.util.findCall(currentStep + 1, this.traceAnalyser.traceCache.callsTree.call);
      return call.return + 1 < this.traceAnalyser.trace.length ? call.return + 1 : this.traceAnalyser.trace.length - 1;
    }

    return this.traceAnalyser.trace.length >= currentStep + 1 ? currentStep + 1 : currentStep;
  }

  findNextCall(currentStep) {
    const call = remix_lib_1.util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
    const subCalls = Object.keys(call.calls);

    if (subCalls.length) {
      const callStart = remix_lib_1.util.findLowerBound(currentStep, subCalls) + 1;

      if (subCalls.length > callStart) {
        return parseInt(subCalls[callStart]) - 1;
      }

      return currentStep;
    }

    return currentStep;
  }

  findStepOut(currentStep) {
    const call = remix_lib_1.util.findCall(currentStep, this.traceAnalyser.traceCache.callsTree.call);
    return call.return;
  }

}

exports.TraceStepManager = TraceStepManager;

/***/ }),
/* 2171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodeManager = void 0;

const tslib_1 = __webpack_require__(23);

const eventManager_1 = __webpack_require__(1157);

const traceHelper_1 = __webpack_require__(1146);

const sourceMappingDecoder_1 = __webpack_require__(1328);

const codeResolver_1 = __webpack_require__(2172);
/*
  resolve contract code referenced by vmtrace in order to be used by asm listview.
  events:
   - changed: triggered when an item is selected
   - resolvingStep: when CodeManager resolves code/selected instruction of a new step
*/


class CodeManager {
  constructor(_traceManager) {
    this.event = new eventManager_1.EventManager();
    this.isLoading = false;
    this.traceManager = _traceManager;
    this.codeResolver = new codeResolver_1.CodeResolver({
      getCode: address => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          this.traceManager.web3.eth.getCode(address, (error, code) => {
            if (error) {
              return reject(error);
            }

            return resolve(code);
          });
        });
      }),
      fork: this.traceManager.getCurrentFork()
    });
  }
  /**
   * clear the cache
   *
   */


  clear() {
    this.codeResolver.clear();
  }
  /**
   * resolve the code of the given @arg stepIndex and trigger appropriate event
   *
   * @param {String} stepIndex - vm trace step
   * @param {Object} tx - transaction (given by web3)
   */


  resolveStep(stepIndex, tx) {
    if (stepIndex < 0) return;
    this.event.trigger('resolvingStep');

    if (stepIndex === 0) {
      return this.retrieveCodeAndTrigger(this, tx.to, stepIndex, tx);
    }

    try {
      const address = this.traceManager.getCurrentCalledAddressAt(stepIndex);
      this.retrieveCodeAndTrigger(this, address, stepIndex, tx);
    } catch (error) {
      return console.log(error);
    }
  }
  /**
   * Retrieve the code located at the given @arg address
   *
   * @param {String} address - address of the contract to get the code from
   * @param {Function} cb - callback function, return the bytecode
   */


  getCode(address) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (!(0, traceHelper_1.isContractCreation)(address)) {
        const code = yield this.codeResolver.resolveCode(address);
        return code;
      }

      let codes = this.codeResolver.getExecutingCodeFromCache(address);

      if (codes) {
        return codes;
      }

      const hexCode = this.traceManager.getContractCreationCode(address);
      codes = this.codeResolver.cacheExecutingCode(address, hexCode);
      return codes;
    });
  }
  /**
   * Retrieve the called function for the current vm step for the given @arg address
   *
   * @param {String} stepIndex - vm trace step
   * @param {String} sourceMap - source map given byt the compilation result
   * @param {Object} ast - ast given by the compilation result
   * @return {Object} return the ast node of the function
   */


  getFunctionFromStep(stepIndex, sourceMap, ast) {
    try {
      const address = this.traceManager.getCurrentCalledAddressAt(stepIndex);
      const pc = this.traceManager.getCurrentPC(stepIndex);
      return this.getFunctionFromPC(address, pc, sourceMap, ast);
    } catch (error) {
      console.log(error);
      return {
        error: 'Cannot retrieve current address or PC for ' + stepIndex
      };
    }
  }
  /**
   * Retrieve the instruction index of the given @arg step
   *
   * @param {String} address - address of the current context
   * @param {String} step - vm trace step
   * @param {Function} callback - instruction index
   */


  getInstructionIndex(address, step) {
    try {
      const pc = this.traceManager.getCurrentPC(step);
      const itemIndex = this.codeResolver.getInstructionIndex(address, pc);
      return itemIndex;
    } catch (error) {
      console.log(error);
      throw new Error('Cannot retrieve current PC for ' + step);
    }
  }
  /**
   * Retrieve the called function for the given @arg pc and @arg address
   *
   * @param {String} address - address of the current context (used to resolve instruction index)
   * @param {String} pc - pc that point to the instruction index
   * @param {String} sourceMap - source map given byt the compilation result
   * @param {Object} ast - ast given by the compilation result
   * @return {Object} return the ast node of the function
   */


  getFunctionFromPC(address, pc, sourceMap, ast) {
    const instIndex = this.codeResolver.getInstructionIndex(address, pc);
    return (0, sourceMappingDecoder_1.findNodeAtInstructionIndex)('FunctionDefinition', instIndex, sourceMap, ast);
  }

  retrieveCodeAndTrigger(codeMananger, address, stepIndex, tx) {
    codeMananger.getCode(address).then(result => {
      this.retrieveIndexAndTrigger(codeMananger, address, stepIndex, result.instructions);
    }).catch(error => {
      return console.log(error);
    });
  }

  retrieveIndexAndTrigger(codeMananger, address, step, code) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      let result;
      const next = [];
      const returnInstructionIndexes = [];
      const outOfGasInstructionIndexes = [];

      try {
        result = codeMananger.getInstructionIndex(address, step);

        for (let i = 1; i < 6; i++) {
          if (this.traceManager.inRange(step + i)) {
            next.push(codeMananger.getInstructionIndex(address, step + i));
          }
        }

        let values = this.traceManager.getAllStopIndexes();

        if (values) {
          for (const value of values) {
            if (value.address === address) {
              returnInstructionIndexes.push({
                instructionIndex: this.getInstructionIndex(address, value.index),
                address
              });
            }
          }
        }

        values = this.traceManager.getAllOutofGasIndexes();

        if (values) {
          for (const value of values) {
            if (value.address === address) {
              outOfGasInstructionIndexes.push({
                instructionIndex: this.getInstructionIndex(address, value.index),
                address
              });
            }
          }
        }
      } catch (error) {
        return console.log(error);
      }

      try {
        codeMananger.event.trigger('changed', [code, address, result, next, returnInstructionIndexes, outOfGasInstructionIndexes]);
      } catch (e) {
        console.log('dispatching event failed', e);
      }
    });
  }

}

exports.CodeManager = CodeManager;

/***/ }),
/* 2172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodeResolver = void 0;

const tslib_1 = __webpack_require__(23);

const codeUtils_1 = __webpack_require__(2173);

class CodeResolver {
  constructor({
    getCode,
    fork
  }) {
    this.getCode = getCode;
    this.bytecodeByAddress = {}; // bytes code by contract addesses

    this.instructionsByAddress = {}; // assembly items instructions list by contract addesses

    this.instructionsIndexByBytesOffset = {}; // mapping between bytes offset and instructions index.

    this.fork = fork;
  }

  clear() {
    this.bytecodeByAddress = {};
    this.instructionsByAddress = {};
    this.instructionsIndexByBytesOffset = {};
  }

  resolveCode(address) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const cache = this.getExecutingCodeFromCache(address);

      if (cache) {
        return cache;
      }

      const code = yield this.getCode(address);
      return this.cacheExecutingCode(address, code);
    });
  }

  cacheExecutingCode(address, hexCode) {
    const codes = this.formatCode(hexCode);
    this.bytecodeByAddress[address] = hexCode;
    this.instructionsByAddress[address] = codes.code;
    this.instructionsIndexByBytesOffset[address] = codes.instructionsIndexByBytesOffset;
    return this.getExecutingCodeFromCache(address);
  }

  formatCode(hexCode) {
    const [code, instructionsIndexByBytesOffset] = (0, codeUtils_1.nameOpCodes)(Buffer.from(hexCode.substring(2), 'hex'), this.fork);
    return {
      code,
      instructionsIndexByBytesOffset
    };
  }

  getExecutingCodeFromCache(address) {
    if (!this.instructionsByAddress[address]) {
      return null;
    }

    return {
      instructions: this.instructionsByAddress[address],
      instructionsIndexByBytesOffset: this.instructionsIndexByBytesOffset[address],
      bytecode: this.bytecodeByAddress[address]
    };
  }

  getInstructionIndex(address, pc) {
    return this.getExecutingCodeFromCache(address).instructionsIndexByBytesOffset[pc];
  }

}

exports.CodeResolver = CodeResolver;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.roundLog = exports.log = exports.pad = exports.parseCode = exports.nameOpCodes = void 0;

const tslib_1 = __webpack_require__(23);

const common_1 = (0, tslib_1.__importDefault)(__webpack_require__(221));

const opcodes_1 = __webpack_require__(1329);

const opcodes_2 = (0, tslib_1.__importDefault)(__webpack_require__(2178));

function nameOpCodes(raw, hardfork) {
  const common = new common_1.default({
    chain: 'mainnet',
    hardfork
  });
  const opcodes = (0, opcodes_1.getOpcodesForHF)(common);
  let pushData = '';
  const codeMap = {};
  const code = [];

  for (let i = 0; i < raw.length; i++) {
    const pc = i;
    let curOpCode;

    try {
      curOpCode = opcodes.get(raw[pc]).fullName;
    } catch (e) {
      curOpCode = 'INVALID';
    }

    codeMap[i] = code.length; // no destinations into the middle of PUSH

    if (curOpCode.slice(0, 4) === 'PUSH') {
      const jumpNum = raw[pc] - 0x5f;
      pushData = raw.slice(pc + 1, pc + jumpNum + 1);
      i += jumpNum;
    }

    const data = pushData.toString('hex') !== '' ? ' ' + pushData.toString('hex') : '';
    code.push(pad(pc, roundLog(raw.length, 10)) + ' ' + curOpCode + data);
    pushData = '';
  }

  return [code, codeMap];
}

exports.nameOpCodes = nameOpCodes;
/**
 * Parses code as a list of integers into a list of objects containing
 * information about the opcode.
 */

function parseCode(raw) {
  const common = new common_1.default({
    chain: 'mainnet',
    hardfork: 'london'
  });
  const opcodes = (0, opcodes_1.getOpcodesForHF)(common);
  const code = [];

  for (let i = 0; i < raw.length; i++) {
    const opcode = {
      name: 'INVALID'
    };

    try {
      const code = opcodes.get(raw[i]);
      const opcodeDetails = (0, opcodes_2.default)(raw[i], false);
      opcode.in = opcodeDetails.in;
      opcode.out = opcodeDetails.out;
      opcode.name = code.fullName;
    } catch (e) {
      opcode.name = 'INVALID';
    }

    if (opcode.name.slice(0, 4) === 'PUSH') {
      const length = raw[i] - 0x5f;
      opcode.pushData = raw.slice(i + 1, i + length + 1); // in case pushdata extends beyond code

      if (i + 1 + length > raw.length) {
        for (let j = opcode['pushData'].length; j < length; j++) {
          opcode['pushData'].push(0);
        }
      }

      i += length;
    }

    code.push(opcode);
  }

  return code;
}

exports.parseCode = parseCode;

function pad(num, size) {
  let s = num + '';

  while (s.length < size) s = '0' + s;

  return s;
}

exports.pad = pad;

function log(num, base) {
  return Math.log(num) / Math.log(base);
}

exports.log = log;

function roundLog(num, base) {
  return Math.ceil(log(num, base));
}

exports.roundLog = roundLog;

/***/ }),
/* 2174 */,
/* 2175 */,
/* 2176 */,
/* 2177 */,
/* 2178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function default_1(op, full) {
  const codes = {
    // 0x0 range - arithmetic ops
    // name, baseCost, off stack, on stack, dynamic, async
    // @todo can be improved on basis of this: https://github.com/ethereumjs/ethereumjs-vm/blob/master/lib/evm/opcodes.ts
    0x00: ['STOP', 0, 0, 0, false],
    0x01: ['ADD', 3, 2, 1, false],
    0x02: ['MUL', 5, 2, 1, false],
    0x03: ['SUB', 3, 2, 1, false],
    0x04: ['DIV', 5, 2, 1, false],
    0x05: ['SDIV', 5, 2, 1, false],
    0x06: ['MOD', 5, 2, 1, false],
    0x07: ['SMOD', 5, 2, 1, false],
    0x08: ['ADDMOD', 8, 3, 1, false],
    0x09: ['MULMOD', 8, 3, 1, false],
    0x0a: ['EXP', 10, 2, 1, false],
    0x0b: ['SIGNEXTEND', 5, 2, 1, false],
    // 0x10 range - bit ops
    0x10: ['LT', 3, 2, 1, false],
    0x11: ['GT', 3, 2, 1, false],
    0x12: ['SLT', 3, 2, 1, false],
    0x13: ['SGT', 3, 2, 1, false],
    0x14: ['EQ', 3, 2, 1, false],
    0x15: ['ISZERO', 3, 1, 1, false],
    0x16: ['AND', 3, 2, 1, false],
    0x17: ['OR', 3, 2, 1, false],
    0x18: ['XOR', 3, 2, 1, false],
    0x19: ['NOT', 3, 1, 1, false],
    0x1a: ['BYTE', 3, 2, 1, false],
    0x1b: ['SHL', 3, 2, 1, false],
    0x1c: ['SHR', 3, 2, 1, false],
    0x1d: ['SAR', 3, 2, 1, false],
    // 0x20 range - crypto
    0x20: ['SHA3', 30, 2, 1, false],
    // 0x30 range - closure state
    0x30: ['ADDRESS', 2, 0, 1, true],
    0x31: ['BALANCE', 700, 1, 1, true, true],
    0x32: ['ORIGIN', 2, 0, 1, true],
    0x33: ['CALLER', 2, 0, 1, true],
    0x34: ['CALLVALUE', 2, 0, 1, true],
    0x35: ['CALLDATALOAD', 3, 1, 1, true],
    0x36: ['CALLDATASIZE', 2, 0, 1, true],
    0x37: ['CALLDATACOPY', 3, 3, 0, true],
    0x38: ['CODESIZE', 2, 0, 1, false],
    0x39: ['CODECOPY', 3, 3, 0, false],
    0x3a: ['GASPRICE', 2, 0, 1, false],
    0x3b: ['EXTCODESIZE', 700, 1, 1, true, true],
    0x3c: ['EXTCODECOPY', 700, 4, 0, true, true],
    0x3d: ['RETURNDATASIZE', 2, 0, 1, true],
    0x3e: ['RETURNDATACOPY', 3, 3, 0, true],
    0x3f: ['EXTCODEHASH', 400, 3, 0, true],
    // '0x40' range - block operations
    0x40: ['BLOCKHASH', 20, 1, 1, true, true],
    0x41: ['COINBASE', 2, 0, 1, true],
    0x42: ['TIMESTAMP', 2, 0, 1, true],
    0x43: ['NUMBER', 2, 0, 1, true],
    0x44: ['DIFFICULTY', 2, 0, 1, true],
    0x45: ['GASLIMIT', 2, 0, 1, true],
    0x46: ['CHAINID', 2, 0, 1, false],
    0x47: ['SELFBALANCE', 5, 0, 1, false],
    // 0x50 range - 'storage' and execution
    0x50: ['POP', 2, 1, 0, false],
    0x51: ['MLOAD', 3, 1, 1, false],
    0x52: ['MSTORE', 3, 2, 0, false],
    0x53: ['MSTORE8', 3, 2, 0, false],
    0x54: ['SLOAD', 800, 1, 1, true, true],
    0x55: ['SSTORE', 0, 2, 0, true, true],
    0x56: ['JUMP', 8, 1, 0, false],
    0x57: ['JUMPI', 10, 2, 0, false],
    0x58: ['PC', 2, 0, 1, false],
    0x59: ['MSIZE', 2, 0, 1, false],
    0x5a: ['GAS', 2, 0, 1, false],
    0x5b: ['JUMPDEST', 1, 0, 0, false],
    // 0x60, range
    0x60: ['PUSH1', 3, 0, 1, false],
    0x61: ['PUSH2', 3, 0, 1, false],
    0x62: ['PUSH3', 3, 0, 1, false],
    0x63: ['PUSH4', 3, 0, 1, false],
    0x64: ['PUSH5', 3, 0, 1, false],
    0x65: ['PUSH6', 3, 0, 1, false],
    0x66: ['PUSH7', 3, 0, 1, false],
    0x67: ['PUSH8', 3, 0, 1, false],
    0x68: ['PUSH9', 3, 0, 1, false],
    0x69: ['PUSH10', 3, 0, 1, false],
    0x6a: ['PUSH11', 3, 0, 1, false],
    0x6b: ['PUSH12', 3, 0, 1, false],
    0x6c: ['PUSH13', 3, 0, 1, false],
    0x6d: ['PUSH14', 3, 0, 1, false],
    0x6e: ['PUSH15', 3, 0, 1, false],
    0x6f: ['PUSH16', 3, 0, 1, false],
    0x70: ['PUSH17', 3, 0, 1, false],
    0x71: ['PUSH18', 3, 0, 1, false],
    0x72: ['PUSH19', 3, 0, 1, false],
    0x73: ['PUSH20', 3, 0, 1, false],
    0x74: ['PUSH21', 3, 0, 1, false],
    0x75: ['PUSH22', 3, 0, 1, false],
    0x76: ['PUSH23', 3, 0, 1, false],
    0x77: ['PUSH24', 3, 0, 1, false],
    0x78: ['PUSH25', 3, 0, 1, false],
    0x79: ['PUSH26', 3, 0, 1, false],
    0x7a: ['PUSH27', 3, 0, 1, false],
    0x7b: ['PUSH28', 3, 0, 1, false],
    0x7c: ['PUSH29', 3, 0, 1, false],
    0x7d: ['PUSH30', 3, 0, 1, false],
    0x7e: ['PUSH31', 3, 0, 1, false],
    0x7f: ['PUSH32', 3, 0, 1, false],
    0x80: ['DUP1', 3, 0, 1, false],
    0x81: ['DUP2', 3, 0, 1, false],
    0x82: ['DUP3', 3, 0, 1, false],
    0x83: ['DUP4', 3, 0, 1, false],
    0x84: ['DUP5', 3, 0, 1, false],
    0x85: ['DUP6', 3, 0, 1, false],
    0x86: ['DUP7', 3, 0, 1, false],
    0x87: ['DUP8', 3, 0, 1, false],
    0x88: ['DUP9', 3, 0, 1, false],
    0x89: ['DUP10', 3, 0, 1, false],
    0x8a: ['DUP11', 3, 0, 1, false],
    0x8b: ['DUP12', 3, 0, 1, false],
    0x8c: ['DUP13', 3, 0, 1, false],
    0x8d: ['DUP14', 3, 0, 1, false],
    0x8e: ['DUP15', 3, 0, 1, false],
    0x8f: ['DUP16', 3, 0, 1, false],
    0x90: ['SWAP1', 3, 0, 0, false],
    0x91: ['SWAP2', 3, 0, 0, false],
    0x92: ['SWAP3', 3, 0, 0, false],
    0x93: ['SWAP4', 3, 0, 0, false],
    0x94: ['SWAP5', 3, 0, 0, false],
    0x95: ['SWAP6', 3, 0, 0, false],
    0x96: ['SWAP7', 3, 0, 0, false],
    0x97: ['SWAP8', 3, 0, 0, false],
    0x98: ['SWAP9', 3, 0, 0, false],
    0x99: ['SWAP10', 3, 0, 0, false],
    0x9a: ['SWAP11', 3, 0, 0, false],
    0x9b: ['SWAP12', 3, 0, 0, false],
    0x9c: ['SWAP13', 3, 0, 0, false],
    0x9d: ['SWAP14', 3, 0, 0, false],
    0x9e: ['SWAP15', 3, 0, 0, false],
    0x9f: ['SWAP16', 3, 0, 0, false],
    0xa0: ['LOG0', 375, 2, 0, false],
    0xa1: ['LOG1', 375, 3, 0, false],
    0xa2: ['LOG2', 375, 4, 0, false],
    0xa3: ['LOG3', 375, 5, 0, false],
    0xa4: ['LOG4', 375, 6, 0, false],
    // '0xf0' range - closures
    0xf0: ['CREATE', 32000, 3, 1, true, true],
    0xf1: ['CALL', 700, 7, 1, true, true],
    0xf2: ['CALLCODE', 700, 7, 1, true, true],
    0xf3: ['RETURN', 0, 2, 0, false],
    0xf4: ['DELEGATECALL', 700, 6, 1, true, true],
    0xf5: ['CREATE2', 32000, 4, 1, true, true],
    0xfa: ['STATICCALL', 700, 6, 1, true, true],
    0xfd: ['REVERT', 0, 2, 0, false],
    // '0x70', range - other
    0xfe: ['INVALID', 0, 0, 0, false],
    0xff: ['SELFDESTRUCT', 5000, 1, 0, false, true]
  };
  const code = codes[op] ? codes[op] : ['INVALID', 0, 0, 0, false, false];
  let opcode = code[0];

  if (full) {
    if (opcode === 'LOG') {
      opcode += op - 0xa0;
    }

    if (opcode === 'PUSH') {
      opcode += op - 0x5f;
    }

    if (opcode === 'DUP') {
      opcode += op - 0x7f;
    }

    if (opcode === 'SWAP') {
      opcode += op - 0x8f;
    }
  }

  return {
    name: opcode,
    fee: code[1],
    in: code[2],
    out: code[3],
    dynamic: code[4],
    async: code[5]
  };
}

exports.default = default_1;

/***/ }),
/* 2179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SolidityProxy = void 0;

const tslib_1 = __webpack_require__(23);

const remix_lib_1 = __webpack_require__(311);

const traceHelper_1 = __webpack_require__(1146);

const stateDecoder_1 = __webpack_require__(1331);

const astHelper_1 = __webpack_require__(1514);

class SolidityProxy {
  constructor({
    getCurrentCalledAddressAt,
    getCode
  }) {
    this.cache = new Cache();
    this.reset({});
    this.getCurrentCalledAddressAt = getCurrentCalledAddressAt;
    this.getCode = getCode;
  }
  /**
    * reset the cache and apply a new @arg compilationResult
    *
    * @param {Object} compilationResult  - result os a compilatiion (diectly returned by the compiler)
    */


  reset(compilationResult) {
    this.sources = compilationResult.sources;
    this.contracts = compilationResult.contracts;
    this.cache.reset();
  }
  /**
    * check if the object has been properly loaded
    *
    * @return {Bool} - returns true if a compilation result has been applied
    */


  loaded() {
    return this.contracts !== undefined;
  }
  /**
    * retrieve the compiled contract name at the @arg vmTraceIndex (cached)
    *
    * @param {Int} vmTraceIndex  - index in the vm trave where to resolve the executed contract name
    * @param {Function} cb  - callback returns (error, contractName)
    */


  contractObjectAt(vmTraceIndex) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const address = this.getCurrentCalledAddressAt(vmTraceIndex);

      if (this.cache.contractObjectByAddress[address]) {
        return this.cache.contractObjectByAddress[address];
      }

      const code = yield this.getCode(address);
      const contract = contractObjectFromCode(this.contracts, code.bytecode, address);
      this.cache.contractObjectByAddress[address] = contract;
      return contract;
    });
  }
  /**
    * extract the state variables of the given compiled @arg contractName (cached)
    *
    * @param {String} contractName  - name of the contract to retrieve state variables from
    * @return {Object} - returns state variables of @args contractName
    */


  extractStatesDefinitions() {
    if (!this.cache.contractDeclarations) {
      this.cache.contractDeclarations = (0, astHelper_1.extractContractDefinitions)(this.sources);
    }

    if (!this.cache.statesDefinitions) {
      this.cache.statesDefinitions = (0, astHelper_1.extractStatesDefinitions)(this.sources, this.cache.contractDeclarations);
    }

    return this.cache.statesDefinitions;
  }
  /**
    * extract the state variables of the given compiled @arg contractName (cached)
    *
    * @param {String} contractName  - name of the contract to retrieve state variables from
    * @return {Object} - returns state variables of @args contractName
    */


  extractStateVariables(contractName) {
    if (!this.cache.stateVariablesByContractName[contractName]) {
      this.cache.stateVariablesByContractName[contractName] = (0, stateDecoder_1.extractStateVariables)(contractName, this.sources);
    }

    return this.cache.stateVariablesByContractName[contractName];
  }
  /**
    * extract the state variables of the given compiled @arg vmtraceIndex (cached)
    *
    * @param {Int} vmTraceIndex  - index in the vm trave where to resolve the state variables
    * @return {Object} - returns state variables of @args vmTraceIndex
    */


  extractStateVariablesAt(vmtraceIndex) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const contract = yield this.contractObjectAt(vmtraceIndex);
      return this.extractStateVariables(contract.name);
    });
  }
  /**
    * get the AST of the file declare in the @arg sourceLocation
    *
    * @param {Object} sourceLocation  - source location containing the 'file' to retrieve the AST from
    * @return {Object} - AST of the current file
    */


  ast(sourceLocation, generatedSources) {
    const file = this.fileNameFromIndex(sourceLocation.file);

    if (!file && generatedSources && generatedSources.length) {
      for (const source of generatedSources) {
        if (source.id === sourceLocation.file) return source.ast;
      }
    } else if (this.sources[file]) {
      return this.sources[file].ast;
    }

    return null;
  }
  /**
   * get the filename refering to the index from the compilation result
   *
   * @param {Int} index  - index of the filename
   * @return {String} - filename
   */


  fileNameFromIndex(index) {
    return Object.keys(this.contracts)[index];
  }

}

exports.SolidityProxy = SolidityProxy;

function contractObjectFromCode(contracts, code, address) {
  const isCreation = (0, traceHelper_1.isContractCreation)(address);

  for (const file in contracts) {
    for (const contract in contracts[file]) {
      const bytecode = isCreation ? contracts[file][contract].evm.bytecode.object : contracts[file][contract].evm.deployedBytecode.object;

      if (remix_lib_1.util.compareByteCode(code, '0x' + bytecode)) {
        return {
          name: contract,
          contract: contracts[file][contract]
        };
      }
    }
  }

  return null;
}

class Cache {
  constructor() {
    this.reset();
  }

  reset() {
    this.contractObjectByAddress = {};
    this.stateVariablesByContractName = {};
    this.contractDeclarations = null;
    this.statesDefinitions = null;
  }

}

/***/ }),
/* 2180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Address = void 0;

const util_1 = __webpack_require__(1143);

const ValueType_1 = __webpack_require__(1181);

class Address extends ValueType_1.ValueType {
  constructor() {
    super(1, 20, 'address');
  }

  decodeValue(value) {
    if (!value) {
      return '0x0000000000000000000000000000000000000000';
    }

    return '0x' + (0, util_1.extractHexByteSlice)(value, this.storageBytes, 0).toUpperCase();
  }

}

exports.Address = Address;

/***/ }),
/* 2181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayType = void 0;

const tslib_1 = __webpack_require__(23);

const util_1 = __webpack_require__(1143);

const remix_lib_1 = __webpack_require__(311);

const ethereumjs_util_1 = __webpack_require__(34);

const RefType_1 = __webpack_require__(1254);

const sha3256 = remix_lib_1.util.sha3_256;

class ArrayType extends RefType_1.RefType {
  constructor(underlyingType, arraySize, location) {
    let storageSlots = null;

    if (arraySize === 'dynamic') {
      storageSlots = 1;
    } else {
      if (underlyingType.storageBytes < 32) {
        const itemPerSlot = Math.floor(32 / underlyingType.storageBytes);
        storageSlots = Math.ceil(arraySize / itemPerSlot);
      } else {
        storageSlots = arraySize * underlyingType.storageSlots;
      }
    }

    const size = arraySize !== 'dynamic' ? arraySize : '';
    super(storageSlots, 32, underlyingType.typeName + '[' + size + ']', location);
    this.underlyingType = underlyingType;
    this.arraySize = arraySize;
  }

  decodeFromStorage(location, storageResolver) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const ret = [];
      let size = null;
      let slotValue;

      try {
        slotValue = yield (0, util_1.extractHexValue)(location, storageResolver, this.storageBytes);
      } catch (e) {
        console.log(e);
        return {
          error: '<decoding failed - ' + e.message + '>',
          type: this.typeName
        };
      }

      const currentLocation = {
        offset: 0,
        slot: location.slot
      };

      if (this.arraySize === 'dynamic') {
        size = (0, util_1.toBN)('0x' + slotValue);
        currentLocation.slot = sha3256(location.slot);
      } else {
        size = new ethereumjs_util_1.BN(this.arraySize);
      }

      const k = (0, util_1.toBN)(0);

      for (; k.lt(size) && k.ltn(300); k.iaddn(1)) {
        try {
          ret.push(yield this.underlyingType.decodeFromStorage(currentLocation, storageResolver));
        } catch (e) {
          return {
            error: '<decoding failed - ' + e.message + '>',
            type: this.typeName
          };
        }

        if (this.underlyingType.storageSlots === 1 && location.offset + this.underlyingType.storageBytes <= 32) {
          currentLocation.offset += this.underlyingType.storageBytes;

          if (currentLocation.offset + this.underlyingType.storageBytes > 32) {
            currentLocation.offset = 0;
            currentLocation.slot = '0x' + (0, util_1.add)(currentLocation.slot, 1).toString(16);
          }
        } else {
          currentLocation.slot = '0x' + (0, util_1.add)(currentLocation.slot, this.underlyingType.storageSlots).toString(16);
          currentLocation.offset = 0;
        }
      }

      return {
        value: ret,
        length: '0x' + size.toString(16),
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory, skip) {
    const ret = [];
    let length = this.arraySize;

    if (this.arraySize === 'dynamic') {
      length = memory.substr(2 * offset, 64);
      length = parseInt(length, 16);
      offset = offset + 32;
    }

    if (isNaN(length)) {
      return {
        error: '<decoding failed - length is NaN>',
        type: 'Error'
      };
    }

    if (!skip) skip = 0;
    if (skip) offset = offset + 32 * skip;
    let limit = length - skip;
    if (limit > 10) limit = 10;

    for (let k = 0; k < limit; k++) {
      const contentOffset = offset;
      ret.push(this.underlyingType.decodeFromMemory(contentOffset, memory));
      offset += 32;
    }

    return {
      value: ret,
      length: '0x' + length.toString(16),
      type: this.typeName,
      cursor: skip + limit,
      hasNext: length > skip + limit
    };
  }

}

exports.ArrayType = ArrayType;

/***/ }),
/* 2182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bool = void 0;

const ValueType_1 = __webpack_require__(1181);

const util_1 = __webpack_require__(1143);

class Bool extends ValueType_1.ValueType {
  constructor() {
    super(1, 1, 'bool');
  }

  decodeValue(value) {
    if (!value) {
      return false;
    }

    value = (0, util_1.extractHexByteSlice)(value, this.storageBytes, 0);
    return value !== '00';
  }

}

exports.Bool = Bool;

/***/ }),
/* 2183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixedByteArray = void 0;

const ValueType_1 = __webpack_require__(1181);

class FixedByteArray extends ValueType_1.ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'bytes' + storageBytes);
  }

  decodeValue(value) {
    return '0x' + value.substr(0, 2 * this.storageBytes).toUpperCase();
  }

}

exports.FixedByteArray = FixedByteArray;

/***/ }),
/* 2184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Enum = void 0;

const ValueType_1 = __webpack_require__(1181);

class Enum extends ValueType_1.ValueType {
  constructor(enumDef) {
    let storageBytes = 0;
    let length = enumDef.members.length;

    while (length > 1) {
      length = length / 256;
      storageBytes++;
    }

    super(1, storageBytes, 'enum');
    this.enumDef = enumDef;
  }

  decodeValue(value) {
    if (!value) {
      return this.enumDef.members[0].name;
    }

    value = parseInt(value, 16);

    if (this.enumDef.members.length > value) {
      return this.enumDef.members[value].name;
    }

    return 'INVALID_ENUM<' + value + '>';
  }

}

exports.Enum = Enum;

/***/ }),
/* 2185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringType = void 0;

const tslib_1 = __webpack_require__(23);

const DynamicByteArray_1 = __webpack_require__(1516);

class StringType extends DynamicByteArray_1.DynamicByteArray {
  constructor(location) {
    super(location);
    this.typeName = 'string';
  }

  decodeFromStorage(location, storageResolver) {
    const _super = Object.create(null, {
      decodeFromStorage: {
        get: () => super.decodeFromStorage
      }
    });

    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      let decoded = '0x';

      try {
        decoded = yield _super.decodeFromStorage.call(this, location, storageResolver);
      } catch (e) {
        console.log(e);
        return {
          error: '<decoding failed - ' + e.message + '>'
        };
      }

      return format(decoded);
    });
  }

  decodeFromStack(stackDepth, stack, memory, storageResolver, calldata, cursor, variableDetails) {
    const _super = Object.create(null, {
      decodeFromStack: {
        get: () => super.decodeFromStack
      }
    });

    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        return yield _super.decodeFromStack.call(this, stackDepth, stack, memory, storageResolver, calldata, cursor, variableDetails);
      } catch (e) {
        console.log(e);
        return {
          error: '<decoding failed - ' + e.message + '>'
        };
      }
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const decoded = super.decodeFromMemoryInternal(offset, memory);
    return format(decoded);
  }

}

exports.StringType = StringType;

function format(decoded) {
  if (decoded.error) {
    return decoded;
  }

  let value = decoded.value;
  value = value.replace('0x', '').replace(/(..)/g, '%$1');
  const ret = {
    length: decoded.length,
    raw: decoded.value,
    type: 'string'
  };

  try {
    ret['value'] = decodeURIComponent(value);
  } catch (e) {
    ret['error'] = 'Invalid UTF8 encoding';
    ret.raw = decoded.value;
  }

  return ret;
}

/***/ }),
/* 2186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Struct = void 0;

const tslib_1 = __webpack_require__(23);

const util_1 = __webpack_require__(1143);

const RefType_1 = __webpack_require__(1254);

const Mapping_1 = __webpack_require__(1517);

class Struct extends RefType_1.RefType {
  constructor(memberDetails, location, fullType) {
    super(memberDetails.storageSlots, 32, 'struct ' + fullType, location);
    this.members = memberDetails.members;
  }

  decodeFromStorage(location, storageResolver) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const ret = {};

      for (const item of this.members) {
        const globalLocation = {
          offset: location.offset + item.storagelocation.offset,
          slot: (0, util_1.add)(location.slot, item.storagelocation.slot)
        };

        try {
          ret[item.name] = yield item.type.decodeFromStorage(globalLocation, storageResolver);
        } catch (e) {
          console.log(e);
          ret[item.name] = {
            error: '<decoding failed - ' + e.message + '>'
          };
        }
      }

      return {
        value: ret,
        type: this.typeName
      };
    });
  }

  decodeFromMemoryInternal(offset, memory) {
    const ret = {};
    this.members.map((item, i) => {
      const contentOffset = offset;
      const member = item.type.decodeFromMemory(contentOffset, memory);
      ret[item.name] = member;
      if (!(item.type instanceof Mapping_1.Mapping)) offset += 32;
    });
    return {
      value: ret,
      type: this.typeName
    };
  }

}

exports.Struct = Struct;

/***/ }),
/* 2187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Int = void 0;

const util_1 = __webpack_require__(1143);

const ValueType_1 = __webpack_require__(1181);

class Int extends ValueType_1.ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'int' + storageBytes * 8);
  }

  decodeValue(value) {
    value = (0, util_1.extractHexByteSlice)(value, this.storageBytes, 0);
    return (0, util_1.decodeIntFromHex)(value, this.storageBytes, true);
  }

}

exports.Int = Int;

/***/ }),
/* 2188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint = void 0;

const util_1 = __webpack_require__(1143);

const ValueType_1 = __webpack_require__(1181);

class Uint extends ValueType_1.ValueType {
  constructor(storageBytes) {
    super(1, storageBytes, 'uint' + storageBytes * 8);
  }

  decodeValue(value) {
    value = (0, util_1.extractHexByteSlice)(value, this.storageBytes, 0);
    return (0, util_1.decodeIntFromHex)(value, this.storageBytes, false);
  }

}

exports.Uint = Uint;

/***/ }),
/* 2189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionType = void 0;

const ValueType_1 = __webpack_require__(1181);

class FunctionType extends ValueType_1.ValueType {
  constructor(type, stateDefinitions, contractName, location) {
    super(1, 8, 'function');
  }

  decodeValue(value) {
    return 'at program counter ' + value;
  }

}

exports.FunctionType = FunctionType;

/***/ }),
/* 2190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalCallTree = void 0;

const tslib_1 = __webpack_require__(23);

const remix_astwalker_1 = __webpack_require__(1180);

const remix_lib_1 = __webpack_require__(311);

const sourceLocationTracker_1 = __webpack_require__(2191);

const eventManager_1 = __webpack_require__(1157);

const decodeInfo_1 = __webpack_require__(1515);

const traceHelper_1 = __webpack_require__(1146);

const util_1 = __webpack_require__(1143);
/**
 * Tree representing internal jump into function.
 * Triggers `callTreeReady` event when tree is ready
 * Triggers `callTreeBuildFailed` event when tree fails to build
 */


class InternalCallTree {
  /**
    * constructor
    *
    * @param {Object} debuggerEvent  - event declared by the debugger (EthDebugger)
    * @param {Object} traceManager  - trace manager
    * @param {Object} solidityProxy  - solidity proxy
    * @param {Object} codeManager  - code manager
    * @param {Object} opts  - { includeLocalVariables, debugWithGeneratedSources }
    */
  constructor(debuggerEvent, traceManager, solidityProxy, codeManager, opts) {
    this.includeLocalVariables = opts.includeLocalVariables;
    this.debugWithGeneratedSources = opts.debugWithGeneratedSources;
    this.event = new eventManager_1.EventManager();
    this.solidityProxy = solidityProxy;
    this.traceManager = traceManager;
    this.sourceLocationTracker = new sourceLocationTracker_1.SourceLocationTracker(codeManager, {
      debugWithGeneratedSources: opts.debugWithGeneratedSources
    });
    debuggerEvent.register('newTraceLoaded', trace => {
      this.reset();

      if (!this.solidityProxy.loaded()) {
        this.event.trigger('callTreeBuildFailed', ['compilation result not loaded. Cannot build internal call tree']);
      } else {
        // each recursive call to buildTree represent a new context (either call, delegatecall, internal function)
        const calledAddress = traceManager.getCurrentCalledAddressAt(0);
        const isCreation = (0, traceHelper_1.isContractCreation)(calledAddress);
        buildTree(this, 0, '', true, isCreation).then(result => {
          if (result.error) {
            this.event.trigger('callTreeBuildFailed', [result.error]);
          } else {
            createReducedTrace(this, traceManager.trace.length - 1);
            this.event.trigger('callTreeReady', [this.scopes, this.scopeStarts]);
          }
        }, reason => {
          console.log('analyzing trace falls ' + reason);
          this.event.trigger('callTreeNotReady', [reason]);
        });
      }
    });
  }
  /**
    * reset tree
    *
    */


  reset() {
    /*
      scopes: map of scopes defined by range in the vmtrace {firstStep, lastStep, locals}.
      Keys represent the level of deepness (scopeId)
      scopeId : <currentscope_id>.<sub_scope_id>.<sub_sub_scope_id>
    */
    this.scopes = {};
    /*
      scopeStart: represent start of a new scope. Keys are index in the vmtrace, values are scopeId
    */

    this.sourceLocationTracker.clearCache();
    this.functionCallStack = [];
    this.functionDefinitionsByScope = {};
    this.scopeStarts = {};
    this.variableDeclarationByFile = {};
    this.functionDefinitionByFile = {};
    this.astWalker = new remix_astwalker_1.AstWalker();
    this.reducedTrace = [];
  }
  /**
    * find the scope given @arg vmTraceIndex
    *
    * @param {Int} vmtraceIndex  - index on the vm trace
    */


  findScope(vmtraceIndex) {
    let scopeId = this.findScopeId(vmtraceIndex);
    if (scopeId !== '' && !scopeId) return null;
    let scope = this.scopes[scopeId];

    while (scope.lastStep && scope.lastStep < vmtraceIndex && scope.firstStep > 0) {
      scopeId = this.parentScope(scopeId);
      scope = this.scopes[scopeId];
    }

    return scope;
  }

  parentScope(scopeId) {
    if (scopeId.indexOf('.') === -1) return '';
    return scopeId.replace(/(\.\d+)$/, '');
  }

  findScopeId(vmtraceIndex) {
    const scopes = Object.keys(this.scopeStarts);
    if (!scopes.length) return null;
    const scopeStart = remix_lib_1.util.findLowerBoundValue(vmtraceIndex, scopes);
    return this.scopeStarts[scopeStart];
  }

  retrieveFunctionsStack(vmtraceIndex) {
    const scope = this.findScope(vmtraceIndex);
    if (!scope) return [];
    let scopeId = this.scopeStarts[scope.firstStep];
    const functions = [];
    if (!scopeId) return functions;
    let i = 0; // eslint-disable-next-line no-constant-condition

    while (true) {
      i += 1;
      if (i > 1000) throw new Error('retrieFunctionStack: recursion too deep');
      const functionDefinition = this.functionDefinitionsByScope[scopeId];

      if (functionDefinition !== undefined) {
        functions.push(functionDefinition);
      }

      const parent = this.parentScope(scopeId);
      if (!parent) break;else scopeId = parent;
    }

    return functions;
  }

  extractSourceLocation(step) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const location = yield this.sourceLocationTracker.getSourceLocationFromVMTraceIndex(address, step, this.solidityProxy.contracts);
        return location;
      } catch (error) {
        throw new Error('InternalCallTree - Cannot retrieve sourcelocation for step ' + step + ' ' + error);
      }
    });
  }

  extractValidSourceLocation(step) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      try {
        const address = this.traceManager.getCurrentCalledAddressAt(step);
        const location = yield this.sourceLocationTracker.getValidSourceLocationFromVMTraceIndex(address, step, this.solidityProxy.contracts);
        return location;
      } catch (error) {
        throw new Error('InternalCallTree - Cannot retrieve valid sourcelocation for step ' + step + ' ' + error);
      }
    });
  }

}

exports.InternalCallTree = InternalCallTree;

function buildTree(tree, step, scopeId, isExternalCall, isCreation) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    let subScope = 1;
    tree.scopeStarts[step] = scopeId;
    tree.scopes[scopeId] = {
      firstStep: step,
      locals: {},
      isCreation
    };

    function callDepthChange(step, trace) {
      if (step + 1 < trace.length) {
        return trace[step].depth !== trace[step + 1].depth;
      }

      return false;
    }

    function includedSource(source, included) {
      return included.start !== -1 && included.length !== -1 && included.file !== -1 && included.start >= source.start && included.start + included.length <= source.start + source.length && included.file === source.file;
    }

    let currentSourceLocation = {
      start: -1,
      length: -1,
      file: -1
    };
    let previousSourceLocation = currentSourceLocation;

    while (step < tree.traceManager.trace.length) {
      let sourceLocation;
      let newLocation = false;

      try {
        sourceLocation = yield tree.extractSourceLocation(step);

        if (!includedSource(sourceLocation, currentSourceLocation)) {
          tree.reducedTrace.push(step);
          currentSourceLocation = sourceLocation;
          newLocation = true;
        }
      } catch (e) {
        return {
          outStep: step,
          error: 'InternalCallTree - Error resolving source location. ' + step + ' ' + e
        };
      }

      if (!sourceLocation) {
        return {
          outStep: step,
          error: 'InternalCallTree - No source Location. ' + step
        };
      }

      const isCallInstrn = (0, traceHelper_1.isCallInstruction)(tree.traceManager.trace[step]);
      const isCreateInstrn = (0, traceHelper_1.isCreateInstruction)(tree.traceManager.trace[step]); // we are checking if we are jumping in a new CALL or in an internal function

      if (isCallInstrn || sourceLocation.jump === 'i') {
        try {
          const externalCallResult = yield buildTree(tree, step + 1, scopeId === '' ? subScope.toString() : scopeId + '.' + subScope, isCallInstrn, isCreateInstrn);

          if (externalCallResult.error) {
            return {
              outStep: step,
              error: 'InternalCallTree - ' + externalCallResult.error
            };
          } else {
            step = externalCallResult.outStep;
            subScope++;
          }
        } catch (e) {
          return {
            outStep: step,
            error: 'InternalCallTree - ' + e.message
          };
        }
      } else if (isExternalCall && callDepthChange(step, tree.traceManager.trace) || !isExternalCall && sourceLocation.jump === 'o') {
        // if not, we might be returning from a CALL or internal function. This is what is checked here.
        tree.scopes[scopeId].lastStep = step;
        return {
          outStep: step + 1
        };
      } else {
        // if not, we are in the current scope.
        // We check in `includeVariableDeclaration` if there is a new local variable in scope for this specific `step`
        if (tree.includeLocalVariables) {
          yield includeVariableDeclaration(tree, step, sourceLocation, scopeId, newLocation, previousSourceLocation);
        }

        previousSourceLocation = sourceLocation;
        step++;
      }
    }

    return {
      outStep: step
    };
  });
} // the reduced trace contain an entry only if that correspond to a new source location


function createReducedTrace(tree, index) {
  tree.reducedTrace.push(index);
}

function getGeneratedSources(tree, scopeId, contractObj) {
  if (tree.debugWithGeneratedSources && contractObj && tree.scopes[scopeId]) {
    return tree.scopes[scopeId].isCreation ? contractObj.contract.evm.bytecode.generatedSources : contractObj.contract.evm.deployedBytecode.generatedSources;
  }

  return null;
}

function includeVariableDeclaration(tree, step, sourceLocation, scopeId, newLocation, previousSourceLocation) {
  return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
    const contractObj = yield tree.solidityProxy.contractObjectAt(step);
    let states = null;
    const generatedSources = getGeneratedSources(tree, scopeId, contractObj);
    const variableDeclarations = resolveVariableDeclaration(tree, sourceLocation, generatedSources); // using the vm trace step, the current source location and the ast,
    // we check if the current vm trace step target a new ast node of type VariableDeclaration
    // that way we know that there is a new local variable from here.

    if (variableDeclarations && variableDeclarations.length) {
      for (const variableDeclaration of variableDeclarations) {
        if (variableDeclaration && !tree.scopes[scopeId].locals[variableDeclaration.name]) {
          try {
            const stack = tree.traceManager.getStackAt(step); // the stack length at this point is where the value of the new local variable will be stored.
            // so, either this is the direct value, or the offset in memory. That depends on the type.

            if (variableDeclaration.name !== '') {
              states = tree.solidityProxy.extractStatesDefinitions();
              let location = (0, util_1.extractLocationFromAstVariable)(variableDeclaration);
              location = location === 'default' ? 'storage' : location; // we push the new local variable in our tree

              tree.scopes[scopeId].locals[variableDeclaration.name] = {
                name: variableDeclaration.name,
                type: (0, decodeInfo_1.parseType)(variableDeclaration.typeDescriptions.typeString, states, contractObj.name, location),
                stackDepth: stack.length,
                sourceLocation: sourceLocation
              };
            }
          } catch (error) {
            console.log(error);
          }
        }
      }
    } // we check here if we are at the beginning inside a new function.
    // if that is the case, we have to add to locals tree the inputs and output params


    const functionDefinition = resolveFunctionDefinition(tree, previousSourceLocation, generatedSources);
    if (!functionDefinition) return;
    const previousIsJumpDest2 = (0, traceHelper_1.isJumpDestInstruction)(tree.traceManager.trace[step - 2]);
    const previousIsJumpDest1 = (0, traceHelper_1.isJumpDestInstruction)(tree.traceManager.trace[step - 1]);
    const isConstructor = functionDefinition.kind === 'constructor';

    if (newLocation && (previousIsJumpDest1 || previousIsJumpDest2 || isConstructor)) {
      tree.functionCallStack.push(step);
      const functionDefinitionAndInputs = {
        functionDefinition,
        inputs: []
      }; // means: the previous location was a function definition && JUMPDEST
      // => we are at the beginning of the function and input/output are setup

      try {
        const stack = tree.traceManager.getStackAt(step);
        states = tree.solidityProxy.extractStatesDefinitions();

        if (functionDefinition.parameters) {
          const inputs = functionDefinition.parameters;
          const outputs = functionDefinition.returnParameters; // for (const element of functionDefinition.parameters) {
          //   if (element.nodeType === 'ParameterList') {
          //     if (!inputs) inputs = element
          //     else {
          //       outputs = element
          //       break
          //     }
          //   }
          // }
          // input params

          if (inputs && inputs.parameters) {
            functionDefinitionAndInputs.inputs = addParams(inputs, tree, scopeId, states, contractObj, previousSourceLocation, stack.length, inputs.parameters.length, -1);
          } // output params


          if (outputs) addParams(outputs, tree, scopeId, states, contractObj, previousSourceLocation, stack.length, 0, 1);
        }
      } catch (error) {
        console.log(error);
      }

      tree.functionDefinitionsByScope[scopeId] = functionDefinitionAndInputs;
    }
  });
} // this extract all the variable declaration for a given ast and file
// and keep this in a cache


function resolveVariableDeclaration(tree, sourceLocation, generatedSources) {
  if (!tree.variableDeclarationByFile[sourceLocation.file]) {
    const ast = tree.solidityProxy.ast(sourceLocation, generatedSources);

    if (ast) {
      tree.variableDeclarationByFile[sourceLocation.file] = extractVariableDeclarations(ast, tree.astWalker);
    } else {
      return null;
    }
  }

  return tree.variableDeclarationByFile[sourceLocation.file][sourceLocation.start + ':' + sourceLocation.length + ':' + sourceLocation.file];
} // this extract all the function definition for a given ast and file
// and keep this in a cache


function resolveFunctionDefinition(tree, sourceLocation, generatedSources) {
  if (!tree.functionDefinitionByFile[sourceLocation.file]) {
    const ast = tree.solidityProxy.ast(sourceLocation, generatedSources);

    if (ast) {
      tree.functionDefinitionByFile[sourceLocation.file] = extractFunctionDefinitions(ast, tree.astWalker);
    } else {
      return null;
    }
  }

  return tree.functionDefinitionByFile[sourceLocation.file][sourceLocation.start + ':' + sourceLocation.length + ':' + sourceLocation.file];
}

function extractVariableDeclarations(ast, astWalker) {
  const ret = {};
  astWalker.walkFull(ast, node => {
    if (node.nodeType === 'VariableDeclaration' || node.nodeType === 'YulVariableDeclaration') {
      ret[node.src] = [node];
    }

    const hasChild = node.initialValue && (node.nodeType === 'VariableDeclarationStatement' || node.nodeType === 'YulVariableDeclarationStatement');
    if (hasChild) ret[node.initialValue.src] = node.declarations;
  });
  return ret;
}

function extractFunctionDefinitions(ast, astWalker) {
  const ret = {};
  astWalker.walkFull(ast, node => {
    if (node.nodeType === 'FunctionDefinition' || node.nodeType === 'YulFunctionDefinition') {
      ret[node.src] = node;
    }
  });
  return ret;
}

function addParams(parameterList, tree, scopeId, states, contractObj, sourceLocation, stackLength, stackPosition, dir) {
  const contractName = contractObj.name;
  const params = [];

  for (const inputParam in parameterList.parameters) {
    const param = parameterList.parameters[inputParam];
    const stackDepth = stackLength + dir * stackPosition;

    if (stackDepth >= 0) {
      let location = (0, util_1.extractLocationFromAstVariable)(param);
      location = location === 'default' ? 'memory' : location;
      const attributesName = param.name === '' ? `$${inputParam}` : param.name;
      tree.scopes[scopeId].locals[attributesName] = {
        name: attributesName,
        type: (0, decodeInfo_1.parseType)(param.typeDescriptions.typeString, states, contractName, location),
        stackDepth: stackDepth,
        sourceLocation: sourceLocation,
        abi: contractObj.contract.abi
      };
      params.push(attributesName);
    }

    stackPosition += dir;
  }

  return params;
}

/***/ }),
/* 2191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SourceLocationTracker = void 0;

const tslib_1 = __webpack_require__(23);

const eventManager_1 = __webpack_require__(1157);

const traceHelper_1 = __webpack_require__(1146);

const sourceMappingDecoder_1 = __webpack_require__(1328);

const remix_lib_1 = __webpack_require__(311);
/**
 * Process the source code location for the current executing bytecode
 */


class SourceLocationTracker {
  constructor(_codeManager, {
    debugWithGeneratedSources
  }) {
    this.opts = {
      debugWithGeneratedSources: debugWithGeneratedSources || false
    };
    this.codeManager = _codeManager;
    this.event = new eventManager_1.EventManager();
    this.sourceMapByAddress = {};
  }
  /**
   * Return the source location associated with the given @arg index (instruction index)
   *
   * @param {String} address - contract address from which the source location is retrieved
   * @param {Int} index - index in the instruction list from where the source location is retrieved
   * @param {Object} contractDetails - AST of compiled contracts
   */


  getSourceLocationFromInstructionIndex(address, index, contracts) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const sourceMap = yield this.extractSourceMap(this, this.codeManager, address, contracts);
      return (0, sourceMappingDecoder_1.atIndex)(index, sourceMap['map']);
    });
  }
  /**
   * Return the source location associated with the given @arg vmTraceIndex
   *
   * @param {String} address - contract address from which the source location is retrieved
   * @param {Int} vmtraceStepIndex - index of the current code in the vmtrace
   * @param {Object} contractDetails - AST of compiled contracts
   */


  getSourceLocationFromVMTraceIndex(address, vmtraceStepIndex, contracts) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const sourceMap = yield this.extractSourceMap(this, this.codeManager, address, contracts);
      const index = this.codeManager.getInstructionIndex(address, vmtraceStepIndex);
      return (0, sourceMappingDecoder_1.atIndex)(index, sourceMap['map']);
    });
  }
  /**
   * Returns the generated sources from a specific @arg address
   *
   * @param {String} address - contract address from which has generated sources
   * @param {Object} generatedSources - Object containing the sourceid, ast and the source code.
   */


  getGeneratedSourcesFromAddress(address) {
    if (!this.opts.debugWithGeneratedSources) return null;
    if (this.sourceMapByAddress[address]) return this.sourceMapByAddress[address].generatedSources;
    return null;
  }
  /**
   * Returns the total amount of sources from a specific @arg address and @arg contracts
   *
   * @param {String} address - contract address from which has generated sources
   * @param {Object} contracts - AST of compiled contracts
   */


  getTotalAmountOfSources(address, contracts) {
    let sourcesLength = Object.keys(contracts).length;
    const generatedSources = this.getGeneratedSourcesFromAddress(address);
    if (generatedSources) sourcesLength = sourcesLength + Object.keys(generatedSources).length;
    return sourcesLength;
  }
  /**
   * Return a valid source location associated with the given @arg vmTraceIndex
   *
   * @param {String} address - contract address from which the source location is retrieved
   * @param {Int} vmtraceStepIndex - index of the current code in the vmtrace
   * @param {Object} contractDetails - AST of compiled contracts
   */


  getValidSourceLocationFromVMTraceIndex(address, vmtraceStepIndex, contracts) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const amountOfSources = this.getTotalAmountOfSources(address, contracts);
      let map = {
        file: -1
      };
      /*
        (map.file === -1) this indicates that it isn't associated with a known source code
        (map.file > amountOfSources - 1) this indicates the current file index exceed the total number of files.
                                                this happens when generated sources should not be considered.
      */

      while (vmtraceStepIndex >= 0 && (map.file === -1 || map.file > amountOfSources - 1)) {
        map = yield this.getSourceLocationFromVMTraceIndex(address, vmtraceStepIndex, contracts);
        vmtraceStepIndex = vmtraceStepIndex - 1;
      }

      return map;
    });
  }

  clearCache() {
    this.sourceMapByAddress = {};
  }

  getSourceMap(address, code, contracts) {
    const isCreation = (0, traceHelper_1.isContractCreation)(address);
    let bytes;

    for (const file in contracts) {
      for (const contract in contracts[file]) {
        const bytecode = contracts[file][contract].evm.bytecode;
        const deployedBytecode = contracts[file][contract].evm.deployedBytecode;
        if (!deployedBytecode) continue;
        bytes = isCreation ? bytecode.object : deployedBytecode.object;

        if (remix_lib_1.util.compareByteCode(code, '0x' + bytes)) {
          const generatedSources = isCreation ? bytecode.generatedSources : deployedBytecode.generatedSources;
          const map = isCreation ? bytecode.sourceMap : deployedBytecode.sourceMap;
          return {
            generatedSources,
            map
          };
        }
      }
    }

    return null;
  }

  extractSourceMap(self, codeManager, address, contracts) {
    return new Promise((resolve, reject) => {
      if (self.sourceMapByAddress[address]) return resolve(self.sourceMapByAddress[address]);
      codeManager.getCode(address).then(result => {
        const sourceMap = this.getSourceMap(address, result.bytecode, contracts);

        if (sourceMap) {
          if (!(0, traceHelper_1.isContractCreation)(address)) self.sourceMapByAddress[address] = sourceMap;
          return resolve(sourceMap);
        }

        reject(new Error('no sourcemap associated with the code ' + address));
      }).catch(reject);
    });
  }

}

exports.SourceLocationTracker = SourceLocationTracker;

/***/ }),
/* 2192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerStepManager = void 0;

const remix_lib_1 = __webpack_require__(311);

const eventManager_1 = __webpack_require__(1157);

class DebuggerStepManager {
  constructor(_debugger, traceManager) {
    this.event = new eventManager_1.EventManager();
    this.debugger = _debugger;
    this.traceManager = traceManager;
    this.currentStepIndex = 0;
    this.traceLength = 0;
    this.codeTraceLength = 0;
    this.revertionPoint = null;
    this.listenToEvents();
  }

  listenToEvents() {
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.traceManager.getLength((error, newLength) => {
        if (error) {
          return console.log(error);
        }

        if (this.traceLength !== newLength) {
          this.event.trigger('traceLengthChanged', [newLength]);
          this.traceLength = newLength;
          this.codeTraceLength = this.calculateCodeLength();
        }

        this.jumpTo(0);
      });
    });
    this.debugger.callTree.event.register('callTreeReady', () => {
      if (this.debugger.callTree.functionCallStack.length) {
        this.jumpTo(this.debugger.callTree.functionCallStack[0]);
      }
    });
    this.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.currentStepIndex !== index) return;
      this.traceManager.buildCallPath(index).then(callsPath => {
        this.currentCall = callsPath[callsPath.length - 1];

        if (this.currentCall.reverted) {
          const revertedReason = this.currentCall.outofgas ? 'outofgas' : 'reverted';
          this.revertionPoint = this.currentCall.return;
          this.event.trigger('revertWarning', [revertedReason]);
          return;
        }

        for (let k = callsPath.length - 2; k >= 0; k--) {
          const parent = callsPath[k];

          if (parent.reverted) {
            this.revertionPoint = parent.return;
            this.event.trigger('revertWarning', ['parenthasthrown']);
            return;
          }
        }

        this.event.trigger('revertWarning', ['']);
      }).catch(error => {
        console.log(error);
        this.event.trigger('revertWarning', ['']);
      });
    });
  }

  triggerStepChanged(step) {
    this.traceManager.getLength((error, length) => {
      let stepState = 'valid';

      if (error) {
        stepState = 'invalid';
      } else if (step <= 0) {
        stepState = 'initial';
      } else if (step >= length - 1) {
        stepState = 'end';
      }

      const jumpOutDisabled = step === this.traceManager.findStepOut(step);
      this.event.trigger('stepChanged', [step, stepState, jumpOutDisabled]);
    });
  }

  stepIntoBack(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex - 1;
    this.currentStepIndex = step;

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, -1);
    }

    if (!this.traceManager.inRange(step)) {
      return;
    }

    this.triggerStepChanged(step);
  }

  stepIntoForward(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.currentStepIndex + 1;
    this.currentStepIndex = step;

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 1);
    }

    if (!this.traceManager.inRange(step)) {
      return;
    }

    this.triggerStepChanged(step);
  }

  stepOverBack(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.traceManager.findStepOverBack(this.currentStepIndex);

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, -1);
    }

    if (this.currentStepIndex === step) return;
    this.currentStepIndex = step;
    this.triggerStepChanged(step);
  }

  stepOverForward(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    if (this.currentStepIndex >= this.traceLength - 1) return;
    let step = this.currentStepIndex + 1;
    const scope = this.debugger.callTree.findScope(step);

    if (scope && scope.firstStep === step) {
      step = scope.lastStep + 1;
    }

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 1);
    }

    if (this.currentStepIndex === step) return;
    this.currentStepIndex = step;
    this.triggerStepChanged(step);
  }

  jumpOut(solidityMode) {
    if (!this.traceManager.isLoaded()) return;
    let step = this.traceManager.findStepOut(this.currentStepIndex);

    if (solidityMode) {
      step = this.resolveToReducedTrace(step, 0);
    }

    if (this.currentStepIndex === step) return;
    this.currentStepIndex = step;
    this.triggerStepChanged(step);
  }

  jumpTo(step) {
    if (!this.traceManager.inRange(step)) return;
    if (this.currentStepIndex === step) return;
    this.currentStepIndex = step;
    this.triggerStepChanged(step);
  }

  jumpToException() {
    this.jumpTo(this.revertionPoint);
  }

  jumpNextBreakpoint() {
    this.debugger.breakpointManager.jumpNextBreakpoint(this.currentStepIndex, true);
  }

  jumpPreviousBreakpoint() {
    this.debugger.breakpointManager.jumpPreviousBreakpoint(this.currentStepIndex, true);
  }

  calculateFirstStep() {
    const step = this.resolveToReducedTrace(0, 1);
    return this.resolveToReducedTrace(step, 1);
  }

  calculateCodeStepList() {
    let step = 0;
    let steps = [];

    while (step < this.traceLength) {
      const _step = this.resolveToReducedTrace(step, 1);

      if (!_step) break;
      steps.push(_step);
      step += 1;
    }

    steps = steps.filter((item, pos, self) => {
      return steps.indexOf(item) === pos;
    });
    return steps;
  }

  calculateCodeLength() {
    this.calculateCodeStepList().reverse();
    return this.calculateCodeStepList().reverse()[1] || this.traceLength;
  }

  nextStep() {
    return this.resolveToReducedTrace(this.currentStepIndex, 1);
  }

  previousStep() {
    return this.resolveToReducedTrace(this.currentStepIndex, -1);
  }

  resolveToReducedTrace(value, incr) {
    if (!this.debugger.callTree.reducedTrace.length) {
      return value;
    }

    let nextSource = remix_lib_1.util.findClosestIndex(value, this.debugger.callTree.reducedTrace);
    nextSource = nextSource + incr;

    if (nextSource <= 0) {
      nextSource = 0;
    } else if (nextSource > this.debugger.callTree.reducedTrace.length) {
      nextSource = this.debugger.callTree.reducedTrace.length - 1;
    }

    return this.debugger.callTree.reducedTrace[nextSource];
  }

}

exports.DebuggerStepManager = DebuggerStepManager;

/***/ }),
/* 2193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VmDebuggerLogic = void 0;

const tslib_1 = __webpack_require__(23);

const eventManager_1 = __webpack_require__(1157);

const storageResolver_1 = __webpack_require__(1327);

const storageViewer_1 = __webpack_require__(1218);

const remix_lib_1 = __webpack_require__(311);

const solidityState_1 = __webpack_require__(2194);

const solidityLocals_1 = __webpack_require__(2195);

const {
  ui
} = remix_lib_1.helpers;

class VmDebuggerLogic {
  constructor(_debugger, tx, _stepManager, _traceManager, _codeManager, _solidityProxy, _callTree) {
    this.event = new eventManager_1.EventManager();
    this.debugger = _debugger;
    this.stepManager = _stepManager;
    this._traceManager = _traceManager;
    this._codeManager = _codeManager;
    this._solidityProxy = _solidityProxy;
    this._callTree = _callTree;
    this.storageResolver = null;
    this.tx = tx;
    this.debuggerSolidityState = new solidityState_1.DebuggerSolidityState(tx, _stepManager, _traceManager, _codeManager, _solidityProxy);
    this.debuggerSolidityLocals = new solidityLocals_1.DebuggerSolidityLocals(tx, _stepManager, _traceManager, _callTree);
  }

  start() {
    this.listenToEvents();
    this.listenToCodeManagerEvents();
    this.listenToTraceManagerEvents();
    this.listenToFullStorageChanges();
    this.listenToNewChanges();
    this.listenToSolidityStateEvents();
    this.listenToSolidityLocalsEvents();
  }

  listenToEvents() {
    this.debugger.event.register('traceUnloaded', () => {
      this.event.trigger('traceUnloaded');
    });
    this.debugger.event.register('newTraceLoaded', () => {
      this.event.trigger('newTraceLoaded');
    });
  }

  listenToCodeManagerEvents() {
    this._codeManager.event.register('changed', (code, address, index, nextIndexes, returnInstructionIndexes, outOfGasInstructionIndexes) => {
      this.event.trigger('codeManagerChanged', [code, address, index, nextIndexes, returnInstructionIndexes, outOfGasInstructionIndexes]);
    });
  }

  listenToTraceManagerEvents() {
    let triggerStorageUpdateStampId;
    this.event.register('indexChanged', this, index => {
      if (index < 0) return;
      if (this.stepManager.currentStepIndex !== index) return;
      this.event.trigger('indexUpdate', [index]);

      try {
        const calldata = this._traceManager.getCallDataAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerCallDataUpdate', [calldata]);
        }
      } catch (error) {
        this.event.trigger('traceManagerCallDataUpdate', [{}]);
      }

      try {
        const callstack = this._traceManager.getCallStackAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerCallStackUpdate', [callstack]);
        }
      } catch (error) {
        this.event.trigger('traceManagerCallStackUpdate', [{}]);
      }

      try {
        const callstack = this._traceManager.getStackAt(index);

        if (this.stepManager.currentStepIndex === index) {
          this.event.trigger('traceManagerStackUpdate', [callstack]);
        }
      } catch (error) {
        this.event.trigger('traceManagerStackUpdate', [{}]);
      }

      if (triggerStorageUpdateStampId) {
        clearTimeout(triggerStorageUpdateStampId);
        triggerStorageUpdateStampId = null;
      }

      triggerStorageUpdateStampId = setTimeout(() => {
        (() => {
          try {
            this.event.trigger('functionsStackUpdate', [this._callTree.retrieveFunctionsStack(index)]);
          } catch (e) {
            console.log(e);
          }

          try {
            const memory = this._traceManager.getMemoryAt(index);

            if (this.stepManager.currentStepIndex === index) {
              this.event.trigger('traceManagerMemoryUpdate', [ui.formatMemory(memory, 16)]);
            }
          } catch (error) {
            this.event.trigger('traceManagerMemoryUpdate', [{}]);
          }

          try {
            const address = this._traceManager.getCurrentCalledAddressAt(index);

            if (!this.storageResolver) return;
            const storageViewer = new storageViewer_1.StorageViewer({
              stepIndex: this.stepManager.currentStepIndex,
              tx: this.tx,
              address: address
            }, this.storageResolver, this._traceManager);
            storageViewer.storageRange().then(storage => {
              if (this.stepManager.currentStepIndex === index) {
                const header = storageViewer.isComplete(address) ? '[Completely Loaded]' : '[Partially Loaded]';
                this.event.trigger('traceManagerStorageUpdate', [storage, header]);
              }
            }).catch(_error => {
              this.event.trigger('traceManagerStorageUpdate', [{}]);
            });
          } catch (error) {
            this.event.trigger('traceManagerStorageUpdate', [{}]);
          }

          try {
            const returnValue = this._traceManager.getReturnValue(index);

            if (this.stepManager.currentStepIndex === index) {
              this.event.trigger('traceReturnValueUpdate', [[returnValue]]);
            }
          } catch (error) {
            this.event.trigger('traceReturnValueUpdate', [[error]]);
          }
        })();
      }, 1000);

      try {
        const step = this._traceManager.getCurrentStep(index);

        this.event.trigger('traceCurrentStepUpdate', [null, step]);
      } catch (error) {
        this.event.trigger('traceCurrentStepUpdate', [error]);
      }

      try {
        const addmem = this._traceManager.getMemExpand(index);

        this.event.trigger('traceMemExpandUpdate', [null, addmem]);
      } catch (error) {
        this.event.trigger('traceMemExpandUpdate', [error]);
      }

      try {
        const gas = this._traceManager.getStepCost(index);

        this.event.trigger('traceStepCostUpdate', [null, gas]);
      } catch (error) {
        this.event.trigger('traceStepCostUpdate', [error]);
      }

      try {
        const address = this._traceManager.getCurrentCalledAddressAt(index);

        this.event.trigger('traceCurrentCalledAddressAtUpdate', [null, address]);
      } catch (error) {
        this.event.trigger('traceCurrentCalledAddressAtUpdate', [error]);
      }

      try {
        const remaining = this._traceManager.getRemainingGas(index);

        this.event.trigger('traceRemainingGasUpdate', [null, remaining]);
      } catch (error) {
        this.event.trigger('traceRemainingGasUpdate', [error]);
      }
    });
  }

  listenToFullStorageChanges() {
    this.address = [];
    this.traceLength = 0;
    this.debugger.event.register('newTraceLoaded', length => {
      const addresses = this._traceManager.getAddresses();

      this.event.trigger('traceAddressesUpdate', [addresses]);
      this.addresses = addresses;

      this._traceManager.getLength((error, length) => {
        if (error) return;
        this.event.trigger('traceLengthUpdate', [length]);
        this.traceLength = length;
      });
    });
    this.debugger.event.register('indexChanged', this, index => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (index < 0) return;
      if (this.stepManager.currentStepIndex !== index) return;
      if (!this.storageResolver) return; // Clean up storage update

      if (index === this.traceLength - 1) {
        return this.event.trigger('traceStorageUpdate', [{}]);
      }

      const storageJSON = {};

      for (const k in this.addresses) {
        const address = this.addresses[k];
        const storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: address
        }, this.storageResolver, this._traceManager);

        try {
          storageJSON[address] = yield storageViewer.storageRange();
        } catch (e) {
          console.error(e);
        }
      }

      this.event.trigger('traceStorageUpdate', [storageJSON]);
    }));
  }

  listenToNewChanges() {
    this.debugger.event.register('newTraceLoaded', this, () => {
      this.storageResolver = new storageResolver_1.StorageResolver({
        web3: this.debugger.web3
      });
      this.debuggerSolidityState.storageResolver = this.storageResolver;
      this.debuggerSolidityLocals.storageResolver = this.storageResolver;
      this.event.trigger('newTrace', []);
    });
    this.debugger.callTree.event.register('callTreeReady', () => {
      if (this.debugger.callTree.reducedTrace.length) {
        return this.event.trigger('newCallTree', []);
      }
    });
  }

  listenToSolidityStateEvents() {
    this.event.register('indexChanged', this.debuggerSolidityState.init.bind(this.debuggerSolidityState));
    this.debuggerSolidityState.event.register('solidityState', state => {
      this.event.trigger('solidityState', [state]);
    });
    this.debuggerSolidityState.event.register('solidityStateMessage', message => {
      this.event.trigger('solidityStateMessage', [message]);
    });
    this.debuggerSolidityState.event.register('solidityStateUpdating', () => {
      this.event.trigger('solidityStateUpdating', []);
    });
    this.event.register('traceUnloaded', this.debuggerSolidityState.reset.bind(this.debuggerSolidityState));
    this.event.register('newTraceLoaded', this.debuggerSolidityState.reset.bind(this.debuggerSolidityState));
  }

  listenToSolidityLocalsEvents() {
    this.event.register('sourceLocationChanged', this.debuggerSolidityLocals.init.bind(this.debuggerSolidityLocals));
    this.event.register('solidityLocalsLoadMore', this.debuggerSolidityLocals.decodeMore.bind(this.debuggerSolidityLocals));
    this.debuggerSolidityLocals.event.register('solidityLocalsLoadMoreCompleted', locals => {
      this.event.trigger('solidityLocalsLoadMoreCompleted', [locals]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocals', state => {
      this.event.trigger('solidityLocals', [state]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocalsMessage', message => {
      this.event.trigger('solidityLocalsMessage', [message]);
    });
    this.debuggerSolidityLocals.event.register('solidityLocalsUpdating', () => {
      this.event.trigger('solidityLocalsUpdating', []);
    });
    this.debuggerSolidityLocals.event.register('traceReturnValueUpdate', (data, header) => {
      this.event.trigger('traceReturnValueUpdate', [data, header]);
    });
  }

}

exports.VmDebuggerLogic = VmDebuggerLogic;

/***/ }),
/* 2194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerSolidityState = void 0;

const eventManager_1 = __webpack_require__(1157);

const stateDecoder_1 = __webpack_require__(1331);

const storageViewer_1 = __webpack_require__(1218);

class DebuggerSolidityState {
  constructor(tx, _stepManager, _traceManager, _codeManager, _solidityProxy) {
    this.event = new eventManager_1.EventManager();
    this.storageResolver = null;
    this.stepManager = _stepManager;
    this.traceManager = _traceManager;
    this.codeManager = _codeManager;
    this.solidityProxy = _solidityProxy;
    this.stateVariablesByAddresses = {};
    this.tx = tx;
    this.decodeTimeout = null;
  }

  init(index) {
    if (index < 0) {
      return this.event.trigger('solidityStateMessage', ['invalid step index']);
    }

    if (this.stepManager.currentStepIndex !== index) return;

    if (!this.solidityProxy.loaded()) {
      return this.event.trigger('solidityStateMessage', ['invalid step index']);
    }

    if (!this.storageResolver) {
      return;
    }

    if (this.decodeTimeout) {
      window.clearTimeout(this.decodeTimeout);
    }

    this.event.trigger('solidityStateUpdating');
    this.decodeTimeout = setTimeout(() => {
      // necessary due to some states that can crash the debugger
      try {
        this.decode(index);
      } catch (err) {
        console.dir(err);
      }
    }, 1000);
  }

  reset() {
    this.stateVariablesByAddresses = {};
  }

  decode(index) {
    try {
      const address = this.traceManager.getCurrentCalledAddressAt(this.stepManager.currentStepIndex);

      if (this.stateVariablesByAddresses[address]) {
        return this.extractStateVariables(this.stateVariablesByAddresses[address], address);
      }

      this.solidityProxy.extractStateVariablesAt(index).then(stateVars => {
        this.stateVariablesByAddresses[address] = stateVars;
        this.extractStateVariables(stateVars, address);
      }).catch(_error => {
        this.event.trigger('solidityState', [{}]);
      });
    } catch (error) {
      return this.event.trigger('solidityState', [{}]);
    }
  }

  extractStateVariables(stateVars, address) {
    const storageViewer = new storageViewer_1.StorageViewer({
      stepIndex: this.stepManager.currentStepIndex,
      tx: this.tx,
      address: address
    }, this.storageResolver, this.traceManager);
    (0, stateDecoder_1.decodeState)(stateVars, storageViewer).then(result => {
      this.event.trigger('solidityStateMessage', ['']);

      if (result['error']) {
        return this.event.trigger('solidityStateMessage', [result['error']]);
      }

      this.event.trigger('solidityState', [result]);
    });
  }

}

exports.DebuggerSolidityState = DebuggerSolidityState;

/***/ }),
/* 2195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerSolidityLocals = void 0;

const eventManager_1 = __webpack_require__(1157);

const localDecoder_1 = __webpack_require__(1518);

const storageViewer_1 = __webpack_require__(1218);

class DebuggerSolidityLocals {
  constructor(tx, _stepManager, _traceManager, _internalTreeCall) {
    this.event = new eventManager_1.EventManager();
    this.stepManager = _stepManager;
    this.internalTreeCall = _internalTreeCall;
    this.storageResolver = null;
    this.traceManager = _traceManager;
    this.tx = tx;
    this.decodeTimeout = null;
  }

  init(sourceLocation) {
    this._sourceLocation = sourceLocation;

    if (!this.storageResolver) {
      return this.event.trigger('solidityLocalsMessage', ['storage not ready']);
    }

    if (this.decodeTimeout) {
      window.clearTimeout(this.decodeTimeout);
    }

    this.event.trigger('solidityLocalsUpdating');
    this.decodeTimeout = setTimeout(() => {
      this.decode(sourceLocation);
    }, 1000);
  }

  decode(sourceLocation, cursor) {
    const self = this;
    this.event.trigger('solidityLocalsMessage', ['']);
    this.traceManager.waterfall([function getStackAt(stepIndex, callback) {
      try {
        const result = self.traceManager.getStackAt(stepIndex);
        callback(null, result);
      } catch (error) {
        callback(error);
      }
    }, function getMemoryAt(stepIndex, callback) {
      try {
        const result = self.traceManager.getMemoryAt(stepIndex);
        callback(null, result);
      } catch (error) {
        callback(error);
      }
    }, function getCurrentCalledAddressAt(stepIndex, next) {
      try {
        const address = self.traceManager.getCurrentCalledAddressAt(stepIndex);
        next(null, address);
      } catch (error) {
        next(error);
      }
    }, function getCallDataAt(stepIndex, next) {
      try {
        const calldata = self.traceManager.getCallDataAt(stepIndex);
        next(null, calldata);
      } catch (error) {
        next(error);
      }
    }], this.stepManager.currentStepIndex, (error, result) => {
      if (error) {
        return error;
      }

      const stack = result[0].value;
      const memory = result[1].value;
      const calldata = result[3].value;

      try {
        const storageViewer = new storageViewer_1.StorageViewer({
          stepIndex: this.stepManager.currentStepIndex,
          tx: this.tx,
          address: result[2].value
        }, this.storageResolver, this.traceManager);
        (0, localDecoder_1.solidityLocals)(this.stepManager.currentStepIndex, this.internalTreeCall, stack, memory, storageViewer, calldata, sourceLocation, cursor).then(locals => {
          if (!cursor) {
            if (!locals['error']) {
              this.event.trigger('solidityLocals', [locals]);
            }

            if (!Object.keys(locals).length) {
              this.event.trigger('solidityLocalsMessage', ['no locals']);
            }
          } else {
            if (!locals['error']) {
              this.event.trigger('solidityLocalsLoadMoreCompleted', [locals]);
            }
          }
        });
      } catch (e) {
        this.event.trigger('solidityLocalsMessage', [e.message]);
      }
    });
  }

  decodeMore(cursor) {
    let decodeTimeout = null;
    if (!this.storageResolver) return this.event.trigger('solidityLocalsMessage', ['storage not ready']);
    if (decodeTimeout) window.clearTimeout(decodeTimeout);
    decodeTimeout = setTimeout(() => {
      this.decode(this._sourceLocation, cursor);
    }, 500);
  }

}

exports.DebuggerSolidityLocals = DebuggerSolidityLocals;

/***/ }),
/* 2196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CmdLine = void 0;

const tslib_1 = __webpack_require__(23);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

const debugger_js_1 = __webpack_require__(1519);

const events_1 = __webpack_require__(40);

class CmdLine {
  constructor() {
    this.events = new events_1.EventEmitter();
    this.lineColumnPos = null;
    this.rawLocation = null;
  }

  connect(providerType, url) {
    if (providerType !== 'http') throw new Error('unsupported provider type');
    this.web3 = new web3_1.default(new web3_1.default.providers.HttpProvider(url));
  }

  loadCompilationData(inputJson, outputJson) {
    const data = {};
    data['data'] = outputJson;
    data['source'] = {
      sources: inputJson.sources
    };
    this.loadCompilationResult(data);
  }

  loadCompilationResult(compilationResult) {
    this.compilation = {};
    this.compilation.compilationResult = compilationResult;
  }

  initDebugger(cb) {
    this.debugger = new debugger_js_1.Debugger({
      web3: this.web3,
      compilationResult: () => {
        return this.compilation.compilationResult;
      }
    });
  }

  getSource() {
    const lineColumnPos = this.lineColumnPos;
    if (!lineColumnPos || !lineColumnPos.start) return [];
    const content = this.compilation.compilationResult.source.sources[this.filename].content.split('\n');
    const source = [];
    let line;
    line = content[lineColumnPos.start.line - 2];

    if (line !== undefined) {
      source.push('    ' + (lineColumnPos.start.line - 1) + ':  ' + line);
    }

    line = content[lineColumnPos.start.line - 1];

    if (line !== undefined) {
      source.push('    ' + lineColumnPos.start.line + ':  ' + line);
    }

    const currentLineNumber = lineColumnPos.start.line;
    const currentLine = content[currentLineNumber];
    source.push('=>  ' + (currentLineNumber + 1) + ':  ' + currentLine);
    const startLine = lineColumnPos.start.line;

    for (let i = 1; i < 4; i++) {
      const line = content[startLine + i];
      source.push('    ' + (startLine + i + 1) + ':  ' + line);
    }

    return source;
  }

  getCurrentLine() {
    const lineColumnPos = this.lineColumnPos;
    if (!lineColumnPos) return '';
    const currentLineNumber = lineColumnPos.start.line;
    const content = this.compilation.compilationResult.source.sources[this.filename].content.split('\n');
    return content[currentLineNumber];
  }

  startDebug(txNumber, filename, cb) {
    this.filename = filename;
    this.txHash = txNumber;
    this.debugger.debug(null, txNumber, null, () => {
      this.debugger.event.register('newSourceLocation', (lineColumnPos, rawLocation) => {
        if (!lineColumnPos) return;
        this.lineColumnPos = lineColumnPos;
        this.rawLocation = rawLocation;
        this.events.emit('source', [lineColumnPos, rawLocation]);
      });
      this.debugger.vmDebuggerLogic.event.register('solidityState', data => {
        this.solidityState = data;
        this.events.emit('globals', data);
      }); // TODO: this doesnt work too well, it should request the data instead...

      this.debugger.vmDebuggerLogic.event.register('solidityLocals', data => {
        if (JSON.stringify(data) === '{}') return;
        this.solidityLocals = data;
        this.events.emit('locals', data);
      });

      if (cb) {
        // TODO: this should be an onReady event
        setTimeout(cb, 1000);
      }
    });
  }

  getVars() {
    return {
      locals: this.solidityLocals,
      contract: this.solidityState
    };
  }

  triggerSourceUpdate() {
    this.events.emit('source', [this.lineColumnPos, this.rawLocation]);
  }

  stepJumpNextBreakpoint() {
    this.debugger.step_manager.jumpNextBreakpoint();
  }

  stepJumpPreviousBreakpoint() {
    this.debugger.step_manager.jumpPreviousBreakpoint();
  }

  stepOverForward(solidityMode) {
    this.debugger.step_manager.stepOverForward(solidityMode);
  }

  stepOverBack(solidityMode) {
    this.debugger.step_manager.stepOverBack(solidityMode);
  }

  stepIntoForward(solidityMode) {
    this.debugger.step_manager.stepIntoForward(solidityMode);
  }

  stepIntoBack(solidityMode) {
    this.debugger.step_manager.stepIntoBack(solidityMode);
  }

  jumpTo(step) {
    this.debugger.step_manager.jumpTo(step);
  }

  getTraceLength() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.traceLength;
  }

  getCodeFirstStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.calculateFirstStep();
  }

  getCodeTraceLength() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.calculateCodeLength();
  }

  nextStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.nextStep();
  }

  previousStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.previousStep();
  }

  currentStep() {
    if (!this.debugger.step_manager) return 0;
    return this.debugger.step_manager.currentStepIndex;
  }

  canGoNext() {
    return this.currentStep() < this.getCodeTraceLength();
  }

  canGoPrevious() {
    return this.currentStep() > this.getCodeFirstStep();
  }

  unload() {
    return this.debugger.unload();
  }

  displayLocals() {
    console.dir('= displayLocals');
    console.dir(this.solidityLocals);
  }

  displayGlobals() {
    console.dir('= displayGlobals');
    console.dir(this.solidityState);
  }

}

exports.CmdLine = CmdLine;

/***/ }),
/* 2197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerMetadata = void 0;

var _engine = __webpack_require__(477);

var _remixSolidity = __webpack_require__(1149);

var _crypto = __webpack_require__(480);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const profile = {
  name: 'compilerMetadata',
  methods: ['deployMetadataOf'],
  events: [],
  version: '0.0.1'
};

class CompilerMetadata extends _engine.Plugin {
  constructor() {
    super(profile);

    _defineProperty(this, "networks", void 0);

    _defineProperty(this, "innerPath", void 0);

    this.networks = ['VM:-', 'main:1', 'ropsten:3', 'rinkeby:4', 'kovan:42', 'görli:5', 'Custom'];
    this.innerPath = 'artifacts';
  }

  _JSONFileName(path, contractName) {
    return this.joinPath(path, this.innerPath, contractName + '.json');
  }

  _MetadataFileName(path, contractName) {
    return this.joinPath(path, this.innerPath, contractName + '_metadata.json');
  }

  onActivation() {
    const self = this;
    this.on('solidity', 'compilationFinished', async (file, source, languageVersion, data, input, version) => {
      if (!(await this.call('settings', 'get', 'settings/generate-contract-metadata'))) return;
      const compiler = new _remixSolidity.CompilerAbstract(languageVersion, data, source, input);

      const path = self._extractPathOf(source.target);

      await this.setBuildInfo(version, input, data, path);
      compiler.visitContracts(contract => {
        if (contract.file !== source.target) return;

        (async () => {
          const fileName = self._JSONFileName(path, contract.name);

          const content = (await this.call('fileManager', 'exists', fileName)) ? await this.call('fileManager', 'readFile', fileName) : null;
          await this._setArtefacts(content, contract, path);
        })();
      });
    });
  }

  async setBuildInfo(version, input, output, path) {
    input = JSON.parse(input);
    const solcLongVersion = version.replace('.Emscripten.clang', '');
    const solcVersion = solcLongVersion.substring(0, solcLongVersion.indexOf('+commit'));
    const format = 'hh-sol-build-info-1';
    const json = JSON.stringify({
      _format: format,
      solcVersion,
      solcLongVersion,
      input
    });
    const id = (0, _crypto.createHash)('md5').update(Buffer.from(json)).digest().toString('hex');
    const buildFilename = this.joinPath(path, this.innerPath, 'build-info/' + id + '.json');
    const buildData = {
      id,
      _format: format,
      solcVersion,
      solcLongVersion,
      input,
      output
    };
    await this.call('fileManager', 'writeFile', buildFilename, JSON.stringify(buildData, null, '\t'));
  }

  _extractPathOf(file) {
    const reg = /(.*)(\/).*/;
    const path = reg.exec(file);
    return path ? path[1] : '/';
  }

  async _setArtefacts(content, contract, path) {
    content = content || '{}';

    const fileName = this._JSONFileName(path, contract.name);

    const metadataFileName = this._MetadataFileName(path, contract.name);

    let metadata;

    try {
      metadata = JSON.parse(content);
    } catch (e) {
      console.log(e);
    }

    const deploy = metadata.deploy || {};
    this.networks.forEach(network => {
      deploy[network] = this._syncContext(contract, deploy[network] || {});
    });
    let parsedMetadata;

    try {
      parsedMetadata = contract.object && contract.object.metadata ? JSON.parse(contract.object.metadata) : null;
    } catch (e) {
      console.log(e);
    }

    if (parsedMetadata) await this.call('fileManager', 'writeFile', metadataFileName, JSON.stringify(parsedMetadata, null, '\t'));
    const data = {
      deploy,
      data: {
        bytecode: contract.object.evm.bytecode,
        deployedBytecode: contract.object.evm.deployedBytecode,
        gasEstimates: contract.object.evm.gasEstimates,
        methodIdentifiers: contract.object.evm.methodIdentifiers
      },
      abi: contract.object.abi
    };
    await this.call('fileManager', 'writeFile', fileName, JSON.stringify(data, null, '\t'));
    this.emit('artefactsUpdated', fileName, contract);
  }

  _syncContext(contract, metadata) {
    let linkReferences = metadata.linkReferences;
    let autoDeployLib = metadata.autoDeployLib;
    if (!linkReferences) linkReferences = {};
    if (autoDeployLib === undefined) autoDeployLib = true;

    for (const libFile in contract.object.evm.bytecode.linkReferences) {
      if (!linkReferences[libFile]) linkReferences[libFile] = {};

      for (const lib in contract.object.evm.bytecode.linkReferences[libFile]) {
        if (!linkReferences[libFile][lib]) {
          linkReferences[libFile][lib] = '<address>';
        }
      }
    }

    metadata.linkReferences = linkReferences;
    metadata.autoDeployLib = autoDeployLib;
    return metadata;
  }

  async deployMetadataOf(contractName, fileLocation) {
    let path;

    if (fileLocation) {
      path = fileLocation.split('/');
      path.pop();
      path = path.join('/');
    } else {
      try {
        path = this._extractPathOf(await this.call('fileManager', 'getCurrentFile'));
      } catch (err) {
        console.log(err);
        throw new Error(err);
      }
    }

    try {
      const {
        id,
        name
      } = await this.call('network', 'detectNetwork');

      const fileName = this._JSONFileName(path, contractName);

      try {
        const content = await this.call('fileManager', 'readFile', fileName);
        if (!content) return null;
        let metadata = JSON.parse(content);
        metadata = metadata.deploy || {};
        return metadata[name + ':' + id] || metadata[name] || metadata[id] || metadata[name.toLowerCase() + ':' + id] || metadata[name.toLowerCase()];
      } catch (err) {
        return null;
      }
    } catch (err) {
      console.log(err);
      throw new Error(err);
    }
  }

  joinPath(...paths) {
    paths = paths.filter(value => value !== '').map(path => path.replace(/^\/|\/$/g, '')); // remove first and last slash)

    if (paths.length === 1) return paths[0];
    return paths.join('/');
  }

}

exports.CompilerMetadata = CompilerMetadata;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchAndCompile = void 0;

var _engine = __webpack_require__(477);

var _remixSolidity = __webpack_require__(1149);

var _remixLib = __webpack_require__(311);

var _ethereumjsUtil = __webpack_require__(34);

var _fetchEtherscan = __webpack_require__(1521);

var _fetchSourcify = __webpack_require__(2199);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const profile = {
  name: 'fetchAndCompile',
  methods: ['resolve', 'clearCache'],
  version: '0.0.1'
};

class FetchAndCompile extends _engine.Plugin {
  constructor() {
    super(profile);

    _defineProperty(this, "unresolvedAddresses", void 0);

    _defineProperty(this, "sourceVerifierNetWork", void 0);

    this.unresolvedAddresses = [];
    this.sourceVerifierNetWork = ['Main', 'Rinkeby', 'Ropsten', 'Goerli'];
  }
  /**
   * Clear the cache
   *
   */


  async clearCache() {
    this.unresolvedAddresses = [];
  }
  /**
   * Fetch compiliation metadata from source-Verify from a given @arg contractAddress - https://github.com/ethereum/source-verify
   * Put the artifacts in the file explorer
   * Compile the code using Solidity compiler
   * Returns compilation data
   *
   * @param {string} contractAddress - Address of the contrac to resolve
   * @param {string} deployedBytecode - deployedBytecode of the contract
   * @param {string} targetPath - Folder where to save the compilation arfefacts
   * @return {CompilerAbstract} - compilation data targeting the given @arg contractAddress
   */


  async resolve(contractAddress, codeAtAddress, targetPath) {
    contractAddress = (0, _ethereumjsUtil.toChecksumAddress)(contractAddress);

    const localCompilation = async () => (await this.call('compilerArtefacts', 'get', contractAddress)) ? await this.call('compilerArtefacts', 'get', contractAddress) : (await this.call('compilerArtefacts', 'get', '__last')) ? await this.call('compilerArtefacts', 'get', '__last') : null;

    const resolved = await this.call('compilerArtefacts', 'get', contractAddress);
    if (resolved) return resolved;
    if (this.unresolvedAddresses.includes(contractAddress)) return localCompilation(); // sometimes when doing an internal call, the only available artifact is the Solidity interface.
    // resolving addresses of internal call would allow to step over the source code, even if the declaration was made using an Interface.

    let network;

    try {
      network = await this.call('network', 'detectNetwork');
    } catch (e) {
      return localCompilation();
    }

    if (!network) return localCompilation();
    if (!this.sourceVerifierNetWork.includes(network.name)) return localCompilation(); // check if the contract if part of the local compilation result

    const compilation = await localCompilation();

    if (compilation) {
      let found = false;
      compilation.visitContracts(contract => {
        found = _remixLib.util.compareByteCode('0x' + contract.object.evm.deployedBytecode.object, codeAtAddress);
        return found;
      });

      if (found) {
        await this.call('compilerArtefacts', 'addResolvedContract', contractAddress, compilation);
        setTimeout(_ => this.emit('usingLocalCompilation', contractAddress), 0);
        return compilation;
      }
    }

    targetPath = `${targetPath}/${network.id}/${contractAddress}`;
    let data;

    try {
      data = await (0, _fetchSourcify.fetchContractFromSourcify)(this, network, contractAddress, targetPath);
    } catch (e) {
      this.call('notification', 'toast', e.message);
      console.log(e); // and fallback to getting the compilation result from etherscan
    }

    if (!data) {
      this.call('notification', 'toast', `contract ${contractAddress} not found in Sourcify, checking in Etherscan..`);

      try {
        data = await (0, _fetchEtherscan.fetchContractFromEtherscan)(this, network, contractAddress, targetPath);
      } catch (e) {
        this.call('notification', 'toast', e.message);
        setTimeout(_ => this.emit('notFound', contractAddress), 0); // plugin framework returns a time out error although it actually didn't find the source...

        this.unresolvedAddresses.push(contractAddress);
        return localCompilation();
      }
    }

    if (!data) {
      setTimeout(_ => this.emit('notFound', contractAddress), 0);
      this.unresolvedAddresses.push(contractAddress);
      return localCompilation();
    }

    const {
      settings,
      compilationTargets
    } = data;

    try {
      setTimeout(_ => this.emit('compiling', settings), 0);
      const compData = await (0, _remixSolidity.compile)(compilationTargets, settings, async (url, cb) => {
        // we first try to resolve the content from the compilation target using a more appropiate path
        const path = `${targetPath}/${url}`;

        if (compilationTargets[path] && compilationTargets[path].content) {
          return cb(null, compilationTargets[path].content);
        } else {
          await this.call('contentImport', 'resolveAndSave', url).then(result => cb(null, result)).catch(error => cb(error.message));
        }
      });
      await this.call('compilerArtefacts', 'addResolvedContract', contractAddress, compData);
      return compData;
    } catch (e) {
      this.unresolvedAddresses.push(contractAddress);
      setTimeout(_ => this.emit('compilationFailed'), 0);
      return localCompilation();
    }
  }

}

exports.FetchAndCompile = FetchAndCompile;

/***/ }),
/* 2199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchContractFromSourcify = void 0;

const fetchContractFromSourcify = async (plugin, network, contractAddress, targetPath) => {
  let data;
  const compilationTargets = {};

  try {
    data = await plugin.call('sourcify', 'fetchByNetwork', contractAddress, network.id);
  } catch (e) {
    console.log(e);
  }

  if (!data || !data.metadata) {
    return null;
  } // set the solidity contract code using metadata


  await plugin.call('fileManager', 'setFile', `${targetPath}/metadata.json`, JSON.stringify(data.metadata, null, '\t'));

  for (let file in data.metadata.sources) {
    const urls = data.metadata.sources[file].urls;

    for (const url of urls) {
      if (url.includes('ipfs')) {
        const stdUrl = `ipfs://${url.split('/')[2]}`;
        const source = await plugin.call('contentImport', 'resolve', stdUrl);
        file = file.replace('browser/', ''); // should be fixed in the remix IDE end.

        if (await plugin.call('contentImport', 'isExternalUrl', file)) {// nothing to do, the compiler callback will handle those
        } else {
          const path = `${targetPath}/${file}`;
          await plugin.call('fileManager', 'setFile', path, source.content);
          compilationTargets[path] = {
            content: source.content
          };
        }

        break;
      }
    }
  }

  const settings = {
    version: data.metadata.compiler.version,
    language: data.metadata.language,
    evmVersion: data.metadata.settings.evmVersion,
    optimize: data.metadata.settings.optimizer.enabled,
    runs: data.metadata.settings.optimizer.runs
  };
  return {
    settings,
    compilationTargets
  };
};

exports.fetchContractFromSourcify = fetchContractFromSourcify;

/***/ }),
/* 2200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerImports = void 0;

var _engine = __webpack_require__(477);

var _remixUrlResolver = __webpack_require__(2201);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const profile = {
  name: 'contentImport',
  displayName: 'content import',
  version: '0.0.1',
  methods: ['resolve', 'resolveAndSave', 'isExternalUrl']
};

class CompilerImports extends _engine.Plugin {
  constructor() {
    super(profile);

    _defineProperty(this, "previouslyHandled", void 0);

    _defineProperty(this, "urlResolver", void 0);

    this.urlResolver = new _remixUrlResolver.RemixURLResolver();
    this.previouslyHandled = {}; // cache import so we don't make the request at each compilation.
  }

  async setToken() {
    try {
      const protocol = typeof window !== 'undefined' && window.location.protocol;
      const token = await this.call('settings', 'get', 'settings/gist-access-token');
      this.urlResolver.setGistToken(token, protocol);
    } catch (error) {
      console.log(error);
    }
  }

  isRelativeImport(url) {
    return /^([^/]+)/.exec(url);
  }

  isExternalUrl(url) {
    const handlers = this.urlResolver.getHandlers(); // we filter out "npm" because this will be recognized as internal url although it's not the case.

    return handlers.filter(handler => handler.type !== 'npm').some(handler => handler.match(url));
  }
  /**
    * resolve the content of @arg url. This only resolves external URLs.
    *
    * @param {String} url  - external URL of the content. can be basically anything like raw HTTP, ipfs URL, github address etc...
    * @returns {Promise} - { content, cleanUrl, type, url }
    */


  resolve(url) {
    return new Promise((resolve, reject) => {
      this.import(url, null, (error, content, cleanUrl, type, url) => {
        if (error) return reject(error);
        resolve({
          content,
          cleanUrl,
          type,
          url
        });
      }, null);
    });
  }

  async import(url, force, loadingCb, cb) {
    if (typeof force !== 'boolean') {
      const temp = loadingCb;
      loadingCb = force;
      cb = temp;
      force = false;
    }

    if (!loadingCb) loadingCb = () => {};
    if (!cb) cb = () => {};
    const self = this;
    if (force) delete this.previouslyHandled[url];
    const imported = this.previouslyHandled[url];

    if (imported) {
      return cb(null, imported.content, imported.cleanUrl, imported.type, url);
    }

    let resolved;

    try {
      await this.setToken();
      resolved = await this.urlResolver.resolve(url);
      const {
        content,
        cleanUrl,
        type
      } = resolved;
      self.previouslyHandled[url] = {
        content,
        cleanUrl,
        type
      };
      cb(null, content, cleanUrl, type, url);
    } catch (e) {
      return cb(new Error('not found ' + url));
    }
  }

  importExternal(url, targetPath) {
    return new Promise((resolve, reject) => {
      this.import(url, // TODO: handle this event
      loadingMsg => {
        this.emit('message', loadingMsg);
      }, async (error, content, cleanUrl, type, url) => {
        if (error) return reject(error);

        try {
          const provider = await this.call('fileManager', 'getProviderOf', null);
          const path = targetPath || type + '/' + cleanUrl;
          if (provider) await provider.addExternal('.deps/' + path, content, url);
        } catch (err) {
          console.error(err);
        }

        resolve(content);
      }, null);
    });
  }
  /**
    * import the content of @arg url.
    * first look in the browser localstorage (browser explorer) or locahost explorer. if the url start with `browser/*` or  `localhost/*`
    * then check if the @arg url is located in the localhost, in the node_modules or installed_contracts folder
    * then check if the @arg url match any external url
    *
    * @param {String} url - URL of the content. can be basically anything like file located in the browser explorer, in the localhost explorer, raw HTTP, github address etc...
    * @param {String} targetPath - (optional) internal path where the content should be saved to
    * @returns {Promise} - string content
    */


  async resolveAndSave(url, targetPath) {
    try {
      if (targetPath && this.currentRequest) {
        const canCall = await this.askUserPermission('resolveAndSave', 'This action will update the path ' + targetPath);
        if (!canCall) throw new Error('No permission to update ' + targetPath);
      }

      const provider = await this.call('fileManager', 'getProviderOf', url);

      if (provider) {
        if (provider.type === 'localhost' && !provider.isConnected()) {
          throw new Error(`file provider ${provider.type} not available while trying to resolve ${url}`);
        }

        let exist = await provider.exists(url);
        /*
          if the path is absolute and the file does not exist, we can stop here
          Doesn't make sense to try to resolve "localhost/node_modules/localhost/node_modules/<path>" and we'll end in an infinite loop.
        */

        if (!exist && (url === 'remix_tests.sol' || url === 'remix_accounts.sol')) {
          await this.call('solidityUnitTesting', 'createTestLibs');
          exist = await provider.exists(url);
        }

        if (!exist && url.startsWith('browser/')) throw new Error(`not found ${url}`);
        if (!exist && url.startsWith('localhost/')) throw new Error(`not found ${url}`);

        if (exist) {
          const content = await (() => {
            return new Promise((resolve, reject) => {
              provider.get(url, (error, content) => {
                if (error) return reject(error);
                resolve(content);
              });
            });
          })();
          return content;
        } else {
          const localhostProvider = await this.call('fileManager', 'getProviderByName', 'localhost');

          if (localhostProvider.isConnected()) {
            const splitted = /([^/]+)\/(.*)$/g.exec(url);
            const possiblePaths = ['localhost/installed_contracts/' + url]; // pick remix-tests library contracts from '.deps'

            if (url.startsWith('remix_')) possiblePaths.push('localhost/.deps/remix-tests/' + url);
            if (splitted) possiblePaths.push('localhost/installed_contracts/' + splitted[1] + '/contracts/' + splitted[2]);
            possiblePaths.push('localhost/node_modules/' + url);
            if (splitted) possiblePaths.push('localhost/node_modules/' + splitted[1] + '/contracts/' + splitted[2]);

            for (const path of possiblePaths) {
              try {
                const content = await this.resolveAndSave(path, null);

                if (content) {
                  localhostProvider.addNormalizedName(path.replace('localhost/', ''), url);
                  return content;
                }
              } catch (e) {}
            }

            return await this.importExternal(url, targetPath);
          }

          return await this.importExternal(url, targetPath);
        }
      }
    } catch (e) {
      throw new Error(e);
    }
  }

}

exports.CompilerImports = CompilerImports;

/***/ }),
/* 2201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixURLResolver = void 0;

var resolve_1 = __webpack_require__(2202);

Object.defineProperty(exports, "RemixURLResolver", {
  enumerable: true,
  get: function () {
    return resolve_1.RemixURLResolver;
  }
});

/***/ }),
/* 2202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixURLResolver = void 0;

const tslib_1 = __webpack_require__(23); // eslint-disable-next-line no-unused-vars


const axios_1 = (0, tslib_1.__importDefault)(__webpack_require__(1332));

const bzz_node_1 = __webpack_require__(2220);

class RemixURLResolver {
  constructor(gistToken, protocol = 'http:') {
    this.previouslyHandled = {};
    this.setGistToken(gistToken, protocol);
  }

  setGistToken(gistToken, protocol = 'http:') {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.gistAccessToken = gistToken || '';
      this.protocol = protocol;
    });
  }
  /**
  * Handle an import statement based on github
  * @param root The root of the github import statement
  * @param filePath path of the file in github
  */


  handleGithubCall(root, filePath) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const regex = filePath.match(/blob\/([^/]+)\/(.*)/);
      let reference = 'master';

      if (regex) {
        // if we have /blob/master/+path we extract the branch name "master" and add it as a parameter to the github api
        // the ref can be branch name, tag, commit id
        reference = regex[1];
        filePath = filePath.replace(`blob/${reference}/`, '');
      } // eslint-disable-next-line no-useless-catch


      try {
        const req = `https://raw.githubusercontent.com/${root}/${reference}/${filePath}`;
        const response = yield axios_1.default.get(req, {
          transformResponse: []
        });
        return {
          content: response.data,
          cleanUrl: root + '/' + filePath
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on http
  * @param url The url of the import statement
  * @param cleanUrl
  */


  handleHttp(url, cleanUrl) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      // eslint-disable-next-line no-useless-catch
      try {
        const response = yield axios_1.default.get(url, {
          transformResponse: []
        });
        return {
          content: response.data,
          cleanUrl
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on https
  * @param url The url of the import statement
  * @param cleanUrl
  */


  handleHttps(url, cleanUrl) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      // eslint-disable-next-line no-useless-catch
      try {
        const response = yield axios_1.default.get(url, {
          transformResponse: []
        });
        return {
          content: response.data,
          cleanUrl
        };
      } catch (e) {
        throw e;
      }
    });
  }

  handleSwarm(url, cleanUrl) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      // eslint-disable-next-line no-useless-catch
      try {
        const bzz = new bzz_node_1.BzzNode({
          url: this.protocol + '//swarm-gateways.net'
        });
        const url = bzz.getDownloadURL(cleanUrl, {
          mode: 'raw'
        });
        const response = yield axios_1.default.get(url, {
          transformResponse: []
        });
        return {
          content: response.data,
          cleanUrl
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on IPFS
  * @param url The url of the IPFS import statement
  */


  handleIPFS(url) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      // replace ipfs:// with /ipfs/
      url = url.replace(/^ipfs:\/\/?/, 'ipfs/'); // eslint-disable-next-line no-useless-catch

      try {
        const req = 'https://jqgt.remixproject.org/' + url; // If you don't find greeter.sol on ipfs gateway use local
        // const req = 'http://localhost:8080/' + url

        const response = yield axios_1.default.get(req, {
          transformResponse: []
        });
        return {
          content: response.data,
          cleanUrl: url.replace('ipfs/', '')
        };
      } catch (e) {
        throw e;
      }
    });
  }
  /**
  * Handle an import statement based on NPM
  * @param url The url of the NPM import statement
  */


  handleNpmImport(url) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      // eslint-disable-next-line no-useless-catch
      try {
        const req = 'https://unpkg.com/' + url;
        const response = yield axios_1.default.get(req, {
          transformResponse: []
        });
        return {
          content: response.data,
          cleanUrl: url
        };
      } catch (e) {
        throw e;
      }
    });
  }

  getHandlers() {
    return [{
      type: 'github',
      match: url => {
        return /^(https?:\/\/)?(www.)?github.com\/([^/]*\/[^/]*)\/(.*)/.exec(url);
      },
      handle: match => this.handleGithubCall(match[3], match[4])
    }, {
      type: 'http',
      match: url => {
        return /^(http?:\/\/?(.*))$/.exec(url);
      },
      handle: match => this.handleHttp(match[1], match[2])
    }, {
      type: 'https',
      match: url => {
        return /^(https?:\/\/?(.*))$/.exec(url);
      },
      handle: match => this.handleHttps(match[1], match[2])
    }, {
      type: 'swarm',
      match: url => {
        return /^(bzz-raw?:\/\/?(.*))$/.exec(url);
      },
      handle: match => this.handleSwarm(match[1], match[2])
    }, {
      type: 'ipfs',
      match: url => {
        return /^(ipfs:\/\/?.+)/.exec(url);
      },
      handle: match => this.handleIPFS(match[1])
    }, {
      type: 'npm',
      match: url => {
        return /^[^/][^\n"?:*<>|]*$/g.exec(url);
      },
      handle: match => this.handleNpmImport(match[0])
    }];
  }

  resolve(filePath, customHandlers) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      let imported = this.previouslyHandled[filePath];

      if (imported) {
        return imported;
      }

      const builtinHandlers = this.getHandlers();
      const handlers = customHandlers ? [...builtinHandlers, ...customHandlers] : [...builtinHandlers];
      const matchedHandler = handlers.filter(handler => handler.match(filePath));
      const handler = matchedHandler[0];
      const match = handler.match(filePath);
      const {
        content,
        cleanUrl
      } = yield handler.handle(match);
      imported = {
        content,
        cleanUrl: cleanUrl || filePath,
        type: handler.type
      };
      this.previouslyHandled[filePath] = imported;
      return imported;
    });
  }

}

exports.RemixURLResolver = RemixURLResolver;

/***/ }),
/* 2203 */,
/* 2204 */,
/* 2205 */,
/* 2206 */,
/* 2207 */,
/* 2208 */,
/* 2209 */,
/* 2210 */,
/* 2211 */,
/* 2212 */,
/* 2213 */,
/* 2214 */,
/* 2215 */,
/* 2216 */,
/* 2217 */,
/* 2218 */,
/* 2219 */,
/* 2220 */,
/* 2221 */,
/* 2222 */,
/* 2223 */,
/* 2224 */,
/* 2225 */,
/* 2226 */,
/* 2227 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2228 */,
/* 2229 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2230 */,
/* 2231 */,
/* 2232 */,
/* 2233 */,
/* 2234 */,
/* 2235 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2236 */,
/* 2237 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2238 */,
/* 2239 */,
/* 2240 */,
/* 2241 */,
/* 2242 */,
/* 2243 */,
/* 2244 */,
/* 2245 */,
/* 2246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerArtefacts = void 0;

var _engine = __webpack_require__(477);

var _remixLib = __webpack_require__(311);

var _remixSolidity = __webpack_require__(1149);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const profile = {
  name: 'compilerArtefacts',
  methods: ['get', 'addResolvedContract', 'getCompilerAbstract', 'getAllContractDatas', 'getLastCompilationResult', 'getArtefactsByContractName', 'getContractDataFromAddress'],
  events: [],
  version: '0.0.1'
};

class CompilerArtefacts extends _engine.Plugin {
  constructor() {
    super(profile);

    _defineProperty(this, "compilersArtefactsPerFile", void 0);

    _defineProperty(this, "compilersArtefacts", void 0);

    this.compilersArtefacts = {};
    this.compilersArtefactsPerFile = {};
  }

  clear() {
    this.compilersArtefacts = {};
    this.compilersArtefactsPerFile = {};
  }

  onActivation() {
    const saveCompilationPerFileResult = (file, source, languageVersion, data, input) => {
      this.compilersArtefactsPerFile[file] = new _remixSolidity.CompilerAbstract(languageVersion, data, source, input);
    };

    this.on('solidity', 'compilationFinished', (file, source, languageVersion, data, input, version) => {
      this.compilersArtefacts.__last = new _remixSolidity.CompilerAbstract(languageVersion, data, source, input);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('vyper', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts.__last = new _remixSolidity.CompilerAbstract(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('lexon', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts.__last = new _remixSolidity.CompilerAbstract(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('yulp', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts.__last = new _remixSolidity.CompilerAbstract(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
    this.on('solidityUnitTesting', 'compilationFinished', (file, source, languageVersion, data, input, version) => {
      this.compilersArtefacts.__last = new _remixSolidity.CompilerAbstract(languageVersion, data, source, input);
      saveCompilationPerFileResult(file, source, languageVersion, data, input);
    });
    this.on('nahmii-compiler', 'compilationFinished', (file, source, languageVersion, data) => {
      this.compilersArtefacts.__last = new _remixSolidity.CompilerAbstract(languageVersion, data, source);
      saveCompilationPerFileResult(file, source, languageVersion, data);
    });
  }
  /**
   * Get artefacts for last compiled contract 
   * * @returns last compiled contract compiler abstract
   */


  getLastCompilationResult() {
    return this.compilersArtefacts.__last;
  }
  /**
   * Get compilation output for contracts compiled during a session of Remix IDE
   * @returns compilatin output
   */


  getAllContractDatas() {
    return this.filterAllContractDatas(() => true);
  }
  /**
   * filter compilation output for contracts compiled during a session of Remix IDE
   * @returns compilatin output
   */


  filterAllContractDatas(filter) {
    const contractsData = {};
    Object.keys(this.compilersArtefactsPerFile).map(targetFile => {
      const contracts = this.compilersArtefactsPerFile[targetFile].getContracts();
      Object.keys(contracts).map(file => {
        if (filter(file, contracts[file])) contractsData[file] = contracts[file];
      });
    }); // making sure we save last compilation result in there

    if (this.compilersArtefacts.__last) {
      const contracts = this.compilersArtefacts.__last.getContracts();

      Object.keys(contracts).map(file => {
        if (filter(file, contracts[file])) contractsData[file] = contracts[file];
      });
    }

    return contractsData;
  }
  /**
   * Get a particular contract output/artefacts from a compiler output of a Solidity file compilation
   * @param compilerOutput compiler output 
   * @param contractName contract name
   * @returns arefacts object, with fully qualified name (e.g; contracts/1_Storage.sol:Storage) as key
   */


  _getAllContractArtefactsfromOutput(compilerOutput, contractName) {
    const contractArtefacts = {};

    for (const filename in compilerOutput) {
      if (Object.keys(compilerOutput[filename]).includes(contractName)) contractArtefacts[filename + ':' + contractName] = compilerOutput[filename][contractName];
    }

    return contractArtefacts;
  }
  /**
   * Populate resultant object with a particular contract output/artefacts by processing all the artifacts stored in file explorer
   * @param path path to start looking from
   * @param contractName contract to be looked for
   * @param contractArtefacts populated resultant artefacts object, with fully qualified name (e.g: contracts/1_Storage.sol:Storage) as key
   * Once method execution completes, contractArtefacts object will hold all possible artefacts for contract
   */


  async _populateAllContractArtefactsFromFE(path, contractName, contractArtefacts) {
    const dirList = await this.call('fileManager', 'dirList', path);

    if (dirList && dirList.length) {
      for (const dirPath of dirList) {
        // check if directory contains an 'artifacts' folder and a 'build-info' folder inside 'artifacts'
        if (dirPath === path + '/artifacts' && (await this.call('fileManager', 'exists', dirPath + '/build-info'))) {
          const buildFileList = await this.call('fileManager', 'fileList', dirPath + '/build-info'); // process each build-info file to populate the artefacts for contractName

          for (const buildFile of buildFileList) {
            let content = await this.call('fileManager', 'readFile', buildFile);
            if (content) content = JSON.parse(content);
            const compilerOutput = content.output.contracts;

            const artefacts = this._getAllContractArtefactsfromOutput(compilerOutput, contractName); // populate the resultant object with artefacts


            Object.assign(contractArtefacts, artefacts);
          }
        } else await this._populateAllContractArtefactsFromFE(dirPath, contractName, contractArtefacts);
      }
    } else return;
  }
  /**
   * Get artefacts for a contract (called by script-runner)
   * @param name contract name or fully qualified name i.e. <filename>:<contractname> e.g: contracts/1_Storage.sol:Storage 
   * @returns artefacts for the contract
   */


  async getArtefactsByContractName(name) {
    const contractsDataByFilename = this.getAllContractDatas(); // check if name is a fully qualified name

    if (name.includes(':')) {
      const fullyQualifiedName = name;
      const nameArr = fullyQualifiedName.split(':');
      const filename = nameArr[0];
      const contract = nameArr[1];
      if (Object.keys(contractsDataByFilename).includes(filename) && contractsDataByFilename[filename][contract]) return contractsDataByFilename[filename][contract];else {
        const allContractsData = {};
        await this._populateAllContractArtefactsFromFE('contracts', contract, allContractsData);
        if (allContractsData[fullyQualifiedName]) return {
          fullyQualifiedName,
          artefact: allContractsData[fullyQualifiedName]
        };else throw new Error(`Could not find artifacts for ${fullyQualifiedName}. Compile contract to generate artifacts.`);
      }
    } else {
      const contractName = name;

      const contractArtefacts = this._getAllContractArtefactsfromOutput(contractsDataByFilename, contractName);

      let keys = Object.keys(contractArtefacts);

      if (!keys.length) {
        await this._populateAllContractArtefactsFromFE('contracts', contractName, contractArtefacts);
        keys = Object.keys(contractArtefacts);
      }

      if (keys.length === 1) return {
        fullyQualifiedName: keys[0],
        artefact: contractArtefacts[keys[0]]
      };else if (keys.length > 1) {
        throw new Error(`There are multiple artifacts for contract "${contractName}", please use a fully qualified name.\n
          Please replace ${contractName} for one of these options wherever you are trying to read its artifact: \n
          ${keys.join()}\n
          OR just compile the required contract again`);
      } else throw new Error(`Could not find artifacts for ${contractName}. Compile contract to generate artifacts.`);
    }
  }

  getCompilerAbstract(file) {
    return this.compilersArtefactsPerFile[file];
  } // compilerData is a CompilerAbstract object


  addResolvedContract(address, compilerData) {
    this.compilersArtefacts[address] = compilerData;
  }

  isResolved(address) {
    return this.compilersArtefacts[address] !== undefined;
  }

  get(key) {
    return this.compilersArtefacts[key];
  }

  async getContractDataFromAddress(address) {
    const code = await this.call('blockchain', 'getCode', address);
    let found;
    this.filterAllContractDatas((file, contractsData) => {
      for (const name of Object.keys(contractsData)) {
        const contract = contractsData[name];

        if (_remixLib.util.compareByteCode(code, '0x' + contract.evm.deployedBytecode.object)) {
          found = {
            name,
            contract
          };
          return true;
        }
      }

      return true;
    });
    return found;
  }

}

exports.CompilerArtefacts = CompilerArtefacts;

/***/ }),
/* 2247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditorContextListener = void 0;

var _engine = __webpack_require__(477);

var _remixDebug = __webpack_require__(1217);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const profile = {
  name: 'contextualListener',
  methods: ['referencesOf', 'getActiveHighlights', 'gasEstimation', 'declarationOf'],
  events: [],
  version: '0.0.1'
};
/*
  trigger contextChanged(nodes)
*/

class EditorContextListener extends _engine.Plugin {
  constructor(astWalker) {
    super(profile);

    _defineProperty(this, "_index", void 0);

    _defineProperty(this, "_activeHighlights", void 0);

    _defineProperty(this, "astWalker", void 0);

    _defineProperty(this, "currentPosition", void 0);

    _defineProperty(this, "currentFile", void 0);

    _defineProperty(this, "nodes", void 0);

    _defineProperty(this, "results", void 0);

    _defineProperty(this, "estimationObj", void 0);

    _defineProperty(this, "creationCost", void 0);

    _defineProperty(this, "codeDepositCost", void 0);

    _defineProperty(this, "contract", void 0);

    _defineProperty(this, "activated", void 0);

    this.activated = false;
    this._index = {
      Declarations: {},
      FlatReferences: {}
    };
    this._activeHighlights = [];
    this.astWalker = astWalker;
  }

  onActivation() {
    this.on('editor', 'contentChanged', () => {
      this._stopHighlighting();
    });
    this.on('solidity', 'compilationFinished', (file, source, languageVersion, data, input, version) => {
      if (languageVersion.indexOf('soljson') !== 0) return;

      this._stopHighlighting();

      this._index = {
        Declarations: {},
        FlatReferences: {}
      };

      this._buildIndex(data, source);
    });
    setInterval(async () => {
      const compilationResult = await this.call('compilerArtefacts', 'getLastCompilationResult');

      if (compilationResult && compilationResult.languageversion.indexOf('soljson') === 0) {
        let currentFile;

        try {
          currentFile = await this.call('fileManager', 'file');
        } catch (error) {
          if (error.message !== 'Error: No such file or directory No file selected') throw error;
        }

        this._highlightItems(await this.call('editor', 'getCursorPosition'), compilationResult, currentFile);
      }
    }, 1000);
    this.activated = true;
  }

  getActiveHighlights() {
    return [...this._activeHighlights];
  }

  declarationOf(node) {
    if (node && node.referencedDeclaration) {
      return this._index.FlatReferences[node.referencedDeclaration];
    }

    return null;
  }

  referencesOf(node) {
    return this._index.Declarations[node.id];
  }

  async _highlightItems(cursorPosition, compilationResult, file) {
    if (this.currentPosition === cursorPosition) return;

    this._stopHighlighting();

    this.currentPosition = cursorPosition;
    this.currentFile = file;

    if (compilationResult && compilationResult.data && compilationResult.data.sources && compilationResult.data.sources[file]) {
      const nodes = _remixDebug.sourceMappingDecoder.nodesAtPosition(null, cursorPosition, compilationResult.data.sources[file]);

      this.nodes = nodes;

      if (nodes && nodes.length && nodes[nodes.length - 1]) {
        await this._highlightExpressions(nodes[nodes.length - 1], compilationResult);
      }

      this.emit('contextChanged', nodes);
    }
  }

  _buildIndex(compilationResult, source) {
    if (compilationResult && compilationResult.sources) {
      const callback = node => {
        if (node && node.referencedDeclaration) {
          if (!this._index.Declarations[node.referencedDeclaration]) {
            this._index.Declarations[node.referencedDeclaration] = [];
          }

          this._index.Declarations[node.referencedDeclaration].push(node);
        }

        this._index.FlatReferences[node.id] = node;
      };

      for (const s in compilationResult.sources) {
        this.astWalker.walkFull(compilationResult.sources[s].ast, callback);
      }
    }
  }

  async _highlight(node, compilationResult) {
    if (!node) return;

    const position = _remixDebug.sourceMappingDecoder.decode(node.src);

    const fileTarget = compilationResult.getSourceName(position.file);

    const nodeFound = this._activeHighlights.find(el => el.fileTarget === fileTarget && el.position.file === position.file && el.position.length === position.length && el.position.start === position.start);

    if (nodeFound) return; // if the content is already highlighted, do nothing.

    await this._highlightInternal(position, node, compilationResult);

    if (compilationResult && compilationResult.languageversion.indexOf('soljson') === 0) {
      this._activeHighlights.push({
        position,
        fileTarget,
        nodeId: node.id
      });
    }
  }

  async _highlightInternal(position, node, compilationResult) {
    if (node.nodeType === 'Block') return;

    if (compilationResult && compilationResult.languageversion.indexOf('soljson') === 0) {
      let lineColumn = await this.call('offsetToLineColumnConverter', 'offsetToLineColumn', position, position.file, compilationResult.getSourceCode().sources, compilationResult.getAsts());

      if (node.nodes && node.nodes.length) {
        // If node has children, highlight the entire line. if not, just highlight the current source position of the node.
        lineColumn = {
          start: {
            line: lineColumn.start.line,
            column: 0
          },
          end: {
            line: lineColumn.start.line + 1,
            column: 0
          }
        };
      }

      const fileName = compilationResult.getSourceName(position.file);

      if (fileName) {
        return await this.call('editor', 'highlight', lineColumn, fileName, '', {
          focus: false
        });
      }
    }

    return null;
  }

  async _highlightExpressions(node, compilationResult) {
    const highlights = async id => {
      if (this._index.Declarations && this._index.Declarations[id]) {
        const refs = this._index.Declarations[id];

        for (const ref in refs) {
          const node = refs[ref];
          await this._highlight(node, compilationResult);
        }
      }
    };

    if (node && node.referencedDeclaration) {
      await highlights(node.referencedDeclaration);
      const current = this._index.FlatReferences[node.referencedDeclaration];
      await this._highlight(current, compilationResult);
    } else {
      await highlights(node.id);
      await this._highlight(node, compilationResult);
    }

    this.results = compilationResult;
  }

  _stopHighlighting() {
    this.call('editor', 'discardHighlight');
    this.emit('stopHighlighting');
    this._activeHighlights = [];
  }

  gasEstimation(node) {
    this._loadContractInfos(node);

    let executionCost, codeDepositCost;

    if (node.nodeType === 'FunctionDefinition') {
      const visibility = node.visibility;

      if (node.kind !== 'constructor') {
        const fnName = node.name;

        const fn = fnName + this._getInputParams(node);

        if (visibility === 'public' || visibility === 'external') {
          executionCost = this.estimationObj === null ? '-' : this.estimationObj.external[fn];
        } else if (visibility === 'private' || visibility === 'internal') {
          executionCost = this.estimationObj === null ? '-' : this.estimationObj.internal[fn];
        }
      } else {
        executionCost = this.creationCost;
        codeDepositCost = this.codeDepositCost;
      }
    } else {
      executionCost = '-';
    }

    return {
      executionCost,
      codeDepositCost
    };
  }

  _loadContractInfos(node) {
    const path = this.nodes.length && this.nodes[0].absolutePath || this.results.source.target;

    for (const i in this.nodes) {
      if (this.nodes[i].id === node.scope) {
        const contract = this.nodes[i];
        this.contract = this.results.data.contracts[path][contract.name];

        if (contract) {
          this.estimationObj = this.contract.evm.gasEstimates;
          this.creationCost = this.estimationObj === null ? '-' : this.estimationObj.creation.totalCost;
          this.codeDepositCost = this.estimationObj === null ? '-' : this.estimationObj.creation.codeDepositCost;
        }
      }
    }
  }

  _getInputParams(node) {
    const params = [];
    const target = node.parameters; // for (const i in node.children) {
    //   if (node.children[i].name === 'ParameterList') {
    //     target = node.children[i]
    //     break
    //   }
    // }

    if (target) {
      const children = target.parameters;

      for (const j in children) {
        if (children[j].nodeType === 'VariableDeclaration') {
          params.push(children[j].typeDescriptions.typeString);
        }
      }
    }

    return '(' + params.toString() + ')';
  }

}

exports.EditorContextListener = EditorContextListener;

/***/ }),
/* 2248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global fetch */


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GistHandler = void 0;

var _engine = __webpack_require__(477);

const profile = {
  name: 'gistHandler',
  methods: ['load'],
  events: [],
  version: '0.0.1'
};

class GistHandler extends _engine.Plugin {
  constructor() {
    super(profile);
  }

  async handleLoad(gistId, cb) {
    if (!cb) cb = () => {};
    let loadingFromGist = false;

    if (!gistId) {
      loadingFromGist = true;
      let value;

      try {
        value = await (() => {
          return new Promise((resolve, reject) => {
            const modalContent = {
              id: 'gisthandler',
              title: 'Load a Gist',
              message: 'Enter the ID of the Gist or URL you would like to load.',
              modalType: 'prompt',
              okLabel: 'OK',
              cancelLabel: 'Cancel',
              okFn: value => {
                setTimeout(() => resolve(value), 0);
              },
              cancelFn: () => {
                setTimeout(() => reject(new Error('Canceled')), 0);
              },
              hideFn: () => {
                setTimeout(() => reject(new Error('Hide')), 0);
              }
            };
            this.call('notification', 'modal', modalContent);
          });
        })();
      } catch (e) {
        // the modal has been canceled
        return;
      }

      if (value !== '') {
        gistId = getGistId(value);

        if (gistId) {
          cb(gistId);
        } else {
          const modalContent = {
            id: 'gisthandler',
            title: 'Gist load error',
            message: 'Error while loading gist. Please provide a valid Gist ID or URL.'
          };
          this.call('notification', 'alert', modalContent);
        }
      } else {
        const modalContent = {
          id: 'gisthandlerEmpty',
          title: 'Gist load error',
          message: 'Error while loading gist. Id cannot be empty.'
        };
        this.call('notification', 'alert', modalContent);
      }

      return loadingFromGist;
    } else {
      loadingFromGist = !!gistId;
    }

    if (loadingFromGist) {
      cb(gistId);
    }

    return loadingFromGist;
  }

  load(gistId) {
    const self = this;
    return self.handleLoad(gistId, async gistId => {
      let data;

      try {
        data = await (await fetch(`https://api.github.com/gists/${gistId}`)).json();

        if (!data.files) {
          const modalContent = {
            id: 'gisthandler',
            title: 'Gist load error',
            message: data.message,
            modalType: 'alert',
            okLabel: 'OK'
          };
          await this.call('notification', 'modal', modalContent);
          return;
        }
      } catch (e) {
        const modalContent = {
          id: 'gisthandler',
          title: 'Gist load error',
          message: e.message
        };
        await this.call('notification', 'alert', modalContent);
        return;
      }

      const obj = {};
      Object.keys(data.files).forEach(element => {
        const path = element.replace(/\.\.\./g, '/');
        obj['/gist-' + gistId + '/' + path] = data.files[element];
      });
      this.call('fileManager', 'setBatchFiles', obj, 'workspace', true, async errorSavingFiles => {
        if (errorSavingFiles) {
          const modalContent = {
            id: 'gisthandler',
            title: 'Gist load error',
            message: errorSavingFiles.message || errorSavingFiles
          };
          this.call('notification', 'alert', modalContent);
        }
      });
    });
  }

}

exports.GistHandler = GistHandler;

const getGistId = str => {
  const idr = /[0-9A-Fa-f]{8,}/;
  const match = idr.exec(str);
  return match ? match[0] : null;
};

/***/ }),
/* 2249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 2250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkLibraries = exports.DeployLibraries = void 0;

var _remixLib = __webpack_require__(311);

var _engine = __webpack_require__(477);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const {
  txFormat
} = _remixLib.execution;
const profileDeployLibraries = {
  name: 'deploy-libraries',
  displayName: 'deploy-libraries',
  description: 'deploy-libraries',
  methods: ['isConcerned', 'execute']
};
const profileLinkLibraries = {
  name: 'link-libraries',
  displayName: 'link-libraries',
  description: 'link-libraries',
  methods: ['isConcerned', 'execute']
};

class DeployLibraries extends _engine.Plugin {
  constructor(blockchain) {
    super(profileDeployLibraries);

    _defineProperty(this, "blockchain", void 0);

    this.blockchain = blockchain;
  }

  async isConcerned(contractData) {
    return Object.keys(contractData.bytecodeLinkReferences).length > 0;
  }

  execute(contractData, contractMetadata, compiledContracts) {
    // we deploy libraries
    // and return the linked bytecode
    return new Promise((resolve, reject) => {
      txFormat.linkBytecode(contractData.object, compiledContracts, (error, bytecode) => {
        if (error) return reject(error); // final Callback

        resolve(bytecode);
      }, message => {
        // step Callback
        console.log(message);
      }, (data, runTxCallback) => {
        // deploy library Callback
        // called for libraries deployment
        this.blockchain.runTx(data, () => {}, () => {}, () => {}, runTxCallback);
      });
    });
  }

}

exports.DeployLibraries = DeployLibraries;

class LinkLibraries extends _engine.Plugin {
  constructor(blockchain) {
    super(profileLinkLibraries);

    _defineProperty(this, "blockchain", void 0);

    this.blockchain = blockchain;
  }

  async isConcerned(contractData) {
    return Object.keys(contractData.bytecodeLinkReferences).length > 0;
  }

  execute(contractData, contractMetadata, compiledContracts) {
    // we just link libraries
    // and return the linked bytecode
    return new Promise((resolve, reject) => {
      txFormat.linkLibraries(contractData, contractMetadata.linkReferences, contractData.bytecodeLinkReferences, (error, bytecode) => {
        if (error) return reject(error);
        resolve(bytecode);
      });
    });
  }

}

exports.LinkLibraries = LinkLibraries;

/***/ }),
/* 2251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenZeppelinProxy = void 0;

var _engine = __webpack_require__(477);

var _uups = __webpack_require__(2252);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const proxyProfile = {
  name: 'openzeppelin-proxy',
  displayName: 'openzeppelin-proxy',
  description: 'openzeppelin-proxy',
  methods: ['isConcerned', 'executeUUPSProxy', 'executeUUPSContractUpgrade', 'getProxyOptions', 'getUpgradeOptions']
};

class OpenZeppelinProxy extends _engine.Plugin {
  constructor(blockchain) {
    super(proxyProfile);

    _defineProperty(this, "blockchain", void 0);

    _defineProperty(this, "kind", void 0);

    this.blockchain = blockchain;
  }

  async isConcerned(ast = {}) {
    // check in the AST if it's an upgradable contract
    const UUPSSymbol = ast.exportedSymbols && ast.exportedSymbols[_uups.UUPS] ? ast.exportedSymbols[_uups.UUPS][0] : null;

    if (UUPSSymbol) {
      this.kind = 'UUPS';
      return true;
    } //
    // else if transparent contract run check true/false
    //


    return false;
  }

  async getProxyOptions(data, file) {
    const contracts = data.contracts[file];
    const ast = data.sources[file].ast;

    if (this.kind === 'UUPS') {
      const options = await this.getUUPSContractOptions(contracts, ast, file);
      return options;
    }
  }

  async getUUPSContractOptions(contracts, ast, file) {
    const options = {};
    await Promise.all(Object.keys(contracts).map(async name => {
      if (ast) {
        const UUPSSymbol = ast.exportedSymbols[_uups.UUPS] ? ast.exportedSymbols[_uups.UUPS][0] : null;
        await Promise.all(ast.absolutePath === file && ast.nodes.map(async node => {
          if (node.name === name && node.linearizedBaseContracts.includes(UUPSSymbol)) {
            const abi = contracts[name].abi;
            const initializeInput = abi.find(node => node.name === 'initialize');
            const isDeployWithProxyEnabled = (await this.call('config', 'getAppParameter', _uups.EnableProxyURLParam)) || false;
            const isDeployWithUpgradeEnabled = (await this.call('config', 'getAppParameter', _uups.EnableUpgradeURLParam)) || false;
            options[name] = {
              options: [{
                title: 'Deploy with Proxy',
                active: isDeployWithProxyEnabled
              }, {
                title: 'Upgrade with Proxy',
                active: isDeployWithUpgradeEnabled
              }],
              initializeOptions: {
                inputs: initializeInput,
                initializeInputs: initializeInput ? this.blockchain.getInputs(initializeInput) : null
              }
            };
          }
        }));
      }
    }));
    return options;
  }

  async executeUUPSProxy(implAddress, args = '', initializeABI, implementationContractObject) {
    // deploy the proxy, or use an existing one
    if (!initializeABI) throw new Error('Cannot deploy proxy: Missing initialize ABI');
    args = args === '' ? [] : args;

    const _data = await this.blockchain.getEncodedFunctionHex(args || [], initializeABI);

    if (this.kind === 'UUPS') this.deployUUPSProxy(implAddress, _data, implementationContractObject);
  }

  async executeUUPSContractUpgrade(proxyAddress, newImplAddress, newImplementationContractObject) {
    if (!newImplAddress) throw new Error('Cannot upgrade: Missing implementation address');
    if (!proxyAddress) throw new Error('Cannot upgrade: Missing proxy address');
    if (this.kind === 'UUPS') this.upgradeUUPSProxy(proxyAddress, newImplAddress, newImplementationContractObject);
  }

  async deployUUPSProxy(implAddress, _data, implementationContractObject) {
    const args = [implAddress, _data];
    const constructorData = await this.blockchain.getEncodedParams(args, _uups.UUPSfunAbi);
    const proxyName = 'ERC1967Proxy';
    const data = {
      contractABI: _uups.UUPSABI,
      contractByteCode: _uups.UUPSBytecode,
      contractName: proxyName,
      funAbi: _uups.UUPSfunAbi,
      funArgs: args,
      linkReferences: {},
      dataHex: _uups.UUPSBytecode + constructorData.replace('0x', '')
    }; // re-use implementation contract's ABI for UI display in udapp and change name to proxy name.

    implementationContractObject.name = proxyName;
    this.blockchain.deployProxy(data, implementationContractObject);
  }

  async upgradeUUPSProxy(proxyAddress, newImplAddress, newImplementationContractObject) {
    const fnData = await this.blockchain.getEncodedFunctionHex([newImplAddress], _uups.UUPSupgradeAbi);
    const proxyName = 'ERC1967Proxy';
    const data = {
      contractABI: _uups.UUPSABI,
      contractName: proxyName,
      funAbi: _uups.UUPSupgradeAbi,
      funArgs: [newImplAddress],
      linkReferences: {},
      dataHex: fnData.replace('0x', '')
    }; // re-use implementation contract's ABI for UI display in udapp and change name to proxy name.

    newImplementationContractObject.name = proxyName;
    this.blockchain.upgradeProxy(proxyAddress, newImplAddress, data, newImplementationContractObject);
  }

}

exports.OpenZeppelinProxy = OpenZeppelinProxy;

/***/ }),
/* 2252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UUPSupgradeAbi = exports.UUPSfunAbi = exports.UUPSBytecode = exports.UUPSABI = exports.UUPS = exports.EnableUpgradeURLParam = exports.EnableProxyURLParam = void 0;
const UUPS = 'UUPSUpgradeable';
exports.UUPS = UUPS;
const UUPSBytecode = '608060405260405162000d8638038062000d86833981810160405281019062000029919062000467565b60017f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd60001c6200005b9190620006a5565b60001b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b146200009357620000926200078a565b5b620000a782826000620000af60201b60201c565b5050620008f4565b620000c083620000f260201b60201c565b600082511180620000ce5750805b15620000ed57620000eb83836200014960201b620000371760201c565b505b505050565b62000103816200017f60201b60201c565b8073ffffffffffffffffffffffffffffffffffffffff167fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b60405160405180910390a250565b606062000177838360405180606001604052806027815260200162000d5f602791396200025560201b60201c565b905092915050565b62000195816200033960201b620000641760201c565b620001d7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620001ce90620005d0565b60405180910390fd5b80620002117f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b6200035c60201b620000871760201c565b60000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b606062000268846200033960201b60201c565b620002aa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620002a190620005f2565b60405180910390fd5b6000808573ffffffffffffffffffffffffffffffffffffffff1685604051620002d4919062000593565b600060405180830381855af49150503d806000811462000311576040519150601f19603f3d011682016040523d82523d6000602084013e62000316565b606091505b50915091506200032e8282866200036660201b60201c565b925050509392505050565b6000808273ffffffffffffffffffffffffffffffffffffffff163b119050919050565b6000819050919050565b606083156200037857829050620003cb565b6000835111156200038c5782518084602001fd5b816040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401620003c29190620005ac565b60405180910390fd5b9392505050565b6000620003e9620003e3846200063d565b62000614565b9050828152602081018484840111156200040857620004076200081c565b5b620004158482856200071e565b509392505050565b6000815190506200042e81620008da565b92915050565b600082601f8301126200044c576200044b62000817565b5b81516200045e848260208601620003d2565b91505092915050565b6000806040838503121562000481576200048062000826565b5b600062000491858286016200041d565b925050602083015167ffffffffffffffff811115620004b557620004b462000821565b5b620004c38582860162000434565b9150509250929050565b6000620004da8262000673565b620004e6818562000689565b9350620004f88185602086016200071e565b80840191505092915050565b600062000511826200067e565b6200051d818562000694565b93506200052f8185602086016200071e565b6200053a816200082b565b840191505092915050565b600062000554602d8362000694565b915062000561826200083c565b604082019050919050565b60006200057b60268362000694565b915062000588826200088b565b604082019050919050565b6000620005a18284620004cd565b915081905092915050565b60006020820190508181036000830152620005c8818462000504565b905092915050565b60006020820190508181036000830152620005eb8162000545565b9050919050565b600060208201905081810360008301526200060d816200056c565b9050919050565b60006200062062000633565b90506200062e828262000754565b919050565b6000604051905090565b600067ffffffffffffffff8211156200065b576200065a620007e8565b5b62000666826200082b565b9050602081019050919050565b600081519050919050565b600081519050919050565b600081905092915050565b600082825260208201905092915050565b6000620006b28262000714565b9150620006bf8362000714565b925082821015620006d557620006d4620007b9565b5b828203905092915050565b6000620006ed82620006f4565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60005b838110156200073e57808201518184015260208101905062000721565b838111156200074e576000848401525b50505050565b6200075f826200082b565b810181811067ffffffffffffffff82111715620007815762000780620007e8565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60008201527f6f74206120636f6e747261637400000000000000000000000000000000000000602082015250565b7f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60008201527f6e74726163740000000000000000000000000000000000000000000000000000602082015250565b620008e581620006e0565b8114620008f157600080fd5b50565b61045b80620009046000396000f3fe6080604052366100135761001161001d565b005b61001b61001d565b005b610025610091565b610035610030610093565b6100a2565b565b606061005c83836040518060600160405280602781526020016103ff602791396100c8565b905092915050565b6000808273ffffffffffffffffffffffffffffffffffffffff163b119050919050565b6000819050919050565b565b600061009d610195565b905090565b3660008037600080366000845af43d6000803e80600081146100c3573d6000f35b3d6000fd5b60606100d384610064565b610112576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161010990610319565b60405180910390fd5b6000808573ffffffffffffffffffffffffffffffffffffffff168560405161013a91906102e0565b600060405180830381855af49150503d8060008114610175576040519150601f19603f3d011682016040523d82523d6000602084013e61017a565b606091505b509150915061018a8282866101ec565b925050509392505050565b60006101c37f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b610087565b60000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b606083156101fc5782905061024c565b60008351111561020f5782518084602001fd5b816040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161024391906102f7565b60405180910390fd5b9392505050565b600061025e82610339565b610268818561034f565b935061027881856020860161036b565b80840191505092915050565b600061028f82610344565b610299818561035a565b93506102a981856020860161036b565b6102b28161039e565b840191505092915050565b60006102ca60268361035a565b91506102d5826103af565b604082019050919050565b60006102ec8284610253565b915081905092915050565b600060208201905081810360008301526103118184610284565b905092915050565b60006020820190508181036000830152610332816102bd565b9050919050565b600081519050919050565b600081519050919050565b600081905092915050565b600082825260208201905092915050565b60005b8381101561038957808201518184015260208101905061036e565b83811115610398576000848401525b50505050565b6000601f19601f8301169050919050565b7f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60008201527f6e7472616374000000000000000000000000000000000000000000000000000060208201525056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201fbb70b81fbc37a0d465e50bdaf6c661d6411918ae96ccedacef32b393f9533964736f6c63430008070033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564';
exports.UUPSBytecode = UUPSBytecode;
const UUPSABI = [{
  "inputs": [{
    "internalType": "address",
    "name": "_logic",
    "type": "address"
  }, {
    "internalType": "bytes",
    "name": "_data",
    "type": "bytes"
  }],
  "stateMutability": "payable",
  "type": "constructor"
}, {
  "anonymous": false,
  "inputs": [{
    "indexed": false,
    "internalType": "address",
    "name": "previousAdmin",
    "type": "address"
  }, {
    "indexed": false,
    "internalType": "address",
    "name": "newAdmin",
    "type": "address"
  }],
  "name": "AdminChanged",
  "type": "event"
}, {
  "anonymous": false,
  "inputs": [{
    "indexed": true,
    "internalType": "address",
    "name": "beacon",
    "type": "address"
  }],
  "name": "BeaconUpgraded",
  "type": "event"
}, {
  "anonymous": false,
  "inputs": [{
    "indexed": true,
    "internalType": "address",
    "name": "implementation",
    "type": "address"
  }],
  "name": "Upgraded",
  "type": "event"
}, {
  "stateMutability": "payable",
  "type": "fallback"
}, {
  "stateMutability": "payable",
  "type": "receive"
}];
exports.UUPSABI = UUPSABI;
const UUPSfunAbi = {
  name: "",
  inputs: [{
    "internalType": "address",
    "name": "_logic",
    "type": "address"
  }, {
    "internalType": "bytes",
    "name": "_data",
    "type": "bytes"
  }],
  type: "constructor",
  outputs: [],
  stateMutability: "payable"
};
exports.UUPSfunAbi = UUPSfunAbi;
const UUPSupgradeAbi = {
  "inputs": [{
    "internalType": "address",
    "name": "newImplementation",
    "type": "address"
  }],
  "name": "upgradeTo",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
};
exports.UUPSupgradeAbi = UUPSupgradeAbi;
const EnableProxyURLParam = 'deployProxy';
exports.EnableProxyURLParam = EnableProxyURLParam;
const EnableUpgradeURLParam = 'upgradeProxy';
exports.EnableUpgradeURLParam = EnableUpgradeURLParam;

/***/ }),
/* 2253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WalkthroughService = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var introJs = __webpack_require__(2254);

var profile = {
  name: 'walkthrough',
  displayName: 'Walkthrough',
  description: 'Remix walkthrough for beginner',
  version: packageJson.version,
  methods: ['start']
};

var WalkthroughService = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(WalkthroughService, _Plugin);

  var _super = _createSuper(WalkthroughService);

  function WalkthroughService(appManager, showMatamo) {
    var _this;

    (0, _classCallCheck2["default"])(this, WalkthroughService);
    _this = _super.call(this, profile);
    appManager.event.on('activate', function (plugin) {
      if (plugin.name === 'udapp' && !showMatamo) {
        _this.start();
      }
    });
    return _this;
  }

  (0, _createClass2["default"])(WalkthroughService, [{
    key: "start",
    value: function start() {
      if (!localStorage.getItem('hadTour_initial')) {
        introJs().setOptions({
          steps: [{
            title: 'Welcome to Remix IDE',
            intro: 'Click to launch the Home tab that contains links, tips, and shortcuts..',
            element: document.querySelector('#verticalIconsHomeIcon'),
            tooltipClass: 'bg-light text-dark',
            position: 'right'
          }, {
            element: document.querySelector('#verticalIconsKindsolidity'),
            title: 'Solidity Compiler',
            intro: 'Having selected a .sol file in the File Explorer (the icon above), compile it with the Solidity Compiler.',
            tooltipClass: 'bg-light text-dark',
            position: 'right'
          }, {
            title: 'Deploy your contract',
            element: document.querySelector('#verticalIconsKindudapp'),
            intro: 'Choose a chain, deploy a contract and play with your functions.',
            tooltipClass: 'bg-light text-dark',
            position: 'right'
          }]
        }).onafterchange(function (targetElement) {
          var header = document.getElementsByClassName('introjs-tooltip-header')[0];

          if (header) {
            header.classList.add('d-flex');
            header.classList.add('justify-content-between');
            header.classList.add('text-nowrap');
            header.classList.add('pr-0');
          }

          var skipbutton = document.getElementsByClassName('introjs-skipbutton')[0];

          if (skipbutton) {
            skipbutton.classList.add('ml-3');
            skipbutton.classList.add('text-decoration-none');
            skipbutton.id = 'remixTourSkipbtn';
          }
        }).start();
        localStorage.setItem('hadTour_initial', true);
      }
    }
  }]);
  return WalkthroughService;
}(_engine.Plugin);

exports.WalkthroughService = WalkthroughService;

/***/ }),
/* 2254 */,
/* 2255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigPlugin = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var _remixLib = __webpack_require__(311);

var _registry = _interopRequireDefault(__webpack_require__(315));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'config',
  displayName: 'Config',
  description: 'Config',
  methods: ['getAppParameter', 'setAppParameter']
};

var ConfigPlugin = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(ConfigPlugin, _Plugin);

  var _super = _createSuper(ConfigPlugin);

  function ConfigPlugin() {
    (0, _classCallCheck2["default"])(this, ConfigPlugin);
    return _super.call(this, profile);
  }

  (0, _createClass2["default"])(ConfigPlugin, [{
    key: "getAppParameter",
    value: function getAppParameter(name) {
      var queryParams = new _remixLib.QueryParams();
      var params = queryParams.get();

      var config = _registry["default"].getInstance().get('config').api;

      var param = params[name] || config.get(name) || config.get('settings/' + name);
      if (param === 'true') return true;
      if (param === 'false') return false;
      return param;
    }
  }, {
    key: "setAppParameter",
    value: function setAppParameter(name, value) {
      var config = _registry["default"].getInstance().get('config').api;

      config.set(name, value);
    }
  }]);
  return ConfigPlugin;
}(_engine.Plugin);

exports.ConfigPlugin = ConfigPlugin;

/***/ }),
/* 2256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StoragePlugin = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'storage',
  displayName: 'Storage',
  description: 'Storage',
  methods: ['getStorage', 'formatString']
};

var StoragePlugin = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(StoragePlugin, _Plugin);

  var _super = _createSuper(StoragePlugin);

  function StoragePlugin() {
    (0, _classCallCheck2["default"])(this, StoragePlugin);
    return _super.call(this, profile);
  }

  (0, _createClass2["default"])(StoragePlugin, [{
    key: "getStorage",
    value: function () {
      var _getStorage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var storage, _paq;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                storage = null;

                if (!('storage' in navigator && 'estimate' in navigator.storage && window.remixFileSystem.name !== 'localstorage')) {
                  _context.next = 7;
                  break;
                }

                _context.next = 4;
                return navigator.storage.estimate();

              case 4:
                storage = _context.sent;
                _context.next = 8;
                break;

              case 7:
                storage = {
                  usage: parseFloat(this.calculateLocalStorage()) * 1000,
                  quota: 5000000
                };

              case 8:
                _paq = window._paq = window._paq || [];

                _paq.push(['trackEvent', 'Storage', 'used', this.formatString(storage)]);

                return _context.abrupt("return", storage);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getStorage() {
        return _getStorage.apply(this, arguments);
      }

      return getStorage;
    }()
  }, {
    key: "formatString",
    value: function formatString(storage) {
      return "".concat(this.formatBytes(storage.usage), " / ").concat(this.formatBytes(storage.quota));
    }
  }, {
    key: "calculateLocalStorage",
    value: function calculateLocalStorage() {
      var _lsTotal = 0;

      var _xLen;

      var _x;

      for (_x in localStorage) {
        // eslint-disable-next-line no-prototype-builtins
        if (!localStorage.hasOwnProperty(_x)) {
          continue;
        }

        _xLen = localStorage[_x].length + _x.length;
        _lsTotal += _xLen;
      }

      return (_lsTotal / 1024).toFixed(2);
    }
  }, {
    key: "formatBytes",
    value: function formatBytes(bytes) {
      var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      if (bytes === 0) return '0 Bytes';
      var k = 1024;
      var dm = decimals < 0 ? 0 : decimals;
      var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
      var i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
  }]);
  return StoragePlugin;
}(_engine.Plugin);

exports.StoragePlugin = StoragePlugin;

/***/ }),
/* 2257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layout = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engine = __webpack_require__(477);

var _events = __webpack_require__(40);

var _remixLib = __webpack_require__(311);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'layout',
  description: 'layout',
  methods: ['minimize']
};

var Layout = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(Layout, _Plugin);

  var _super = _createSuper(Layout);

  function Layout() {
    var _this;

    (0, _classCallCheck2["default"])(this, Layout);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "event", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "panels", void 0);
    _this.event = new _events.EventEmitter();
    return _this;
  }

  (0, _createClass2["default"])(Layout, [{
    key: "onActivation",
    value: function () {
      var _onActivation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _this2 = this;

        var queryParams, params;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.on('fileManager', 'currentFileChanged', function () {
                  _this2.panels.editor.active = true;
                  _this2.panels.main.active = false;

                  _this2.event.emit('change', null);
                });
                this.on('tabs', 'openFile', function () {
                  _this2.panels.editor.active = true;
                  _this2.panels.main.active = false;

                  _this2.event.emit('change', null);
                });
                this.on('tabs', 'switchApp', function (name) {
                  _this2.call('mainPanel', 'showContent', name);

                  _this2.panels.editor.active = false;
                  _this2.panels.main.active = true;

                  _this2.event.emit('change', null);
                });
                this.on('tabs', 'closeApp', function (name) {
                  _this2.panels.editor.active = true;
                  _this2.panels.main.active = false;

                  _this2.event.emit('change', null);
                });
                this.on('manager', 'activate', function (profile) {
                  switch (profile.name) {
                    case 'filePanel':
                      _this2.call('menuicons', 'select', 'filePanel');

                      break;
                  }
                });
                document.addEventListener('keypress', function (e) {
                  if (e.shiftKey && e.ctrlKey) {
                    if (e.code === 'KeyF') {
                      // Ctrl+Shift+F
                      _this2.call('menuicons', 'select', 'filePanel');
                    } else if (e.code === 'KeyA') {
                      // Ctrl+Shift+A
                      _this2.call('menuicons', 'select', 'pluginManager');
                    }

                    e.preventDefault();
                  }
                });
                queryParams = new _remixLib.QueryParams();
                params = queryParams.get();

                if (params.minimizeterminal || params.embed) {
                  this.panels.terminal.minimized = true;
                  this.event.emit('change', this.panels);
                  this.emit('change', this.panels);
                }

                if (params.minimizesidepanel || params.embed) {
                  this.event.emit('minimizesidepanel');
                }

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function onActivation() {
        return _onActivation.apply(this, arguments);
      }

      return onActivation;
    }()
  }, {
    key: "minimize",
    value: function minimize(name, minimized) {
      this.panels[name].minimized = minimized;
      this.event.emit('change', null);
    }
  }]);
  return Layout;
}(_engine.Plugin);

exports.Layout = Layout;

/***/ }),
/* 2258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotificationPlugin = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engine = __webpack_require__(477);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'notification',
  displayName: 'Notification',
  description: 'Displays notifications',
  methods: ['modal', 'alert', 'toast']
};

var NotificationPlugin = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(NotificationPlugin, _Plugin);

  var _super = _createSuper(NotificationPlugin);

  function NotificationPlugin() {
    var _this;

    (0, _classCallCheck2["default"])(this, NotificationPlugin);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dispatcher", void 0);
    return _this;
  }

  (0, _createClass2["default"])(NotificationPlugin, [{
    key: "setDispatcher",
    value: function setDispatcher(dispatcher) {
      this.dispatcher = dispatcher;
    }
  }, {
    key: "modal",
    value: function () {
      var _modal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(args) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.dispatcher.modal(args));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function modal(_x) {
        return _modal.apply(this, arguments);
      }

      return modal;
    }()
  }, {
    key: "alert",
    value: function () {
      var _alert = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(args) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.dispatcher.alert(args));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function alert(_x2) {
        return _alert.apply(this, arguments);
      }

      return alert;
    }()
  }, {
    key: "toast",
    value: function () {
      var _toast = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(message) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.dispatcher.toast(message);

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function toast(_x3) {
        return _toast.apply(this, arguments);
      }

      return toast;
    }()
  }]);
  return NotificationPlugin;
}(_engine.Plugin);

exports.NotificationPlugin = NotificationPlugin;

/***/ }),
/* 2259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Blockchain = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _web = _interopRequireDefault(__webpack_require__(1125));

var _engine = __webpack_require__(477);

var _ethereumjsUtil = __webpack_require__(34);

var _events = __webpack_require__(40);

var _util = __webpack_require__(313);

var _executionContext = __webpack_require__(2260);

var _vm = _interopRequireDefault(__webpack_require__(2261));

var _injected = _interopRequireDefault(__webpack_require__(2436));

var _node = _interopRequireDefault(__webpack_require__(2437));

var _remixLib = __webpack_require__(311);

var _helper = __webpack_require__(2438);

var _helper2 = __webpack_require__(1121);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var txFormat = _remixLib.execution.txFormat,
    txExecution = _remixLib.execution.txExecution,
    typeConversion = _remixLib.execution.typeConversion,
    Txlistener = _remixLib.execution.txListener,
    TxRunner = _remixLib.execution.TxRunner,
    TxRunnerWeb3 = _remixLib.execution.TxRunnerWeb3,
    txHelper = _remixLib.execution.txHelper;
var resultToRemixTx = _remixLib.helpers.txResultHelper;

var packageJson = __webpack_require__(312);

var _paq = window._paq = window._paq || []; //eslint-disable-line


var profile = {
  name: 'blockchain',
  displayName: 'Blockchain',
  description: 'Blockchain - Logic',
  methods: ['getCode', 'getTransactionReceipt', 'addProvider', 'removeProvider'],
  version: packageJson.version
};

var Blockchain = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(Blockchain, _Plugin);

  var _super = _createSuper(Blockchain);

  // NOTE: the config object will need to be refactored out in remix-lib
  function Blockchain(config) {
    var _this;

    (0, _classCallCheck2["default"])(this, Blockchain);
    _this = _super.call(this, profile);
    _this.event = new _remixLib.EventManager();
    _this.executionContext = new _executionContext.ExecutionContext();
    _this.events = new _events.EventEmitter();
    _this.config = config;
    var web3Runner = new TxRunnerWeb3({
      config: _this.config,
      detectNetwork: function detectNetwork(cb) {
        _this.executionContext.detectNetwork(cb);
      },
      isVM: function isVM() {
        return _this.executionContext.isVM();
      },
      personalMode: function personalMode() {
        return _this.getProvider() === 'web3' ? _this.config.get('settings/personal-mode') : false;
      }
    }, function (_) {
      return _this.executionContext.web3();
    }, function (_) {
      return _this.executionContext.currentblockGasLimit();
    });
    _this.txRunner = new TxRunner(web3Runner, {
      runAsync: true
    });

    _this.executionContext.event.register('contextChanged', _this.resetEnvironment.bind((0, _assertThisInitialized2["default"])(_this)));

    _this.networkcallid = 0;
    _this.networkStatus = {
      name: ' - ',
      id: ' - '
    };

    _this.setupEvents();

    _this.setupProviders();

    return _this;
  }

  (0, _createClass2["default"])(Blockchain, [{
    key: "setupEvents",
    value: function setupEvents() {
      var _this2 = this;

      this.executionContext.event.register('contextChanged', function (context, silent) {
        _this2.event.trigger('contextChanged', [context, silent]);
      });
      this.executionContext.event.register('addProvider', function (network) {
        _this2.event.trigger('addProvider', [network]);
      });
      this.executionContext.event.register('removeProvider', function (name) {
        _this2.event.trigger('removeProvider', [name]);
      });
      setInterval(function () {
        _this2.detectNetwork(function (error, network) {
          _this2.networkStatus = {
            network: network,
            error: error
          };

          _this2.event.trigger('networkStatus', [_this2.networkStatus]);
        });
      }, 1000);
    }
  }, {
    key: "getCurrentNetworkStatus",
    value: function getCurrentNetworkStatus() {
      return this.networkStatus;
    }
  }, {
    key: "setupProviders",
    value: function setupProviders() {
      this.providers = {};
      this.providers.vm = new _vm["default"](this.executionContext);
      this.providers.injected = new _injected["default"](this.executionContext);
      this.providers.web3 = new _node["default"](this.executionContext, this.config);
    }
  }, {
    key: "getCurrentProvider",
    value: function getCurrentProvider() {
      var provider = this.getProvider();
      if (this.providers[provider]) return this.providers[provider];
      return this.providers.web3; // default to the common type of provider
    }
    /** Return the list of accounts */
    // note: the dual promise/callback is kept for now as it was before

  }, {
    key: "getAccounts",
    value: function getAccounts(cb) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _this3.getCurrentProvider().getAccounts(function (error, accounts) {
          if (cb) {
            return cb(error, accounts);
          }

          if (error) {
            reject(error);
          }

          resolve(accounts);
        });
      });
    }
  }, {
    key: "deployContractAndLibraries",
    value: function deployContractAndLibraries(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
      var _this4 = this;

      var continueCb = callbacks.continueCb,
          promptCb = callbacks.promptCb,
          statusCb = callbacks.statusCb,
          finalCb = callbacks.finalCb;
      var constructor = selectedContract.getConstructorInterface();
      txFormat.buildData(selectedContract.name, selectedContract.object, compilerContracts, true, constructor, args, function (error, data) {
        if (error) {
          return statusCb("creation of ".concat(selectedContract.name, " errored: ").concat(error.message ? error.message : error));
        }

        statusCb("creation of ".concat(selectedContract.name, " pending..."));

        _this4.createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb);
      }, statusCb, function (data, runTxCallback) {
        // called for libraries deployment
        _this4.runTx(data, confirmationCb, continueCb, promptCb, runTxCallback);
      });
    }
  }, {
    key: "deployContractWithLibrary",
    value: function deployContractWithLibrary(selectedContract, args, contractMetadata, compilerContracts, callbacks, confirmationCb) {
      var _this5 = this;

      var continueCb = callbacks.continueCb,
          promptCb = callbacks.promptCb,
          statusCb = callbacks.statusCb,
          finalCb = callbacks.finalCb;
      var constructor = selectedContract.getConstructorInterface();
      txFormat.encodeConstructorCallAndLinkLibraries(selectedContract.object, args, constructor, contractMetadata.linkReferences, selectedContract.bytecodeLinkReferences, function (error, data) {
        if (error) {
          return statusCb("creation of ".concat(selectedContract.name, " errored: ").concat(error.message ? error.message : error));
        }

        statusCb("creation of ".concat(selectedContract.name, " pending..."));

        _this5.createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb);
      });
    }
  }, {
    key: "deployProxy",
    value: function () {
      var _deployProxy = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(proxyData, implementationContractObject) {
        var _this6 = this;

        var proxyModal;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                proxyModal = {
                  id: 'confirmProxyDeployment',
                  title: 'Confirm Deploy Proxy (ERC1967)',
                  message: "Confirm you want to deploy an ERC1967 proxy contract that is connected to your implementation.           \n      For more info on ERC1967, see: https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy",
                  modalType: 'modal',
                  okLabel: 'OK',
                  cancelLabel: 'Cancel',
                  okFn: function okFn() {
                    _this6.runProxyTx(proxyData, implementationContractObject);

                    _paq.push(['trackEvent', 'blockchain', 'Deploy With Proxy', 'modal ok confirmation']);
                  },
                  cancelFn: function cancelFn() {
                    _this6.call('notification', 'toast', (0, _helper2.cancelProxyMsg)());

                    _paq.push(['trackEvent', 'blockchain', 'Deploy With Proxy', 'cancel proxy deployment']);
                  },
                  hideFn: function hideFn() {
                    return null;
                  }
                };
                this.call('notification', 'modal', proxyModal);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function deployProxy(_x, _x2) {
        return _deployProxy.apply(this, arguments);
      }

      return deployProxy;
    }()
  }, {
    key: "runProxyTx",
    value: function () {
      var _runProxyTx = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(proxyData, implementationContractObject) {
        var _this7 = this;

        var args, networkInfo, confirmationCb, continueCb, promptCb, finalCb;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                args = {
                  useCall: false,
                  data: proxyData
                };

                confirmationCb = function confirmationCb(network, tx, gasEstimation, continueTxExecution, cancelCb) {
                  networkInfo = network; // continue using original authorization given by user

                  continueTxExecution(null);
                };

                continueCb = function continueCb(error, continueTxExecution, cancelCb) {
                  continueTxExecution();
                };

                promptCb = function promptCb(okCb, cancelCb) {
                  okCb();
                };

                finalCb = function finalCb(error, txResult, address, returnValue) {
                  if (error) {
                    var log = (0, _helper2.logBuilder)(error);

                    _paq.push(['trackEvent', 'blockchain', 'Deploy With Proxy', 'Proxy deployment failed: ' + error]);

                    return _this7.call('terminal', 'logHtml', log);
                  }

                  if (networkInfo.name === 'VM') _this7.config.set('vm/proxy', address);else _this7.config.set("".concat(networkInfo.name, "/").concat(networkInfo.currentFork, "/").concat(networkInfo.id, "/proxy"), address);

                  _paq.push(['trackEvent', 'blockchain', 'Deploy With Proxy', 'Proxy deployment successful']);

                  return _this7.call('udapp', 'resolveContractAndAddInstance', implementationContractObject, address);
                };

                this.runTx(args, confirmationCb, continueCb, promptCb, finalCb);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function runProxyTx(_x3, _x4) {
        return _runProxyTx.apply(this, arguments);
      }

      return runProxyTx;
    }()
  }, {
    key: "upgradeProxy",
    value: function () {
      var _upgradeProxy = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(proxyAddress, newImplAddress, data, newImplementationContractObject) {
        var _this8 = this;

        var upgradeModal;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                upgradeModal = {
                  id: 'confirmProxyDeployment',
                  title: 'Confirm Update Proxy (ERC1967)',
                  message: "Confirm you want to update your proxy contract with the new implementation contract's address:  ".concat(newImplAddress, "."),
                  modalType: 'modal',
                  okLabel: 'OK',
                  cancelLabel: 'Cancel',
                  okFn: function okFn() {
                    _this8.runUpgradeTx(proxyAddress, data, newImplementationContractObject);

                    _paq.push(['trackEvent', 'blockchain', 'Upgrade With Proxy', 'proxy upgrade confirmation click']);
                  },
                  cancelFn: function cancelFn() {
                    _this8.call('notification', 'toast', (0, _helper2.cancelUpgradeMsg)());

                    _paq.push(['trackEvent', 'blockchain', 'Upgrade With Proxy', 'proxy upgrade cancel click']);
                  },
                  hideFn: function hideFn() {
                    return null;
                  }
                };
                this.call('notification', 'modal', upgradeModal);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function upgradeProxy(_x5, _x6, _x7, _x8) {
        return _upgradeProxy.apply(this, arguments);
      }

      return upgradeProxy;
    }()
  }, {
    key: "runUpgradeTx",
    value: function () {
      var _runUpgradeTx = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(proxyAddress, data, newImplementationContractObject) {
        var _this9 = this;

        var args, confirmationCb, continueCb, promptCb, finalCb;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                args = {
                  useCall: false,
                  data: data,
                  to: proxyAddress
                };

                confirmationCb = function confirmationCb(network, tx, gasEstimation, continueTxExecution, cancelCb) {
                  // continue using original authorization given by user
                  continueTxExecution(null);
                };

                continueCb = function continueCb(error, continueTxExecution, cancelCb) {
                  continueTxExecution();
                };

                promptCb = function promptCb(okCb, cancelCb) {
                  okCb();
                };

                finalCb = function finalCb(error, txResult, address, returnValue) {
                  if (error) {
                    var log = (0, _helper2.logBuilder)(error);

                    _paq.push(['trackEvent', 'blockchain', 'Upgrade With Proxy', 'Upgrade failed']);

                    return _this9.call('terminal', 'logHtml', log);
                  }

                  _paq.push(['trackEvent', 'blockchain', 'Upgrade With Proxy', 'Upgrade Successful']);

                  return _this9.call('udapp', 'resolveContractAndAddInstance', newImplementationContractObject, proxyAddress);
                };

                this.runTx(args, confirmationCb, continueCb, promptCb, finalCb);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function runUpgradeTx(_x9, _x10, _x11) {
        return _runUpgradeTx.apply(this, arguments);
      }

      return runUpgradeTx;
    }()
  }, {
    key: "getEncodedFunctionHex",
    value: function () {
      var _getEncodedFunctionHex = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(args, funABI) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", new Promise(function (resolve, reject) {
                  txFormat.encodeFunctionCall(args, funABI, function (error, data) {
                    if (error) return reject(error);
                    resolve(data.dataHex);
                  });
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function getEncodedFunctionHex(_x12, _x13) {
        return _getEncodedFunctionHex.apply(this, arguments);
      }

      return getEncodedFunctionHex;
    }()
  }, {
    key: "getEncodedParams",
    value: function () {
      var _getEncodedParams = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(args, funABI) {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", new Promise(function (resolve, reject) {
                  txFormat.encodeParams(args, funABI, function (error, encodedParams) {
                    if (error) return reject(error);
                    return resolve(encodedParams.dataHex);
                  });
                }));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function getEncodedParams(_x14, _x15) {
        return _getEncodedParams.apply(this, arguments);
      }

      return getEncodedParams;
    }()
  }, {
    key: "createContract",
    value: function createContract(selectedContract, data, continueCb, promptCb, confirmationCb, finalCb) {
      if (data) {
        data.contractName = selectedContract.name;
        data.linkReferences = selectedContract.bytecodeLinkReferences;
        data.contractABI = selectedContract.abi;
      }

      this.runTx({
        data: data,
        useCall: false
      }, confirmationCb, continueCb, promptCb, function (error, txResult, address) {
        if (error) {
          return finalCb("creation of ".concat(selectedContract.name, " errored: ").concat(error.message ? error.message : error));
        }

        if (txResult.receipt.status === false || txResult.receipt.status === '0x0') {
          return finalCb("creation of ".concat(selectedContract.name, " errored: transaction execution failed"));
        }

        finalCb(null, selectedContract, address);
      });
    }
  }, {
    key: "determineGasPrice",
    value: function determineGasPrice(cb) {
      var _this10 = this;

      this.getCurrentProvider().getGasPrice(function (error, gasPrice) {
        var warnMessage = ' Please fix this issue before sending any transaction. ';

        if (error) {
          return cb('Unable to retrieve the current network gas price.' + warnMessage + error);
        }

        try {
          var gasPriceValue = _this10.fromWei(gasPrice, false, 'gwei');

          cb(null, gasPriceValue);
        } catch (e) {
          cb(warnMessage + e.message, null, false);
        }
      });
    }
  }, {
    key: "getInputs",
    value: function getInputs(funABI) {
      if (!funABI.inputs) {
        return '';
      }

      return txHelper.inputParametersDeclarationToString(funABI.inputs);
    }
  }, {
    key: "fromWei",
    value: function fromWei(value, doTypeConversion, unit) {
      if (doTypeConversion) {
        return _web["default"].utils.fromWei(typeConversion.toInt(value), unit || 'ether');
      }

      return _web["default"].utils.fromWei(value.toString(10), unit || 'ether');
    }
  }, {
    key: "toWei",
    value: function toWei(value, unit) {
      return _web["default"].utils.toWei(value, unit || 'gwei');
    }
  }, {
    key: "calculateFee",
    value: function calculateFee(gas, gasPrice, unit) {
      return _web["default"].utils.toBN(gas).mul(_web["default"].utils.toBN(_web["default"].utils.toWei(gasPrice.toString(10), unit || 'gwei')));
    }
  }, {
    key: "determineGasFees",
    value: function determineGasFees(tx) {
      var _this11 = this;

      var determineGasFeesCb = function determineGasFeesCb(gasPrice, cb) {
        var txFeeText, priceStatus; // TODO: this try catch feels like an anti pattern, can/should be
        // removed, but for now keeping the original logic

        try {
          var fee = _this11.calculateFee(tx.gas, gasPrice);

          txFeeText = ' ' + _this11.fromWei(fee, false, 'ether') + ' Ether';
          priceStatus = true;
        } catch (e) {
          txFeeText = ' Please fix this issue before sending any transaction. ' + e.message;
          priceStatus = false;
        }

        cb(txFeeText, priceStatus);
      };

      return determineGasFeesCb;
    }
  }, {
    key: "changeExecutionContext",
    value: function changeExecutionContext(context, confirmCb, infoCb, cb) {
      return this.executionContext.executionContextChange(context, null, confirmCb, infoCb, cb);
    }
  }, {
    key: "setProviderFromEndpoint",
    value: function setProviderFromEndpoint(target, context, cb) {
      return this.executionContext.setProviderFromEndpoint(target, context, cb);
    }
  }, {
    key: "detectNetwork",
    value: function detectNetwork(cb) {
      return this.executionContext.detectNetwork(cb);
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return this.executionContext.getProvider();
    }
  }, {
    key: "getInjectedWeb3Address",
    value: function getInjectedWeb3Address() {
      return this.executionContext.getSelectedAddress();
    }
    /**
     * return the fork name applied to the current envionment
     * @return {String} - fork name
     */

  }, {
    key: "getCurrentFork",
    value: function getCurrentFork() {
      return this.executionContext.getCurrentFork();
    }
  }, {
    key: "isWeb3Provider",
    value: function isWeb3Provider() {
      var isVM = this.getProvider() === 'vm';
      var isInjected = this.getProvider() === 'injected';
      return !isVM && !isInjected;
    }
  }, {
    key: "isInjectedWeb3",
    value: function isInjectedWeb3() {
      return this.getProvider() === 'injected';
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, passphrase, cb) {
      this.getCurrentProvider().signMessage(message, account, passphrase, cb);
    }
  }, {
    key: "web3",
    value: function web3() {
      // @todo(https://github.com/ethereum/remix-project/issues/431)
      var isVM = this.getProvider() === 'vm';

      if (isVM) {
        return this.providers.vm.web3;
      }

      return this.executionContext.web3();
    }
  }, {
    key: "getTxListener",
    value: function getTxListener(opts) {
      opts.event = {
        // udapp: this.udapp.event
        udapp: this.event
      };
      var txlistener = new Txlistener(opts, this.executionContext);
      return txlistener;
    }
  }, {
    key: "runOrCallContractMethod",
    value: function runOrCallContractMethod(contractName, contractAbi, funABI, contract, value, address, callType, lookupOnly, logMsg, logCallback, outputCb, confirmationCb, continueCb, promptCb) {
      var _this12 = this;

      // contractsDetails is used to resolve libraries
      txFormat.buildData(contractName, contractAbi, {}, false, funABI, callType, function (error, data) {
        if (error) {
          return logCallback("".concat(logMsg, " errored: ").concat(error.message ? error.message : error));
        }

        if (!lookupOnly) {
          logCallback("".concat(logMsg, " pending ... "));
        } else {
          logCallback("".concat(logMsg));
        }

        if (funABI.type === 'fallback') data.dataHex = value;

        if (data) {
          data.contractName = contractName;
          data.contractABI = contractAbi;
          data.contract = contract;
        }

        var useCall = funABI.stateMutability === 'view' || funABI.stateMutability === 'pure';

        _this12.runTx({
          to: address,
          data: data,
          useCall: useCall
        }, confirmationCb, continueCb, promptCb, function (error, txResult, _address, returnValue) {
          if (error) {
            return logCallback("".concat(logMsg, " errored: ").concat(error.message ? error.message : error));
          }

          if (lookupOnly) {
            outputCb(returnValue);
          }
        });
      }, function (msg) {
        logCallback(msg);
      }, function (data, runTxCallback) {
        // called for libraries deployment
        _this12.runTx(data, confirmationCb, runTxCallback, promptCb, function () {
          /* Do nothing. */
        });
      });
    }
  }, {
    key: "context",
    value: function context() {
      return this.executionContext.isVM() ? 'memory' : 'blockchain';
    } // NOTE: the config is only needed because exectuionContext.init does
    // if config.get('settings/always-use-vm'), we can simplify this later

  }, {
    key: "resetAndInit",
    value: function resetAndInit(config, transactionContextAPI) {
      this.transactionContextAPI = transactionContextAPI;
      this.executionContext.init(config);
      this.executionContext.stopListenOnLastBlock();
      this.executionContext.listenOnLastBlock();
      this.resetEnvironment();
    }
  }, {
    key: "addProvider",
    value: function addProvider(provider) {
      this.executionContext.addProvider(provider);
    }
  }, {
    key: "removeProvider",
    value: function removeProvider(name) {
      this.executionContext.removeProvider(name);
    } // TODO : event should be triggered by Udapp instead of TxListener

    /** Listen on New Transaction. (Cannot be done inside constructor because txlistener doesn't exist yet) */

  }, {
    key: "startListening",
    value: function startListening(txlistener) {
      var _this13 = this;

      txlistener.event.register('newTransaction', function (tx, receipt) {
        _this13.events.emit('newTransaction', tx, receipt);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {
      var _this14 = this;

      this.getCurrentProvider().resetEnvironment(); // TODO: most params here can be refactored away in txRunner

      var web3Runner = new TxRunnerWeb3({
        config: this.config,
        detectNetwork: function detectNetwork(cb) {
          _this14.executionContext.detectNetwork(cb);
        },
        isVM: function isVM() {
          return _this14.executionContext.isVM();
        },
        personalMode: function personalMode() {
          return _this14.getProvider() === 'web3' ? _this14.config.get('settings/personal-mode') : false;
        }
      }, function (_) {
        return _this14.executionContext.web3();
      }, function (_) {
        return _this14.executionContext.currentblockGasLimit();
      });
      web3Runner.event.register('transactionBroadcasted', function (txhash) {
        _this14.executionContext.detectNetwork(function (error, network) {
          if (error || !network) return;
          if (network.name === 'VM') return;
          var viewEtherScanLink = (0, _helper.etherScanLink)(network.name, txhash);

          if (viewEtherScanLink) {
            _this14.call('terminal', 'logHtml', /*#__PURE__*/_react["default"].createElement("a", {
              href: (0, _helper.etherScanLink)(network.name, txhash),
              target: "_blank"
            }, "view on etherscan"));
          }
        });
      });
      this.txRunner = new TxRunner(web3Runner, {
        runAsync: true
      });
    }
    /**
     * Create a VM Account
     * @param {{privateKey: string, balance: string}} newAccount The new account to create
     */

  }, {
    key: "createVMAccount",
    value: function createVMAccount(newAccount) {
      if (this.getProvider() !== 'vm') {
        throw new Error('plugin API does not allow creating a new account through web3 connection. Only vm mode is allowed');
      }

      return this.providers.vm.createVMAccount(newAccount);
    }
  }, {
    key: "newAccount",
    value: function newAccount(_password, passwordPromptCb, cb) {
      return this.getCurrentProvider().newAccount(passwordPromptCb, cb);
    }
    /** Get the balance of an address, and convert wei to ether */

  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      this.getCurrentProvider().getBalanceInEther(address, cb);
    }
  }, {
    key: "pendingTransactionsCount",
    value: function pendingTransactionsCount() {
      return Object.keys(this.txRunner.pendingTxs).length;
    }
  }, {
    key: "getCode",
    value: function () {
      var _getCode = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(address) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.web3().eth.getCode(address);

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getCode(_x16) {
        return _getCode.apply(this, arguments);
      }

      return getCode;
    }()
  }, {
    key: "getTransactionReceipt",
    value: function () {
      var _getTransactionReceipt = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(hash) {
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.web3().eth.getTransactionReceipt(hash);

              case 2:
                return _context8.abrupt("return", _context8.sent);

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getTransactionReceipt(_x17) {
        return _getTransactionReceipt.apply(this, arguments);
      }

      return getTransactionReceipt;
    }()
    /**
     * This function send a tx only to Remix VM or testnet, will return an error for the mainnet
     * SHOULD BE TAKEN CAREFULLY!
     *
     * @param {Object} tx    - transaction.
     */

  }, {
    key: "sendTransaction",
    value: function sendTransaction(tx) {
      var _this15 = this;

      return new Promise(function (resolve, reject) {
        _this15.executionContext.detectNetwork(function (error, network) {
          if (error) return reject(error);

          if (network.name === 'Main' && network.id === '1') {
            return reject(new Error('It is not allowed to make this action against mainnet'));
          }

          _this15.txRunner.rawRun(tx, function (network, tx, gasEstimation, continueTxExecution, cancelCb) {
            continueTxExecution();
          }, function (error, continueTxExecution, cancelCb) {
            if (error) {
              reject(error);
            } else {
              continueTxExecution();
            }
          }, function (okCb, cancelCb) {
            okCb();
          }, /*#__PURE__*/function () {
            var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(error, result) {
              var execResult;
              return _regenerator["default"].wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      if (!error) {
                        _context9.next = 2;
                        break;
                      }

                      return _context9.abrupt("return", reject(error));

                    case 2:
                      _context9.prev = 2;
                      _context9.next = 5;
                      return _this15.web3().eth.getExecutionResultFromSimulator(result.transactionHash);

                    case 5:
                      execResult = _context9.sent;
                      resolve(resultToRemixTx(result, execResult));
                      _context9.next = 12;
                      break;

                    case 9:
                      _context9.prev = 9;
                      _context9.t0 = _context9["catch"](2);
                      reject(_context9.t0);

                    case 12:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, null, [[2, 9]]);
            }));

            return function (_x18, _x19) {
              return _ref.apply(this, arguments);
            };
          }());
        });
      });
    }
  }, {
    key: "runTx",
    value: function () {
      var _runTx = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(args, confirmationCb, continueCb, promptCb, cb) {
        var _this16 = this;

        var getGasLimit, queryValue, getAccount, runTransaction, transaction, txResult, tx, isVM, execResult, returnValue, hhlogs, finalLogs, _iterator, _step, log, formattedLog, compiledContracts, vmError, address;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                getGasLimit = function getGasLimit() {
                  return new Promise(function (resolve, reject) {
                    if (_this16.transactionContextAPI.getGasLimit) {
                      return _this16.transactionContextAPI.getGasLimit(function (err, value) {
                        if (err) return reject(err);
                        return resolve(value);
                      });
                    }

                    return resolve(3000000);
                  });
                };

                queryValue = function queryValue() {
                  return new Promise(function (resolve, reject) {
                    if (args.value) {
                      return resolve(args.value);
                    }

                    if (args.useCall || !_this16.transactionContextAPI.getValue) {
                      return resolve(0);
                    }

                    _this16.transactionContextAPI.getValue(function (err, value) {
                      if (err) return reject(err);
                      return resolve(value);
                    });
                  });
                };

                getAccount = function getAccount() {
                  return new Promise(function (resolve, reject) {
                    if (args.from) {
                      return resolve(args.from);
                    }

                    if (_this16.transactionContextAPI.getAddress) {
                      return _this16.transactionContextAPI.getAddress(function (err, address) {
                        if (err) return reject(err);
                        if (!address) return reject('"from" is not defined. Please make sure an account is selected. If you are using a public node, it is likely that no account will be provided. In that case, add the public node to your injected provider (type Metamask) and use injected provider in Remix.');
                        return resolve(address);
                      });
                    }

                    _this16.getAccounts(function (err, accounts) {
                      if (err) return reject(err);
                      var address = accounts[0];
                      if (!address) return reject('No accounts available');

                      if (this.executionContext.isVM() && !this.providers.vm.RemixSimulatorProvider.Accounts.accounts[address]) {
                        return reject('Invalid account selected');
                      }

                      return resolve(address);
                    });
                  });
                };

                runTransaction = /*#__PURE__*/function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12() {
                    return _regenerator["default"].wrap(function _callee12$(_context12) {
                      while (1) {
                        switch (_context12.prev = _context12.next) {
                          case 0:
                            return _context12.abrupt("return", new Promise( /*#__PURE__*/function () {
                              var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(resolve, reject) {
                                var fromAddress, value, gasLimit, tx, payLoad, timestamp, error;
                                return _regenerator["default"].wrap(function _callee11$(_context11) {
                                  while (1) {
                                    switch (_context11.prev = _context11.next) {
                                      case 0:
                                        _context11.prev = 0;
                                        _context11.next = 3;
                                        return getAccount();

                                      case 3:
                                        fromAddress = _context11.sent;
                                        _context11.next = 6;
                                        return queryValue();

                                      case 6:
                                        value = _context11.sent;
                                        _context11.next = 9;
                                        return getGasLimit();

                                      case 9:
                                        gasLimit = _context11.sent;
                                        _context11.next = 16;
                                        break;

                                      case 12:
                                        _context11.prev = 12;
                                        _context11.t0 = _context11["catch"](0);
                                        reject(_context11.t0);
                                        return _context11.abrupt("return");

                                      case 16:
                                        tx = {
                                          to: args.to,
                                          data: args.data.dataHex,
                                          useCall: args.useCall,
                                          from: fromAddress,
                                          value: value,
                                          gasLimit: gasLimit,
                                          timestamp: args.data.timestamp
                                        };
                                        payLoad = {
                                          funAbi: args.data.funAbi,
                                          funArgs: args.data.funArgs,
                                          contractBytecode: args.data.contractBytecode,
                                          contractName: args.data.contractName,
                                          contractABI: args.data.contractABI,
                                          linkReferences: args.data.linkReferences
                                        };
                                        if (!tx.timestamp) tx.timestamp = Date.now();
                                        timestamp = tx.timestamp;

                                        _this16.event.trigger('initiatingTransaction', [timestamp, tx, payLoad]);

                                        _context11.prev = 21;

                                        _this16.txRunner.rawRun(tx, confirmationCb, continueCb, promptCb, /*#__PURE__*/function () {
                                          var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(error, result) {
                                            var isVM, eventName;
                                            return _regenerator["default"].wrap(function _callee10$(_context10) {
                                              while (1) {
                                                switch (_context10.prev = _context10.next) {
                                                  case 0:
                                                    if (!error) {
                                                      _context10.next = 3;
                                                      break;
                                                    }

                                                    if (typeof error !== 'string') {
                                                      if (error.message) error = error.message;else {
                                                        try {
                                                          error = 'error: ' + JSON.stringify(error);
                                                        } catch (e) {
                                                          console.log(e);
                                                        }
                                                      }
                                                    }

                                                    return _context10.abrupt("return", reject(error));

                                                  case 3:
                                                    isVM = _this16.executionContext.isVM();

                                                    if (!(isVM && tx.useCall)) {
                                                      _context10.next = 14;
                                                      break;
                                                    }

                                                    _context10.prev = 5;
                                                    _context10.next = 8;
                                                    return _this16.web3().eth.getHashFromTagBySimulator(timestamp);

                                                  case 8:
                                                    result.transactionHash = _context10.sent;
                                                    _context10.next = 14;
                                                    break;

                                                  case 11:
                                                    _context10.prev = 11;
                                                    _context10.t0 = _context10["catch"](5);
                                                    console.log('unable to retrieve back the "call" hash', _context10.t0);

                                                  case 14:
                                                    eventName = tx.useCall ? 'callExecuted' : 'transactionExecuted';

                                                    _this16.event.trigger(eventName, [error, tx.from, tx.to, tx.data, tx.useCall, result, timestamp, payLoad]);

                                                    return _context10.abrupt("return", resolve({
                                                      result: result,
                                                      tx: tx
                                                    }));

                                                  case 17:
                                                  case "end":
                                                    return _context10.stop();
                                                }
                                              }
                                            }, _callee10, null, [[5, 11]]);
                                          }));

                                          return function (_x27, _x28) {
                                            return _ref4.apply(this, arguments);
                                          };
                                        }());

                                        _context11.next = 30;
                                        break;

                                      case 25:
                                        _context11.prev = 25;
                                        _context11.t1 = _context11["catch"](21);
                                        error = _context11.t1;

                                        if (error && typeof error !== 'string') {
                                          if (error.message) error = error.message;else {
                                            try {
                                              error = 'error: ' + JSON.stringify(error);
                                            } catch (e) {
                                              console.log(e);
                                            }
                                          }
                                        }

                                        return _context11.abrupt("return", reject(error));

                                      case 30:
                                      case "end":
                                        return _context11.stop();
                                    }
                                  }
                                }, _callee11, null, [[0, 12], [21, 25]]);
                              }));

                              return function (_x25, _x26) {
                                return _ref3.apply(this, arguments);
                              };
                            }()));

                          case 1:
                          case "end":
                            return _context12.stop();
                        }
                      }
                    }, _callee12);
                  }));

                  return function runTransaction() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                _context13.prev = 4;
                _context13.next = 7;
                return runTransaction();

              case 7:
                transaction = _context13.sent;
                txResult = transaction.result;
                tx = transaction.tx;
                /*
                value of txResult is inconsistent:
                    - transact to contract:
                      {"receipt": { ... }, "tx":{ ... }, "transactionHash":"0x7ba4c05075210fdbcf4e6660258379db5cc559e15703f9ac6f970a320c2dee09"}
                    - call to contract:
                      {"result":"0x0000000000000000000000000000000000000000000000000000000000000000","transactionHash":"0x5236a76152054a8aad0c7135bcc151f03bccb773be88fbf4823184e47fc76247"}
                */

                isVM = this.executionContext.isVM();
                returnValue = null;

                if (!isVM) {
                  _context13.next = 28;
                  break;
                }

                _context13.next = 15;
                return this.web3().eth.getHHLogsForTx(txResult.transactionHash);

              case 15:
                hhlogs = _context13.sent;

                if (hhlogs && hhlogs.length) {
                  finalLogs = '<b>console.log:</b>\n';
                  _iterator = _createForOfIteratorHelper(hhlogs);

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      log = _step.value;
                      formattedLog = void 0; // Hardhat implements the same formatting options that can be found in Node.js' console.log,
                      // which in turn uses util.format: https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args
                      // For example: console.log("Name: %s, Age: %d", remix, 6) will log 'Name: remix, Age: 6'
                      // We check first arg to determine if 'util.format' is needed

                      if (typeof log[0] === 'string' && (log[0].includes('%s') || log[0].includes('%d'))) {
                        formattedLog = _util.format.apply(void 0, [log[0]].concat((0, _toConsumableArray2["default"])(log.slice(1))));
                      } else {
                        formattedLog = log.join(' ');
                      }

                      finalLogs = finalLogs + '&emsp;' + formattedLog + '\n';
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }

                  _paq.push(['trackEvent', 'udapp', 'hardhat', 'console.log']);

                  this.call('terminal', 'log', {
                    type: 'info',
                    value: finalLogs
                  });
                }

                _context13.next = 19;
                return this.web3().eth.getExecutionResultFromSimulator(txResult.transactionHash);

              case 19:
                execResult = _context13.sent;

                if (!execResult) {
                  _context13.next = 28;
                  break;
                }

                // if it's not the VM, we don't have return value. We only have the transaction, and it does not contain the return value.
                returnValue = execResult ? execResult.returnValue : (0, _ethereumjsUtil.toBuffer)((0, _ethereumjsUtil.addHexPrefix)(txResult.result) || '0x0000000000000000000000000000000000000000000000000000000000000000');
                _context13.next = 24;
                return this.call('compilerArtefacts', 'getAllContractDatas');

              case 24:
                compiledContracts = _context13.sent;
                vmError = txExecution.checkVMError(execResult, compiledContracts);

                if (!vmError.error) {
                  _context13.next = 28;
                  break;
                }

                return _context13.abrupt("return", cb(vmError.message));

              case 28:
                if (!isVM && tx && tx.useCall) {
                  returnValue = (0, _ethereumjsUtil.toBuffer)((0, _ethereumjsUtil.addHexPrefix)(txResult.result));
                }

                address = null;

                if (txResult && txResult.receipt) {
                  address = txResult.receipt.contractAddress;
                }

                cb(null, txResult, address, returnValue);
                _context13.next = 37;
                break;

              case 34:
                _context13.prev = 34;
                _context13.t0 = _context13["catch"](4);
                cb(_context13.t0);

              case 37:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[4, 34]]);
      }));

      function runTx(_x20, _x21, _x22, _x23, _x24) {
        return _runTx.apply(this, arguments);
      }

      return runTx;
    }()
  }]);
  return Blockchain;
}(_engine.Plugin);

exports.Blockchain = Blockchain;

/***/ }),
/* 2260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global ethereum */


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExecutionContext = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _web2 = _interopRequireDefault(__webpack_require__(1125));

var _remixLib = __webpack_require__(311);

var _events = _interopRequireDefault(__webpack_require__(1196));

var _paq = window._paq = window._paq || [];

var _web;

if (typeof window !== 'undefined' && typeof window.ethereum !== 'undefined') {
  var injectedProvider = window.ethereum;
  _web = new _web2["default"](injectedProvider);
} else {
  _web = new _web2["default"](new _web2["default"].providers.HttpProvider('http://localhost:8545'));
}
/*
  trigger contextChanged, web3EndpointChanged
*/


var ExecutionContext = /*#__PURE__*/function () {
  function ExecutionContext() {
    (0, _classCallCheck2["default"])(this, ExecutionContext);
    this.event = new _events["default"]();
    this.executionContext = null;
    this.lastBlock = null;
    this.blockGasLimitDefault = 4300000;
    this.blockGasLimit = this.blockGasLimitDefault;
    this.currentFork = 'london';
    this.mainNetGenesisHash = '0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3';
    this.customNetWorks = {};
    this.blocks = {};
    this.latestBlockNumber = 0;
    this.txs = {};
    this.customWeb3 = {}; // mapping between a context name and a web3.js instance
  }

  (0, _createClass2["default"])(ExecutionContext, [{
    key: "init",
    value: function init(config) {
      if (config.get('settings/always-use-vm')) {
        this.executionContext = 'vm';
      } else {
        this.executionContext = injectedProvider ? 'injected' : 'vm';
        if (this.executionContext === 'injected') this.askPermission();
      }
    }
  }, {
    key: "askPermission",
    value: function askPermission() {
      // metamask
      if (ethereum && typeof ethereum.enable === 'function') ethereum.enable();
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return this.executionContext;
    }
  }, {
    key: "getSelectedAddress",
    value: function getSelectedAddress() {
      return injectedProvider ? injectedProvider.selectedAddress : null;
    }
  }, {
    key: "getCurrentFork",
    value: function getCurrentFork() {
      return this.currentFork;
    }
  }, {
    key: "isVM",
    value: function isVM() {
      return this.executionContext === 'vm';
    }
  }, {
    key: "setWeb3",
    value: function setWeb3(context, web3) {
      this.customWeb3[context] = web3;
    }
  }, {
    key: "web3",
    value: function web3() {
      if (this.customWeb3[this.executionContext]) return this.customWeb3[this.executionContext];
      return _web;
    }
  }, {
    key: "detectNetwork",
    value: function detectNetwork(callback) {
      var _this = this;

      if (this.isVM()) {
        callback(null, {
          id: '-',
          name: 'VM'
        });
      } else {
        if (!_web.currentProvider) {
          return callback('No provider set');
        }

        if (_web.currentProvider.isConnected && !_web.currentProvider.isConnected()) {
          if (_web.currentProvider.isMetaMask) {
            this.askPermission();
          }

          return callback('Provider not connected');
        }

        _web.eth.net.getId(function (err, id) {
          var name = null;
          if (err) name = 'Unknown'; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
          else if (id === 1) name = 'Main';else if (id === 3) name = 'Ropsten';else if (id === 4) name = 'Rinkeby';else if (id === 5) name = 'Goerli';else if (id === 42) name = 'Kovan';else name = 'Custom';

          if (id === '1') {
            _web.eth.getBlock(0, function (error, block) {
              if (error) console.log('cant query first block');
              if (block && block.hash !== _this.mainNetGenesisHash) name = 'Custom';
              callback(err, {
                id: id,
                name: name,
                lastBlock: _this.lastBlock,
                currentFork: _this.currentFork
              });
            });
          } else {
            callback(err, {
              id: id,
              name: name,
              lastBlock: _this.lastBlock,
              currentFork: _this.currentFork
            });
          }
        });
      }
    }
  }, {
    key: "removeProvider",
    value: function removeProvider(name) {
      if (name && this.customNetWorks[name]) {
        if (this.executionContext === name) this.setContext('vm', null, null, null);
        delete this.customNetWorks[name];
        this.event.trigger('removeProvider', [name]);
      }
    }
  }, {
    key: "addProvider",
    value: function addProvider(network) {
      if (network && network.name && !this.customNetWorks[network.name]) {
        this.customNetWorks[network.name] = network;
        this.event.trigger('addProvider', [network]);
      }
    }
  }, {
    key: "internalWeb3",
    value: function internalWeb3() {
      return _web;
    }
  }, {
    key: "blankWeb3",
    value: function blankWeb3() {
      return new _web2["default"]();
    }
  }, {
    key: "setContext",
    value: function setContext(context, endPointUrl, confirmCb, infoCb) {
      this.executionContext = context;
      this.executionContextChange(context, endPointUrl, confirmCb, infoCb, null);
    }
  }, {
    key: "executionContextChange",
    value: function () {
      var _executionContextChange = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(value, endPointUrl, confirmCb, infoCb, cb) {
        var context, network;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _paq.push(['trackEvent', 'udapp', 'providerChanged', value.context]);

                context = value.context;
                if (!cb) cb = function cb() {
                  /* Do nothing. */
                };
                if (!confirmCb) confirmCb = function confirmCb() {
                  /* Do nothing. */
                };
                if (!infoCb) infoCb = function infoCb() {
                  /* Do nothing. */
                };

                if (!(context === 'vm')) {
                  _context.next = 10;
                  break;
                }

                this.executionContext = context;
                this.currentFork = value.fork;
                this.event.trigger('contextChanged', ['vm']);
                return _context.abrupt("return", cb());

              case 10:
                if (!(context === 'injected')) {
                  _context.next = 28;
                  break;
                }

                if (!(injectedProvider === undefined)) {
                  _context.next = 16;
                  break;
                }

                infoCb('No injected provider found. Make sure your provider (e.g. MetaMask) is active and running (when recently activated you may have to reload the page).');
                return _context.abrupt("return", cb());

              case 16:
                if (!(injectedProvider && injectedProvider._metamask && injectedProvider._metamask.isUnlocked)) {
                  _context.next = 21;
                  break;
                }

                _context.next = 19;
                return injectedProvider._metamask.isUnlocked();

              case 19:
                if (_context.sent) {
                  _context.next = 21;
                  break;
                }

                infoCb('Please make sure the injected provider is unlocked (e.g Metamask).');

              case 21:
                this.askPermission();
                this.executionContext = context;

                _web.setProvider(injectedProvider);

                _context.next = 26;
                return this._updateChainContext();

              case 26:
                this.event.trigger('contextChanged', ['injected']);
                return _context.abrupt("return", cb());

              case 28:
                if (!this.customNetWorks[context]) {
                  _context.next = 41;
                  break;
                }

                network = this.customNetWorks[context];

                if (this.customNetWorks[context].isInjected) {
                  _context.next = 34;
                  break;
                }

                this.setProviderFromEndpoint(network.provider, {
                  context: network.name
                }, function (error) {
                  if (error) infoCb(error);
                  cb();
                });
                _context.next = 41;
                break;

              case 34:
                // injected
                this.askPermission();
                this.executionContext = context;

                _web.setProvider(network.provider);

                _context.next = 39;
                return this._updateChainContext();

              case 39:
                this.event.trigger('contextChanged', [context]);
                return _context.abrupt("return", cb());

              case 41:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function executionContextChange(_x, _x2, _x3, _x4, _x5) {
        return _executionContextChange.apply(this, arguments);
      }

      return executionContextChange;
    }()
  }, {
    key: "currentblockGasLimit",
    value: function currentblockGasLimit() {
      return this.blockGasLimit;
    }
  }, {
    key: "stopListenOnLastBlock",
    value: function stopListenOnLastBlock() {
      if (this.listenOnLastBlockId) clearInterval(this.listenOnLastBlockId);
      this.listenOnLastBlockId = null;
    }
  }, {
    key: "_updateChainContext",
    value: function () {
      var _updateChainContext2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var block;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this.getProvider() !== 'vm')) {
                  _context2.next = 27;
                  break;
                }

                _context2.prev = 1;
                _context2.next = 4;
                return _web.eth.getBlock('latest');

              case 4:
                block = _context2.sent;
                // we can't use the blockGasLimit cause the next blocks could have a lower limit : https://github.com/ethereum/remix/issues/506
                this.blockGasLimit = block && block.gasLimit ? Math.floor(block.gasLimit - 5 * block.gasLimit / 1024) : this.blockGasLimitDefault;
                this.lastBlock = block;
                _context2.prev = 7;
                _context2.t0 = _remixLib.execution;
                _context2.next = 11;
                return _web.eth.net.getId();

              case 11:
                _context2.t1 = _context2.sent;
                _context2.t2 = block.number;
                this.currentFork = _context2.t0.forkAt.call(_context2.t0, _context2.t1, _context2.t2);
                _context2.next = 21;
                break;

              case 16:
                _context2.prev = 16;
                _context2.t3 = _context2["catch"](7);
                this.currentFork = 'london';
                console.log("unable to detect fork, defaulting to ".concat(this.currentFork, ".."));
                console.error(_context2.t3);

              case 21:
                _context2.next = 27;
                break;

              case 23:
                _context2.prev = 23;
                _context2.t4 = _context2["catch"](1);
                console.error(_context2.t4);
                this.blockGasLimit = this.blockGasLimitDefault;

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[1, 23], [7, 16]]);
      }));

      function _updateChainContext() {
        return _updateChainContext2.apply(this, arguments);
      }

      return _updateChainContext;
    }()
  }, {
    key: "listenOnLastBlock",
    value: function listenOnLastBlock() {
      var _this2 = this;

      this.listenOnLastBlockId = setInterval(function () {
        _this2._updateChainContext();
      }, 15000);
    } // TODO: remove this when this function is moved

  }, {
    key: "setProviderFromEndpoint",
    value: function setProviderFromEndpoint(endpoint, value, cb) {
      var _this3 = this;

      var oldProvider = _web.currentProvider;
      var context = value.context;

      _web.setProvider(endpoint);

      _web.eth.net.isListening(function (err, isConnected) {
        if (!err && isConnected === true) {
          _this3.executionContext = context;

          _this3._updateChainContext();

          _this3.event.trigger('contextChanged', [context]);

          _this3.event.trigger('web3EndpointChanged');

          cb();
        } else if (isConnected === 'canceled') {
          _web.setProvider(oldProvider);

          cb();
        } else {
          _web.setProvider(oldProvider);

          cb("Not possible to connect to ".concat(context, ". Make sure the provider is running, a connection is open (via IPC or RPC) or that the provider plugin is properly configured."));
        }
      });
    }
  }, {
    key: "txDetailsLink",
    value: function txDetailsLink(network, hash) {
      var transactionDetailsLinks = {
        Main: 'https://www.etherscan.io/tx/',
        Rinkeby: 'https://rinkeby.etherscan.io/tx/',
        Ropsten: 'https://ropsten.etherscan.io/tx/',
        Kovan: 'https://kovan.etherscan.io/tx/',
        Goerli: 'https://goerli.etherscan.io/tx/'
      };

      if (transactionDetailsLinks[network]) {
        return transactionDetailsLinks[network] + hash;
      }
    }
  }]);
  return ExecutionContext;
}();

exports.ExecutionContext = ExecutionContext;

/***/ }),
/* 2261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _interopRequireDefault = __webpack_require__(30);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var Web3 = __webpack_require__(1125);

var _require = __webpack_require__(34),
    BN = _require.BN,
    privateToAddress = _require.privateToAddress,
    hashPersonalMessage = _require.hashPersonalMessage;

var _require2 = __webpack_require__(1547),
    Provider = _require2.Provider,
    extend = _require2.extend;

var VMProvider = /*#__PURE__*/function () {
  function VMProvider(executionContext) {
    (0, _classCallCheck2["default"])(this, VMProvider);
    this.executionContext = executionContext;
  }

  (0, _createClass2["default"])(VMProvider, [{
    key: "getAccounts",
    value: function getAccounts(cb) {
      this.web3.eth.getAccounts(function (err, accounts) {
        if (err) {
          return cb('No accounts?');
        }

        return cb(null, accounts);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {
      this.accounts = {};
      this.RemixSimulatorProvider = new Provider({
        fork: this.executionContext.getCurrentFork()
      });
      this.RemixSimulatorProvider.init();
      this.web3 = new Web3(this.RemixSimulatorProvider);
      extend(this.web3);
      this.accounts = {};
      this.executionContext.setWeb3('vm', this.web3);
    } // TODO: is still here because of the plugin API
    // can be removed later when we update the API

  }, {
    key: "createVMAccount",
    value: function createVMAccount(newAccount) {
      var privateKey = newAccount.privateKey,
          balance = newAccount.balance;

      this.RemixSimulatorProvider.Accounts._addAccount(privateKey, balance);

      var privKey = Buffer.from(privateKey, 'hex');
      return '0x' + privateToAddress(privKey).toString('hex');
    }
  }, {
    key: "newAccount",
    value: function newAccount(_passwordPromptCb, cb) {
      this.RemixSimulatorProvider.Accounts.newAccount(cb);
    }
  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      this.web3.eth.getBalance(address, function (err, res) {
        if (err) {
          return cb(err);
        }

        cb(null, Web3.utils.fromWei(new BN(res).toString(10), 'ether'));
      });
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice(cb) {
      this.web3.eth.getGasPrice(cb);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, _passphrase, cb) {
      var messageHash = hashPersonalMessage(Buffer.from(message));
      this.web3.eth.sign(message, account, function (error, signedData) {
        if (error) {
          return cb(error);
        }

        cb(null, '0x' + messageHash.toString('hex'), signedData);
      });
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return 'vm';
    }
  }]);
  return VMProvider;
}();

module.exports = VMProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extend = exports.Provider = void 0;

const tslib_1 = __webpack_require__(23);

const blocks_1 = __webpack_require__(2263);

const logs_1 = __webpack_require__(2264);

const merge_1 = (0, tslib_1.__importDefault)(__webpack_require__(2267));

const accounts_1 = __webpack_require__(2268);

const filters_1 = __webpack_require__(2269);

const misc_1 = __webpack_require__(2270);

const net_1 = __webpack_require__(2272);

const transactions_1 = __webpack_require__(2273);

const debug_1 = __webpack_require__(2275);

const genesis_1 = __webpack_require__(2276);

const vm_context_1 = __webpack_require__(2277);

class Provider {
  constructor(options = {}) {
    this.options = options;
    this.connected = true;
    this.vmContext = new vm_context_1.VMContext(options['fork']);
    this.Accounts = new accounts_1.Accounts(this.vmContext);
    this.Transactions = new transactions_1.Transactions(this.vmContext);
    this.methods = {};
    this.methods = (0, merge_1.default)(this.methods, this.Accounts.methods());
    this.methods = (0, merge_1.default)(this.methods, new blocks_1.Blocks(this.vmContext, options).methods());
    this.methods = (0, merge_1.default)(this.methods, (0, misc_1.methods)());
    this.methods = (0, merge_1.default)(this.methods, new filters_1.Filters(this.vmContext).methods());
    this.methods = (0, merge_1.default)(this.methods, (0, net_1.methods)());
    this.methods = (0, merge_1.default)(this.methods, this.Transactions.methods());
    this.methods = (0, merge_1.default)(this.methods, new debug_1.Debug(this.vmContext).methods());
  }

  init() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      yield (0, genesis_1.generateBlock)(this.vmContext);
      yield this.Accounts.resetAccounts();
      this.Transactions.init(this.Accounts.accounts);
    });
  }

  sendAsync(payload, callback) {
    // log.info('payload method is ', payload.method) // commented because, this floods the IDE console
    const method = this.methods[payload.method];

    if (this.options.logDetails) {
      (0, logs_1.info)(payload);
    }

    if (method) {
      return method.call(method, payload, (err, result) => {
        if (this.options.logDetails) {
          (0, logs_1.info)(err);
          (0, logs_1.info)(result);
        }

        if (err) {
          return callback(err);
        }

        const response = {
          id: payload.id,
          jsonrpc: '2.0',
          result: result
        };
        callback(null, response);
      });
    }

    callback(new Error('unknown method ' + payload.method));
  }

  send(payload, callback) {
    this.sendAsync(payload, callback || function () {});
  }

  isConnected() {
    return true;
  }

  disconnect() {
    return false;
  }

  supportsSubscriptions() {
    return true;
  }

  on(type, cb) {
    this.vmContext.logsManager.addListener(type, cb);
  }

}

exports.Provider = Provider;

function extend(web3) {
  if (!web3.extend) {
    return;
  } // DEBUG


  const methods = [];

  if (!(web3.eth && web3.eth.getExecutionResultFromSimulator)) {
    methods.push(new web3.extend.Method({
      name: 'getExecutionResultFromSimulator',
      call: 'eth_getExecutionResultFromSimulator',
      inputFormatter: [null],
      params: 1
    }));
  }

  if (!(web3.eth && web3.eth.getHHLogsForTx)) {
    methods.push(new web3.extend.Method({
      name: 'getHHLogsForTx',
      call: 'eth_getHHLogsForTx',
      inputFormatter: [null],
      params: 1
    }));
  }

  if (!(web3.eth && web3.eth.getHashFromTagBySimulator)) {
    methods.push(new web3.extend.Method({
      name: 'getHashFromTagBySimulator',
      call: 'eth_getHashFromTagBySimulator',
      inputFormatter: [null],
      params: 1
    }));
  }

  if (methods.length > 0) {
    web3.extend({
      property: 'eth',
      methods: methods,
      properties: []
    });
  }
}

exports.extend = extend;

/***/ }),
/* 2263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Blocks = void 0;

const tslib_1 = __webpack_require__(23);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

class Blocks {
  constructor(vmContext, _options) {
    this.TX_INDEX = '0x0'; // currently there's always only 1 tx per block, so the transaction index will always be 0x0

    this.vmContext = vmContext;
    const options = _options || {};
    this.coinbase = options.coinbase || '0x0000000000000000000000000000000000000000';
  }

  methods() {
    return {
      eth_getBlockByNumber: this.eth_getBlockByNumber.bind(this),
      eth_gasPrice: this.eth_gasPrice.bind(this),
      eth_coinbase: this.eth_coinbase.bind(this),
      eth_blockNumber: this.eth_blockNumber.bind(this),
      eth_getBlockByHash: this.eth_getBlockByHash.bind(this),
      eth_getBlockTransactionCountByHash: this.eth_getBlockTransactionCountByHash.bind(this),
      eth_getBlockTransactionCountByNumber: this.eth_getBlockTransactionCountByNumber.bind(this),
      eth_getUncleCountByBlockHash: this.eth_getUncleCountByBlockHash.bind(this),
      eth_getUncleCountByBlockNumber: this.eth_getUncleCountByBlockNumber.bind(this),
      eth_getStorageAt: this.eth_getStorageAt.bind(this)
    };
  }

  eth_getBlockByNumber(payload, cb) {
    let blockIndex = payload.params[0];

    if (blockIndex === 'latest') {
      blockIndex = this.vmContext.latestBlockNumber;
    }

    if (Number.isInteger(blockIndex)) {
      blockIndex = '0x' + blockIndex.toString(16);
    }

    const block = this.vmContext.blocks[blockIndex];

    if (!block) {
      return cb(new Error('block not found'));
    }

    const transactions = block.transactions.map(t => {
      const hash = '0x' + t.hash().toString('hex');
      const tx = this.vmContext.txByHash[hash];
      const receipt = this.vmContext.currentVm.web3vm.txsReceipt[hash];

      if (receipt) {
        return {
          blockHash: '0x' + block.hash().toString('hex'),
          blockNumber: '0x' + block.header.number.toString('hex'),
          from: receipt.from,
          gas: web3_1.default.utils.toHex(receipt.gas),
          chainId: '0xd05',
          gasPrice: '0x4a817c800',
          hash: receipt.transactionHash,
          input: receipt.input,
          nonce: '0x' + tx.nonce.toString('hex'),
          transactionIndex: this.TX_INDEX,
          value: receipt.value === '0x' ? '0x0' : receipt.value,
          to: receipt.to ? receipt.to : null
        };
      }
    });
    const b = {
      baseFeePerGas: '0x01',
      number: this.toHex(block.header.number),
      hash: this.toHex(block.hash()),
      parentHash: this.toHex(block.header.parentHash),
      nonce: this.toHex(block.header.nonce),
      sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
      logsBloom: '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
      transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
      stateRoot: this.toHex(block.header.stateRoot),
      miner: this.coinbase,
      difficulty: this.toHex(block.header.difficulty),
      totalDifficulty: this.toHex(block.header.totalDifficulty),
      extraData: this.toHex(block.header.extraData),
      size: '0x027f07',
      gasLimit: this.toHex(block.header.gasLimit),
      gasUsed: this.toHex(block.header.gasUsed),
      timestamp: this.toHex(block.header.timestamp),
      transactions,
      uncles: []
    };
    cb(null, b);
  }

  toHex(value) {
    if (!value) return '0x0';
    const v = value.toString('hex');
    return v === '0x' || v === '' ? '0x0' : '0x' + v;
  }

  eth_getBlockByHash(payload, cb) {
    const block = this.vmContext.blocks[payload.params[0]];
    const transactions = block.transactions.map(t => {
      const hash = '0x' + t.hash().toString('hex');
      const tx = this.vmContext.txByHash[hash];
      const receipt = this.vmContext.currentVm.web3vm.txsReceipt[hash];

      if (receipt) {
        return {
          blockHash: '0x' + block.hash().toString('hex'),
          blockNumber: '0x' + block.header.number.toString('hex'),
          from: receipt.from,
          gas: web3_1.default.utils.toHex(receipt.gas),
          chainId: '0xd05',
          gasPrice: '0x4a817c800',
          hash: receipt.transactionHash,
          input: receipt.input,
          nonce: '0x' + tx.nonce.toString('hex'),
          transactionIndex: this.TX_INDEX,
          value: receipt.value === '0x' ? '0x0' : receipt.value,
          to: receipt.to ? receipt.to : null
        };
      }
    });
    const b = {
      baseFeePerGas: '0x01',
      number: this.toHex(block.header.number),
      hash: this.toHex(block.hash()),
      parentHash: this.toHex(block.header.parentHash),
      nonce: this.toHex(block.header.nonce),
      sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
      logsBloom: '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
      transactionsRoot: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
      stateRoot: this.toHex(block.header.stateRoot),
      miner: this.coinbase,
      difficulty: this.toHex(block.header.difficulty),
      totalDifficulty: this.toHex(block.header.totalDifficulty),
      extraData: this.toHex(block.header.extraData),
      size: '0x027f07',
      gasLimit: this.toHex(block.header.gasLimit),
      gasUsed: this.toHex(block.header.gasUsed),
      timestamp: this.toHex(block.header.timestamp),
      transactions,
      uncles: []
    };
    cb(null, b);
  }

  eth_gasPrice(payload, cb) {
    cb(null, 1);
  }

  eth_coinbase(payload, cb) {
    cb(null, this.coinbase);
  }

  eth_blockNumber(payload, cb) {
    cb(null, parseInt(this.vmContext.latestBlockNumber));
  }

  eth_getBlockTransactionCountByHash(payload, cb) {
    const block = this.vmContext.blocks[payload.params[0]];
    cb(null, block.transactions.length);
  }

  eth_getBlockTransactionCountByNumber(payload, cb) {
    const block = this.vmContext.blocks[payload.params[0]];
    cb(null, block.transactions.length);
  }

  eth_getUncleCountByBlockHash(payload, cb) {
    cb(null, 0);
  }

  eth_getUncleCountByBlockNumber(payload, cb) {
    cb(null, 0);
  }

  eth_getStorageAt(payload, cb) {
    const [address, position, blockNumber] = payload.params;
    this.vmContext.web3().debug.storageRangeAt(blockNumber, 'latest', address.toLowerCase(), position, 1, (err, result) => {
      if (err || result.storage && Object.values(result.storage).length === 0) {
        return cb(err, '');
      }

      const value = Object.values(result.storage)[0]['value'];
      cb(err, value);
    });
  }

}

exports.Blocks = Blocks;

/***/ }),
/* 2264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.error = exports.warn = exports.dir = exports.info = exports.log = void 0;

const tslib_1 = __webpack_require__(23);

const ansi_gray_1 = (0, tslib_1.__importDefault)(__webpack_require__(2265));
const time_stamp_1 = (0, tslib_1.__importDefault)(__webpack_require__(1548));
const color_support_1 = (0, tslib_1.__importDefault)(__webpack_require__(1549));

function hasFlag(flag) {
  return typeof process !== 'undefined' && process.argv.indexOf('--' + flag) !== -1;
}

function addColor(str) {
  if (hasFlag('no-color')) {
    return str;
  }

  if (hasFlag('color')) {
    return (0, ansi_gray_1.default)(str);
  }

  if ((0, color_support_1.default)()) {
    return (0, ansi_gray_1.default)(str);
  }

  return str;
}

function stdout(arg) {
  if (typeof process === 'undefined' || !process.stdout) return;
  process.stdout.write(arg);
}

function stderr(arg) {
  if (typeof process === 'undefined' || process.stderr) return;
  process.stderr.write(arg);
}

function getTimestamp() {
  const coloredTimestamp = addColor((0, time_stamp_1.default)('HH:mm:ss'));
  return '[' + coloredTimestamp + ']';
}

function log(...args) {
  const time = getTimestamp();
  stdout(time + ' ');
  console.log(args);
}

exports.log = log;

function info(...args) {
  const time = getTimestamp();
  stdout(time + ' ');
  console.info(args);
}

exports.info = info;

function dir(...args) {
  const time = getTimestamp();
  stdout(time + ' ');
  console.dir(args);
}

exports.dir = dir;

function warn(...args) {
  const time = getTimestamp();
  stderr(time + ' ');
  console.warn(args);
}

exports.warn = warn;

function error(...args) {
  const time = getTimestamp();
  stderr(time + ' ');
  console.error(args);
}

exports.error = error;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 2265 */,
/* 2266 */,
/* 2267 */,
/* 2268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Accounts = void 0;

const tslib_1 = __webpack_require__(23);

const ethereumjs_util_1 = __webpack_require__(34);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));
const crypto = (0, tslib_1.__importStar)(__webpack_require__(480));

class Accounts {
  constructor(vmContext) {
    this.web3 = new web3_1.default();
    this.vmContext = vmContext; // TODO: make it random and/or use remix-libs

    this.accounts = {};
    this.accountsKeys = {};
  }

  resetAccounts() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.accounts = {};
      this.accountsKeys = {};
      yield this._addAccount('503f38a9c967ed597e47fe25643985f032b072db8075426a92110f82df48dfcb', '0x56BC75E2D63100000');
      yield this._addAccount('7e5bfb82febc4c2c8529167104271ceec190eafdca277314912eaabdb67c6e5f', '0x56BC75E2D63100000');
      yield this._addAccount('cc6d63f85de8fef05446ebdd3c537c72152d0fc437fd7aa62b3019b79bd1fdd4', '0x56BC75E2D63100000');
      yield this._addAccount('638b5c6c8c5903b15f0d3bf5d3f175c64e6e98a10bdb9768a2003bf773dcb86a', '0x56BC75E2D63100000');
      yield this._addAccount('f49bf239b6e554fdd08694fde6c67dac4d01c04e0dda5ee11abee478983f3bc0', '0x56BC75E2D63100000');
      yield this._addAccount('adeee250542d3790253046eee928d8058fd544294a5219bea152d1badbada395', '0x56BC75E2D63100000');
      yield this._addAccount('097ffe12069dcb3c3d99e6771e2cbf491a9b8b2f93ff4d3468f550c5e8264755', '0x56BC75E2D63100000');
      yield this._addAccount('5f58e8b9f1867ef00578b6f03e159428ab168f776aa445bc3ecdb02c7db8e865', '0x56BC75E2D63100000');
      yield this._addAccount('290e721ac87c7b3f31bef7b70104b9280ed3fa1425a59451490c9c02bf50d08f', '0x56BC75E2D63100000');
      yield this._addAccount('27efe944ff128cf510ab447b529eec28772f13bf65ebf1cbd504192c4f26e9d8', '0x56BC75E2D63100000');
      yield this._addAccount('3cd7232cd6f3fc66a57a6bedc1a8ed6c228fff0a327e169c2bcc5e869ed49511', '0x56BC75E2D63100000');
      yield this._addAccount('2ac6c190b09897cd8987869cc7b918cfea07ee82038d492abce033c75c1b1d0c', '0x56BC75E2D63100000');
      yield this._addAccount('dae9801649ba2d95a21e688b56f77905e5667c44ce868ec83f82e838712a2c7a', '0x56BC75E2D63100000');
      yield this._addAccount('d74aa6d18aa79a05f3473dd030a97d3305737cbc8337d940344345c1f6b72eea', '0x56BC75E2D63100000');
      yield this._addAccount('71975fbf7fe448e004ac7ae54cad0a383c3906055a65468714156a07385e96ce', '0x56BC75E2D63100000');
    });
  }

  _addAccount(privateKey, balance) {
    return new Promise((resolve, reject) => {
      privateKey = Buffer.from(privateKey, 'hex');
      const address = (0, ethereumjs_util_1.privateToAddress)(privateKey);
      const addressStr = (0, ethereumjs_util_1.toChecksumAddress)('0x' + address.toString('hex'));
      this.accounts[addressStr] = {
        privateKey,
        nonce: 0
      };
      this.accountsKeys[addressStr] = '0x' + privateKey.toString('hex');
      const stateManager = this.vmContext.vm().stateManager;
      stateManager.getAccount(ethereumjs_util_1.Address.fromString(addressStr)).then(account => {
        account.balance = new ethereumjs_util_1.BN(balance.replace('0x', '') || 'f00000000000000001', 16);
        stateManager.putAccount(ethereumjs_util_1.Address.fromString(addressStr), account).catch(error => {
          reject(error);
        }).then(() => {
          resolve({});
        });
      }).catch(error => {
        reject(error);
      });
    });
  }

  newAccount(cb) {
    let privateKey;

    do {
      privateKey = crypto.randomBytes(32);
    } while (!(0, ethereumjs_util_1.isValidPrivate)(privateKey));

    this._addAccount(privateKey, '0x56BC75E2D63100000');

    return cb(null, '0x' + (0, ethereumjs_util_1.privateToAddress)(privateKey).toString('hex'));
  }

  methods() {
    return {
      eth_accounts: this.eth_accounts.bind(this),
      eth_getBalance: this.eth_getBalance.bind(this),
      eth_sign: this.eth_sign.bind(this)
    };
  }

  eth_accounts(_payload, cb) {
    return cb(null, Object.keys(this.accounts));
  }

  eth_getBalance(payload, cb) {
    const address = payload.params[0];
    this.vmContext.vm().stateManager.getAccount(ethereumjs_util_1.Address.fromString(address)).then(account => {
      cb(null, new ethereumjs_util_1.BN(account.balance).toString(10));
    }).catch(error => {
      cb(error);
    });
  }

  eth_sign(payload, cb) {
    const address = payload.params[0];
    const message = payload.params[1];
    const privateKey = this.accountsKeys[(0, ethereumjs_util_1.toChecksumAddress)(address)];

    if (!privateKey) {
      return cb(new Error('unknown account'));
    }

    const account = this.web3.eth.accounts.privateKeyToAccount(privateKey);
    const data = account.sign(message);
    cb(null, data.signature);
  }

}

exports.Accounts = Accounts;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Filters = void 0;

class Filters {
  constructor(vmContext) {
    this.vmContext = vmContext;
  }

  methods() {
    return {
      eth_getLogs: this.eth_getLogs.bind(this),
      eth_subscribe: this.eth_subscribe.bind(this),
      eth_unsubscribe: this.eth_unsubscribe.bind(this)
    };
  }

  eth_getLogs(payload, cb) {
    const results = this.vmContext.logsManager.getLogsFor(payload.params[0]);
    cb(null, results);
  }

  eth_subscribe(payload, cb) {
    const subscriptionId = this.vmContext.logsManager.subscribe(payload.params);
    cb(null, subscriptionId);
  }

  eth_unsubscribe(payload, cb) {
    this.vmContext.logsManager.unsubscribe(payload.params[0]);
    cb(null, true);
  }

  eth_newFilter(payload, cb) {
    const filterId = this.vmContext.logsManager.newFilter('filter', payload.params[0]);
    cb(null, filterId);
  }

  eth_newBlockFilter(payload, cb) {
    const filterId = this.vmContext.logsManager.newFilter('block');
    cb(null, filterId);
  }

  eth_newPendingTransactionFilter(payload, cb) {
    const filterId = this.vmContext.logsManager.newFilter('pendingTransactions');
    cb(null, filterId);
  }

  eth_uninstallfilter(payload, cb) {
    const result = this.vmContext.logsManager.uninstallFilter(payload.params[0]);
    cb(null, result);
  }

  eth_getFilterChanges(payload, cb) {
    const filterId = payload.params[0];
    const results = this.vmContext.logsManager.getLogsForFilter(filterId);
    cb(null, results);
  }

  eth_getFilterLogs(payload, cb) {
    const filterId = payload.params[0];
    const results = this.vmContext.logsManager.getLogsForFilter(filterId, true);
    cb(null, results);
  }

}

exports.Filters = Filters;

/***/ }),
/* 2270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eth_compileSerpent = exports.eth_compileLLL = exports.eth_compileSolidity = exports.eth_getCompilers = exports.web3_sha3 = exports.eth_hashrate = exports.eth_mining = exports.eth_syncing = exports.eth_protocolVersion = exports.web3_clientVersion = exports.methods = void 0;

const tslib_1 = __webpack_require__(23);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

const version = __webpack_require__(2271).version;

function methods() {
  return {
    web3_clientVersion: web3_clientVersion,
    eth_protocolVersion: eth_protocolVersion,
    eth_syncing: eth_syncing,
    eth_mining: eth_mining,
    eth_hashrate: eth_hashrate,
    web3_sha3: web3_sha3,
    eth_getCompilers: eth_getCompilers,
    eth_compileSolidity: eth_compileSolidity,
    eth_compileLLL: eth_compileLLL,
    eth_compileSerpent: eth_compileSerpent
  };
}

exports.methods = methods;

function web3_clientVersion(payload, cb) {
  cb(null, 'Remix Simulator/' + version);
}

exports.web3_clientVersion = web3_clientVersion;

function eth_protocolVersion(payload, cb) {
  cb(null, '0x3f');
}

exports.eth_protocolVersion = eth_protocolVersion;

function eth_syncing(payload, cb) {
  cb(null, false);
}

exports.eth_syncing = eth_syncing;

function eth_mining(payload, cb) {
  // TODO: should depend on the state
  cb(null, false);
}

exports.eth_mining = eth_mining;

function eth_hashrate(payload, cb) {
  cb(null, '0x0');
}

exports.eth_hashrate = eth_hashrate;

function web3_sha3(payload, cb) {
  const str = payload.params[0];
  cb(null, web3_1.default.utils.sha3(str));
}

exports.web3_sha3 = web3_sha3;

function eth_getCompilers(payload, cb) {
  cb(null, []);
}

exports.eth_getCompilers = eth_getCompilers;

function eth_compileSolidity(payload, cb) {
  cb(null, 'unsupported');
}

exports.eth_compileSolidity = eth_compileSolidity;

function eth_compileLLL(payload, cb) {
  cb(null, 'unsupported');
}

exports.eth_compileLLL = eth_compileLLL;

function eth_compileSerpent(payload, cb) {
  cb(null, 'unsupported');
}

exports.eth_compileSerpent = eth_compileSerpent;

/***/ }),
/* 2271 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@remix-project/remix-simulator\",\"version\":\"0.2.15\",\"description\":\"Ethereum IDE and tools for the web\",\"contributors\":[{\"name\":\"Iuri Matias\",\"email\":\"iuri@ethereum.org\"},{\"name\":\"Yann Levreau\",\"email\":\"yann@ethdev.com\"}],\"main\":\"src/index.js\",\"dependencies\":{\"@ethereumjs/block\":\"^3.5.1\",\"@ethereumjs/common\":\"^2.5.0\",\"@ethereumjs/tx\":\"^3.3.2\",\"@ethereumjs/vm\":\"^5.5.3\",\"@remix-project/remix-lib\":\"^0.5.15\",\"ansi-gray\":\"^0.1.1\",\"async\":\"^3.1.0\",\"body-parser\":\"^1.18.2\",\"color-support\":\"^1.1.3\",\"commander\":\"^2.19.0\",\"cors\":\"^2.8.5\",\"ethereumjs-util\":\"^7.0.10\",\"ethers\":\"^5.4.2\",\"ethjs-util\":\"^0.1.6\",\"express\":\"^4.16.3\",\"express-ws\":\"^4.0.0\",\"merge\":\"^1.2.0\",\"string-similarity\":\"^4.0.4\",\"time-stamp\":\"^2.0.0\",\"web3\":\"^1.5.1\"},\"devDependencies\":{\"@babel/core\":\"^7.4.5\",\"@babel/plugin-transform-object-assign\":\"^7.2.0\",\"@babel/preset-env\":\"^7.4.5\",\"@babel/preset-es2015\":\"latest\",\"@babel/preset-es2017\":\"latest\",\"@babel/preset-stage-0\":\"^7.0.0\",\"babel-eslint\":\"^7.1.1\",\"babelify\":\"^10.0.0\",\"mocha\":\"^5.2.0\"},\"scripts\":{\"test\":\"./../../node_modules/.bin/ts-node --require tsconfig-paths/register ./../../node_modules/.bin/mocha test/*.ts\"},\"publishConfig\":{\"access\":\"public\"},\"bin\":{\"ethsim\":\"./bin/ethsim\",\"remix-simulator\":\"./bin/ethsim\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ethereum/remix-project.git\"},\"author\":\"Remix Team\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ethereum/remix-project/issues\"},\"homepage\":\"https://github.com/ethereum/remix-project/tree/master/libs/remix-simulator#readme\",\"typings\":\"src/index.d.ts\",\"gitHead\":\"714a13ef29c4c5b018e25b49270809f2ea456b08\"}");

/***/ }),
/* 2272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.net_peerCount = exports.net_listening = exports.net_version = exports.methods = void 0;

function methods() {
  return {
    net_version: net_version,
    net_listening: net_listening,
    net_peerCount: net_peerCount
  };
}

exports.methods = methods;

function net_version(payload, cb) {
  // should be configured networkId
  cb(null, 1337);
}

exports.net_version = net_version;

function net_listening(payload, cb) {
  cb(null, true);
}

exports.net_listening = net_listening;

function net_peerCount(payload, cb) {
  cb(null, 0);
}

exports.net_peerCount = net_peerCount;

/***/ }),
/* 2273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transactions = void 0;

const tslib_1 = __webpack_require__(23);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

const ethereumjs_util_1 = __webpack_require__(34);

const txProcess_1 = __webpack_require__(2274);

const remix_lib_1 = __webpack_require__(311);

const ethers_1 = __webpack_require__(140);

const TxRunnerVM = remix_lib_1.execution.TxRunnerVM;
const TxRunner = remix_lib_1.execution.TxRunner;

class Transactions {
  constructor(vmContext) {
    this.TX_INDEX = '0x0'; // currently there's always only 1 tx per block, so the transaction index will always be 0x0

    this.vmContext = vmContext;
    this.tags = {};
  }

  init(accounts) {
    this.accounts = accounts;
    const api = {
      logMessage: msg => {},
      logHtmlMessage: msg => {},
      config: {
        getUnpersistedProperty: key => {
          return true;
        },
        get: () => {
          return true;
        }
      },
      detectNetwork: cb => {
        cb();
      },
      personalMode: () => {
        return false;
      }
    };
    this.txRunnerVMInstance = new TxRunnerVM(accounts, api, _ => this.vmContext.vmObject());
    this.txRunnerInstance = new TxRunner(this.txRunnerVMInstance, {
      runAsync: false
    });
    this.txRunnerInstance.vmaccounts = accounts;
  }

  methods() {
    return {
      eth_sendTransaction: this.eth_sendTransaction.bind(this),
      eth_getTransactionReceipt: this.eth_getTransactionReceipt.bind(this),
      eth_getCode: this.eth_getCode.bind(this),
      eth_call: this.eth_call.bind(this),
      eth_estimateGas: this.eth_estimateGas.bind(this),
      eth_getTransactionCount: this.eth_getTransactionCount.bind(this),
      eth_getTransactionByHash: this.eth_getTransactionByHash.bind(this),
      eth_getTransactionByBlockHashAndIndex: this.eth_getTransactionByBlockHashAndIndex.bind(this),
      eth_getTransactionByBlockNumberAndIndex: this.eth_getTransactionByBlockNumberAndIndex.bind(this),
      eth_getExecutionResultFromSimulator: this.eth_getExecutionResultFromSimulator.bind(this),
      eth_getHHLogsForTx: this.eth_getHHLogsForTx.bind(this),
      eth_getHashFromTagBySimulator: this.eth_getHashFromTagBySimulator.bind(this)
    };
  }

  eth_sendTransaction(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = (0, ethereumjs_util_1.toChecksumAddress)(payload.params[0].from);
    }

    (0, txProcess_1.processTx)(this.txRunnerInstance, payload, false, (error, result) => {
      if (!error && result) {
        this.vmContext.addBlock(result.block);
        const hash = '0x' + result.tx.hash().toString('hex');
        this.vmContext.trackTx(hash, result.block, result.tx);
        this.vmContext.trackExecResult(hash, result.result.execResult);
        return cb(null, result.transactionHash);
      }

      cb(error);
    });
  }

  eth_getExecutionResultFromSimulator(payload, cb) {
    const txHash = payload.params[0];
    cb(null, this.vmContext.exeResults[txHash]);
  }

  eth_getHHLogsForTx(payload, cb) {
    const txHash = payload.params[0];
    cb(null, this.vmContext.currentVm.web3vm.hhLogs[txHash] ? this.vmContext.currentVm.web3vm.hhLogs[txHash] : []);
  }

  eth_getTransactionReceipt(payload, cb) {
    this.vmContext.web3().eth.getTransactionReceipt(payload.params[0], (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const txBlock = this.vmContext.blockByTxHash[receipt.hash];
      const logs = this.vmContext.logsManager.getLogsByTxHash(receipt.hash);
      const r = {
        transactionHash: receipt.hash,
        transactionIndex: this.TX_INDEX,
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        gasUsed: receipt.gasUsed,
        cumulativeGasUsed: receipt.gasUsed,
        contractAddress: receipt.contractAddress,
        logs,
        status: receipt.status,
        to: receipt.to
      };

      if (r.blockNumber === '0x') {
        r.blockNumber = '0x0';
      }

      cb(null, r);
    });
  }

  eth_estimateGas(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = (0, ethereumjs_util_1.toChecksumAddress)(payload.params[0].from);
    }

    if (payload.params && payload.params.length > 0 && payload.params[0].to) {
      payload.params[0].to = (0, ethereumjs_util_1.toChecksumAddress)(payload.params[0].to);
    }

    payload.params[0].gas = 10000000 * 10;
    (0, txProcess_1.processTx)(this.txRunnerInstance, payload, true, (error, {
      result
    }) => {
      if (error) return cb(error);

      if (result.status === '0x0') {
        try {
          const msg = result.execResult.returnValue;
          const abiCoder = new ethers_1.ethers.utils.AbiCoder();
          const reason = abiCoder.decode(['string'], msg.slice(4))[0];
          return cb('revert ' + reason);
        } catch (e) {
          return cb(e.message);
        }
      }

      let gasUsed = result.execResult.gasUsed.toNumber();

      if (result.execResult.gasRefund) {
        gasUsed += result.execResult.gasRefund.toNumber();
      }

      cb(null, Math.ceil(gasUsed + 15 * gasUsed / 100));
    });
  }

  eth_getCode(payload, cb) {
    const address = payload.params[0];
    this.vmContext.web3().eth.getCode(address, (error, result) => {
      if (error) {
        console.dir('error getting code');
        console.dir(error);
      }

      cb(error, result);
    });
  }

  eth_call(payload, cb) {
    // from might be lowercased address (web3)
    if (payload.params && payload.params.length > 0 && payload.params[0].from) {
      payload.params[0].from = (0, ethereumjs_util_1.toChecksumAddress)(payload.params[0].from);
    }

    if (payload.params && payload.params.length > 0 && payload.params[0].to) {
      payload.params[0].to = (0, ethereumjs_util_1.toChecksumAddress)(payload.params[0].to);
    }

    payload.params[0].value = undefined;
    const tag = payload.params[0].timestamp; // e2e reference

    (0, txProcess_1.processTx)(this.txRunnerInstance, payload, true, (error, result) => {
      if (!error && result) {
        this.vmContext.addBlock(result.block);
        const hash = '0x' + result.tx.hash().toString('hex');
        this.vmContext.trackTx(hash, result.block, result.tx);
        this.vmContext.trackExecResult(hash, result.result.execResult);
        this.tags[tag] = result.transactionHash; // calls are not supposed to return a transaction hash. we do this for keeping track of it and allowing debugging calls.

        const returnValue = `0x${result.result.execResult.returnValue.toString('hex') || '0'}`;
        return cb(null, returnValue);
      }

      cb(error);
    });
  }

  eth_getHashFromTagBySimulator(payload, cb) {
    return cb(null, this.tags[payload.params[0]]);
  }

  eth_getTransactionCount(payload, cb) {
    const address = payload.params[0];
    this.vmContext.vm().stateManager.getAccount(ethereumjs_util_1.Address.fromString(address)).then(account => {
      const nonce = new ethereumjs_util_1.BN(account.nonce).toString(10);
      cb(null, nonce);
    }).catch(error => {
      cb(error);
    });
  }

  eth_getTransactionByHash(payload, cb) {
    const address = payload.params[0];
    this.vmContext.web3().eth.getTransactionReceipt(address, (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const txBlock = this.vmContext.blockByTxHash[receipt.transactionHash];
      const tx = this.vmContext.txByHash[receipt.transactionHash]; // TODO: params to add later

      const r = {
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        from: receipt.from,
        gas: web3_1.default.utils.toHex(receipt.gas),
        chainId: '0xd05',
        // 'gasPrice': '2000000000000', // 0x123
        gasPrice: '0x4a817c800',
        hash: receipt.transactionHash,
        input: receipt.input,
        nonce: '0x' + tx.nonce.toString('hex'),
        transactionIndex: this.TX_INDEX,
        value: receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r['to'] = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      if (r.blockNumber === '0x') {
        r.blockNumber = '0x0';
      }

      cb(null, r);
    });
  }

  eth_getTransactionByBlockHashAndIndex(payload, cb) {
    const txIndex = payload.params[1];
    const txBlock = this.vmContext.blocks[payload.params[0]];
    const txHash = '0x' + txBlock.transactions[web3_1.default.utils.toDecimal(txIndex)].hash().toString('hex');
    this.vmContext.web3().eth.getTransactionReceipt(txHash, (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const tx = this.vmContext.txByHash[receipt.transactionHash]; // TODO: params to add later

      const r = {
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        from: receipt.from,
        gas: web3_1.default.utils.toHex(receipt.gas),
        chainId: '0xd05',
        // 'gasPrice': '2000000000000', // 0x123
        gasPrice: '0x4a817c800',
        hash: receipt.transactionHash,
        input: receipt.input,
        nonce: '0x' + tx.nonce.toString('hex'),
        transactionIndex: this.TX_INDEX,
        value: receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r['to'] = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      cb(null, r);
    });
  }

  eth_getTransactionByBlockNumberAndIndex(payload, cb) {
    const txIndex = payload.params[1];
    const txBlock = this.vmContext.blocks[payload.params[0]];
    const txHash = '0x' + txBlock.transactions[web3_1.default.utils.toDecimal(txIndex)].hash().toString('hex');
    this.vmContext.web3().eth.getTransactionReceipt(txHash, (error, receipt) => {
      if (error) {
        return cb(error);
      }

      const tx = this.vmContext.txByHash[receipt.transactionHash]; // TODO: params to add later

      const r = {
        blockHash: '0x' + txBlock.hash().toString('hex'),
        blockNumber: '0x' + txBlock.header.number.toString('hex'),
        from: receipt.from,
        gas: web3_1.default.utils.toHex(receipt.gas),
        // 'gasPrice': '2000000000000', // 0x123
        chainId: '0xd05',
        gasPrice: '0x4a817c800',
        hash: receipt.transactionHash,
        input: receipt.input,
        nonce: '0x' + tx.nonce.toString('hex'),
        transactionIndex: this.TX_INDEX,
        value: receipt.value // "value":"0xf3dbb76162000" // 4290000000000000
        // "v": "0x25", // 37
        // "r": "0x1b5e176d927f8e9ab405058b2d2457392da3e20f328b16ddabcebc33eaac5fea",
        // "s": "0x4ba69724e8f69de52f0125ad8b3c5c2cef33019bac3249e2c0a2192766d1721c"

      };

      if (receipt.to) {
        r['to'] = receipt.to;
      }

      if (r.value === '0x') {
        r.value = '0x0';
      }

      cb(null, r);
    });
  }

}

exports.Transactions = Transactions;

/***/ }),
/* 2274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processTx = void 0;

const remix_lib_1 = __webpack_require__(311);

const TxExecution = remix_lib_1.execution.txExecution;

function runCall(payload, from, to, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    return callback(null, result);
  };

  TxExecution.callFunction(from, to, data, value, gasLimit, {
    constant: true
  }, txRunner, callbacks, finalCallback);
}

function runTx(payload, from, to, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    callback(null, result);
  };

  TxExecution.callFunction(from, to, data, value, gasLimit, {
    constant: false
  }, txRunner, callbacks, finalCallback);
}

function createContract(payload, from, data, value, gasLimit, txRunner, callbacks, callback) {
  const finalCallback = function (err, result) {
    if (err) {
      return callback(err);
    }

    callback(null, result);
  };

  TxExecution.createContract(from, data, value, gasLimit, txRunner, callbacks, finalCallback);
}

function processTx(txRunnerInstance, payload, isCall, callback) {
  let {
    from,
    to,
    data,
    value,
    gas
  } = payload.params[0]; // eslint-disable-line

  gas = gas || 3000000;
  const callbacks = {
    confirmationCb: (network, tx, gasEstimation, continueTxExecution, cancelCb) => {
      continueTxExecution(null);
    },
    gasEstimationForceSend: (error, continueTxExecution, cancelCb) => {
      if (error) {
        continueTxExecution(error);
      }

      continueTxExecution();
    },
    promptCb: (okCb, cancelCb) => {
      okCb();
    }
  };

  if (isCall) {
    runCall(payload, from, to, data, value, gas, txRunnerInstance, callbacks, callback);
  } else if (to) {
    runTx(payload, from, to, data, value, gas, txRunnerInstance, callbacks, callback);
  } else {
    createContract(payload, from, data, value, gas, txRunnerInstance, callbacks, callback);
  }
}

exports.processTx = processTx;

/***/ }),
/* 2275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Debug = void 0;

class Debug {
  constructor(vmContext) {
    this.vmContext = vmContext;
  }

  methods() {
    return {
      debug_traceTransaction: this.debug_traceTransaction.bind(this),
      debug_preimage: this.debug_preimage.bind(this),
      debug_storageRangeAt: this.debug_storageRangeAt.bind(this)
    };
  }

  debug_traceTransaction(payload, cb) {
    this.vmContext.web3().debug.traceTransaction(payload.params[0], {}, cb);
  }

  debug_preimage(payload, cb) {
    this.vmContext.web3().debug.preimage(payload.params[0], cb);
  }

  debug_storageRangeAt(payload, cb) {
    this.vmContext.web3().debug.storageRangeAt(payload.params[0], payload.params[1], payload.params[2], payload.params[3], payload.params[4], cb);
  }

}

exports.Debug = Debug;

/***/ }),
/* 2276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBlock = void 0;

const block_1 = __webpack_require__(478);

const ethereumjs_util_1 = __webpack_require__(34);

function generateBlock(vmContext) {
  return new Promise((resolve, reject) => {
    const block = block_1.Block.fromBlockData({
      header: {
        timestamp: new Date().getTime() / 1000 | 0,
        number: 0,
        coinbase: '0x0e9281e9c6a0808672eaba6bd1220e144c9bb07a',
        difficulty: new ethereumjs_util_1.BN('69762765929000', 10),
        gasLimit: new ethereumjs_util_1.BN('8000000').imuln(1)
      }
    }, {
      common: vmContext.vmObject().common
    });
    vmContext.vm().runBlock({
      block: block,
      generate: true,
      skipBlockValidation: true,
      skipBalance: false
    }).then(() => {
      vmContext.addBlock(block);
      resolve({});
    }).catch(e => reject(e));
  });
}

exports.generateBlock = generateBlock;

/***/ }),
/* 2277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global ethereum */


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VMContext = void 0;

const tslib_1 = __webpack_require__(23);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

const ethereumjs_util_1 = __webpack_require__(34);

const remix_lib_1 = __webpack_require__(311);

const {
  LogsManager
} = remix_lib_1.execution;

const VmProxy_1 = __webpack_require__(2278);

const vm_1 = (0, tslib_1.__importDefault)(__webpack_require__(2279));
const common_1 = (0, tslib_1.__importDefault)(__webpack_require__(221));
const stateManager_1 = (0, tslib_1.__importDefault)(__webpack_require__(2411));
/*
  extend vm state manager and instanciate VM
*/

class StateManagerCommonStorageDump extends stateManager_1.default {
  constructor() {
    super();
    this.keyHashes = {};
  }

  putContractStorage(address, key, value) {
    this.keyHashes[(0, ethereumjs_util_1.keccak)(key).toString('hex')] = (0, ethereumjs_util_1.bufferToHex)(key);
    return super.putContractStorage(address, key, value);
  }

  dumpStorage(address) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => {
        this._getStorageTrie(address).then(trie => {
          const storage = {};
          const stream = trie.createReadStream();
          stream.on('data', val => {
            const value = ethereumjs_util_1.rlp.decode(val.value);
            storage['0x' + val.key.toString('hex')] = {
              key: this.keyHashes[val.key.toString('hex')],
              value: '0x' + value.toString('hex')
            };
          });
          stream.on('end', () => {
            resolve(storage);
          });
        }).catch(e => {
          reject(e);
        });
      });
    });
  }

  getStateRoot(force = false) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      yield this._cache.flush();
      const stateRoot = this._trie.root;
      return stateRoot;
    });
  }

  setStateRoot(stateRoot) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      if (this._checkpointCount !== 0) {
        throw new Error('Cannot set state root with uncommitted checkpoints');
      }

      yield this._cache.flush();

      if (!stateRoot.equals(this._trie.EMPTY_TRIE_ROOT)) {
        const hasRoot = yield this._trie.checkRoot(stateRoot);

        if (!hasRoot) {
          throw new Error('State trie does not contain state root');
        }
      }

      this._trie.root = stateRoot;

      this._cache.clear();

      this._storageTries = {};
    });
  }

}
/*
  trigger contextChanged, web3EndpointChanged
*/


class VMContext {
  constructor(fork) {
    this.blockGasLimitDefault = 4300000;
    this.blockGasLimit = this.blockGasLimitDefault;
    this.currentFork = fork || 'london';
    this.currentVm = this.createVm(this.currentFork);
    this.blocks = {};
    this.latestBlockNumber = "0x0";
    this.blockByTxHash = {};
    this.txByHash = {};
    this.exeResults = {};
    this.logsManager = new LogsManager();
  }

  createVm(hardfork) {
    const stateManager = new StateManagerCommonStorageDump();
    const common = new common_1.default({
      chain: 'mainnet',
      hardfork
    });
    const vm = new vm_1.default({
      common,
      activatePrecompiles: true,
      stateManager,
      allowUnlimitedContractSize: true
    }); // VmProxy and VMContext are very intricated.
    // VmProxy is used to track the EVM execution (to listen on opcode execution, in order for instance to generate the VM trace)

    const web3vm = new VmProxy_1.VmProxy(this);
    web3vm.setVM(vm);
    return {
      vm,
      web3vm,
      stateManager,
      common
    };
  }

  getCurrentFork() {
    return this.currentFork;
  }

  web3() {
    return this.currentVm.web3vm;
  }

  blankWeb3() {
    return new web3_1.default();
  }

  vm() {
    return this.currentVm.vm;
  }

  vmObject() {
    return this.currentVm;
  }

  addBlock(block) {
    let blockNumber = '0x' + block.header.number.toString('hex');

    if (blockNumber === '0x') {
      blockNumber = '0x0';
    }

    this.blocks['0x' + block.hash().toString('hex')] = block;
    this.blocks[blockNumber] = block;
    this.latestBlockNumber = blockNumber;
    this.logsManager.checkBlock(blockNumber, block, this.web3());
  }

  trackTx(txHash, block, tx) {
    this.blockByTxHash[txHash] = block;
    this.txByHash[txHash] = tx;
  }

  trackExecResult(tx, execReult) {
    this.exeResults[tx] = execReult;
  }

}

exports.VMContext = VMContext;

/***/ }),
/* 2278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VmProxy = void 0;

const tslib_1 = __webpack_require__(23);

const remix_lib_1 = __webpack_require__(311);

const {
  hexListFromBNs,
  formatMemory
} = remix_lib_1.util;

const remix_lib_2 = __webpack_require__(311);

const {
  normalizeHexAddress
} = remix_lib_2.helpers.ui;

const remix_lib_3 = __webpack_require__(311);

const ethereumjs_util_1 = __webpack_require__(34);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

const ethers_1 = __webpack_require__(140);

class VmProxy {
  constructor(vmContext) {
    this.vmContext = vmContext;
    this.web3 = new web3_1.default();
    this.vm = null;
    this.vmTraces = {};
    this.txs = {};
    this.txsReceipt = {};
    this.hhLogs = {};
    this.processingHash = null;
    this.processingAddress = null;
    this.processingIndex = null;
    this.previousDepth = 0;
    this.incr = 0;
    this.eth = {};
    this.debug = {};

    this.eth.getCode = (address, cb) => this.getCode(address, cb);

    this.eth.getTransaction = (txHash, cb) => this.getTransaction(txHash, cb);

    this.eth.getTransactionReceipt = (txHash, cb) => this.getTransactionReceipt(txHash, cb);

    this.eth.getTransactionFromBlock = (blockNumber, txIndex, cb) => this.getTransactionFromBlock(blockNumber, txIndex, cb);

    this.eth.getBlockNumber = cb => this.getBlockNumber(cb);

    this.debug.traceTransaction = (txHash, options, cb) => this.traceTransaction(txHash, options, cb);

    this.debug.storageRangeAt = (blockNumber, txIndex, address, start, maxLength, cb) => this.storageRangeAt(blockNumber, txIndex, address, start, maxLength, cb);

    this.debug.preimage = (hashedKey, cb) => this.preimage(hashedKey, cb);

    this.providers = {
      HttpProvider: function (url) {}
    };
    this.currentProvider = {
      host: 'vm provider'
    };
    this.storageCache = {};
    this.lastProcessedStorageTxHash = {};
    this.sha3Preimages = {}; // util

    this.sha3 = (...args) => this.web3.utils.sha3.apply(this, args);

    this.toHex = (...args) => this.web3.utils.toHex.apply(this, args);

    this.toAscii = (...args) => this.web3.utils.toAscii.apply(this, args);

    this.fromAscii = (...args) => this.web3.utils.fromAscii.apply(this, args);

    this.fromDecimal = (...args) => this.web3.utils.fromDecimal.apply(this, args);

    this.fromWei = (...args) => this.web3.utils.fromWei.apply(this, args);

    this.toWei = (...args) => this.web3.utils.toWei.apply(this, args);

    this.toBigNumber = (...args) => this.web3.utils.toBN.apply(this, args);

    this.isAddress = (...args) => this.web3.utils.isAddress.apply(this, args);

    this.utils = web3_1.default.utils || [];
    this.txsMapBlock = {};
    this.blocks = {};
    this.latestBlockNumber = 0;
  }

  setVM(vm) {
    if (this.vm === vm) return;
    this.vm = vm;
    this.vm.on('step', (data, next) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      yield this.pushTrace(data);
      next();
    }));
    this.vm.on('afterTx', (data, next) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      yield this.txProcessed(data);
      next();
    }));
    this.vm.on('beforeTx', (data, next) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      yield this.txWillProcess(data);
      next();
    }));
  }

  releaseCurrentHash() {
    const ret = this.processingHash;
    this.processingHash = undefined;
    return ret;
  }

  txWillProcess(data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.incr++;
      this.processingHash = (0, ethereumjs_util_1.bufferToHex)(data.hash());
      this.vmTraces[this.processingHash] = {
        gas: '0x0',
        return: '0x0',
        structLogs: []
      };
      const tx = {};
      tx['hash'] = this.processingHash;
      tx['from'] = (0, ethereumjs_util_1.toChecksumAddress)(data.getSenderAddress().toString());

      if (data.to) {
        tx['to'] = (0, ethereumjs_util_1.toChecksumAddress)(data.to.toString());
      }

      this.processingAddress = tx['to'];
      tx['input'] = (0, ethereumjs_util_1.bufferToHex)(data.data);
      tx['gas'] = data.gasLimit.toString(10);

      if (data.value) {
        tx['value'] = data.value.toString(10);
      }

      this.txs[this.processingHash] = tx;
      this.txsReceipt[this.processingHash] = tx;
      this.storageCache[this.processingHash] = {};

      if (data.to) {
        try {
          const storage = yield this.vm.stateManager.dumpStorage(data.to);
          this.storageCache[this.processingHash][tx['to']] = storage;
          this.lastProcessedStorageTxHash[tx['to']] = this.processingHash;
        } catch (e) {
          console.log(e);
        }
      }

      this.processingIndex = 0;
    });
  }

  txProcessed(data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const lastOp = this.vmTraces[this.processingHash].structLogs[this.processingIndex - 1];

      if (lastOp) {
        lastOp.error = lastOp.op !== 'RETURN' && lastOp.op !== 'STOP' && lastOp.op !== 'DESTRUCT';
      }

      const gasUsed = '0x' + data.gasUsed.toString(16);
      this.vmTraces[this.processingHash].gas = gasUsed;
      this.txsReceipt[this.processingHash].gasUsed = gasUsed;
      const logs = [];

      for (const l in data.execResult.logs) {
        const log = data.execResult.logs[l];
        const topics = [];

        if (log[1].length > 0) {
          for (const k in log[1]) {
            topics.push('0x' + log[1][k].toString('hex'));
          }
        } else {
          topics.push('0x');
        }

        logs.push({
          address: '0x' + log[0].toString('hex'),
          data: '0x' + log[2].toString('hex'),
          topics: topics,
          rawVMResponse: log
        });
      }

      this.txsReceipt[this.processingHash].logs = logs;
      this.txsReceipt[this.processingHash].transactionHash = this.processingHash;
      const status = data.execResult.exceptionError ? 0 : 1;
      this.txsReceipt[this.processingHash].status = `0x${status}`;

      if (data.createdAddress) {
        const address = data.createdAddress.toString();
        this.vmTraces[this.processingHash].return = (0, ethereumjs_util_1.toChecksumAddress)(address);
        this.txsReceipt[this.processingHash].contractAddress = (0, ethereumjs_util_1.toChecksumAddress)(address);
      } else if (data.execResult.returnValue) {
        this.vmTraces[this.processingHash].return = (0, ethereumjs_util_1.bufferToHex)(data.execResult.returnValue);
      } else {
        this.vmTraces[this.processingHash].return = '0x';
      }

      this.processingIndex = null;
      this.processingAddress = null;
      this.previousDepth = 0;
    });
  }

  pushTrace(data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const depth = data.depth + 1; // geth starts the depth from 1

      if (!this.processingHash) {
        console.log('no tx processing');
        return;
      }

      let previousopcode;

      if (this.vmTraces[this.processingHash] && this.vmTraces[this.processingHash].structLogs[this.processingIndex - 1]) {
        previousopcode = this.vmTraces[this.processingHash].structLogs[this.processingIndex - 1];
      }

      if (this.previousDepth > depth && previousopcode) {
        // returning from context, set error it is not STOP, RETURN
        previousopcode.invalidDepthChange = previousopcode.op !== 'RETURN' && previousopcode.op !== 'STOP';
      }

      const step = {
        stack: hexListFromBNs(data.stack),
        memory: formatMemory(data.memory),
        storage: data.storage,
        op: data.opcode.name,
        pc: data.pc,
        gasCost: data.opcode.fee.toString(),
        gas: data.gasLeft.toString(),
        depth: depth,
        error: data.error === false ? undefined : data.error
      };
      this.vmTraces[this.processingHash].structLogs.push(step); // Track hardhat console.log call

      if (step.op === 'STATICCALL' && step.stack[step.stack.length - 2] === '0x000000000000000000000000000000000000000000636f6e736f6c652e6c6f67') {
        const stackLength = step.stack.length;
        const payloadStart = parseInt(step.stack[stackLength - 3], 16);
        const memory = step.memory.join('');
        let payload = memory.substring(payloadStart * 2, memory.length);
        const fnselectorStr = payload.substring(0, 8);
        const fnselectorStrInHex = '0x' + fnselectorStr;
        const fnselector = parseInt(fnselectorStrInHex);
        const fnArgs = remix_lib_3.ConsoleLogs[fnselector];
        const iface = new ethers_1.ethers.utils.Interface([`function log${fnArgs} view`]);
        const functionDesc = iface.getFunction(`log${fnArgs}`);
        const sigHash = iface.getSighash(`log${fnArgs}`);

        if (fnArgs.includes('uint') && sigHash !== fnselectorStrInHex) {
          payload = payload.replace(fnselectorStr, sigHash);
        } else {
          payload = '0x' + payload;
        }

        const consoleArgs = iface.decodeFunctionData(functionDesc, payload);
        this.hhLogs[this.processingHash] = this.hhLogs[this.processingHash] ? this.hhLogs[this.processingHash] : [];
        this.hhLogs[this.processingHash].push(consoleArgs);
      }

      if (step.op === 'CREATE' || step.op === 'CALL') {
        if (step.op === 'CREATE') {
          this.processingAddress = '(Contract Creation - Step ' + this.processingIndex + ')';
          this.storageCache[this.processingHash][this.processingAddress] = {};
          this.lastProcessedStorageTxHash[this.processingAddress] = this.processingHash;
        } else {
          this.processingAddress = normalizeHexAddress(step.stack[step.stack.length - 2]);
          this.processingAddress = (0, ethereumjs_util_1.toChecksumAddress)(this.processingAddress);

          if (!this.storageCache[this.processingHash][this.processingAddress]) {
            const account = ethereumjs_util_1.Address.fromString(this.processingAddress);

            try {
              const storage = yield this.vm.stateManager.dumpStorage(account);
              this.storageCache[this.processingHash][this.processingAddress] = storage;
              this.lastProcessedStorageTxHash[this.processingAddress] = this.processingHash;
            } catch (e) {
              console.log(e);
            }
          }
        }
      }

      if (previousopcode && previousopcode.op === 'SHA3') {
        const preimage = this.getSha3Input(previousopcode.stack, previousopcode.memory);
        const imageHash = step.stack[step.stack.length - 1].replace('0x', '');
        this.sha3Preimages[imageHash] = {
          preimage: preimage
        };
      }

      this.processingIndex++;
      this.previousDepth = depth;
    });
  }

  getCode(address, cb) {
    address = (0, ethereumjs_util_1.toChecksumAddress)(address);
    this.vm.stateManager.getContractCode(ethereumjs_util_1.Address.fromString(address)).then(result => {
      cb(null, (0, ethereumjs_util_1.bufferToHex)(result));
    }).catch(error => {
      cb(error);
    });
  }

  setProvider(provider) {}

  traceTransaction(txHash, options, cb) {
    if (this.vmTraces[txHash]) {
      if (cb) {
        cb(null, this.vmTraces[txHash]);
      }

      return this.vmTraces[txHash];
    }

    if (cb) {
      cb('unable to retrieve traces ' + txHash, null);
    }
  }

  storageRangeAt(blockNumber, txIndex, address, start, maxLength, cb) {
    // we don't use the range params here
    address = (0, ethereumjs_util_1.toChecksumAddress)(address);
    let txHash;

    if (txIndex === 'latest') {
      txHash = this.lastProcessedStorageTxHash[address];
    } else {
      const block = this.vmContext.blocks[blockNumber];
      txHash = '0x' + block.transactions[txIndex].hash().toString('hex');
    }

    if (this.storageCache[txHash] && this.storageCache[txHash][address]) {
      const storage = this.storageCache[txHash][address];
      return cb(null, {
        storage: JSON.parse(JSON.stringify(storage)),
        nextKey: null
      });
    } // Before https://github.com/ethereum/remix-project/pull/1703, it used to throw error as
    // 'unable to retrieve storage ' + txIndex + ' ' + address


    cb(null, {
      storage: {}
    });
  }

  getBlockNumber(cb) {
    cb(null, 'vm provider');
  }

  getTransaction(txHash, cb) {
    if (this.txs[txHash]) {
      if (cb) {
        cb(null, this.txs[txHash]);
      }

      return this.txs[txHash];
    }

    if (cb) {
      cb('unable to retrieve tx ' + txHash, null);
    }
  }

  getTransactionReceipt(txHash, cb) {
    // same as getTransaction but return the created address also
    if (this.txsReceipt[txHash]) {
      if (cb) {
        cb(null, this.txsReceipt[txHash]);
      }

      return this.txsReceipt[txHash];
    }

    if (cb) {
      cb('unable to retrieve txReceipt ' + txHash, null);
    }
  }

  getTransactionFromBlock(blockNumber, txIndex, cb) {
    const mes = 'not supposed to be needed by remix in vmmode';
    console.log(mes);

    if (cb) {
      cb(mes, null);
    }
  }

  preimage(hashedKey, cb) {
    hashedKey = hashedKey.replace('0x', '');
    cb(null, this.sha3Preimages[hashedKey] !== undefined ? this.sha3Preimages[hashedKey].preimage : null);
  }

  getSha3Input(stack, memory) {
    let memoryStart = stack[stack.length - 1];
    let memoryLength = stack[stack.length - 2];
    const memStartDec = new ethereumjs_util_1.BN(memoryStart.replace('0x', ''), 16).toString(10);
    memoryStart = parseInt(memStartDec) * 2;
    const memLengthDec = new ethereumjs_util_1.BN(memoryLength.replace('0x', ''), 16).toString(10);
    memoryLength = parseInt(memLengthDec) * 2;
    let i = Math.floor(memoryStart / 32);
    const maxIndex = Math.floor(memoryLength / 32) + i;

    if (!memory[i]) {
      return this.emptyFill(memoryLength);
    }

    let sha3Input = memory[i].slice(memoryStart - 32 * i);
    i++;

    while (i < maxIndex) {
      sha3Input += memory[i] ? memory[i] : this.emptyFill(32);
      i++;
    }

    if (sha3Input.length < memoryLength) {
      const leftSize = memoryLength - sha3Input.length;
      sha3Input += memory[i] ? memory[i].slice(0, leftSize) : this.emptyFill(leftSize);
    }

    return sha3Input;
  }

  emptyFill(size) {
    return new Array(size).join('0');
  }

}

exports.VmProxy = VmProxy;

/***/ }),
/* 2279 */,
/* 2280 */,
/* 2281 */,
/* 2282 */,
/* 2283 */,
/* 2284 */,
/* 2285 */,
/* 2286 */,
/* 2287 */,
/* 2288 */,
/* 2289 */,
/* 2290 */,
/* 2291 */,
/* 2292 */,
/* 2293 */,
/* 2294 */,
/* 2295 */,
/* 2296 */,
/* 2297 */,
/* 2298 */,
/* 2299 */,
/* 2300 */,
/* 2301 */,
/* 2302 */,
/* 2303 */,
/* 2304 */,
/* 2305 */,
/* 2306 */,
/* 2307 */,
/* 2308 */,
/* 2309 */,
/* 2310 */,
/* 2311 */,
/* 2312 */,
/* 2313 */,
/* 2314 */,
/* 2315 */,
/* 2316 */,
/* 2317 */,
/* 2318 */,
/* 2319 */,
/* 2320 */,
/* 2321 */,
/* 2322 */,
/* 2323 */,
/* 2324 */,
/* 2325 */,
/* 2326 */,
/* 2327 */,
/* 2328 */,
/* 2329 */,
/* 2330 */,
/* 2331 */,
/* 2332 */,
/* 2333 */,
/* 2334 */,
/* 2335 */,
/* 2336 */,
/* 2337 */,
/* 2338 */,
/* 2339 */,
/* 2340 */,
/* 2341 */,
/* 2342 */,
/* 2343 */,
/* 2344 */,
/* 2345 */,
/* 2346 */,
/* 2347 */,
/* 2348 */,
/* 2349 */,
/* 2350 */,
/* 2351 */,
/* 2352 */,
/* 2353 */,
/* 2354 */,
/* 2355 */,
/* 2356 */,
/* 2357 */,
/* 2358 */,
/* 2359 */,
/* 2360 */,
/* 2361 */,
/* 2362 */,
/* 2363 */,
/* 2364 */,
/* 2365 */,
/* 2366 */,
/* 2367 */,
/* 2368 */,
/* 2369 */,
/* 2370 */,
/* 2371 */,
/* 2372 */,
/* 2373 */,
/* 2374 */,
/* 2375 */,
/* 2376 */,
/* 2377 */,
/* 2378 */,
/* 2379 */,
/* 2380 */,
/* 2381 */,
/* 2382 */,
/* 2383 */,
/* 2384 */,
/* 2385 */,
/* 2386 */,
/* 2387 */,
/* 2388 */,
/* 2389 */,
/* 2390 */,
/* 2391 */,
/* 2392 */,
/* 2393 */,
/* 2394 */,
/* 2395 */,
/* 2396 */,
/* 2397 */,
/* 2398 */,
/* 2399 */,
/* 2400 */,
/* 2401 */,
/* 2402 */,
/* 2403 */,
/* 2404 */,
/* 2405 */,
/* 2406 */,
/* 2407 */,
/* 2408 */,
/* 2409 */,
/* 2410 */,
/* 2411 */,
/* 2412 */,
/* 2413 */,
/* 2414 */,
/* 2415 */,
/* 2416 */,
/* 2417 */,
/* 2418 */,
/* 2419 */,
/* 2420 */,
/* 2421 */,
/* 2422 */,
/* 2423 */,
/* 2424 */,
/* 2425 */,
/* 2426 */,
/* 2427 */,
/* 2428 */,
/* 2429 */,
/* 2430 */,
/* 2431 */,
/* 2432 */,
/* 2433 */,
/* 2434 */,
/* 2435 */,
/* 2436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _interopRequireDefault = __webpack_require__(30);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var Web3 = __webpack_require__(1125);

var _require = __webpack_require__(34),
    hashPersonalMessage = _require.hashPersonalMessage;

var InjectedProvider = /*#__PURE__*/function () {
  function InjectedProvider(executionContext) {
    (0, _classCallCheck2["default"])(this, InjectedProvider);
    this.executionContext = executionContext;
  }

  (0, _createClass2["default"])(InjectedProvider, [{
    key: "getAccounts",
    value: function getAccounts(cb) {
      return this.executionContext.web3().eth.getAccounts(cb);
    }
  }, {
    key: "newAccount",
    value: function newAccount(passwordPromptCb, cb) {
      var _this = this;

      passwordPromptCb(function (passphrase) {
        _this.executionContext.web3().eth.personal.newAccount(passphrase, cb);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {
      /* Do nothing. */
    }
  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      this.executionContext.web3().eth.getBalance(address, function (err, res) {
        if (err) {
          return cb(err);
        }

        cb(null, Web3.utils.fromWei(res.toString(10), 'ether'));
      });
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice(cb) {
      this.executionContext.web3().eth.getGasPrice(cb);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, _passphrase, cb) {
      var messageHash = hashPersonalMessage(Buffer.from(message));

      try {
        this.executionContext.web3().eth.personal.sign(message, account, function (error, signedData) {
          cb(error, '0x' + messageHash.toString('hex'), signedData);
        });
      } catch (e) {
        cb(e.message);
      }
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return 'injected';
    }
  }]);
  return InjectedProvider;
}();

module.exports = InjectedProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _interopRequireDefault = __webpack_require__(30);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var Web3 = __webpack_require__(1125);

var _require = __webpack_require__(34),
    hashPersonalMessage = _require.hashPersonalMessage;

var Personal = __webpack_require__(1288);

var NodeProvider = /*#__PURE__*/function () {
  function NodeProvider(executionContext, config) {
    (0, _classCallCheck2["default"])(this, NodeProvider);
    this.executionContext = executionContext;
    this.config = config;
  }

  (0, _createClass2["default"])(NodeProvider, [{
    key: "getAccounts",
    value: function getAccounts(cb) {
      if (this.config.get('settings/personal-mode')) {
        return this.executionContext.web3().eth.personal.getAccounts(cb);
      }

      return this.executionContext.web3().eth.getAccounts(cb);
    }
  }, {
    key: "newAccount",
    value: function newAccount(passwordPromptCb, cb) {
      var _this = this;

      if (!this.config.get('settings/personal-mode')) {
        return cb('Not running in personal mode');
      }

      passwordPromptCb(function (passphrase) {
        _this.executionContext.web3().eth.personal.newAccount(passphrase, cb);
      });
    }
  }, {
    key: "resetEnvironment",
    value: function resetEnvironment() {
      /* Do nothing. */
    }
  }, {
    key: "getBalanceInEther",
    value: function getBalanceInEther(address, cb) {
      this.executionContext.web3().eth.getBalance(address, function (err, res) {
        if (err) {
          return cb(err);
        }

        cb(null, Web3.utils.fromWei(res.toString(10), 'ether'));
      });
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice(cb) {
      this.executionContext.web3().eth.getGasPrice(cb);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message, account, passphrase, cb) {
      var messageHash = hashPersonalMessage(Buffer.from(message));

      try {
        var personal = new Personal(this.executionContext.web3().currentProvider);
        personal.sign(message, account, passphrase, function (error, signedData) {
          cb(error, '0x' + messageHash.toString('hex'), signedData);
        });
      } catch (e) {
        cb(e.message);
      }
    }
  }, {
    key: "getProvider",
    value: function getProvider() {
      return this.executionContext.getProvider();
    }
  }]);
  return NodeProvider;
}();

module.exports = NodeProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.etherScanLink = etherScanLink;
var transactionDetailsLinks = {
  Main: 'https://www.etherscan.io/tx/',
  Rinkeby: 'https://rinkeby.etherscan.io/tx/',
  Ropsten: 'https://ropsten.etherscan.io/tx/',
  Kovan: 'https://kovan.etherscan.io/tx/',
  Goerli: 'https://goerli.etherscan.io/tx/'
};

function etherScanLink(network, hash) {
  if (transactionDetailsLinks[network]) {
    return transactionDetailsLinks[network] + hash;
  }
}

/***/ }),
/* 2439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HardhatProvider = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var _abstractProvider = __webpack_require__(1266);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'hardhat-provider',
  displayName: 'Hardhat Provider',
  kind: 'provider',
  description: 'Hardhat provider',
  methods: ['sendAsync'],
  version: packageJson.version
};

var HardhatProvider = /*#__PURE__*/function (_AbstractProvider) {
  (0, _inherits2["default"])(HardhatProvider, _AbstractProvider);

  var _super = _createSuper(HardhatProvider);

  function HardhatProvider(blockchain) {
    (0, _classCallCheck2["default"])(this, HardhatProvider);
    return _super.call(this, profile, blockchain, 'http://127.0.0.1:8545');
  }

  (0, _createClass2["default"])(HardhatProvider, [{
    key: "body",
    value: function body() {
      return /*#__PURE__*/_react["default"].createElement("div", null, " Note: To run Hardhat network node on your system, go to hardhat project folder and run command:", /*#__PURE__*/_react["default"].createElement("div", {
        className: "p-1 pl-3"
      }, /*#__PURE__*/_react["default"].createElement("b", null, "npx hardhat node")), /*#__PURE__*/_react["default"].createElement("div", {
        className: "pt-2 pb-4"
      }, "For more info, visit: ", /*#__PURE__*/_react["default"].createElement("a", {
        href: "https://hardhat.org/getting-started/#connecting-a-wallet-or-dapp-to-hardhat-network",
        target: "_blank"
      }, "Hardhat Documentation")), /*#__PURE__*/_react["default"].createElement("div", null, "Hardhat JSON-RPC Endpoint:"));
    }
  }]);
  return HardhatProvider;
}(_abstractProvider.AbstractProvider);

exports.HardhatProvider = HardhatProvider;

/***/ }),
/* 2440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GanacheProvider = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var _abstractProvider = __webpack_require__(1266);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'ganache-provider',
  displayName: 'Ganache Provider',
  kind: 'provider',
  description: 'Truffle Ganache provider',
  methods: ['sendAsync'],
  version: packageJson.version
};

var GanacheProvider = /*#__PURE__*/function (_AbstractProvider) {
  (0, _inherits2["default"])(GanacheProvider, _AbstractProvider);

  var _super = _createSuper(GanacheProvider);

  function GanacheProvider(blockchain) {
    (0, _classCallCheck2["default"])(this, GanacheProvider);
    return _super.call(this, profile, blockchain, 'http://127.0.0.1:8545');
  }

  (0, _createClass2["default"])(GanacheProvider, [{
    key: "body",
    value: function body() {
      return /*#__PURE__*/_react["default"].createElement("div", null, " Note: To run Ganache on your system, run:", /*#__PURE__*/_react["default"].createElement("div", {
        className: "p-1 pl-3"
      }, /*#__PURE__*/_react["default"].createElement("b", null, "yarn global add ganache")), /*#__PURE__*/_react["default"].createElement("div", {
        className: "p-1 pl-3"
      }, /*#__PURE__*/_react["default"].createElement("b", null, "ganache")), /*#__PURE__*/_react["default"].createElement("div", {
        className: "pt-2 pb-4"
      }, "For more info, visit: ", /*#__PURE__*/_react["default"].createElement("a", {
        href: "https://github.com/trufflesuite/ganache",
        target: "_blank"
      }, "Ganache Documentation")), /*#__PURE__*/_react["default"].createElement("div", null, "Ganache JSON-RPC Endpoint:"));
    }
  }]);
  return GanacheProvider;
}(_abstractProvider.AbstractProvider);

exports.GanacheProvider = GanacheProvider;

/***/ }),
/* 2441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FoundryProvider = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var _abstractProvider = __webpack_require__(1266);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'foundry-provider',
  displayName: 'Foundry Provider',
  kind: 'provider',
  description: 'Foundry Anvil provider',
  methods: ['sendAsync'],
  version: packageJson.version
};

var FoundryProvider = /*#__PURE__*/function (_AbstractProvider) {
  (0, _inherits2["default"])(FoundryProvider, _AbstractProvider);

  var _super = _createSuper(FoundryProvider);

  function FoundryProvider(blockchain) {
    (0, _classCallCheck2["default"])(this, FoundryProvider);
    return _super.call(this, profile, blockchain, 'http://127.0.0.1:8545');
  }

  (0, _createClass2["default"])(FoundryProvider, [{
    key: "body",
    value: function body() {
      return /*#__PURE__*/_react["default"].createElement("div", null, " Note: To run Anvil on your system, run:", /*#__PURE__*/_react["default"].createElement("div", {
        className: "p-1 pl-3"
      }, /*#__PURE__*/_react["default"].createElement("b", null, "curl -L https://foundry.paradigm.xyz | bash")), /*#__PURE__*/_react["default"].createElement("div", {
        className: "p-1 pl-3"
      }, /*#__PURE__*/_react["default"].createElement("b", null, "anvil")), /*#__PURE__*/_react["default"].createElement("div", {
        className: "pt-2 pb-4"
      }, "For more info, visit: ", /*#__PURE__*/_react["default"].createElement("a", {
        href: "https://github.com/foundry-rs/foundry",
        target: "_blank"
      }, "Foundry Documentation")), /*#__PURE__*/_react["default"].createElement("div", null, "Anvil JSON-RPC Endpoint:"));
    }
  }]);
  return FoundryProvider;
}(_abstractProvider.AbstractProvider);

exports.FoundryProvider = FoundryProvider;

/***/ }),
/* 2442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExternalHttpProvider = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var _abstractProvider = __webpack_require__(1266);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'basic-http-provider',
  displayName: 'External Http Provider',
  kind: 'provider',
  description: 'External Http Provider',
  methods: ['sendAsync'],
  version: packageJson.version
};

var ExternalHttpProvider = /*#__PURE__*/function (_AbstractProvider) {
  (0, _inherits2["default"])(ExternalHttpProvider, _AbstractProvider);

  var _super = _createSuper(ExternalHttpProvider);

  function ExternalHttpProvider(blockchain) {
    (0, _classCallCheck2["default"])(this, ExternalHttpProvider);
    return _super.call(this, profile, blockchain, 'http://127.0.0.1:8545');
  }

  (0, _createClass2["default"])(ExternalHttpProvider, [{
    key: "body",
    value: function body() {
      var thePath = '<path/to/local/folder/for/test/chain>';
      return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, /*#__PURE__*/_react["default"].createElement("div", {
        className: ""
      }, "Note: To use Geth & https://remix.ethereum.org, configure it to allow requests from Remix:(see ", /*#__PURE__*/_react["default"].createElement("a", {
        href: "https://geth.ethereum.org/docs/rpc/server",
        target: "_blank",
        rel: "noreferrer"
      }, "Geth Docs on rpc server"), ")", /*#__PURE__*/_react["default"].createElement("div", {
        className: "border p-1"
      }, "geth --http --http.corsdomain https://remix.ethereum.org"), /*#__PURE__*/_react["default"].createElement("br", null), "To run Remix & a local Geth test node, use this command: (see ", /*#__PURE__*/_react["default"].createElement("a", {
        href: "https://geth.ethereum.org/getting-started/dev-mode",
        target: "_blank",
        rel: "noreferrer"
      }, "Geth Docs on Dev mode"), ")", /*#__PURE__*/_react["default"].createElement("div", {
        className: "border p-1"
      }, "geth --http --http.corsdomain=\"", window.origin, "\" --http.api web3,eth,debug,personal,net --vmdebug --datadir ", thePath, " --dev console"), /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("b", null, "WARNING:"), " It is not safe to use the --http.corsdomain flag with a wildcard: ", /*#__PURE__*/_react["default"].createElement("b", null, "--http.corsdomain *"), /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("br", null), "For more info: ", /*#__PURE__*/_react["default"].createElement("a", {
        href: "https://remix-ide.readthedocs.io/en/latest/run.html#more-about-web3-provider",
        target: "_blank",
        rel: "noreferrer"
      }, "Remix Docs on External HTTP Provider"), /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("br", null), "External HTTP Provider Endpoint"));
    }
  }]);
  return ExternalHttpProvider;
}(_abstractProvider.AbstractProvider);

exports.ExternalHttpProvider = ExternalHttpProvider;

/***/ }),
/* 2443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Injected0ptimismProvider = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _injectedProvider = __webpack_require__(1579);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'injected-optimism-provider',
  displayName: 'Injected Optimism Provider',
  kind: 'provider',
  description: 'injected Optimism Provider',
  methods: ['sendAsync'],
  version: packageJson.version
};

var Injected0ptimismProvider = /*#__PURE__*/function (_InjectedProvider) {
  (0, _inherits2["default"])(Injected0ptimismProvider, _InjectedProvider);

  var _super = _createSuper(Injected0ptimismProvider);

  function Injected0ptimismProvider() {
    var _this;

    (0, _classCallCheck2["default"])(this, Injected0ptimismProvider);
    _this = _super.call(this, profile);
    _this.chainName = 'Optimism';
    _this.chainId = '0xa';
    _this.rpcUrls = ['https://mainnet.optimism.io'];
    return _this;
  }

  return Injected0ptimismProvider;
}(_injectedProvider.InjectedProvider);

exports.Injected0ptimismProvider = Injected0ptimismProvider;

/***/ }),
/* 2444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InjectedArbitrumOneProvider = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _injectedProvider = __webpack_require__(1579);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'injected-arbitrum-one-provider',
  displayName: 'Injected Arbitrum One Provider',
  kind: 'provider',
  description: 'injected Arbitrum One Provider',
  methods: ['sendAsync'],
  version: packageJson.version
};

var InjectedArbitrumOneProvider = /*#__PURE__*/function (_InjectedProvider) {
  (0, _inherits2["default"])(InjectedArbitrumOneProvider, _InjectedProvider);

  var _super = _createSuper(InjectedArbitrumOneProvider);

  function InjectedArbitrumOneProvider() {
    var _this;

    (0, _classCallCheck2["default"])(this, InjectedArbitrumOneProvider);
    _this = _super.call(this, profile);
    _this.chainName = 'Arbitrum One';
    _this.chainId = '0xa4b1';
    _this.rpcUrls = ['https://arb1.arbitrum.io/rpc'];
    return _this;
  }

  return InjectedArbitrumOneProvider;
}(_injectedProvider.InjectedProvider);

exports.InjectedArbitrumOneProvider = InjectedArbitrumOneProvider;

/***/ }),
/* 2445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchPlugin = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var _search = __webpack_require__(2446);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'search',
  displayName: 'Search in files',
  methods: [''],
  events: [],
  icon: 'assets/img/search_icon.webp',
  description: 'Find and replace in file explorer',
  kind: '',
  location: 'sidePanel',
  documentation: '',
  version: packageJson.version,
  maintainedBy: 'Remix'
};

var SearchPlugin = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(SearchPlugin, _ViewPlugin);

  var _super = _createSuper(SearchPlugin);

  function SearchPlugin() {
    (0, _classCallCheck2["default"])(this, SearchPlugin);
    return _super.call(this, profile);
  }

  (0, _createClass2["default"])(SearchPlugin, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "searchTab"
      }, /*#__PURE__*/_react["default"].createElement(_search.SearchTab, {
        plugin: this
      }));
    }
  }]);
  return SearchPlugin;
}(_engineWeb.ViewPlugin);

exports.SearchPlugin = SearchPlugin;

/***/ }),
/* 2446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "SearchTab", {
  enumerable: true,
  get: function () {
    return _Search.SearchTab;
  }
});

var _Search = __webpack_require__(2447);

/***/ }),
/* 2447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchTab = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _Results = __webpack_require__(2455);

__webpack_require__(2460);

var _Include = __webpack_require__(2462);

var _Exclude = __webpack_require__(2463);

var _FindContainer = __webpack_require__(2464);

var _Undo = __webpack_require__(2468);

var _jsxRuntime = __webpack_require__(46);

const SearchTab = props => {
  const plugin = props.plugin;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "search_plugin_search_tab pr-4 px-2 pb-4",
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_context.SearchProvider, {
        plugin: plugin,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_FindContainer.FindContainer, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Include.Include, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Exclude.Exclude, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Undo.Undo, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_Results.Results, {})]
      })
    })
  });
};

exports.SearchTab = SearchTab;

/***/ }),
/* 2448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceTextInLine = exports.replaceAllInFile = exports.getDirectory = exports.findLinesInStringWithMatch = void 0;

var _os = __webpack_require__(1184);

const getDirectory = async (dir, plugin) => {
  let result = [];
  const files = await plugin.call('fileManager', 'readdir', dir);
  const fileArray = normalize(files);

  for (const fi of fileArray) {
    if (fi) {
      const type = fi.data.isDirectory;

      if (type === true) {
        result = [...result, ...(await getDirectory(`${fi.filename}`, plugin))];
      } else {
        result = [...result, fi.filename];
      }
    }
  }

  return result;
};

exports.getDirectory = getDirectory;

const normalize = filesList => {
  const folders = [];
  const files = [];
  Object.keys(filesList || {}).forEach(key => {
    if (filesList[key].isDirectory) {
      folders.push({
        filename: key,
        data: filesList[key]
      });
    } else {
      files.push({
        filename: key,
        data: filesList[key]
      });
    }
  });
  return [...folders, ...files];
};

const findLinesInStringWithMatch = (str, re) => {
  return str.split(/\r?\n/).map(function (line, i) {
    const matchResult = matchesInString(line, re);

    if (matchResult.length) {
      return {
        lines: splitLines(matchResult, i)
      };
    }
  }).filter(Boolean);
};

exports.findLinesInStringWithMatch = findLinesInStringWithMatch;

const matchesInString = (str, re) => {
  let a;
  const results = [];

  while ((a = re.exec(str || '')) !== null) {
    results.push(a);
  }

  return results;
};

const splitLines = (matchResult, lineNumber) => {
  return matchResult.map((matchResultPart, i) => {
    const result = {
      left: matchResultPart.input.substring(0, matchResultPart.index),
      right: matchResultPart.input.substring(matchResultPart.index + matchResultPart[0].length),
      center: matchResultPart[0],
      position: {
        start: {
          line: lineNumber,
          column: matchResultPart.index
        },
        end: {
          line: lineNumber,
          column: matchResultPart.index + matchResultPart[0].length
        }
      }
    };
    return result;
  });
};

function getEOL(text) {
  const m = text.match(/\r\n|\n/g);
  const u = m && m.filter(a => a === '\n').length;
  const w = m && m.length - u;

  if (u === w) {
    return _os.EOL; // use the OS default
  }

  return u > w ? '\n' : '\r\n';
}

const replaceAllInFile = (string, re, newText) => {
  return string.replace(re, newText);
};

exports.replaceAllInFile = replaceAllInFile;

const replaceTextInLine = (str, searchResultLine, newText) => {
  return str.split(/\r?\n/).map(function (line, i) {
    if (i === searchResultLine.position.start.line) {
      return searchResultLine.left + newText + searchResultLine.right;
    }

    return line;
  }).join(getEOL(str));
};

exports.replaceTextInLine = replaceTextInLine;

/***/ }),
/* 2449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SearchReducer = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _types = __webpack_require__(1580);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const SearchReducer = (state = _types.SearchingInitialState, action) => {
  switch (action.type) {
    case 'START_SEARCH':
      return _objectSpread(_objectSpread({}, state), {}, {
        timeStamp: Date.now()
      });

    case 'SET_FIND':
      return _objectSpread(_objectSpread({}, state), {}, {
        searchResults: null,
        find: action.payload
      });

    case 'SET_REPLACE':
      return _objectSpread(_objectSpread({}, state), {}, {
        replace: action.payload
      });

    case 'SET_REPLACE_ENABLED':
      return _objectSpread(_objectSpread({}, state), {}, {
        replaceEnabled: action.payload
      });

    case 'SET_INCLUDE':
      return _objectSpread(_objectSpread({}, state), {}, {
        include: action.payload
      });

    case 'SET_EXCLUDE':
      return _objectSpread(_objectSpread({}, state), {}, {
        exclude: action.payload
      });

    case 'SET_SEARCH_RESULTS':
      return _objectSpread(_objectSpread({}, state), {}, {
        searchResults: action.payload,
        count: 0,
        run: true
      });

    case 'SET_UNDO_ENABLED':
      if (action.payload.workspace && state.undoBuffer[`${action.payload.workspace}/${action.payload.path}`]) {
        state.undoBuffer[`${action.payload.workspace}/${action.payload.path}`].enabled = action.payload.content === state.undoBuffer[`${action.payload.workspace}/${action.payload.path}`].newContent;
        state.undoBuffer[`${action.payload.workspace}/${action.payload.path}`].visible = action.payload.content !== state.undoBuffer[`${action.payload.workspace}/${action.payload.path}`].oldContent;
      }

      return _objectSpread({}, state);

    case 'SET_UNDO':
      {
        const undoState = {
          newContent: action.payload.newContent,
          oldContent: action.payload.oldContent,
          path: action.payload.path,
          workspace: action.payload.workspace,
          timeStamp: Date.now(),
          enabled: true,
          visible: true
        };
        state.undoBuffer[`${undoState.workspace}/${undoState.path}`] = undoState;
        return _objectSpread({}, state);
      }

    case 'CLEAR_STATS':
      return _objectSpread(_objectSpread({}, state), {}, {
        count: 0,
        fileCount: 0,
        searchResults: null,
        searching: null
      });

    case 'SET_SEARCHING':
      return _objectSpread(_objectSpread({}, state), {}, {
        searching: action.payload
      });

    case 'CLEAR_UNDO':
      {
        state.undoBuffer = [];
        return _objectSpread({}, state);
      }

    case 'UPDATE_COUNT':
      if (state.searchResults) {
        const findFile = state.searchResults.find(file => file.filename === action.payload.file);
        let count = 0;
        let fileCount = 0;
        const clipped = false;

        if (findFile) {
          findFile.count = action.payload.count;
        }

        state.searchResults.forEach(file => {
          if (file.count) {
            count += file.count;
            fileCount++;
          }
        });
        return _objectSpread(_objectSpread({}, state), {}, {
          count: count,
          fileCount,
          clipped
        });
      } else {
        return state;
      }

    case 'SET_CLIPPED':
      return _objectSpread(_objectSpread({}, state), {}, {
        clipped: action.payload
      });

    case 'SET_RUN':
      return _objectSpread(_objectSpread({}, state), {}, {
        run: action.payload
      });

    case 'TOGGLE_CASE_SENSITIVE':
      return _objectSpread(_objectSpread({}, state), {}, {
        casesensitive: !state.casesensitive,
        timeStamp: Date.now()
      });

    case 'TOGGLE_USE_REGEX':
      return _objectSpread(_objectSpread({}, state), {}, {
        useRegExp: !state.useRegExp,
        timeStamp: Date.now()
      });

    case 'TOGGLE_MATCH_WHOLE_WORD':
      return _objectSpread(_objectSpread({}, state), {}, {
        matchWord: !state.matchWord,
        timeStamp: Date.now()
      });

    case 'SET_REPLACE_WITHOUT_CONFIRMATION':
      return _objectSpread(_objectSpread({}, state), {}, {
        replaceWithOutConfirmation: action.payload
      });

    case 'DISABLE_FORCE_RELOAD':
      if (state.searchResults) {
        const findFile = state.searchResults.find(file => file.filename === action.payload);
        if (findFile) findFile.forceReload = false;
      }

      return _objectSpread({}, state);

    case 'SET_CURRENT_FILE':
      return _objectSpread(_objectSpread({}, state), {}, {
        currentFile: action.payload
      });

    case 'SET_CURRENT_WORKSPACE':
      return _objectSpread(_objectSpread({}, state), {}, {
        workspace: action.payload
      });

    case 'RELOAD_FILE':
      if (state.searchResults) {
        const findFile = state.searchResults.find(file => file.filename === action.payload);
        if (findFile) findFile.forceReload = true;
      }

      return _objectSpread({}, state);

    default:
      return _objectSpread({}, state);
  }
};

exports.SearchReducer = SearchReducer;

/***/ }),
/* 2450 */,
/* 2451 */,
/* 2452 */,
/* 2453 */,
/* 2454 */,
/* 2455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Results = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _StopSearch = __webpack_require__(2456);

var _ResultItem = __webpack_require__(2457);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Results = () => {
  const {
    state
  } = (0, _react.useContext)(_context.SearchContext);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    "data-id": "search_results",
    className: "mt-2",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_search_indicator py-1",
      children: [state.searching && !state.clipped ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_StopSearch.StopSearch, {}) : null, " ", state.searching && !state.clipped ? `searching in ${state.searching}` : null, /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {})]
    }), state.find && !state.clipped ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_result_count_number badge badge-pill badge-secondary",
      children: ["showing ", state.count, " results ", state.fileCount, " in files"]
    }) : null, state.find && state.clipped ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "alert alert-warning mt-1",
      children: ["Too many resuls to display...", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "Please narrow down your search."]
    }) : null, state.searchResults && state.searchResults.map((result, index) => {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_ResultItem.ResultItem, {
        index: index,
        file: result
      }, index);
    })]
  });
};

exports.Results = Results;

/***/ }),
/* 2456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StopSearch = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const StopSearch = () => {
  const {
    cancelSearch
  } = (0, _react.useContext)(_context.SearchContext);

  const cancel = async () => {
    await cancelSearch(false);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
    className: "badge badge-danger search_plugin_stop",
    onClick: async () => await cancel(),
    children: "stop"
  });
};

exports.StopSearch = StopSearch;

/***/ }),
/* 2457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResultItem = void 0;

var _app = __webpack_require__(483);

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _ResultFileName = __webpack_require__(2458);

var _ResultSummary = __webpack_require__(2459);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ResultItem = props => {
  const {
    state,
    findText,
    disableForceReload,
    updateCount,
    replaceAllInFile
  } = (0, _react.useContext)(_context.SearchContext);
  const [loading, setLoading] = (0, _react.useState)(false);
  const [lines, setLines] = (0, _react.useState)([]);
  const [toggleExpander, setToggleExpander] = (0, _react.useState)(false);
  const reloadTimeOut = (0, _react.useRef)(null);
  const loadTimeout = (0, _react.useRef)(null);
  const subscribed = (0, _react.useRef)(true);
  const {
    modal
  } = (0, _app.useDialogDispatchers)();
  (0, _react.useEffect)(() => {
    reload();
  }, [props.file.timeStamp]);
  (0, _react.useEffect)(() => {
    if (props.file.forceReload) {
      console.log('force reload');
      clearTimeout(reloadTimeOut.current);
      clearTimeout(loadTimeout.current);
      subscribed.current = true;
      reloadTimeOut.current = setTimeout(() => reload(0), 1000);
    }
  }, [props.file.forceReload]);

  const toggleClass = () => {
    setToggleExpander(!toggleExpander);
  };

  (0, _react.useEffect)(() => {
    subscribed.current = true;
    return () => {
      clearTimeout(reloadTimeOut.current);
      clearTimeout(loadTimeout.current);
      subscribed.current = false;
    };
  }, []);
  (0, _react.useEffect)(() => {
    if (!state.run) {
      clearTimeout(reloadTimeOut.current);
      clearTimeout(loadTimeout.current);
      subscribed.current = false;
    } else {
      subscribed.current = true;
    }
  }, [state.run]);

  const confirmReplace = async () => {
    setLoading(true);

    try {
      await replaceAllInFile(props.file);
    } catch (e) {}

    setLoading(false);
  };

  const replace = async () => {
    if (state.replaceWithOutConfirmation) {
      confirmReplace();
    } else {
      modal({
        id: 'confirmreplace',
        title: 'Replace',
        message: `Are you sure you want to replace '${state.find}' by '${state.replace}' in ${props.file.filename}?`,
        okLabel: 'Yes',
        okFn: confirmReplace,
        cancelLabel: 'No',
        cancelFn: () => {},
        data: null
      });
    }
  };

  const doLoad = () => {
    if (!subscribed.current) return;
    findText(props.file.filename).then(res => {
      if (subscribed.current) {
        setLines(res);

        if (res) {
          let count = 0;
          res.forEach(line => {
            count += line.lines.length;
          });
          updateCount(count, props.file.filename);
        }

        setLoading(false);
        disableForceReload(props.file.filename);
      }
    }).catch(e => {
      console.error(e);
    });
  };

  const reload = time => {
    loadTimeout.current = setTimeout(doLoad, 150 * (time | props.index));
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: lines && lines.length ? /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        onClick: toggleClass,
        className: "search_plugin_search_result_item_title",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
          className: "btn",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
            className: `fas ${toggleExpander ? 'fa-angle-right' : 'fa-angle-down'}`,
            "aria-hidden": "true"
          })
        }), ' ', /*#__PURE__*/(0, _jsxRuntime.jsx)(_ResultFileName.ResultFileName, {
          file: props.file
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "search_plugin_result_count",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "search_plugin_result_count_number badge badge-pill badge-secondary",
            children: props.file.count
          })
        })]
      }), loading ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "loading",
        children: "Loading..."
      }) : null, !toggleExpander && !loading ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "search_plugin_wrap_summary",
        children: [state.replaceEnabled ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "search_plugin_wrap_summary_replace",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            "data-id": `replace-all-${props.file.filename}`,
            onClick: async () => replace(),
            className: "btn btn-secondary mb-2 btn-sm",
            children: "Replace all"
          })
        }) : null, lines.map((line, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_ResultSummary.ResultSummary, {
          setLoading: setLoading,
          searchResult: props.file,
          line: line
        }, index))]
      }) : null]
    }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {})
  });
};

exports.ResultItem = ResultItem;

/***/ }),
/* 2458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResultFileName = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _helper = __webpack_require__(1121);

var path = _interopRequireWildcard(__webpack_require__(1124));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ResultFileName = props => {
  const [icon, setIcon] = (0, _react.useState)('');
  (0, _react.useEffect)(() => {
    if (props.file && props.file.path) {
      setIcon((0, _helper.getPathIcon)(props.file.path));
    }
  }, [props.file]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [icon ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: `${icon} caret caret_tv`
    }) : null, /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      title: props.file.filename,
      className: "search_plugin_search_file_name ml-2",
      children: [path.basename(props.file.path), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "pl-1 text-muted text-lowercase",
        children: path.dirname(props.file.path)
      })]
    })]
  });
};

exports.ResultFileName = ResultFileName;

/***/ }),
/* 2459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResultSummary = void 0;

var _app = __webpack_require__(483);

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ResultSummary = props => {
  const {
    hightLightInPath,
    replaceText,
    state
  } = (0, _react.useContext)(_context.SearchContext);
  const {
    modal
  } = (0, _app.useDialogDispatchers)();

  const selectLine = async line => {
    await hightLightInPath(props.searchResult, line);
  };

  const confirmReplace = async line => {
    props.setLoading(true);

    try {
      await replaceText(props.searchResult, line);
    } catch (e) {
      props.setLoading(false);
    }
  };

  const replace = async line => {
    if (state.replaceWithOutConfirmation) {
      confirmReplace(line);
    } else {
      modal({
        id: 'confirmreplace',
        title: 'Replace',
        message: `Are you sure you want to replace '${line.center}' by '${state.replace}' in ${props.searchResult.filename}?`,
        okLabel: 'Yes',
        okFn: confirmReplace,
        cancelLabel: 'No',
        cancelFn: () => {},
        data: line
      });
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: props.line.lines.map((lineItem, index) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_search_line_container",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        onClick: async () => {
          selectLine(lineItem);
        },
        "data-id": `${props.searchResult.filename}-${lineItem.position.start.line}-${lineItem.position.start.column}`,
        className: "search_plugin_search_line  pb-1",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "search_plugin_summary_left",
          children: lineItem.left.substring(lineItem.left.length - 20).trimStart()
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("mark", {
          className: `search_plugin_summary_center ${state.replace && state.replaceEnabled ? 'search_plugin_replace_strike' : ''}`,
          children: lineItem.center
        }), state.replace && state.replaceEnabled ? /*#__PURE__*/(0, _jsxRuntime.jsx)("mark", {
          className: "search_plugin_replacement",
          children: state.replace
        }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "search_plugin_summary_right",
          children: lineItem.right.substring(0, 100)
        })]
      }, props.searchResult.filename), state.replaceEnabled ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "search_plugin_search_control",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          title: "Replace",
          "data-id": `replace-${props.searchResult.filename}-${lineItem.position.start.line}-${lineItem.position.start.column}`,
          onClick: async () => {
            replace(lineItem);
          },
          className: "codicon codicon-find-replace",
          role: "button",
          "aria-label": "Replace",
          "aria-disabled": "false"
        })
      }) : null]
    }, index))
  });
};

exports.ResultSummary = ResultSummary;

/***/ }),
/* 2460 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2461);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2461 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".search_plugin_search_result_item_title {\n    display: flex;\n    -webkit-user-select: none; /* Safari */        \n    -moz-user-select: none; /* Firefox */\n    -ms-user-select: none; /* IE10+/Edge */\n    user-select: none; /* Standard */\n    cursor: pointer;\n    align-items: center;\n}\n\n.search_plugin_wrap_summary {\n    overflow: hidden;\n    white-space: nowrap;\n    -webkit-user-select: none; /* Safari */        \n    -moz-user-select: none; /* Firefox */\n    -ms-user-select: none; /* IE10+/Edge */\n    user-select: none; /* Standard */\n    cursor: pointer;\n}\n\n.search_plugin_find-part {\n    display: flex;\n    flex-direction: column;\n    padding-top: 5px;\n}\n\n.search_plugin_controls {\n    display: flex;\n}\n\n.search_plugin_search_tab .search_plugin_search_line_container {\n    display: flex;\n    flex-direction: row;\n    position: relative;\n}\n\n.search_plugin_search_tab .search_plugin_search_line {\n    width: 100%;\n    overflow: hidden;\n    display: flex;\n}\n\n.search_plugin_search_tab .search_plugin_search_control {\n    flex-grow: 0;\n    position: absolute;\n    right: 0px;\n    top: 0px;\n}\n\n.search_plugin_summary_right {\n    min-width: 0;\n    white-space: pre;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.search_plugin_search_tab .search_plugin_replace_strike {\n    text-decoration: line-through;\n}\n\n.search_plugin_summary_left {\n    white-space: pre;\n}\n\n.search_plugin_search_tab mark {\n    padding: 0;\n    white-space: pre;\n}\n\n.search_plugin_search_tab .search_plugin_search_line_container .search_plugin_search_control {\n    display: none;\n}\n\n.search_plugin_search_tab .search_plugin_search_line_container:hover .search_plugin_search_control {\n    display: block;\n}\n\n.search_plugin_search_tab .search_plugin_search_line_container:hover .search_plugin_search_line {\n    width: 93%;\n}\n\n.search_plugin_search-input {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n.search_plugin_search_tab .checked {\n    background-color: var(--secondary);\n}\n\n.search_plugin_search_tab .search_plugin_search_file_name {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    text-transform: uppercase;\n}\n\n.search_plugin_search_tab  .search_plugin_result_count {\n    flex-grow: 1;\n    text-align: right;\n    display: flex;\n    justify-content: flex-end;\n}\n\n.search_plugin_search_tab .search_plugin_result_count_number {\n    font-size: x-small;\n}\n\n.search_plugin_find_container {\n    display: flex;\n    flex-direction: row;\n}\n\n.search_plugin_find_container_internal {\n    display: flex;\n    flex-direction: column;\n    flex-grow: 1;\n}\n\n.search_plugin_find_container_arrow {\n    display: flex !important;\n    align-items: center;\n    cursor:  pointer !important;\n}\n\n.search_plugin_wrap_summary_replace {\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-end;\n}\n\n.undo-button {\n    white-space: pre;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.search_plugin_search_indicator{\n    white-space: pre;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.search_plugin_stop{\n    cursor: pointer;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNlYXJjaC5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7SUFDSSxhQUFhO0lBQ2IseUJBQXlCLEVBQUUsV0FBVztJQUN0QyxzQkFBc0IsRUFBRSxZQUFZO0lBQ3BDLHFCQUFxQixFQUFFLGVBQWU7SUFDdEMsaUJBQWlCLEVBQUUsYUFBYTtJQUNoQyxlQUFlO0lBQ2YsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksZ0JBQWdCO0lBQ2hCLG1CQUFtQjtJQUNuQix5QkFBeUIsRUFBRSxXQUFXO0lBQ3RDLHNCQUFzQixFQUFFLFlBQVk7SUFDcEMscUJBQXFCLEVBQUUsZUFBZTtJQUN0QyxpQkFBaUIsRUFBRSxhQUFhO0lBQ2hDLGVBQWU7QUFDbkI7O0FBRUE7SUFDSSxhQUFhO0lBQ2Isc0JBQXNCO0lBQ3RCLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGFBQWE7QUFDakI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLFdBQVc7SUFDWCxnQkFBZ0I7SUFDaEIsYUFBYTtBQUNqQjs7QUFFQTtJQUNJLFlBQVk7SUFDWixrQkFBa0I7SUFDbEIsVUFBVTtJQUNWLFFBQVE7QUFDWjs7QUFFQTtJQUNJLFlBQVk7SUFDWixnQkFBZ0I7SUFDaEIsdUJBQXVCO0lBQ3ZCLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLDZCQUE2QjtBQUNqQzs7QUFFQTtJQUNJLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLFVBQVU7SUFDVixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxhQUFhO0FBQ2pCOztBQUVBO0lBQ0ksY0FBYztBQUNsQjs7QUFFQTtJQUNJLFVBQVU7QUFDZDs7QUFFQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksa0NBQWtDO0FBQ3RDOztBQUVBO0lBQ0ksdUJBQXVCO0lBQ3ZCLGdCQUFnQjtJQUNoQix5QkFBeUI7QUFDN0I7O0FBRUE7SUFDSSxZQUFZO0lBQ1osaUJBQWlCO0lBQ2pCLGFBQWE7SUFDYix5QkFBeUI7QUFDN0I7O0FBRUE7SUFDSSxrQkFBa0I7QUFDdEI7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtJQUN0QixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksd0JBQXdCO0lBQ3hCLG1CQUFtQjtJQUNuQiwyQkFBMkI7QUFDL0I7O0FBRUE7SUFDSSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLHlCQUF5QjtBQUM3Qjs7QUFFQTtJQUNJLGdCQUFnQjtJQUNoQix1QkFBdUI7SUFDdkIsZ0JBQWdCO0FBQ3BCOztBQUNBO0lBQ0ksZ0JBQWdCO0lBQ2hCLHVCQUF1QjtJQUN2QixnQkFBZ0I7QUFDcEI7O0FBQ0E7SUFDSSxlQUFlO0FBQ25CIiwiZmlsZSI6InNlYXJjaC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuc2VhcmNoX3BsdWdpbl9zZWFyY2hfcmVzdWx0X2l0ZW1fdGl0bGUge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovICAgICAgICBcbiAgICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXG4gICAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAvKiBJRTEwKy9FZGdlICovXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFN0YW5kYXJkICovXG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3dyYXBfc3VtbWFyeSB7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqLyAgICAgICAgXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLyogRmlyZWZveCAqL1xuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSUUxMCsvRWRnZSAqL1xuICAgIHVzZXItc2VsZWN0OiBub25lOyAvKiBTdGFuZGFyZCAqL1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLnNlYXJjaF9wbHVnaW5fZmluZC1wYXJ0IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgcGFkZGluZy10b3A6IDVweDtcbn1cblxuLnNlYXJjaF9wbHVnaW5fY29udHJvbHMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3NlYXJjaF90YWIgLnNlYXJjaF9wbHVnaW5fc2VhcmNoX2xpbmVfY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uc2VhcmNoX3BsdWdpbl9zZWFyY2hfdGFiIC5zZWFyY2hfcGx1Z2luX3NlYXJjaF9saW5lIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGRpc3BsYXk6IGZsZXg7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3NlYXJjaF90YWIgLnNlYXJjaF9wbHVnaW5fc2VhcmNoX2NvbnRyb2wge1xuICAgIGZsZXgtZ3JvdzogMDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDBweDtcbiAgICB0b3A6IDBweDtcbn1cblxuLnNlYXJjaF9wbHVnaW5fc3VtbWFyeV9yaWdodCB7XG4gICAgbWluLXdpZHRoOiAwO1xuICAgIHdoaXRlLXNwYWNlOiBwcmU7XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuLnNlYXJjaF9wbHVnaW5fc2VhcmNoX3RhYiAuc2VhcmNoX3BsdWdpbl9yZXBsYWNlX3N0cmlrZSB7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3N1bW1hcnlfbGVmdCB7XG4gICAgd2hpdGUtc3BhY2U6IHByZTtcbn1cblxuLnNlYXJjaF9wbHVnaW5fc2VhcmNoX3RhYiBtYXJrIHtcbiAgICBwYWRkaW5nOiAwO1xuICAgIHdoaXRlLXNwYWNlOiBwcmU7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3NlYXJjaF90YWIgLnNlYXJjaF9wbHVnaW5fc2VhcmNoX2xpbmVfY29udGFpbmVyIC5zZWFyY2hfcGx1Z2luX3NlYXJjaF9jb250cm9sIHtcbiAgICBkaXNwbGF5OiBub25lO1xufVxuXG4uc2VhcmNoX3BsdWdpbl9zZWFyY2hfdGFiIC5zZWFyY2hfcGx1Z2luX3NlYXJjaF9saW5lX2NvbnRhaW5lcjpob3ZlciAuc2VhcmNoX3BsdWdpbl9zZWFyY2hfY29udHJvbCB7XG4gICAgZGlzcGxheTogYmxvY2s7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3NlYXJjaF90YWIgLnNlYXJjaF9wbHVnaW5fc2VhcmNoX2xpbmVfY29udGFpbmVyOmhvdmVyIC5zZWFyY2hfcGx1Z2luX3NlYXJjaF9saW5lIHtcbiAgICB3aWR0aDogOTMlO1xufVxuXG4uc2VhcmNoX3BsdWdpbl9zZWFyY2gtaW5wdXQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuXG4uc2VhcmNoX3BsdWdpbl9zZWFyY2hfdGFiIC5jaGVja2VkIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmRhcnkpO1xufVxuXG4uc2VhcmNoX3BsdWdpbl9zZWFyY2hfdGFiIC5zZWFyY2hfcGx1Z2luX3NlYXJjaF9maWxlX25hbWUge1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbn1cblxuLnNlYXJjaF9wbHVnaW5fc2VhcmNoX3RhYiAgLnNlYXJjaF9wbHVnaW5fcmVzdWx0X2NvdW50IHtcbiAgICBmbGV4LWdyb3c6IDE7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xufVxuXG4uc2VhcmNoX3BsdWdpbl9zZWFyY2hfdGFiIC5zZWFyY2hfcGx1Z2luX3Jlc3VsdF9jb3VudF9udW1iZXIge1xuICAgIGZvbnQtc2l6ZTogeC1zbWFsbDtcbn1cblxuLnNlYXJjaF9wbHVnaW5fZmluZF9jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbn1cblxuLnNlYXJjaF9wbHVnaW5fZmluZF9jb250YWluZXJfaW50ZXJuYWwge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBmbGV4LWdyb3c6IDE7XG59XG5cbi5zZWFyY2hfcGx1Z2luX2ZpbmRfY29udGFpbmVyX2Fycm93IHtcbiAgICBkaXNwbGF5OiBmbGV4ICFpbXBvcnRhbnQ7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBjdXJzb3I6ICBwb2ludGVyICFpbXBvcnRhbnQ7XG59XG5cbi5zZWFyY2hfcGx1Z2luX3dyYXBfc3VtbWFyeV9yZXBsYWNlIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbn1cblxuLnVuZG8tYnV0dG9uIHtcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG4uc2VhcmNoX3BsdWdpbl9zZWFyY2hfaW5kaWNhdG9ye1xuICAgIHdoaXRlLXNwYWNlOiBwcmU7XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbi5zZWFyY2hfcGx1Z2luX3N0b3B7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufSJdfQ== */", '', '']]

/***/ }),
/* 2462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Include = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Include = props => {
  const {
    setInclude,
    cancelSearch,
    startSearch
  } = (0, _react.useContext)(_context.SearchContext);
  const [includeInput, setIncludeInput] = (0, _react.useState)('*.sol, *.js');

  const change = async e => {
    setIncludeInput(e.target.value);
    await cancelSearch();
  };

  const handleKeypress = async e => {
    await setInclude(includeInput);

    if (e.charCode === 13 || e.keyCode === 13) {
      startSearch();
    }
  };

  (0, _react.useEffect)(() => {
    setInclude(includeInput);
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_find-part pl-3",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "mt-2",
        children: "Files to include"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        id: "search_include",
        placeholder: "Include ie *.sol ( Enter to include )",
        className: "form-control",
        onChange: async e => change(e),
        onKeyUp: handleKeypress,
        value: includeInput
      })]
    })
  });
};

exports.Include = Include;

/***/ }),
/* 2463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Exclude = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Exclude = props => {
  const {
    setExclude,
    cancelSearch,
    startSearch
  } = (0, _react.useContext)(_context.SearchContext);
  const [excludeInput, setExcludeInput] = (0, _react.useState)('.*/**/*');

  const change = async e => {
    setExcludeInput(e.target.value);
    await cancelSearch();
  };

  const handleKeypress = async e => {
    await setExclude(excludeInput);

    if (e.charCode === 13 || e.keyCode === 13) {
      startSearch();
    }
  };

  (0, _react.useEffect)(() => {
    setExclude(excludeInput);
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_find-part pl-3",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "mt-2",
        children: "Files to exclude"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        id: "search_exclude",
        placeholder: "Exclude ie .git/**/* ( Enter to exclude )",
        className: "form-control",
        onKeyUp: handleKeypress,
        onChange: async e => change(e),
        value: excludeInput
      })]
    })
  });
};

exports.Exclude = Exclude;

/***/ }),
/* 2464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindContainer = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _Find = __webpack_require__(2465);

var _OverWriteCheck = __webpack_require__(2466);

var _Replace = __webpack_require__(2467);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const FindContainer = props => {
  const {
    setReplaceEnabled
  } = (0, _react.useContext)(_context.SearchContext);
  const [expanded, setExpanded] = (0, _react.useState)(false);

  const toggleExpand = () => setExpanded(!expanded);

  (0, _react.useEffect)(() => {
    setReplaceEnabled(expanded);
  }, [expanded]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "search_plugin_find_container",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      title: "Toggle Replace",
      "data-id": "toggle_replace",
      className: `codicon codicon-find-${expanded ? 'expanded' : 'collapsed'} search_plugin_find_container_arrow`,
      role: "button",
      onClick: toggleExpand,
      "aria-label": "Toggle Replace",
      "aria-expanded": "true",
      "aria-disabled": "false"
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_find_container_internal",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Find.Find, {}), expanded ? /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Replace.Replace, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_OverWriteCheck.OverWriteCheck, {})]
      }) : null]
    })]
  });
};

exports.FindContainer = FindContainer;

/***/ }),
/* 2465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Find = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Find = () => {
  const {
    setFind,
    cancelSearch,
    startSearch,
    state,
    toggleCaseSensitive,
    toggleMatchWholeWord,
    toggleUseRegex
  } = (0, _react.useContext)(_context.SearchContext);
  const [inputValue, setInputValue] = (0, _react.useState)('');

  const change = async e => {
    setInputValue(e.target.value);
    await cancelSearch();
  };

  const handleKeypress = async e => {
    if (e.charCode === 13 || e.keyCode === 13) {
      startSearch();
    }

    await setFind(inputValue);
  };

  (0, _react.useEffect)(() => {
    setInputValue('');
  }, [state.workspace]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "search_plugin_find-part",
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "search_plugin_search-input",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          id: "search_input",
          placeholder: "Search ( Enter to search )",
          className: "form-control",
          value: inputValue,
          onChange: async e => await change(e),
          onKeyUp: handleKeypress
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "search_plugin_controls",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            "data-id": "search_case_sensitive",
            title: "Match Case",
            className: `monaco-custom-checkbox codicon codicon-case-sensitive ${state.casesensitive ? 'checked' : ''}`,
            role: "checkbox",
            "aria-checked": "false",
            "aria-label": "Match Case",
            "aria-disabled": "false",
            onClick: () => {
              toggleCaseSensitive();
            }
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            "data-id": "search_whole_word",
            title: "Match Whole Word",
            className: `monaco-custom-checkbox codicon codicon-whole-word ${state.matchWord ? 'checked' : ''}`,
            role: "checkbox",
            "aria-checked": "false",
            "aria-label": "Match Whole Word",
            "aria-disabled": "false",
            onClick: () => {
              toggleMatchWholeWord();
            }
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            "data-id": "search_use_regex",
            title: "Use Regular Expression",
            className: `monaco-custom-checkbox codicon codicon-regex ${state.useRegExp ? 'checked' : ''}`,
            role: "checkbox",
            "aria-checked": "false",
            "aria-label": "Use Regular Expression",
            "aria-disabled": "false",
            onClick: () => {
              toggleUseRegex();
            }
          })]
        })]
      })
    })
  });
};

exports.Find = Find;

/***/ }),
/* 2466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OverWriteCheck = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const OverWriteCheck = props => {
  const {
    setReplaceWithoutConfirmation,
    state
  } = (0, _react.useContext)(_context.SearchContext);

  const change = e => {
    setReplaceWithoutConfirmation(e.target.checked);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: state.replaceEnabled ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "search_plugin_find-part",
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "mb-2 remixui_nightlyBuilds custom-control custom-checkbox",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          className: "mr-2 custom-control-input",
          id: "confirm_replace",
          type: "checkbox",
          onChange: change
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          htmlFor: "confirm_replace",
          "data-id": "confirm_replace_label",
          className: "form-check-label custom-control-label",
          children: "replace without confirmation"
        })]
      })
    }) : null
  });
};

exports.OverWriteCheck = OverWriteCheck;

/***/ }),
/* 2467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Replace = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Replace = props => {
  const {
    setReplace
  } = (0, _react.useContext)(_context.SearchContext);
  const timeOutId = (0, _react.useRef)(null);

  const change = e => {
    clearTimeout(timeOutId.current);
    timeOutId.current = setTimeout(() => setReplace(e.target.value), 500);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "search_plugin_find-part ",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "d-none",
        children: "replace in files"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        id: "search_replace",
        placeholder: "Replace",
        className: "form-control",
        onChange: change
      })]
    })
  });
};

exports.Replace = Replace;

/***/ }),
/* 2468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Undo = void 0;

var _app = __webpack_require__(483);

var _react = _interopRequireWildcard(__webpack_require__(29));

var _context = __webpack_require__(1147);

var path = _interopRequireWildcard(__webpack_require__(1124));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Undo = () => {
  const {
    state,
    undoReplace
  } = (0, _react.useContext)(_context.SearchContext);
  const {
    alert
  } = (0, _app.useDialogDispatchers)();

  const undo = async () => {
    try {
      await undoReplace(state.undoBuffer[`${state.workspace}/${state.currentFile}`]);
    } catch (e) {
      alert({
        id: 'undo_error',
        title: 'Cannot undo this change',
        message: e.message
      });
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: state.undoBuffer && state.undoBuffer[`${state.workspace}/${state.currentFile}`] && state.undoBuffer[`${state.workspace}/${state.currentFile}`].visible ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
      "data-id": `undo-replace-${state.currentFile}`,
      disabled: !state.undoBuffer[`${state.workspace}/${state.currentFile}`].enabled,
      onClick: async () => await undo(),
      className: "undo-button btn btn-secondary btn-block my-3",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "fas fa-undo mr-2"
      }), "Undo changes to ", path.basename(state.undoBuffer[`${state.workspace}/${state.currentFile}`].path)]
    }) : null
  });
};

exports.Undo = Undo;

/***/ }),
/* 2469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var FileProvider = __webpack_require__(1362);

module.exports = /*#__PURE__*/function (_FileProvider) {
  (0, _inherits2["default"])(RemixDProvider, _FileProvider);

  var _super = _createSuper(RemixDProvider);

  function RemixDProvider(appManager) {
    var _this;

    (0, _classCallCheck2["default"])(this, RemixDProvider);
    _this = _super.call(this, 'localhost');
    _this._appManager = appManager;
    _this.error = {
      EEXIST: 'File already exists'
    };
    _this._isReady = false;
    _this._readOnlyFiles = {};
    _this._readOnlyMode = false;
    _this.filesContent = {};
    _this.files = {};
    return _this;
  }

  (0, _createClass2["default"])(RemixDProvider, [{
    key: "_registerEvent",
    value: function _registerEvent() {
      var _this2 = this;

      var remixdEvents = ['connecting', 'connected', 'errored', 'closed'];
      remixdEvents.forEach(function (event) {
        _this2._appManager.on('remixd', event, function (value) {
          _this2.event.emit(event, value);
        });
      });

      this._appManager.on('remixd', 'folderAdded', function (path) {
        _this2.event.emit('folderAdded', path);
      });

      this._appManager.on('remixd', 'fileAdded', function (path) {
        _this2.event.emit('fileAdded', path);
      });

      this._appManager.on('remixd', 'fileChanged', function (path) {
        _this2.event.emit('fileChanged', path);
      });

      this._appManager.on('remixd', 'fileRemoved', function (path) {
        _this2.event.emit('fileRemoved', path);
      });

      this._appManager.on('remixd', 'fileRenamed', function (oldPath, newPath) {
        _this2.event.emit('fileRenamed', oldPath, newPath);
      });

      this._appManager.on('remixd', 'rootFolderChanged', function (path) {
        _this2.event.emit('rootFolderChanged', path);
      });

      this._appManager.on('remixd', 'removed', function (path) {
        _this2.event.emit('fileRemoved', path);
      });

      this._appManager.on('remixd', 'changed', function (path) {
        _this2.get(path, function (_error, content) {
          _this2.event.emit('fileExternallyChanged', path, content);
        });
      });
    }
  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._isReady;
    }
  }, {
    key: "close",
    value: function close(cb) {
      this._isReady = false;
      cb();
      this.event.emit('disconnected');
    }
  }, {
    key: "preInit",
    value: function preInit() {
      this.event.emit('loadingLocalhost');
    }
  }, {
    key: "init",
    value: function init(cb) {
      var _this3 = this;

      if (this._isReady) return cb && cb();

      this._appManager.call('remixd', 'folderIsReadOnly', {}).then(function (result) {
        _this3._isReady = true;
        _this3._readOnlyMode = result;

        _this3.event.emit('readOnlyModeChanged', result);

        _this3._registerEvent();

        _this3.event.emit('connected');

        cb && cb();
      })["catch"](function (error) {
        cb && cb(error);
      });
    }
  }, {
    key: "exists",
    value: function exists(path) {
      if (!this._isReady) throw new Error('provider not ready');
      var unprefixedpath = this.removePrefix(path);
      return this._appManager.call('remixd', 'exists', {
        path: unprefixedpath
      }).then(function (result) {
        return result;
      })["catch"](function (error) {
        throw new Error(error);
      });
    }
  }, {
    key: "get",
    value: function () {
      var _get = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(path, cb) {
        var unprefixedpath, file;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._isReady) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", cb && cb('provider not ready'));

              case 2:
                unprefixedpath = this.removePrefix(path);
                _context.prev = 3;
                _context.next = 6;
                return this._appManager.call('remixd', 'get', {
                  path: unprefixedpath
                });

              case 6:
                file = _context.sent;
                this.filesContent[path] = file.content;

                if (file.readonly) {
                  this._readOnlyFiles[path] = 1;
                }

                if (cb) cb(null, file.content);
                return _context.abrupt("return", file.content);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](3);
                if (_context.t0) console.log(_context.t0);

                if (!cb) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return", cb(null, this.filesContent[path]));

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 13]]);
      }));

      function get(_x, _x2) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(path, content, cb) {
        var unprefixedpath;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this._isReady) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", cb && cb('provider not ready'));

              case 2:
                unprefixedpath = this.removePrefix(path);
                return _context3.abrupt("return", this._appManager.call('remixd', 'set', {
                  path: unprefixedpath,
                  content: content
                }).then( /*#__PURE__*/function () {
                  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(result) {
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!cb) {
                              _context2.next = 2;
                              break;
                            }

                            return _context2.abrupt("return", cb(null, result));

                          case 2:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x6) {
                    return _ref.apply(this, arguments);
                  };
                }())["catch"](function (error) {
                  if (cb) return cb(error);
                  throw new Error(error);
                }));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x3, _x4, _x5) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "createDir",
    value: function () {
      var _createDir = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(path, cb) {
        var unprefixedpath;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this._isReady) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", cb && cb('provider not ready'));

              case 2:
                unprefixedpath = this.removePrefix(path);
                return _context4.abrupt("return", this._appManager.call('remixd', 'createDir', {
                  path: unprefixedpath
                }));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function createDir(_x7, _x8) {
        return _createDir.apply(this, arguments);
      }

      return createDir;
    }()
  }, {
    key: "isReadOnly",
    value: function isReadOnly(path) {
      return this._readOnlyMode || this._readOnlyFiles[path] === 1;
    }
  }, {
    key: "remove",
    value: function remove(path) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (!_this4._isReady) return reject(new Error('provider not ready'));

        var unprefixedpath = _this4.removePrefix(path);

        _this4._appManager.call('remixd', 'remove', {
          path: unprefixedpath
        }).then(function (result) {
          var path = unprefixedpath;
          delete _this4.filesContent[path];
          resolve(true);

          _this4.init();
        })["catch"](function (error) {
          if (error) console.log(error);
          resolve(false);
        });
      });
    }
  }, {
    key: "rename",
    value: function rename(oldPath, newPath, isFolder) {
      var _this5 = this;

      var unprefixedoldPath = this.removePrefix(oldPath);
      var unprefixednewPath = this.removePrefix(newPath);
      if (!this._isReady) return new Promise(function (resolve, reject) {
        return reject(new Error('provider not ready'));
      });
      return this._appManager.call('remixd', 'rename', {
        oldPath: unprefixedoldPath,
        newPath: unprefixednewPath
      }).then(function (result) {
        var newPath = unprefixednewPath;
        var oldPath = unprefixedoldPath;
        _this5.filesContent[newPath] = _this5.filesContent[oldPath];
        delete _this5.filesContent[oldPath];

        _this5.init(function () {
          _this5.event.emit('fileRenamed', oldPath, newPath, isFolder);
        });

        return result;
      })["catch"](function (error) {
        console.log(error);
        if (_this5.error[error.code]) error = _this5.error[error.code];

        _this5.event.emit('fileRenamedError', _this5.error[error.code]);
      });
    }
  }, {
    key: "isExternalFolder",
    value: function isExternalFolder(path) {
      return false;
    }
  }, {
    key: "removePrefix",
    value: function removePrefix(path) {
      path = path.indexOf(this.type) === 0 ? path.replace(this.type, '') : path;
      if (path[0] === '/') return path.substring(1);
      if (path === '') return '/';
      return path;
    }
  }, {
    key: "resolveDirectory",
    value: function resolveDirectory(path, callback) {
      if (path[0] === '/') path = path.substring(1);
      var unprefixedpath = this.removePrefix(path);
      if (!this._isReady) return callback && callback('provider not ready');

      this._appManager.call('remixd', 'resolveDirectory', {
        path: unprefixedpath
      }).then(function (result) {
        callback(null, result);
      })["catch"](callback);
    }
  }, {
    key: "isDirectory",
    value: function () {
      var _isDirectory = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(path) {
        var unprefixedpath;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                unprefixedpath = this.removePrefix(path);

                if (this._isReady) {
                  _context5.next = 3;
                  break;
                }

                throw new Error('provider not ready');

              case 3:
                _context5.next = 5;
                return this._appManager.call('remixd', 'isDirectory', {
                  path: unprefixedpath
                });

              case 5:
                return _context5.abrupt("return", _context5.sent);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function isDirectory(_x9) {
        return _isDirectory.apply(this, arguments);
      }

      return isDirectory;
    }()
  }, {
    key: "isFile",
    value: function () {
      var _isFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(path) {
        var unprefixedpath;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                unprefixedpath = this.removePrefix(path);

                if (this._isReady) {
                  _context6.next = 3;
                  break;
                }

                throw new Error('provider not ready');

              case 3:
                _context6.next = 5;
                return this._appManager.call('remixd', 'isFile', {
                  path: unprefixedpath
                });

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function isFile(_x10) {
        return _isFile.apply(this, arguments);
      }

      return isFile;
    }()
  }]);
  return RemixDProvider;
}(FileProvider);

/***/ }),
/* 2470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(498));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _registry = _interopRequireDefault(__webpack_require__(315));

var _events = __webpack_require__(40);

var _helper = __webpack_require__(1121);

var _helper2 = _interopRequireDefault(__webpack_require__(1310));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/*
  attach to files event (removed renamed)
  trigger: currentFileChanged
*/
var profile = {
  name: 'fileManager',
  displayName: 'File manager',
  description: 'Service - read/write to any files or folders, require giving permissions',
  icon: 'assets/img/fileManager.webp',
  permission: true,
  version: packageJson.version,
  methods: ['closeAllFiles', 'closeFile', 'file', 'exists', 'open', 'writeFile', 'readFile', 'copyFile', 'copyDir', 'rename', 'mkdir', 'readdir', 'dirList', 'fileList', 'remove', 'getCurrentFile', 'getFile', 'getFolder', 'setFile', 'switchFile', 'refresh', 'getProviderOf', 'getProviderByName', 'getPathFromUrl', 'getUrlFromPath', 'saveCurrentFile', 'setBatchFiles', 'isGitRepo'],
  kind: 'file-system'
};
var errorMsg = {
  ENOENT: 'No such file or directory',
  EISDIR: 'Path is a directory',
  ENOTDIR: 'Path is not on a directory',
  EEXIST: 'File already exists',
  EPERM: 'Permission denied'
};

var createError = function createError(err) {
  return new Error("".concat(errorMsg[err.code], " ").concat(err.message || ''));
};

var FileManager = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(FileManager, _Plugin);

  var _super = _createSuper(FileManager);

  function FileManager(editor, appManager) {
    var _this;

    (0, _classCallCheck2["default"])(this, FileManager);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mode", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "openedFiles", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "events", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "editor", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_components", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "appManager", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deps", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getCurrentFile", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getFile", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getFolder", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setFile", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "switchFile", void 0);
    _this.mode = 'browser';
    _this.openedFiles = {}; // list all opened files

    _this.events = new _events.EventEmitter();
    _this.editor = editor;
    _this._components = {};
    _this._components.registry = _registry["default"].getInstance();
    _this.appManager = appManager;

    _this.init();

    return _this;
  }

  (0, _createClass2["default"])(FileManager, [{
    key: "getOpenedFiles",
    value: function getOpenedFiles() {
      return this.openedFiles;
    }
  }, {
    key: "setMode",
    value: function setMode(mode) {
      this.mode = mode;
    }
  }, {
    key: "limitPluginScope",
    value: function limitPluginScope(path) {
      return path.replace(/^\/browser\//, '').replace(/^browser\//, ''); // forbids plugin to access the root filesystem
    }
  }, {
    key: "normalize",
    value: function normalize(path) {
      return path.replace(/^\/+/, '');
    }
    /**
     * Emit error if path doesn't exist
     * @param {string} path path of the file/directory
     * @param {string} message message to display if path doesn't exist.
     */

  }, {
    key: "_handleExists",
    value: function () {
      var _handleExists2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(path, message) {
        var exists;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.exists(path);

              case 2:
                exists = _context.sent;

                if (exists) {
                  _context.next = 5;
                  break;
                }

                throw createError({
                  code: 'ENOENT',
                  message: message
                });

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _handleExists(_x, _x2) {
        return _handleExists2.apply(this, arguments);
      }

      return _handleExists;
    }()
    /**
     * Emit error if path is not a file
     * @param {string} path path of the file/directory
     * @param {string} message message to display if path is not a file.
     */

  }, {
    key: "_handleIsFile",
    value: function () {
      var _handleIsFile2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(path, message) {
        var isFile;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.isFile(path);

              case 2:
                isFile = _context2.sent;

                if (isFile) {
                  _context2.next = 5;
                  break;
                }

                throw createError({
                  code: 'EISDIR',
                  message: message
                });

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _handleIsFile(_x3, _x4) {
        return _handleIsFile2.apply(this, arguments);
      }

      return _handleIsFile;
    }()
    /**
     * Emit error if path is not a directory
     * @param {string} path path of the file/directory
     * @param {string} message message to display if path is not a directory.
     */

  }, {
    key: "_handleIsDir",
    value: function () {
      var _handleIsDir2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(path, message) {
        var isDir;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.isDirectory(path);

              case 2:
                isDir = _context3.sent;

                if (isDir) {
                  _context3.next = 5;
                  break;
                }

                throw createError({
                  code: 'ENOTDIR',
                  message: message
                });

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _handleIsDir(_x5, _x6) {
        return _handleIsDir2.apply(this, arguments);
      }

      return _handleIsDir;
    }()
    /** The current opened file */

  }, {
    key: "file",
    value: function file() {
      try {
        var file = this.currentFile();
        if (!file) throw createError({
          code: 'ENOENT',
          message: 'No file selected'
        });
        return file;
      } catch (e) {
        throw new Error(e);
      }
    }
    /**
     * Verify if the path exists (directory or file)
     * @param {string} path path of the directory or file
     * @returns {boolean} true if the path exists
     */

  }, {
    key: "exists",
    value: function () {
      var _exists = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(path) {
        var provider, result;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                provider = this.fileProviderOf(path);
                _context4.next = 6;
                return provider.exists(path);

              case 6:
                result = _context4.sent;
                return _context4.abrupt("return", result);

              case 10:
                _context4.prev = 10;
                _context4.t0 = _context4["catch"](0);
                throw new Error(_context4.t0);

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 10]]);
      }));

      function exists(_x7) {
        return _exists.apply(this, arguments);
      }

      return exists;
    }()
    /*
    * refresh the file explorer
    */

  }, {
    key: "refresh",
    value: function refresh() {
      var provider = this.fileProviderOf('/'); // emit rootFolderChanged so that File Explorer reloads the file tree

      provider.event.emit('rootFolderChanged', provider.workspace || '/');
      this.emit('rootFolderChanged', provider.workspace || '/');
    }
    /**
     * Verify if the path provided is a file
     * @param {string} path path of the directory or file
     * @returns {boolean} true if path is a file.
     */

  }, {
    key: "isFile",
    value: function () {
      var _isFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(path) {
        var provider, result;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                provider = this.fileProviderOf(path);
                _context5.next = 3;
                return provider.isFile(path);

              case 3:
                result = _context5.sent;
                return _context5.abrupt("return", result);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function isFile(_x8) {
        return _isFile.apply(this, arguments);
      }

      return isFile;
    }()
    /**
     * Verify if the path provided is a directory
     * @param {string} path path of the directory
     * @returns {boolean} true if path is a directory.
     */

  }, {
    key: "isDirectory",
    value: function () {
      var _isDirectory = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(path) {
        var provider, result;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                provider = this.fileProviderOf(path);
                _context6.next = 3;
                return provider.isDirectory(path);

              case 3:
                result = _context6.sent;
                return _context6.abrupt("return", result);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function isDirectory(_x9) {
        return _isDirectory.apply(this, arguments);
      }

      return isDirectory;
    }()
    /**
     * Open the content of the file in the context (eg: Editor)
     * @param {string} path path of the file
     * @returns {void}
     */

  }, {
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(path) {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                path = this.getPathFromUrl(path).file;
                _context7.next = 5;
                return this._handleExists(path, "Cannot open file ".concat(path));

              case 5:
                _context7.next = 7;
                return this._handleIsFile(path, "Cannot open file ".concat(path));

              case 7:
                _context7.next = 9;
                return this.openFile(path);

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function open(_x10) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
    /**
     * Set the content of a specific file
     * @param {string} path path of the file
     * @param {string} data content to write on the file
     * @returns {void}
     */

  }, {
    key: "writeFile",
    value: function () {
      var _writeFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(path, data) {
        var ret;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                _context8.next = 5;
                return this.exists(path);

              case 5:
                if (!_context8.sent) {
                  _context8.next = 13;
                  break;
                }

                _context8.next = 8;
                return this._handleIsFile(path, "Cannot write file ".concat(path));

              case 8:
                _context8.next = 10;
                return this.setFileContent(path, data);

              case 10:
                return _context8.abrupt("return", _context8.sent);

              case 13:
                _context8.next = 15;
                return this.setFileContent(path, data);

              case 15:
                ret = _context8.sent;
                this.emit('fileAdded', path);
                return _context8.abrupt("return", ret);

              case 18:
                _context8.next = 23;
                break;

              case 20:
                _context8.prev = 20;
                _context8.t0 = _context8["catch"](0);
                throw new Error(_context8.t0);

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 20]]);
      }));

      function writeFile(_x11, _x12) {
        return _writeFile.apply(this, arguments);
      }

      return writeFile;
    }()
    /**
     * Return the content of a specific file
     * @param {string} path path of the file
     * @returns {string} content of the file
     */

  }, {
    key: "readFile",
    value: function () {
      var _readFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(path) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                _context9.next = 5;
                return this._handleExists(path, "Cannot read file ".concat(path));

              case 5:
                _context9.next = 7;
                return this._handleIsFile(path, "Cannot read file ".concat(path));

              case 7:
                return _context9.abrupt("return", this.getFileContent(path));

              case 10:
                _context9.prev = 10;
                _context9.t0 = _context9["catch"](0);
                throw new Error(_context9.t0);

              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[0, 10]]);
      }));

      function readFile(_x13) {
        return _readFile.apply(this, arguments);
      }

      return readFile;
    }()
    /**
     * Upsert a file with the content of the source file
     * @param {string} src path of the source file
     * @param {string} dest path of the destrination file
     * @returns {void}
     */

  }, {
    key: "copyFile",
    value: function () {
      var _copyFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(src, dest, customName) {
        var content, copiedFilePath;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.prev = 0;
                src = this.normalize(src);
                dest = this.normalize(dest);
                src = this.limitPluginScope(src);
                dest = this.limitPluginScope(dest);
                _context10.next = 7;
                return this._handleExists(src, "Cannot copy from ".concat(src, ". Path does not exist."));

              case 7:
                _context10.next = 9;
                return this._handleIsFile(src, "Cannot copy from ".concat(src, ". Path is not a file."));

              case 9:
                _context10.next = 11;
                return this._handleExists(dest, "Cannot paste content into ".concat(dest, ". Path does not exist."));

              case 11:
                _context10.next = 13;
                return this._handleIsDir(dest, "Cannot paste content into ".concat(dest, ". Path is not directory."));

              case 13:
                _context10.next = 15;
                return this.readFile(src);

              case 15:
                content = _context10.sent;
                copiedFilePath = dest + (customName ? '/' + customName : '/' + "Copy_".concat(_helper2["default"].extractNameFromKey(src)));
                _context10.next = 19;
                return _helper2["default"].createNonClashingNameAsync(copiedFilePath, this);

              case 19:
                copiedFilePath = _context10.sent;
                _context10.next = 22;
                return this.writeFile(copiedFilePath, content);

              case 22:
                _context10.next = 27;
                break;

              case 24:
                _context10.prev = 24;
                _context10.t0 = _context10["catch"](0);
                throw new Error(_context10.t0);

              case 27:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[0, 24]]);
      }));

      function copyFile(_x14, _x15, _x16) {
        return _copyFile.apply(this, arguments);
      }

      return copyFile;
    }()
    /**
     * Upsert a directory with the content of the source directory
     * @param {string} src path of the source dir
     * @param {string} dest path of the destination dir
     * @returns {void}
     */

  }, {
    key: "copyDir",
    value: function () {
      var _copyDir = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(src, dest) {
        var provider;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.prev = 0;
                src = this.normalize(src);
                dest = this.normalize(dest);
                src = this.limitPluginScope(src);
                dest = this.limitPluginScope(dest);
                _context11.next = 7;
                return this._handleExists(src, "Cannot copy from ".concat(src, ". Path does not exist."));

              case 7:
                _context11.next = 9;
                return this._handleIsDir(src, "Cannot copy from ".concat(src, ". Path is not a directory."));

              case 9:
                _context11.next = 11;
                return this._handleExists(dest, "Cannot paste content into ".concat(dest, ". Path does not exist."));

              case 11:
                _context11.next = 13;
                return this._handleIsDir(dest, "Cannot paste content into ".concat(dest, ". Path is not directory."));

              case 13:
                provider = this.fileProviderOf(src);

                if (!provider.isSubDirectory(src, dest)) {
                  _context11.next = 18;
                  break;
                }

                this.call('notification', 'toast', (0, _helper.recursivePasteToastMsg)());
                _context11.next = 20;
                break;

              case 18:
                _context11.next = 20;
                return this.inDepthCopy(src, dest);

              case 20:
                _context11.next = 25;
                break;

              case 22:
                _context11.prev = 22;
                _context11.t0 = _context11["catch"](0);
                throw new Error(_context11.t0);

              case 25:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[0, 22]]);
      }));

      function copyDir(_x17, _x18) {
        return _copyDir.apply(this, arguments);
      }

      return copyDir;
    }()
  }, {
    key: "inDepthCopy",
    value: function () {
      var _inDepthCopy = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(src, dest) {
        var count,
            content,
            copiedFolderPath,
            _i,
            _Object$entries,
            _Object$entries$_i,
            key,
            value,
            _args12 = arguments;

        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                count = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : 0;
                _context12.next = 3;
                return this.readdir(src);

              case 3:
                content = _context12.sent;
                copiedFolderPath = count === 0 ? dest + '/' + "Copy_".concat(_helper2["default"].extractNameFromKey(src)) : dest + '/' + _helper2["default"].extractNameFromKey(src);
                _context12.next = 7;
                return _helper2["default"].createNonClashingDirNameAsync(copiedFolderPath, this);

              case 7:
                copiedFolderPath = _context12.sent;
                _context12.next = 10;
                return this.mkdir(copiedFolderPath);

              case 10:
                _i = 0, _Object$entries = Object.entries(content);

              case 11:
                if (!(_i < _Object$entries.length)) {
                  _context12.next = 23;
                  break;
                }

                _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];

                if (value.isDirectory) {
                  _context12.next = 18;
                  break;
                }

                _context12.next = 16;
                return this.copyFile(key, copiedFolderPath, _helper2["default"].extractNameFromKey(key));

              case 16:
                _context12.next = 20;
                break;

              case 18:
                _context12.next = 20;
                return this.inDepthCopy(key, copiedFolderPath, count + 1);

              case 20:
                _i++;
                _context12.next = 11;
                break;

              case 23:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function inDepthCopy(_x19, _x20) {
        return _inDepthCopy.apply(this, arguments);
      }

      return inDepthCopy;
    }()
    /**
     * Change the path of a file/directory
     * @param {string} oldPath current path of the file/directory
     * @param {string} newPath new path of the file/directory
     * @returns {void}
     */

  }, {
    key: "rename",
    value: function () {
      var _rename = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(oldPath, newPath) {
        var isFile, newPathExists, provider;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.prev = 0;
                oldPath = this.normalize(oldPath);
                newPath = this.normalize(newPath);
                oldPath = this.limitPluginScope(oldPath);
                newPath = this.limitPluginScope(newPath);
                _context13.next = 7;
                return this._handleExists(oldPath, "Cannot rename ".concat(oldPath));

              case 7:
                _context13.next = 9;
                return this.isFile(oldPath);

              case 9:
                isFile = _context13.sent;
                _context13.next = 12;
                return this.exists(newPath);

              case 12:
                newPathExists = _context13.sent;
                provider = this.fileProviderOf(oldPath);

                if (!isFile) {
                  _context13.next = 21;
                  break;
                }

                if (!newPathExists) {
                  _context13.next = 18;
                  break;
                }

                this.call('notification', 'alert', {
                  id: 'fileManagerAlert',
                  message: 'File already exists'
                });
                return _context13.abrupt("return");

              case 18:
                return _context13.abrupt("return", provider.rename(oldPath, newPath, false));

              case 21:
                if (!newPathExists) {
                  _context13.next = 24;
                  break;
                }

                this.call('notification', 'alert', {
                  id: 'fileManagerAlert',
                  message: 'Directory already exists'
                });
                return _context13.abrupt("return");

              case 24:
                return _context13.abrupt("return", provider.rename(oldPath, newPath, true));

              case 25:
                _context13.next = 30;
                break;

              case 27:
                _context13.prev = 27;
                _context13.t0 = _context13["catch"](0);
                throw new Error(_context13.t0);

              case 30:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[0, 27]]);
      }));

      function rename(_x21, _x22) {
        return _rename.apply(this, arguments);
      }

      return rename;
    }()
    /**
     * Create a directory
     * @param {string} path path of the new directory
     * @returns {void}
     */

  }, {
    key: "mkdir",
    value: function () {
      var _mkdir = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(path) {
        var provider;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.prev = 0;
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                _context14.next = 5;
                return this.exists(path);

              case 5:
                if (!_context14.sent) {
                  _context14.next = 7;
                  break;
                }

                throw createError({
                  code: 'EEXIST',
                  message: "Cannot create directory ".concat(path)
                });

              case 7:
                provider = this.fileProviderOf(path);
                _context14.next = 10;
                return provider.createDir(path);

              case 10:
                return _context14.abrupt("return", _context14.sent);

              case 13:
                _context14.prev = 13;
                _context14.t0 = _context14["catch"](0);
                throw new Error(_context14.t0);

              case 16:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[0, 13]]);
      }));

      function mkdir(_x23) {
        return _mkdir.apply(this, arguments);
      }

      return mkdir;
    }()
    /**
     * Get the list of files in the directory
     * @param {string} path path of the directory
     * @returns {string[]} list of the file/directory name in this directory
     */

  }, {
    key: "readdir",
    value: function () {
      var _readdir = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(path) {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.prev = 0;
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                _context15.next = 5;
                return this._handleExists(path);

              case 5:
                _context15.next = 7;
                return this._handleIsDir(path);

              case 7:
                return _context15.abrupt("return", new Promise(function (resolve, reject) {
                  var provider = _this2.fileProviderOf(path);

                  provider.resolveDirectory(path, function (error, filesProvider) {
                    if (error) reject(error);
                    resolve(filesProvider);
                  });
                }));

              case 10:
                _context15.prev = 10;
                _context15.t0 = _context15["catch"](0);
                throw new Error(_context15.t0);

              case 13:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[0, 10]]);
      }));

      function readdir(_x24) {
        return _readdir.apply(this, arguments);
      }

      return readdir;
    }()
    /**
     * Removes a file or directory recursively
     * @param {string} path path of the directory/file to remove
     * @returns {void}
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16(path) {
        var provider;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.prev = 0;
                path = this.normalize(path);
                path = this.limitPluginScope(path);
                _context16.next = 5;
                return this._handleExists(path, "Cannot remove file or directory ".concat(path));

              case 5:
                provider = this.fileProviderOf(path);
                _context16.next = 8;
                return provider.remove(path);

              case 8:
                return _context16.abrupt("return", _context16.sent);

              case 11:
                _context16.prev = 11;
                _context16.t0 = _context16["catch"](0);
                throw new Error(_context16.t0);

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[0, 11]]);
      }));

      function remove(_x25) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      this._deps = {
        config: this._components.registry.get('config').api,
        browserExplorer: this._components.registry.get('fileproviders/browser').api,
        localhostExplorer: this._components.registry.get('fileproviders/localhost').api,
        workspaceExplorer: this._components.registry.get('fileproviders/workspace').api,
        filesProviders: this._components.registry.get('fileproviders').api
      };

      this._deps.config.set('currentFile', ''); // make sure we remove the current file from the previous session


      this._deps.browserExplorer.event.on('fileChanged', function (path) {
        _this3.fileChangedEvent(path);
      });

      this._deps.browserExplorer.event.on('fileRenamed', function (oldName, newName, isFolder) {
        _this3.fileRenamedEvent(oldName, newName, isFolder);
      });

      this._deps.localhostExplorer.event.on('fileRenamed', function (oldName, newName, isFolder) {
        _this3.fileRenamedEvent(oldName, newName, isFolder);
      });

      this._deps.browserExplorer.event.on('fileRemoved', function (path) {
        _this3.fileRemovedEvent(path);
      });

      this._deps.browserExplorer.event.on('fileAdded', function (path) {
        _this3.fileAddedEvent(path);
      });

      this._deps.localhostExplorer.event.on('fileRemoved', function (path) {
        _this3.fileRemovedEvent(path);
      });

      this._deps.localhostExplorer.event.on('errored', function (event) {
        _this3.removeTabsOf(_this3._deps.localhostExplorer);
      });

      this._deps.localhostExplorer.event.on('closed', function (event) {
        _this3.removeTabsOf(_this3._deps.localhostExplorer);
      });

      this._deps.workspaceExplorer.event.on('fileChanged', function (path) {
        _this3.fileChangedEvent(path);
      });

      this._deps.workspaceExplorer.event.on('fileRenamed', function (oldName, newName, isFolder) {
        _this3.fileRenamedEvent(oldName, newName, isFolder);
      });

      this._deps.workspaceExplorer.event.on('fileRemoved', function (path) {
        _this3.fileRemovedEvent(path);
      });

      this._deps.workspaceExplorer.event.on('fileAdded', function (path) {
        _this3.fileAddedEvent(path);
      });

      this.getCurrentFile = this.file;
      this.getFile = this.readFile;
      this.getFolder = this.readdir;
      this.setFile = this.writeFile;
      this.switchFile = this.open;
    }
  }, {
    key: "fileAddedEvent",
    value: function fileAddedEvent(path) {
      this.emit('fileAdded', path);
    }
  }, {
    key: "fileChangedEvent",
    value: function fileChangedEvent(path) {
      this.emit('fileChanged', path);
    }
  }, {
    key: "fileRenamedEvent",
    value: function fileRenamedEvent(oldName, newName, isFolder) {
      if (!isFolder) {
        this._deps.config.set('currentFile', '');

        this.editor.discard(oldName);

        if (this.openedFiles[oldName]) {
          delete this.openedFiles[oldName];
          this.openedFiles[newName] = newName;
        }

        this.openFile(newName);
      } else {
        for (var k in this.openedFiles) {
          if (k.indexOf(oldName + '/') === 0) {
            var newAbsolutePath = k.replace(oldName, newName);
            this.openedFiles[newAbsolutePath] = newAbsolutePath;
            delete this.openedFiles[k];

            if (this._deps.config.get('currentFile') === k) {
              this._deps.config.set('currentFile', '');
            }
          }
        }
      } // TODO: Only keep `this.emit` (issue#2210)


      this.emit('fileRenamed', oldName, newName, isFolder);
      this.events.emit('fileRenamed', oldName, newName, isFolder);
    }
  }, {
    key: "currentFileProvider",
    value: function currentFileProvider() {
      var path = this.currentPath();

      if (path) {
        return this.fileProviderOf(path);
      }

      return null;
    }
  }, {
    key: "currentFile",
    value: function currentFile() {
      return this.editor.current();
    }
  }, {
    key: "closeAllFiles",
    value: function () {
      var _closeAllFiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17() {
        var file;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                // TODO: Only keep `this.emit` (issue#2210)
                this.emit('filesAllClosed');
                this.events.emit('filesAllClosed');
                _context17.t0 = _regenerator["default"].keys(this.openedFiles);

              case 3:
                if ((_context17.t1 = _context17.t0()).done) {
                  _context17.next = 9;
                  break;
                }

                file = _context17.t1.value;
                _context17.next = 7;
                return this.closeFile(file);

              case 7:
                _context17.next = 3;
                break;

              case 9:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function closeAllFiles() {
        return _closeAllFiles.apply(this, arguments);
      }

      return closeAllFiles;
    }()
  }, {
    key: "closeFile",
    value: function () {
      var _closeFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18(name) {
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                delete this.openedFiles[name];

                if (!Object.keys(this.openedFiles).length) {
                  this._deps.config.set('currentFile', ''); // TODO: Only keep `this.emit` (issue#2210)


                  this.emit('noFileSelected');
                  this.events.emit('noFileSelected');
                } // TODO: Only keep `this.emit` (issue#2210)


                this.emit('fileClosed', name);
                this.events.emit('fileClosed', name);

              case 4:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function closeFile(_x26) {
        return _closeFile.apply(this, arguments);
      }

      return closeFile;
    }()
  }, {
    key: "currentPath",
    value: function currentPath() {
      var currentFile = this._deps.config.get('currentFile');

      return this.extractPathOf(currentFile);
    }
  }, {
    key: "extractPathOf",
    value: function extractPathOf(file) {
      var reg = /(.*)(\/).*/;
      var path = reg.exec(file);
      return path ? path[1] : '/';
    }
  }, {
    key: "getFileContent",
    value: function getFileContent(path) {
      var _this4 = this;

      var provider = this.fileProviderOf(path);
      if (!provider) throw createError({
        code: 'ENOENT',
        message: "".concat(path, " not available")
      }); // TODO: change provider to Promise

      return new Promise(function (resolve, reject) {
        if (_this4.currentFile() === path) return resolve(_this4.editor.currentContent());
        provider.get(path, function (err, content) {
          if (err) reject(err);
          resolve(content);
        });
      });
    }
  }, {
    key: "setFileContent",
    value: function () {
      var _setFileContent = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19(path, content) {
        var canCall, required;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                if (!this.currentRequest) {
                  _context19.next = 6;
                  break;
                }

                _context19.next = 3;
                return this.askUserPermission('writeFile', '');

              case 3:
                canCall = _context19.sent;
                required = this.appManager.isRequired(this.currentRequest.from);

                if (canCall && !required) {
                  // inform the user about modification after permission is granted and even if permission was saved before
                  this.call('notification', 'toast', (0, _helper.fileChangedToastMsg)(this.currentRequest.from, path));
                }

              case 6:
                _context19.next = 8;
                return this._setFileInternal(path, content);

              case 8:
                return _context19.abrupt("return", _context19.sent);

              case 9:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function setFileContent(_x27, _x28) {
        return _setFileContent.apply(this, arguments);
      }

      return setFileContent;
    }()
  }, {
    key: "_setFileInternal",
    value: function _setFileInternal(path, content) {
      var _this5 = this;

      var provider = this.fileProviderOf(path);
      if (!provider) throw createError({
        code: 'ENOENT',
        message: "".concat(path, " not available")
      }); // TODO : Add permission
      // TODO : Change Provider to Promise

      return new Promise(function (resolve, reject) {
        provider.set(path, content, function (error) {
          if (error) reject(error);

          _this5.syncEditor(path);

          _this5.emit('fileSaved', path);

          resolve(true);
        });
      });
    }
    /**
     * Try to resolve the given file path (the actual path in the file system)
     * e.g if it's specified a github link, npm library, or any external content,
     * it returns the actual path where the content can be found.
     * @param {string} file url we are trying to resolve
     * @returns {{ string, provider }} file path resolved and its provider.
     */

  }, {
    key: "getPathFromUrl",
    value: function getPathFromUrl(file) {
      var provider = this.fileProviderOf(file);
      if (!provider) throw new Error("no provider for ".concat(file));
      return {
        file: provider.getPathFromUrl(file) || file,
        // in case an external URL is given as input, we resolve it to the right internal path
        provider: provider
      };
    }
    /**
     * Try to resolve the given file URl. opposite of getPathFromUrl
     * @param {string} file path we are trying to resolve
     * @returns {{ string, provider }} file url resolved and its provider.
     */

  }, {
    key: "getUrlFromPath",
    value: function getUrlFromPath(file) {
      var provider = this.fileProviderOf(file);
      if (!provider) throw new Error("no provider for ".concat(file));
      return {
        file: provider.getUrlFromPath(file) || file,
        // in case an external URL is given as input, we resolve it to the right internal path
        provider: provider
      };
    }
  }, {
    key: "removeTabsOf",
    value: function removeTabsOf(provider) {
      for (var tab in this.openedFiles) {
        if (this.fileProviderOf(tab).type === provider.type) {
          this.fileRemovedEvent(tab);
        }
      }
    }
  }, {
    key: "fileRemovedEvent",
    value: function fileRemovedEvent(path) {
      if (path === this._deps.config.get('currentFile')) {
        this._deps.config.set('currentFile', '');
      }

      this.editor.discard(path);
      delete this.openedFiles[path]; // TODO: Only keep `this.emit` (issue#2210)

      this.emit('fileRemoved', path);
      this.events.emit('fileRemoved', path);
      this.openFile(this._deps.config.get('currentFile'));
    }
  }, {
    key: "unselectCurrentFile",
    value: function () {
      var _unselectCurrentFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20() {
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.saveCurrentFile();

              case 2:
                this._deps.config.set('currentFile', ''); // TODO: Only keep `this.emit` (issue#2210)


                this.emit('noFileSelected');
                this.events.emit('noFileSelected');

              case 5:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function unselectCurrentFile() {
        return _unselectCurrentFile.apply(this, arguments);
      }

      return unselectCurrentFile;
    }()
  }, {
    key: "openFile",
    value: function () {
      var _openFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21(file) {
        var resolved, provider, content;
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (file) {
                  _context21.next = 5;
                  break;
                }

                this.emit('noFileSelected');
                this.events.emit('noFileSelected');
                _context21.next = 30;
                break;

              case 5:
                file = this.normalize(file);
                resolved = this.getPathFromUrl(file);
                file = resolved.file;
                _context21.next = 10;
                return this.saveCurrentFile();

              case 10:
                if (!(this.currentFile() === file)) {
                  _context21.next = 12;
                  break;
                }

                return _context21.abrupt("return");

              case 12:
                provider = resolved.provider;

                this._deps.config.set('currentFile', file);

                this.openedFiles[file] = file;
                content = '';
                _context21.prev = 16;
                _context21.next = 19;
                return provider.get(file);

              case 19:
                content = _context21.sent;
                _context21.next = 26;
                break;

              case 22:
                _context21.prev = 22;
                _context21.t0 = _context21["catch"](16);
                console.log(_context21.t0);
                throw _context21.t0;

              case 26:
                if (provider.isReadOnly(file)) {
                  this.editor.openReadOnly(file, content);
                } else {
                  this.editor.open(file, content);
                } // TODO: Only keep `this.emit` (issue#2210)


                this.emit('currentFileChanged', file);
                this.events.emit('currentFileChanged', file);
                return _context21.abrupt("return", true);

              case 30:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this, [[16, 22]]);
      }));

      function openFile(_x29) {
        return _openFile.apply(this, arguments);
      }

      return openFile;
    }()
    /**
    * Async API method getProviderOf
    * @param {string} file
    *
    */

  }, {
    key: "getProviderOf",
    value: function () {
      var _getProviderOf = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22(file) {
        var cancall;
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.askUserPermission('getProviderByName');

              case 2:
                cancall = _context22.sent;

                if (!cancall) {
                  _context22.next = 5;
                  break;
                }

                return _context22.abrupt("return", file ? this.fileProviderOf(file) : this.currentFileProvider());

              case 5:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function getProviderOf(_x30) {
        return _getProviderOf.apply(this, arguments);
      }

      return getProviderOf;
    }()
    /**
    * Async API method getProviderByName
    * @param {string} name
    *
    */

  }, {
    key: "getProviderByName",
    value: function () {
      var _getProviderByName = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23(name) {
        var cancall;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.askUserPermission('getProviderByName');

              case 2:
                cancall = _context23.sent;

                if (!cancall) {
                  _context23.next = 5;
                  break;
                }

                return _context23.abrupt("return", this.getProvider(name));

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getProviderByName(_x31) {
        return _getProviderByName.apply(this, arguments);
      }

      return getProviderByName;
    }()
  }, {
    key: "getProvider",
    value: function getProvider(name) {
      return this._deps.filesProviders[name];
    }
  }, {
    key: "fileProviderOf",
    value: function fileProviderOf(file) {
      if (file.startsWith('localhost') || this.mode === 'localhost') {
        return this._deps.filesProviders.localhost;
      }

      if (file.startsWith('browser')) {
        return this._deps.filesProviders.browser;
      }

      return this._deps.filesProviders.workspace;
    } // returns the list of directories inside path

  }, {
    key: "dirList",
    value: function dirList(path) {
      var _this6 = this;

      var dirPaths = [];

      var collectList = function collectList(path) {
        return new Promise(function (resolve, reject) {
          _this6.readdir(path).then(function (ls) {
            var promises = Object.keys(ls).map(function (item, index) {
              if (ls[item].isDirectory && !dirPaths.includes(item)) {
                dirPaths.push(item);
                resolve(dirPaths);
              }

              return new Promise(function (resolve, reject) {
                resolve(true);
              });
            });
            Promise.all(promises).then(function () {
              resolve(dirPaths);
            });
          });
        });
      };

      return collectList(path);
    }
  }, {
    key: "fileList",
    value: function () {
      var _fileList = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee24(dirPath) {
        var paths, _path;

        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.readdir(dirPath);

              case 2:
                paths = _context24.sent;

                for (_path in paths) {
                  if (paths[_path].isDirectory) delete paths[_path];
                }

                return _context24.abrupt("return", Object.keys(paths));

              case 5:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function fileList(_x32) {
        return _fileList.apply(this, arguments);
      }

      return fileList;
    }()
  }, {
    key: "isRemixDActive",
    value: function isRemixDActive() {
      return this.appManager.isActive('remixd');
    }
  }, {
    key: "saveCurrentFile",
    value: function () {
      var _saveCurrentFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee25() {
        var _this7 = this;

        var currentFile, input, provider;
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                currentFile = this._deps.config.get('currentFile');

                if (currentFile && this.editor.current()) {
                  input = this.editor.get(currentFile);

                  if (input !== null && input !== undefined) {
                    provider = this.fileProviderOf(currentFile);

                    if (provider) {
                      // use old content as default if save operation fails.
                      provider.get(currentFile, function (error, oldContent) {
                        provider.set(currentFile, input, function (error) {
                          if (error) {
                            if (error.message) _this7.call('notification', 'toast', error.message.indexOf('LocalStorage is full') !== -1 ? (0, _helper.storageFullMessage)() : error.message);
                            provider.set(currentFile, oldContent);
                            return console.error(error);
                          } else {
                            _this7.emit('fileSaved', currentFile);
                          }
                        });
                      });
                    } else {
                      console.log('cannot save ' + currentFile + '. Does not belong to any explorer');
                    }
                  }
                }

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function saveCurrentFile() {
        return _saveCurrentFile.apply(this, arguments);
      }

      return saveCurrentFile;
    }()
  }, {
    key: "syncEditor",
    value: function () {
      var _syncEditor = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee26(path) {
        var currentFile, provider, content;
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                currentFile = this._deps.config.get('currentFile');

                if (!(path !== currentFile)) {
                  _context26.next = 3;
                  break;
                }

                return _context26.abrupt("return");

              case 3:
                provider = this.fileProviderOf(currentFile);

                if (!provider) {
                  _context26.next = 17;
                  break;
                }

                _context26.prev = 5;
                _context26.next = 8;
                return provider.get(currentFile);

              case 8:
                content = _context26.sent;
                if (content) this.editor.setText(content);
                _context26.next = 15;
                break;

              case 12:
                _context26.prev = 12;
                _context26.t0 = _context26["catch"](5);
                console.log(_context26.t0);

              case 15:
                _context26.next = 18;
                break;

              case 17:
                console.log('cannot save ' + currentFile + '. Does not belong to any explorer');

              case 18:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this, [[5, 12]]);
      }));

      function syncEditor(_x33) {
        return _syncEditor.apply(this, arguments);
      }

      return syncEditor;
    }()
  }, {
    key: "setBatchFiles",
    value: function () {
      var _setBatchFiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee27(filesSet, fileProvider, override, callback) {
        var self, _i2, _Object$keys, file, name;

        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                self = this;
                if (!fileProvider) fileProvider = 'workspace';
                if (override === undefined) override = false;
                _i2 = 0, _Object$keys = Object.keys(filesSet);

              case 4:
                if (!(_i2 < _Object$keys.length)) {
                  _context27.next = 44;
                  break;
                }

                file = _Object$keys[_i2];

                if (!override) {
                  _context27.next = 19;
                  break;
                }

                _context27.prev = 7;
                _context27.next = 10;
                return self._deps.filesProviders[fileProvider].set(file, filesSet[file].content);

              case 10:
                _context27.next = 15;
                break;

              case 12:
                _context27.prev = 12;
                _context27.t0 = _context27["catch"](7);
                callback(_context27.t0.message || _context27.t0);

              case 15:
                _context27.next = 17;
                return self.syncEditor(fileProvider + file);

              case 17:
                _context27.next = 41;
                break;

              case 19:
                _context27.prev = 19;
                _context27.next = 22;
                return _helper2["default"].createNonClashingNameAsync(file, self._deps.filesProviders[fileProvider]);

              case 22:
                name = _context27.sent;

                if (!_helper2["default"].checkSpecialChars(name)) {
                  _context27.next = 27;
                  break;
                }

                this.call('notification', 'alert', {
                  id: 'fileManagerAlert',
                  message: 'Special characters are not allowed in file names.'
                });
                _context27.next = 36;
                break;

              case 27:
                _context27.prev = 27;
                _context27.next = 30;
                return self._deps.filesProviders[fileProvider].set(name, filesSet[file].content);

              case 30:
                _context27.next = 35;
                break;

              case 32:
                _context27.prev = 32;
                _context27.t1 = _context27["catch"](27);
                return _context27.abrupt("return", callback(_context27.t1.message || _context27.t1));

              case 35:
                self.syncEditor(fileProvider + name);

              case 36:
                _context27.next = 41;
                break;

              case 38:
                _context27.prev = 38;
                _context27.t2 = _context27["catch"](19);

                if (_context27.t2) {
                  this.call('notification', 'alert', {
                    id: 'fileManagerAlert',
                    message: 'Unexpected error loading file ' + file + ': ' + _context27.t2
                  });
                }

              case 41:
                _i2++;
                _context27.next = 4;
                break;

              case 44:
                callback();

              case 45:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this, [[7, 12], [19, 38], [27, 32]]);
      }));

      function setBatchFiles(_x34, _x35, _x36, _x37) {
        return _setBatchFiles.apply(this, arguments);
      }

      return setBatchFiles;
    }()
  }, {
    key: "currentWorkspace",
    value: function currentWorkspace() {
      if (this.mode !== 'localhost') {
        var file = this.currentFile() || '';
        var provider = this.fileProviderOf(file);
        return provider.workspace;
      }
    }
  }, {
    key: "isGitRepo",
    value: function () {
      var _isGitRepo = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee28(directory) {
        var path, exists;
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                path = directory + '/.git';
                _context28.next = 3;
                return this.exists(path);

              case 3:
                exists = _context28.sent;
                return _context28.abrupt("return", exists);

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function isGitRepo(_x38) {
        return _isGitRepo.apply(this, arguments);
      }

      return isGitRepo;
    }()
  }]);
  return FileManager;
}(_engine.Plugin);

module.exports = FileManager;

/***/ }),
/* 2471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _interopRequireDefault = __webpack_require__(30);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engine = __webpack_require__(477);

var _isomorphicGit = _interopRequireDefault(__webpack_require__(2472));

var _ipfsHttpClient = _interopRequireDefault(__webpack_require__(1441));

var _fileSaver = __webpack_require__(2487);

var _web = _interopRequireDefault(__webpack_require__(2488));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _asyncIterator(iterable) { var method, async, sync, retry = 2; if (typeof Symbol !== "undefined") { async = Symbol.asyncIterator; sync = Symbol.iterator; } while (retry--) { if (async && (method = iterable[async]) != null) { return method.call(iterable); } if (sync && (method = iterable[sync]) != null) { return new AsyncFromSyncIterator(method.call(iterable)); } async = "@@asyncIterator"; sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }

function AsyncFromSyncIterator(s) { AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s; this.n = s.next; }; AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(value) { var ret = this.s["return"]; if (ret === undefined) { return Promise.resolve({ value: value, done: true }); } return AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, "throw": function _throw(value) { var thr = this.s["return"]; if (thr === undefined) return Promise.reject(value); return AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }; function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) { return Promise.reject(new TypeError(r + " is not an object.")); } var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return new AsyncFromSyncIterator(s); }

var JSZip = __webpack_require__(489);

var path = __webpack_require__(1124);

var FormData = __webpack_require__(2489);

var axios = __webpack_require__(1332);

var profile = {
  name: 'dGitProvider',
  displayName: 'Decentralized git',
  description: 'Decentralized git provider',
  icon: 'assets/img/fileManager.webp',
  version: '0.0.1',
  methods: ['init', 'localStorageUsed', 'addremote', 'delremote', 'remotes', 'fetch', 'clone', 'export', 'import', 'status', 'log', 'commit', 'add', 'remove', 'rm', 'lsfiles', 'readblob', 'resolveref', 'branches', 'branch', 'checkout', 'currentbranch', 'push', 'pin', 'pull', 'pinList', 'unPin', 'setIpfsConfig', 'zip', 'setItem', 'getItem'],
  kind: 'file-system'
};

var DGitProvider = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(DGitProvider, _Plugin);

  var _super = _createSuper(DGitProvider);

  function DGitProvider() {
    var _this;

    (0, _classCallCheck2["default"])(this, DGitProvider);
    _this = _super.call(this, profile);
    _this.ipfsconfig = {
      host: 'ipfs.remixproject.org',
      port: 443,
      protocol: 'https',
      ipfsurl: 'https://ipfs.remixproject.org/ipfs/'
    };
    _this.globalIPFSConfig = {
      host: 'ipfs.io',
      port: 443,
      protocol: 'https',
      ipfsurl: 'https://ipfs.io/ipfs/'
    };
    _this.remixIPFS = {
      host: 'ipfs.remixproject.org',
      port: 443,
      protocol: 'https',
      ipfsurl: 'https://ipfs.remixproject.org/ipfs/'
    };
    _this.ipfsSources = [_this.remixIPFS, _this.globalIPFSConfig, _this.ipfsconfig];
    return _this;
  }

  (0, _createClass2["default"])(DGitProvider, [{
    key: "getGitConfig",
    value: function () {
      var _getGitConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var workspace;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.call('filePanel', 'getCurrentWorkspace');

              case 2:
                workspace = _context.sent;
                return _context.abrupt("return", {
                  fs: window.remixFileSystemCallback,
                  dir: addSlash(workspace.absolutePath)
                });

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getGitConfig() {
        return _getGitConfig.apply(this, arguments);
      }

      return getGitConfig;
    }()
  }, {
    key: "parseInput",
    value: function () {
      var _parseInput = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(input) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", {
                  corsProxy: 'https://corsproxy.remixproject.org/',
                  http: _web["default"],
                  onAuth: function onAuth(url) {
                    url;
                    var auth = {
                      username: input.token,
                      password: ''
                    };
                    return auth;
                  }
                });

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function parseInput(_x2) {
        return _parseInput.apply(this, arguments);
      }

      return parseInput;
    }()
  }, {
    key: "init",
    value: function () {
      var _init = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(input) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.t0 = _isomorphicGit["default"];
                _context3.t1 = _objectSpread;
                _context3.t2 = _objectSpread;
                _context3.t3 = {};
                _context3.next = 6;
                return this.getGitConfig();

              case 6:
                _context3.t4 = _context3.sent;
                _context3.t5 = (0, _context3.t2)(_context3.t3, _context3.t4);
                _context3.t6 = {};
                _context3.t7 = {
                  defaultBranch: input && input.branch || 'main'
                };
                _context3.t8 = (0, _context3.t1)(_context3.t5, _context3.t6, _context3.t7);
                _context3.next = 13;
                return _context3.t0.init.call(_context3.t0, _context3.t8);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function init(_x3) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "status",
    value: function () {
      var _status = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(cmd) {
        var status;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.t0 = _isomorphicGit["default"];
                _context4.t1 = _objectSpread;
                _context4.t2 = _objectSpread;
                _context4.t3 = {};
                _context4.next = 6;
                return this.getGitConfig();

              case 6:
                _context4.t4 = _context4.sent;
                _context4.t5 = (0, _context4.t2)(_context4.t3, _context4.t4);
                _context4.t6 = cmd;
                _context4.t7 = (0, _context4.t1)(_context4.t5, _context4.t6);
                _context4.next = 12;
                return _context4.t0.statusMatrix.call(_context4.t0, _context4.t7);

              case 12:
                status = _context4.sent;
                return _context4.abrupt("return", status);

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function status(_x4) {
        return _status.apply(this, arguments);
      }

      return status;
    }()
  }, {
    key: "add",
    value: function () {
      var _add = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(cmd) {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.t0 = _isomorphicGit["default"];
                _context6.t1 = _objectSpread;
                _context6.t2 = _objectSpread;
                _context6.t3 = {};
                _context6.next = 6;
                return this.getGitConfig();

              case 6:
                _context6.t4 = _context6.sent;
                _context6.t5 = (0, _context6.t2)(_context6.t3, _context6.t4);
                _context6.t6 = cmd;
                _context6.t7 = (0, _context6.t1)(_context6.t5, _context6.t6);
                _context6.next = 12;
                return _context6.t0.add.call(_context6.t0, _context6.t7);

              case 12:
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
                  return _regenerator["default"].wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this2.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                })), 1000);

              case 13:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function add(_x5) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
  }, {
    key: "rm",
    value: function () {
      var _rm = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(cmd) {
        var _this3 = this;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.t0 = _isomorphicGit["default"];
                _context8.t1 = _objectSpread;
                _context8.t2 = _objectSpread;
                _context8.t3 = {};
                _context8.next = 6;
                return this.getGitConfig();

              case 6:
                _context8.t4 = _context8.sent;
                _context8.t5 = (0, _context8.t2)(_context8.t3, _context8.t4);
                _context8.t6 = cmd;
                _context8.t7 = (0, _context8.t1)(_context8.t5, _context8.t6);
                _context8.next = 12;
                return _context8.t0.remove.call(_context8.t0, _context8.t7);

              case 12:
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
                  return _regenerator["default"].wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          _context7.next = 2;
                          return _this3.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7);
                })), 1000);

              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function rm(_x6) {
        return _rm.apply(this, arguments);
      }

      return rm;
    }()
  }, {
    key: "checkout",
    value: function () {
      var _checkout = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(cmd) {
        var _this4 = this;

        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.t0 = _isomorphicGit["default"];
                _context10.t1 = _objectSpread;
                _context10.t2 = _objectSpread;
                _context10.t3 = {};
                _context10.next = 6;
                return this.getGitConfig();

              case 6:
                _context10.t4 = _context10.sent;
                _context10.t5 = (0, _context10.t2)(_context10.t3, _context10.t4);
                _context10.t6 = cmd;
                _context10.t7 = (0, _context10.t1)(_context10.t5, _context10.t6);
                _context10.next = 12;
                return _context10.t0.checkout.call(_context10.t0, _context10.t7);

              case 12:
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
                  return _regenerator["default"].wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.next = 2;
                          return _this4.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9);
                })), 1000);

              case 13:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function checkout(_x7) {
        return _checkout.apply(this, arguments);
      }

      return checkout;
    }()
  }, {
    key: "log",
    value: function () {
      var _log = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(cmd) {
        var status;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.t0 = _isomorphicGit["default"];
                _context11.t1 = _objectSpread;
                _context11.t2 = _objectSpread;
                _context11.t3 = {};
                _context11.next = 6;
                return this.getGitConfig();

              case 6:
                _context11.t4 = _context11.sent;
                _context11.t5 = (0, _context11.t2)(_context11.t3, _context11.t4);
                _context11.t6 = cmd;
                _context11.t7 = (0, _context11.t1)(_context11.t5, _context11.t6);
                _context11.next = 12;
                return _context11.t0.log.call(_context11.t0, _context11.t7);

              case 12:
                status = _context11.sent;
                return _context11.abrupt("return", status);

              case 14:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function log(_x8) {
        return _log.apply(this, arguments);
      }

      return log;
    }()
  }, {
    key: "remotes",
    value: function () {
      var _remotes = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12() {
        var remotes;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                remotes = [];
                _context12.prev = 1;
                _context12.t0 = _isomorphicGit["default"];
                _context12.t1 = _objectSpread;
                _context12.t2 = {};
                _context12.next = 7;
                return this.getGitConfig();

              case 7:
                _context12.t3 = _context12.sent;
                _context12.t4 = (0, _context12.t1)(_context12.t2, _context12.t3);
                _context12.next = 11;
                return _context12.t0.listRemotes.call(_context12.t0, _context12.t4);

              case 11:
                remotes = _context12.sent;
                _context12.next = 16;
                break;

              case 14:
                _context12.prev = 14;
                _context12.t5 = _context12["catch"](1);

              case 16:
                return _context12.abrupt("return", remotes);

              case 17:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[1, 14]]);
      }));

      function remotes() {
        return _remotes.apply(this, arguments);
      }

      return remotes;
    }()
  }, {
    key: "branch",
    value: function () {
      var _branch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(cmd) {
        var _this5 = this;

        var status;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.t0 = _isomorphicGit["default"];
                _context14.t1 = _objectSpread;
                _context14.t2 = _objectSpread;
                _context14.t3 = {};
                _context14.next = 6;
                return this.getGitConfig();

              case 6:
                _context14.t4 = _context14.sent;
                _context14.t5 = (0, _context14.t2)(_context14.t3, _context14.t4);
                _context14.t6 = cmd;
                _context14.t7 = (0, _context14.t1)(_context14.t5, _context14.t6);
                _context14.next = 12;
                return _context14.t0.branch.call(_context14.t0, _context14.t7);

              case 12:
                status = _context14.sent;
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13() {
                  return _regenerator["default"].wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return _this5.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                })), 1000);
                return _context14.abrupt("return", status);

              case 15:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function branch(_x9) {
        return _branch.apply(this, arguments);
      }

      return branch;
    }()
  }, {
    key: "currentbranch",
    value: function () {
      var _currentbranch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15() {
        var name;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.t0 = _isomorphicGit["default"];
                _context15.t1 = _objectSpread;
                _context15.t2 = {};
                _context15.next = 5;
                return this.getGitConfig();

              case 5:
                _context15.t3 = _context15.sent;
                _context15.t4 = (0, _context15.t1)(_context15.t2, _context15.t3);
                _context15.next = 9;
                return _context15.t0.currentBranch.call(_context15.t0, _context15.t4);

              case 9:
                name = _context15.sent;
                return _context15.abrupt("return", name);

              case 11:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function currentbranch() {
        return _currentbranch.apply(this, arguments);
      }

      return currentbranch;
    }()
  }, {
    key: "branches",
    value: function () {
      var _branches = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16() {
        var cmd, remotes, branches, _iterator3, _step3, _loop;

        return _regenerator["default"].wrap(function _callee16$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.t0 = _objectSpread;
                _context17.t1 = {};
                _context17.next = 4;
                return this.getGitConfig();

              case 4:
                _context17.t2 = _context17.sent;
                cmd = (0, _context17.t0)(_context17.t1, _context17.t2);
                _context17.next = 8;
                return this.remotes();

              case 8:
                remotes = _context17.sent;
                branches = [];
                _context17.next = 12;
                return _isomorphicGit["default"].listBranches(cmd);

              case 12:
                branches = _context17.sent.map(function (branch) {
                  return {
                    remote: undefined,
                    name: branch
                  };
                });
                _iterator3 = _createForOfIteratorHelper(remotes);
                _context17.prev = 14;
                _loop = /*#__PURE__*/_regenerator["default"].mark(function _loop() {
                  var remote, remotebranches;
                  return _regenerator["default"].wrap(function _loop$(_context16) {
                    while (1) {
                      switch (_context16.prev = _context16.next) {
                        case 0:
                          remote = _step3.value;
                          cmd.remote = remote.remote;
                          _context16.next = 4;
                          return _isomorphicGit["default"].listBranches(cmd);

                        case 4:
                          remotebranches = _context16.sent.map(function (branch) {
                            return {
                              remote: remote.remote,
                              name: branch
                            };
                          });
                          branches = [].concat((0, _toConsumableArray2["default"])(branches), (0, _toConsumableArray2["default"])(remotebranches));

                        case 6:
                        case "end":
                          return _context16.stop();
                      }
                    }
                  }, _loop);
                });

                _iterator3.s();

              case 17:
                if ((_step3 = _iterator3.n()).done) {
                  _context17.next = 21;
                  break;
                }

                return _context17.delegateYield(_loop(), "t3", 19);

              case 19:
                _context17.next = 17;
                break;

              case 21:
                _context17.next = 26;
                break;

              case 23:
                _context17.prev = 23;
                _context17.t4 = _context17["catch"](14);

                _iterator3.e(_context17.t4);

              case 26:
                _context17.prev = 26;

                _iterator3.f();

                return _context17.finish(26);

              case 29:
                return _context17.abrupt("return", branches);

              case 30:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee16, this, [[14, 23, 26, 29]]);
      }));

      function branches() {
        return _branches.apply(this, arguments);
      }

      return branches;
    }()
  }, {
    key: "commit",
    value: function () {
      var _commit = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17(cmd) {
        var sha;
        return _regenerator["default"].wrap(function _callee17$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.init();

              case 2:
                _context18.prev = 2;
                _context18.t0 = _isomorphicGit["default"];
                _context18.t1 = _objectSpread;
                _context18.t2 = _objectSpread;
                _context18.t3 = {};
                _context18.next = 9;
                return this.getGitConfig();

              case 9:
                _context18.t4 = _context18.sent;
                _context18.t5 = (0, _context18.t2)(_context18.t3, _context18.t4);
                _context18.t6 = cmd;
                _context18.t7 = (0, _context18.t1)(_context18.t5, _context18.t6);
                _context18.next = 15;
                return _context18.t0.commit.call(_context18.t0, _context18.t7);

              case 15:
                sha = _context18.sent;
                return _context18.abrupt("return", sha);

              case 19:
                _context18.prev = 19;
                _context18.t8 = _context18["catch"](2);
                throw new Error(_context18.t8);

              case 22:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee17, this, [[2, 19]]);
      }));

      function commit(_x10) {
        return _commit.apply(this, arguments);
      }

      return commit;
    }()
  }, {
    key: "lsfiles",
    value: function () {
      var _lsfiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18(cmd) {
        var filesInStaging;
        return _regenerator["default"].wrap(function _callee18$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.t0 = _isomorphicGit["default"];
                _context19.t1 = _objectSpread;
                _context19.t2 = _objectSpread;
                _context19.t3 = {};
                _context19.next = 6;
                return this.getGitConfig();

              case 6:
                _context19.t4 = _context19.sent;
                _context19.t5 = (0, _context19.t2)(_context19.t3, _context19.t4);
                _context19.t6 = cmd;
                _context19.t7 = (0, _context19.t1)(_context19.t5, _context19.t6);
                _context19.next = 12;
                return _context19.t0.listFiles.call(_context19.t0, _context19.t7);

              case 12:
                filesInStaging = _context19.sent;
                return _context19.abrupt("return", filesInStaging);

              case 14:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee18, this);
      }));

      function lsfiles(_x11) {
        return _lsfiles.apply(this, arguments);
      }

      return lsfiles;
    }()
  }, {
    key: "resolveref",
    value: function () {
      var _resolveref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19(cmd) {
        var oid;
        return _regenerator["default"].wrap(function _callee19$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.t0 = _isomorphicGit["default"];
                _context20.t1 = _objectSpread;
                _context20.t2 = _objectSpread;
                _context20.t3 = {};
                _context20.next = 6;
                return this.getGitConfig();

              case 6:
                _context20.t4 = _context20.sent;
                _context20.t5 = (0, _context20.t2)(_context20.t3, _context20.t4);
                _context20.t6 = cmd;
                _context20.t7 = (0, _context20.t1)(_context20.t5, _context20.t6);
                _context20.next = 12;
                return _context20.t0.resolveRef.call(_context20.t0, _context20.t7);

              case 12:
                oid = _context20.sent;
                return _context20.abrupt("return", oid);

              case 14:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee19, this);
      }));

      function resolveref(_x12) {
        return _resolveref.apply(this, arguments);
      }

      return resolveref;
    }()
  }, {
    key: "readblob",
    value: function () {
      var _readblob = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20(cmd) {
        var readBlobResult;
        return _regenerator["default"].wrap(function _callee20$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.t0 = _isomorphicGit["default"];
                _context21.t1 = _objectSpread;
                _context21.t2 = _objectSpread;
                _context21.t3 = {};
                _context21.next = 6;
                return this.getGitConfig();

              case 6:
                _context21.t4 = _context21.sent;
                _context21.t5 = (0, _context21.t2)(_context21.t3, _context21.t4);
                _context21.t6 = cmd;
                _context21.t7 = (0, _context21.t1)(_context21.t5, _context21.t6);
                _context21.next = 12;
                return _context21.t0.readBlob.call(_context21.t0, _context21.t7);

              case 12:
                readBlobResult = _context21.sent;
                return _context21.abrupt("return", readBlobResult);

              case 14:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee20, this);
      }));

      function readblob(_x13) {
        return _readblob.apply(this, arguments);
      }

      return readblob;
    }()
  }, {
    key: "setIpfsConfig",
    value: function () {
      var _setIpfsConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21(config) {
        var _this6 = this;

        return _regenerator["default"].wrap(function _callee21$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this.ipfsconfig = config;
                return _context22.abrupt("return", new Promise(function (resolve) {
                  resolve(_this6.checkIpfsConfig());
                }));

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee21, this);
      }));

      function setIpfsConfig(_x14) {
        return _setIpfsConfig.apply(this, arguments);
      }

      return setIpfsConfig;
    }()
  }, {
    key: "checkIpfsConfig",
    value: function () {
      var _checkIpfsConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22(config) {
        return _regenerator["default"].wrap(function _callee22$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this.ipfs = (0, _ipfsHttpClient["default"])(config || this.ipfsconfig);
                _context23.prev = 1;
                _context23.next = 4;
                return this.ipfs.config.getAll();

              case 4:
                return _context23.abrupt("return", true);

              case 7:
                _context23.prev = 7;
                _context23.t0 = _context23["catch"](1);
                return _context23.abrupt("return", false);

              case 10:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee22, this, [[1, 7]]);
      }));

      function checkIpfsConfig(_x15) {
        return _checkIpfsConfig.apply(this, arguments);
      }

      return checkIpfsConfig;
    }()
  }, {
    key: "addremote",
    value: function () {
      var _addremote = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23(input) {
        return _regenerator["default"].wrap(function _callee23$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.t0 = _isomorphicGit["default"];
                _context24.t1 = _objectSpread;
                _context24.t2 = _objectSpread;
                _context24.t3 = {};
                _context24.next = 6;
                return this.getGitConfig();

              case 6:
                _context24.t4 = _context24.sent;
                _context24.t5 = (0, _context24.t2)(_context24.t3, _context24.t4);
                _context24.t6 = {};
                _context24.t7 = {
                  url: input.url,
                  remote: input.remote
                };
                _context24.t8 = (0, _context24.t1)(_context24.t5, _context24.t6, _context24.t7);
                _context24.next = 13;
                return _context24.t0.addRemote.call(_context24.t0, _context24.t8);

              case 13:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee23, this);
      }));

      function addremote(_x16) {
        return _addremote.apply(this, arguments);
      }

      return addremote;
    }()
  }, {
    key: "delremote",
    value: function () {
      var _delremote = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee24(input) {
        return _regenerator["default"].wrap(function _callee24$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.t0 = _isomorphicGit["default"];
                _context25.t1 = _objectSpread;
                _context25.t2 = _objectSpread;
                _context25.t3 = {};
                _context25.next = 6;
                return this.getGitConfig();

              case 6:
                _context25.t4 = _context25.sent;
                _context25.t5 = (0, _context25.t2)(_context25.t3, _context25.t4);
                _context25.t6 = {};
                _context25.t7 = {
                  remote: input.remote
                };
                _context25.t8 = (0, _context25.t1)(_context25.t5, _context25.t6, _context25.t7);
                _context25.next = 13;
                return _context25.t0.deleteRemote.call(_context25.t0, _context25.t8);

              case 13:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee24, this);
      }));

      function delremote(_x17) {
        return _delremote.apply(this, arguments);
      }

      return delremote;
    }()
  }, {
    key: "localStorageUsed",
    value: function () {
      var _localStorageUsed = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee25() {
        return _regenerator["default"].wrap(function _callee25$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                return _context26.abrupt("return", this.calculateLocalStorage());

              case 1:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee25, this);
      }));

      function localStorageUsed() {
        return _localStorageUsed.apply(this, arguments);
      }

      return localStorageUsed;
    }()
  }, {
    key: "clone",
    value: function () {
      var _clone = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee27(input, workspaceName) {
        var _this7 = this;

        var workspaceExists,
            permission,
            cmd,
            result,
            _args28 = arguments;
        return _regenerator["default"].wrap(function _callee27$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                workspaceExists = _args28.length > 2 && _args28[2] !== undefined ? _args28[2] : false;
                _context28.next = 3;
                return this.askUserPermission('clone', 'Import multiple files into your workspaces.');

              case 3:
                permission = _context28.sent;

                if (permission) {
                  _context28.next = 6;
                  break;
                }

                return _context28.abrupt("return", false);

              case 6:
                if (!(this.calculateLocalStorage() > 10000)) {
                  _context28.next = 8;
                  break;
                }

                throw new Error('The local storage of the browser is full.');

              case 8:
                if (workspaceExists) {
                  _context28.next = 11;
                  break;
                }

                _context28.next = 11;
                return this.call('filePanel', 'createWorkspace', workspaceName || "workspace_".concat(Date.now()), true);

              case 11:
                _context28.t0 = _objectSpread;
                _context28.t1 = _objectSpread;
                _context28.t2 = {
                  url: input.url,
                  singleBranch: input.singleBranch,
                  ref: input.branch,
                  depth: input.depth || 10
                };
                _context28.next = 16;
                return this.parseInput(input);

              case 16:
                _context28.t3 = _context28.sent;
                _context28.t4 = (0, _context28.t1)(_context28.t2, _context28.t3);
                _context28.next = 20;
                return this.getGitConfig();

              case 20:
                _context28.t5 = _context28.sent;
                cmd = (0, _context28.t0)(_context28.t4, _context28.t5);
                _context28.next = 24;
                return _isomorphicGit["default"].clone(cmd);

              case 24:
                result = _context28.sent;

                if (!workspaceExists) {
                  setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee26() {
                    return _regenerator["default"].wrap(function _callee26$(_context27) {
                      while (1) {
                        switch (_context27.prev = _context27.next) {
                          case 0:
                            _context27.next = 2;
                            return _this7.call('fileManager', 'refresh');

                          case 2:
                          case "end":
                            return _context27.stop();
                        }
                      }
                    }, _callee26);
                  })), 1000);
                }

                return _context28.abrupt("return", result);

              case 27:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee27, this);
      }));

      function clone(_x18, _x19) {
        return _clone.apply(this, arguments);
      }

      return clone;
    }()
  }, {
    key: "push",
    value: function () {
      var _push = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee28(input) {
        var cmd;
        return _regenerator["default"].wrap(function _callee28$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.t0 = _objectSpread;
                _context29.t1 = _objectSpread;
                _context29.t2 = {
                  force: input.force,
                  ref: input.ref,
                  remoteRef: input.remoteRef,
                  remote: input.remote,
                  author: {
                    name: input.name,
                    email: input.email
                  }
                };
                _context29.next = 5;
                return this.parseInput(input);

              case 5:
                _context29.t3 = _context29.sent;
                _context29.t4 = (0, _context29.t1)(_context29.t2, _context29.t3);
                _context29.next = 9;
                return this.getGitConfig();

              case 9:
                _context29.t5 = _context29.sent;
                cmd = (0, _context29.t0)(_context29.t4, _context29.t5);
                _context29.next = 13;
                return _isomorphicGit["default"].push(cmd);

              case 13:
                return _context29.abrupt("return", _context29.sent);

              case 14:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee28, this);
      }));

      function push(_x20) {
        return _push.apply(this, arguments);
      }

      return push;
    }()
  }, {
    key: "pull",
    value: function () {
      var _pull = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee30(input) {
        var _this8 = this;

        var cmd, result;
        return _regenerator["default"].wrap(function _callee30$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                _context31.t0 = _objectSpread;
                _context31.t1 = _objectSpread;
                _context31.t2 = {
                  ref: input.ref,
                  remoteRef: input.remoteRef,
                  author: {
                    name: input.name,
                    email: input.email
                  },
                  remote: input.remote
                };
                _context31.next = 5;
                return this.parseInput(input);

              case 5:
                _context31.t3 = _context31.sent;
                _context31.t4 = (0, _context31.t1)(_context31.t2, _context31.t3);
                _context31.next = 9;
                return this.getGitConfig();

              case 9:
                _context31.t5 = _context31.sent;
                cmd = (0, _context31.t0)(_context31.t4, _context31.t5);
                _context31.next = 13;
                return _isomorphicGit["default"].pull(cmd);

              case 13:
                result = _context31.sent;
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee29() {
                  return _regenerator["default"].wrap(function _callee29$(_context30) {
                    while (1) {
                      switch (_context30.prev = _context30.next) {
                        case 0:
                          _context30.next = 2;
                          return _this8.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context30.stop();
                      }
                    }
                  }, _callee29);
                })), 1000);
                return _context31.abrupt("return", result);

              case 16:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee30, this);
      }));

      function pull(_x21) {
        return _pull.apply(this, arguments);
      }

      return pull;
    }()
  }, {
    key: "fetch",
    value: function () {
      var _fetch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee32(input) {
        var _this9 = this;

        var cmd, result;
        return _regenerator["default"].wrap(function _callee32$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                _context33.t0 = _objectSpread;
                _context33.t1 = _objectSpread;
                _context33.t2 = {
                  ref: input.ref,
                  remoteRef: input.remoteRef,
                  author: {
                    name: input.name,
                    email: input.email
                  },
                  remote: input.remote
                };
                _context33.next = 5;
                return this.parseInput(input);

              case 5:
                _context33.t3 = _context33.sent;
                _context33.t4 = (0, _context33.t1)(_context33.t2, _context33.t3);
                _context33.next = 9;
                return this.getGitConfig();

              case 9:
                _context33.t5 = _context33.sent;
                cmd = (0, _context33.t0)(_context33.t4, _context33.t5);
                _context33.next = 13;
                return _isomorphicGit["default"].fetch(cmd);

              case 13:
                result = _context33.sent;
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee31() {
                  return _regenerator["default"].wrap(function _callee31$(_context32) {
                    while (1) {
                      switch (_context32.prev = _context32.next) {
                        case 0:
                          _context32.next = 2;
                          return _this9.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context32.stop();
                      }
                    }
                  }, _callee31);
                })), 1000);
                return _context33.abrupt("return", result);

              case 16:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee32, this);
      }));

      function fetch(_x22) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "export",
    value: function () {
      var _export2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee33(config) {
        var workspace, files, _iterator4, _step4, file, c, ob, addOptions, r;

        return _regenerator["default"].wrap(function _callee33$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                if (this.checkIpfsConfig(config)) {
                  _context34.next = 2;
                  break;
                }

                return _context34.abrupt("return", false);

              case 2:
                _context34.next = 4;
                return this.call('filePanel', 'getCurrentWorkspace');

              case 4:
                workspace = _context34.sent;
                _context34.next = 7;
                return this.getDirectory('/');

              case 7:
                files = _context34.sent;
                this.filesToSend = [];
                _iterator4 = _createForOfIteratorHelper(files);
                _context34.prev = 10;

                _iterator4.s();

              case 12:
                if ((_step4 = _iterator4.n()).done) {
                  _context34.next = 21;
                  break;
                }

                file = _step4.value;
                _context34.next = 16;
                return window.remixFileSystem.readFile("".concat(workspace.absolutePath, "/").concat(file));

              case 16:
                c = _context34.sent;
                ob = {
                  path: file,
                  content: c
                };
                this.filesToSend.push(ob);

              case 19:
                _context34.next = 12;
                break;

              case 21:
                _context34.next = 26;
                break;

              case 23:
                _context34.prev = 23;
                _context34.t0 = _context34["catch"](10);

                _iterator4.e(_context34.t0);

              case 26:
                _context34.prev = 26;

                _iterator4.f();

                return _context34.finish(26);

              case 29:
                addOptions = {
                  wrapWithDirectory: true
                };
                _context34.next = 32;
                return this.ipfs.add(this.filesToSend, addOptions);

              case 32:
                r = _context34.sent;
                return _context34.abrupt("return", r.cid.string);

              case 34:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee33, this, [[10, 23, 26, 29]]);
      }));

      function _export(_x23) {
        return _export2.apply(this, arguments);
      }

      return _export;
    }()
  }, {
    key: "pin",
    value: function () {
      var _pin = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee34(pinataApiKey, pinataSecretApiKey) {
        var workspace, files, data, _iterator5, _step5, file, c, ob, commits, today, metadata, pinataOptions, url, result;

        return _regenerator["default"].wrap(function _callee34$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                _context35.next = 2;
                return this.call('filePanel', 'getCurrentWorkspace');

              case 2:
                workspace = _context35.sent;
                _context35.next = 5;
                return this.getDirectory('/');

              case 5:
                files = _context35.sent;
                this.filesToSend = [];
                data = new FormData();
                _iterator5 = _createForOfIteratorHelper(files);
                _context35.prev = 9;

                _iterator5.s();

              case 11:
                if ((_step5 = _iterator5.n()).done) {
                  _context35.next = 19;
                  break;
                }

                file = _step5.value;
                _context35.next = 15;
                return window.remixFileSystem.readFile("".concat(workspace.absolutePath, "/").concat(file));

              case 15:
                c = _context35.sent;
                data.append('file', new Blob([c]), "base/".concat(file));

              case 17:
                _context35.next = 11;
                break;

              case 19:
                _context35.next = 24;
                break;

              case 21:
                _context35.prev = 21;
                _context35.t0 = _context35["catch"](9);

                _iterator5.e(_context35.t0);

              case 24:
                _context35.prev = 24;

                _iterator5.f();

                return _context35.finish(24);

              case 27:
                _context35.prev = 27;
                _context35.next = 30;
                return this.log({
                  ref: 'HEAD'
                });

              case 30:
                commits = _context35.sent;
                ob = {
                  ref: commits[0].oid,
                  message: commits[0].commit.message,
                  commits: JSON.stringify(commits.map(function (commit) {
                    var _commit$commit, _commit$commit2, _commit$commit3, _commit$commit4, _commit$commit4$commi;

                    return {
                      oid: commit.oid,
                      commit: {
                        parent: (_commit$commit = commit.commit) === null || _commit$commit === void 0 ? void 0 : _commit$commit.parent,
                        tree: (_commit$commit2 = commit.commit) === null || _commit$commit2 === void 0 ? void 0 : _commit$commit2.tree,
                        message: (_commit$commit3 = commit.commit) === null || _commit$commit3 === void 0 ? void 0 : _commit$commit3.message,
                        committer: {
                          timestamp: (_commit$commit4 = commit.commit) === null || _commit$commit4 === void 0 ? void 0 : (_commit$commit4$commi = _commit$commit4.committer) === null || _commit$commit4$commi === void 0 ? void 0 : _commit$commit4$commi.timestamp
                        }
                      }
                    };
                  }))
                };
                _context35.next = 37;
                break;

              case 34:
                _context35.prev = 34;
                _context35.t1 = _context35["catch"](27);
                ob = {
                  ref: 'no commits',
                  message: 'no commits'
                };

              case 37:
                today = new Date();
                metadata = JSON.stringify({
                  name: "remix - ".concat(workspace.name, " - ").concat(today.toLocaleString()),
                  keyvalues: ob
                });
                pinataOptions = JSON.stringify({
                  wrapWithDirectory: false
                });
                data.append('pinataOptions', pinataOptions);
                data.append('pinataMetadata', metadata);
                url = 'https://api.pinata.cloud/pinning/pinFileToIPFS';
                _context35.prev = 43;
                _context35.next = 46;
                return axios.post(url, data, {
                  maxBodyLength: 'Infinity',
                  headers: {
                    'Content-Type': "multipart/form-data; boundary=".concat(data._boundary),
                    pinata_api_key: pinataApiKey,
                    pinata_secret_api_key: pinataSecretApiKey
                  }
                });

              case 46:
                result = _context35.sent;
                _context35.next = 49;
                return this["export"](this.remixIPFS);

              case 49:
                _context35.t2 = _context35.sent;

                if (_context35.t2) {
                  _context35.next = 52;
                  break;
                }

                _context35.t2 = result.data.IpfsHash;

              case 52:
                return _context35.abrupt("return", _context35.t2);

              case 55:
                _context35.prev = 55;
                _context35.t3 = _context35["catch"](43);
                throw new Error(_context35.t3);

              case 58:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee34, this, [[9, 21, 24, 27], [27, 34], [43, 55]]);
      }));

      function pin(_x24, _x25) {
        return _pin.apply(this, arguments);
      }

      return pin;
    }()
  }, {
    key: "pinList",
    value: function () {
      var _pinList = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee35(pinataApiKey, pinataSecretApiKey) {
        var url, result;
        return _regenerator["default"].wrap(function _callee35$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                url = 'https://api.pinata.cloud/data/pinList?status=pinned';
                _context36.prev = 1;
                _context36.next = 4;
                return axios.get(url, {
                  maxBodyLength: 'Infinity',
                  headers: {
                    pinata_api_key: pinataApiKey,
                    pinata_secret_api_key: pinataSecretApiKey
                  }
                });

              case 4:
                result = _context36.sent;
                return _context36.abrupt("return", result.data);

              case 8:
                _context36.prev = 8;
                _context36.t0 = _context36["catch"](1);
                throw new Error(_context36.t0);

              case 11:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee35, null, [[1, 8]]);
      }));

      function pinList(_x26, _x27) {
        return _pinList.apply(this, arguments);
      }

      return pinList;
    }()
  }, {
    key: "unPin",
    value: function () {
      var _unPin = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee36(pinataApiKey, pinataSecretApiKey, hashToUnpin) {
        var url;
        return _regenerator["default"].wrap(function _callee36$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                url = "https://api.pinata.cloud/pinning/unpin/".concat(hashToUnpin);
                _context37.prev = 1;
                _context37.next = 4;
                return axios["delete"](url, {
                  headers: {
                    pinata_api_key: pinataApiKey,
                    pinata_secret_api_key: pinataSecretApiKey
                  }
                });

              case 4:
                return _context37.abrupt("return", true);

              case 7:
                _context37.prev = 7;
                _context37.t0 = _context37["catch"](1);
                throw new Error(_context37.t0);

              case 10:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee36, null, [[1, 7]]);
      }));

      function unPin(_x28, _x29, _x30) {
        return _unPin.apply(this, arguments);
      }

      return unPin;
    }()
  }, {
    key: "importIPFSFiles",
    value: function () {
      var _importIPFSFiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee37(config, cid, workspace) {
        var ipfs, result, data, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, content, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, chunk, dir;

        return _regenerator["default"].wrap(function _callee37$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                ipfs = (0, _ipfsHttpClient["default"])(config);
                result = false;
                _context38.prev = 2;
                data = ipfs.get(cid, {
                  timeout: 60000
                });
                _iteratorAbruptCompletion = false;
                _didIteratorError = false;
                _context38.prev = 6;
                _iterator = _asyncIterator(data);

              case 8:
                _context38.next = 10;
                return _iterator.next();

              case 10:
                if (!(_iteratorAbruptCompletion = !(_step = _context38.sent).done)) {
                  _context38.next = 65;
                  break;
                }

                file = _step.value;
                if (file.path) result = true;
                file.path = file.path.replace(cid, '');

                if (file.content) {
                  _context38.next = 16;
                  break;
                }

                return _context38.abrupt("continue", 62);

              case 16:
                content = [];
                _iteratorAbruptCompletion2 = false;
                _didIteratorError2 = false;
                _context38.prev = 19;
                _iterator2 = _asyncIterator(file.content);

              case 21:
                _context38.next = 23;
                return _iterator2.next();

              case 23:
                if (!(_iteratorAbruptCompletion2 = !(_step2 = _context38.sent).done)) {
                  _context38.next = 29;
                  break;
                }

                chunk = _step2.value;
                content.push(chunk);

              case 26:
                _iteratorAbruptCompletion2 = false;
                _context38.next = 21;
                break;

              case 29:
                _context38.next = 35;
                break;

              case 31:
                _context38.prev = 31;
                _context38.t0 = _context38["catch"](19);
                _didIteratorError2 = true;
                _iteratorError2 = _context38.t0;

              case 35:
                _context38.prev = 35;
                _context38.prev = 36;

                if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                  _context38.next = 40;
                  break;
                }

                _context38.next = 40;
                return _iterator2["return"]();

              case 40:
                _context38.prev = 40;

                if (!_didIteratorError2) {
                  _context38.next = 43;
                  break;
                }

                throw _iteratorError2;

              case 43:
                return _context38.finish(40);

              case 44:
                return _context38.finish(35);

              case 45:
                dir = path.dirname(file.path);
                _context38.prev = 46;
                _context38.next = 49;
                return this.createDirectories("".concat(workspace.absolutePath, "/").concat(dir));

              case 49:
                _context38.next = 54;
                break;

              case 51:
                _context38.prev = 51;
                _context38.t1 = _context38["catch"](46);
                throw new Error(_context38.t1);

              case 54:
                _context38.prev = 54;
                _context38.next = 57;
                return window.remixFileSystem.writeFile("".concat(workspace.absolutePath, "/").concat(file.path), Buffer.concat(content) || new Uint8Array());

              case 57:
                _context38.next = 62;
                break;

              case 59:
                _context38.prev = 59;
                _context38.t2 = _context38["catch"](54);
                throw new Error(_context38.t2);

              case 62:
                _iteratorAbruptCompletion = false;
                _context38.next = 8;
                break;

              case 65:
                _context38.next = 71;
                break;

              case 67:
                _context38.prev = 67;
                _context38.t3 = _context38["catch"](6);
                _didIteratorError = true;
                _iteratorError = _context38.t3;

              case 71:
                _context38.prev = 71;
                _context38.prev = 72;

                if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                  _context38.next = 76;
                  break;
                }

                _context38.next = 76;
                return _iterator["return"]();

              case 76:
                _context38.prev = 76;

                if (!_didIteratorError) {
                  _context38.next = 79;
                  break;
                }

                throw _iteratorError;

              case 79:
                return _context38.finish(76);

              case 80:
                return _context38.finish(71);

              case 81:
                _context38.next = 86;
                break;

              case 83:
                _context38.prev = 83;
                _context38.t4 = _context38["catch"](2);
                throw new Error(_context38.t4);

              case 86:
                return _context38.abrupt("return", result);

              case 87:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee37, this, [[2, 83], [6, 67, 71, 81], [19, 31, 35, 45], [36,, 40, 44], [46, 51], [54, 59], [72,, 76, 80]]);
      }));

      function importIPFSFiles(_x31, _x32, _x33) {
        return _importIPFSFiles.apply(this, arguments);
      }

      return importIPFSFiles;
    }()
  }, {
    key: "calculateLocalStorage",
    value: function calculateLocalStorage() {
      var _lsTotal = 0;

      var _xLen;

      var _x;

      for (_x in localStorage) {
        // eslint-disable-next-line no-prototype-builtins
        if (!localStorage.hasOwnProperty(_x)) {
          continue;
        }

        _xLen = (localStorage[_x].length + _x.length) * 2;
        _lsTotal += _xLen;
      }

      return (_lsTotal / 1024).toFixed(2);
    }
  }, {
    key: "import",
    value: function () {
      var _import2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee39(cmd) {
        var _this10 = this;

        var permission, cid, workspace, result;
        return _regenerator["default"].wrap(function _callee39$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this.askUserPermission('import', 'Import multiple files into your workspaces.');

              case 2:
                permission = _context40.sent;

                if (permission) {
                  _context40.next = 5;
                  break;
                }

                return _context40.abrupt("return", false);

              case 5:
                if (!(this.calculateLocalStorage() > 10000)) {
                  _context40.next = 7;
                  break;
                }

                throw new Error('The local storage of the browser is full.');

              case 7:
                cid = cmd.cid;
                _context40.next = 10;
                return this.call('filePanel', 'createWorkspace', "workspace_".concat(Date.now()), true);

              case 10:
                _context40.next = 12;
                return this.call('filePanel', 'getCurrentWorkspace');

              case 12:
                workspace = _context40.sent;

                if (!cmd.local) {
                  _context40.next = 19;
                  break;
                }

                _context40.next = 16;
                return this.importIPFSFiles(this.ipfsconfig, cid, workspace);

              case 16:
                result = _context40.sent;
                _context40.next = 32;
                break;

              case 19:
                _context40.next = 21;
                return this.importIPFSFiles(this.remixIPFS, cid, workspace);

              case 21:
                _context40.t1 = _context40.sent;

                if (_context40.t1) {
                  _context40.next = 26;
                  break;
                }

                _context40.next = 25;
                return this.importIPFSFiles(this.ipfsconfig, cid, workspace);

              case 25:
                _context40.t1 = _context40.sent;

              case 26:
                _context40.t0 = _context40.t1;

                if (_context40.t0) {
                  _context40.next = 31;
                  break;
                }

                _context40.next = 30;
                return this.importIPFSFiles(this.globalIPFSConfig, cid, workspace);

              case 30:
                _context40.t0 = _context40.sent;

              case 31:
                result = _context40.t0;

              case 32:
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee38() {
                  return _regenerator["default"].wrap(function _callee38$(_context39) {
                    while (1) {
                      switch (_context39.prev = _context39.next) {
                        case 0:
                          _context39.next = 2;
                          return _this10.call('fileManager', 'refresh');

                        case 2:
                        case "end":
                          return _context39.stop();
                      }
                    }
                  }, _callee38);
                })), 1000);

                if (result) {
                  _context40.next = 35;
                  break;
                }

                throw new Error("Cannot pull files from IPFS at ".concat(cid));

              case 35:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee39, this);
      }));

      function _import(_x34) {
        return _import2.apply(this, arguments);
      }

      return _import;
    }()
  }, {
    key: "getItem",
    value: function () {
      var _getItem = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee40(name) {
        return _regenerator["default"].wrap(function _callee40$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (!(typeof window !== 'undefined')) {
                  _context41.next = 2;
                  break;
                }

                return _context41.abrupt("return", window.localStorage.getItem(name));

              case 2:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee40);
      }));

      function getItem(_x35) {
        return _getItem.apply(this, arguments);
      }

      return getItem;
    }()
  }, {
    key: "setItem",
    value: function () {
      var _setItem = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee41(name, content) {
        return _regenerator["default"].wrap(function _callee41$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.prev = 0;

                if (typeof window !== 'undefined') {
                  window.localStorage.setItem(name, content);
                }

                _context42.next = 8;
                break;

              case 4:
                _context42.prev = 4;
                _context42.t0 = _context42["catch"](0);
                console.log(_context42.t0);
                return _context42.abrupt("return", false);

              case 8:
                return _context42.abrupt("return", true);

              case 9:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee41, null, [[0, 4]]);
      }));

      function setItem(_x36, _x37) {
        return _setItem.apply(this, arguments);
      }

      return setItem;
    }()
  }, {
    key: "zip",
    value: function () {
      var _zip = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee42() {
        var zip, workspace, files, _iterator6, _step6, file, c;

        return _regenerator["default"].wrap(function _callee42$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                zip = new JSZip();
                _context43.next = 3;
                return this.call('filePanel', 'getCurrentWorkspace');

              case 3:
                workspace = _context43.sent;
                _context43.next = 6;
                return this.getDirectory('/');

              case 6:
                files = _context43.sent;
                this.filesToSend = [];
                _iterator6 = _createForOfIteratorHelper(files);
                _context43.prev = 9;

                _iterator6.s();

              case 11:
                if ((_step6 = _iterator6.n()).done) {
                  _context43.next = 19;
                  break;
                }

                file = _step6.value;
                _context43.next = 15;
                return window.remixFileSystem.readFile("".concat(workspace.absolutePath, "/").concat(file));

              case 15:
                c = _context43.sent;
                zip.file(file, c);

              case 17:
                _context43.next = 11;
                break;

              case 19:
                _context43.next = 24;
                break;

              case 21:
                _context43.prev = 21;
                _context43.t0 = _context43["catch"](9);

                _iterator6.e(_context43.t0);

              case 24:
                _context43.prev = 24;

                _iterator6.f();

                return _context43.finish(24);

              case 27:
                _context43.next = 29;
                return zip.generateAsync({
                  type: 'blob'
                }).then(function (content) {
                  (0, _fileSaver.saveAs)(content, "".concat(workspace.name, ".zip"));
                });

              case 29:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee42, this, [[9, 21, 24, 27]]);
      }));

      function zip() {
        return _zip.apply(this, arguments);
      }

      return zip;
    }()
  }, {
    key: "createDirectories",
    value: function () {
      var _createDirectories = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee43(strdirectories) {
        var ignore, directories, i, previouspath, finalPath;
        return _regenerator["default"].wrap(function _callee43$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                ignore = ['.', '/.', ''];

                if (!(ignore.indexOf(strdirectories) > -1)) {
                  _context44.next = 3;
                  break;
                }

                return _context44.abrupt("return", false);

              case 3:
                directories = strdirectories.split('/');
                i = 0;

              case 5:
                if (!(i < directories.length)) {
                  _context44.next = 23;
                  break;
                }

                previouspath = '';
                if (i > 0) previouspath = '/' + directories.slice(0, i).join('/');
                finalPath = previouspath + '/' + directories[i];
                _context44.prev = 9;
                _context44.next = 12;
                return window.remixFileSystem.exists(finalPath);

              case 12:
                if (_context44.sent) {
                  _context44.next = 15;
                  break;
                }

                _context44.next = 15;
                return window.remixFileSystem.mkdir(finalPath);

              case 15:
                _context44.next = 20;
                break;

              case 17:
                _context44.prev = 17;
                _context44.t0 = _context44["catch"](9);
                console.log(_context44.t0);

              case 20:
                i++;
                _context44.next = 5;
                break;

              case 23:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee43, null, [[9, 17]]);
      }));

      function createDirectories(_x38) {
        return _createDirectories.apply(this, arguments);
      }

      return createDirectories;
    }()
  }, {
    key: "getDirectory",
    value: function () {
      var _getDirectory = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee44(dir) {
        var result, files, fileArray, _iterator7, _step7, fi, type;

        return _regenerator["default"].wrap(function _callee44$(_context45) {
          while (1) {
            switch (_context45.prev = _context45.next) {
              case 0:
                result = [];
                _context45.next = 3;
                return this.call('fileManager', 'readdir', dir);

              case 3:
                files = _context45.sent;
                fileArray = normalize(files);
                _iterator7 = _createForOfIteratorHelper(fileArray);
                _context45.prev = 6;

                _iterator7.s();

              case 8:
                if ((_step7 = _iterator7.n()).done) {
                  _context45.next = 26;
                  break;
                }

                fi = _step7.value;

                if (!fi) {
                  _context45.next = 24;
                  break;
                }

                type = fi.data.isDirectory;

                if (!(type === true)) {
                  _context45.next = 23;
                  break;
                }

                _context45.t0 = [];
                _context45.t1 = (0, _toConsumableArray2["default"])(result);
                _context45.t2 = _toConsumableArray2["default"];
                _context45.next = 18;
                return this.getDirectory("".concat(fi.filename));

              case 18:
                _context45.t3 = _context45.sent;
                _context45.t4 = (0, _context45.t2)(_context45.t3);
                result = _context45.t0.concat.call(_context45.t0, _context45.t1, _context45.t4);
                _context45.next = 24;
                break;

              case 23:
                result = [].concat((0, _toConsumableArray2["default"])(result), [fi.filename]);

              case 24:
                _context45.next = 8;
                break;

              case 26:
                _context45.next = 31;
                break;

              case 28:
                _context45.prev = 28;
                _context45.t5 = _context45["catch"](6);

                _iterator7.e(_context45.t5);

              case 31:
                _context45.prev = 31;

                _iterator7.f();

                return _context45.finish(31);

              case 34:
                return _context45.abrupt("return", result);

              case 35:
              case "end":
                return _context45.stop();
            }
          }
        }, _callee44, this, [[6, 28, 31, 34]]);
      }));

      function getDirectory(_x39) {
        return _getDirectory.apply(this, arguments);
      }

      return getDirectory;
    }()
  }]);
  return DGitProvider;
}(_engine.Plugin);

var addSlash = function addSlash(file) {
  if (!file.startsWith('/')) file = '/' + file;
  return file;
};

var normalize = function normalize(filesList) {
  var folders = [];
  var files = [];
  Object.keys(filesList || {}).forEach(function (key) {
    if (filesList[key].isDirectory) {
      folders.push({
        filename: key,
        data: filesList[key]
      });
    } else {
      files.push({
        filename: key,
        data: filesList[key]
      });
    }
  });
  return [].concat(folders, files);
};

module.exports = DGitProvider;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4).Buffer))

/***/ }),
/* 2472 */,
/* 2473 */,
/* 2474 */,
/* 2475 */,
/* 2476 */,
/* 2477 */,
/* 2478 */,
/* 2479 */,
/* 2480 */,
/* 2481 */,
/* 2482 */,
/* 2483 */,
/* 2484 */,
/* 2485 */,
/* 2486 */,
/* 2487 */,
/* 2488 */,
/* 2489 */,
/* 2490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _get2 = _interopRequireDefault(__webpack_require__(1197));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var EventManager = __webpack_require__(40);

var FileProvider = __webpack_require__(1362);

var pathModule = __webpack_require__(1124);

var WorkspaceFileProvider = /*#__PURE__*/function (_FileProvider) {
  (0, _inherits2["default"])(WorkspaceFileProvider, _FileProvider);

  var _super = _createSuper(WorkspaceFileProvider);

  function WorkspaceFileProvider() {
    var _this;

    (0, _classCallCheck2["default"])(this, WorkspaceFileProvider);
    _this = _super.call(this, '');
    _this.workspacesPath = '.workspaces';
    _this.workspace = null;
    _this.event = new EventManager();
    return _this;
  }

  (0, _createClass2["default"])(WorkspaceFileProvider, [{
    key: "setWorkspace",
    value: function setWorkspace(workspace) {
      if (!workspace) return;
      workspace = workspace.replace(/^\/|\/$/g, ''); // remove first and last slash

      this.workspace = workspace;
    }
  }, {
    key: "getWorkspace",
    value: function getWorkspace() {
      return this.workspace;
    }
  }, {
    key: "isReady",
    value: function isReady() {
      return this.workspace !== null;
    }
  }, {
    key: "clearWorkspace",
    value: function clearWorkspace() {
      this.workspace = null;
    }
  }, {
    key: "removePrefix",
    value: function removePrefix(path) {
      path = path.replace(/^\/|\/$/g, ''); // remove first and last slash

      path = path.replace(/^\.\/+/, ''); // remove ./ from start of string

      if (path.startsWith(this.workspacesPath + '/' + this.workspace)) return path;
      var splitPath = path.split('/');

      if (splitPath[0] === this.workspace) {
        splitPath[0] = this.workspacesPath + '/' + this.workspace;
        path = splitPath.join('/');
        return path;
      }

      path = (0, _get2["default"])((0, _getPrototypeOf2["default"])(WorkspaceFileProvider.prototype), "removePrefix", this).call(this, path);
      var ret = this.workspacesPath + '/' + this.workspace + '/' + (path === '/' ? '' : path);
      ret = ret.replace(/^\/|\/$/g, '');
      if (!this.isSubDirectory(this.workspacesPath + '/' + this.workspace, ret)) throw new Error('Cannot read/write to path outside workspace');
      return ret;
    }
  }, {
    key: "resolveDirectory",
    value: function resolveDirectory(path, callback) {
      var _this2 = this;

      (0, _get2["default"])((0, _getPrototypeOf2["default"])(WorkspaceFileProvider.prototype), "resolveDirectory", this).call(this, path, function (error, files) {
        if (error) return callback(error);
        var unscoped = {};

        for (var file in files) {
          unscoped[file.replace(_this2.workspacesPath + '/' + _this2.workspace + '/', '')] = files[file];
        }

        callback(null, unscoped);
      });
    }
  }, {
    key: "copyFolderToJson",
    value: function () {
      var _copyFolderToJson = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(directory, visitFile, visitFolder) {
        var regex, json;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                visitFile = visitFile || function () {
                  /* do nothing. */
                };

                visitFolder = visitFolder || function () {
                  /* do nothing. */
                };

                regex = new RegExp(".workspaces/".concat(this.workspace, "/"), 'g');
                _context.next = 5;
                return (0, _get2["default"])((0, _getPrototypeOf2["default"])(WorkspaceFileProvider.prototype), "_copyFolderToJsonInternal", this).call(this, directory, function (_ref) {
                  var path = _ref.path,
                      content = _ref.content;
                  visitFile({
                    path: path.replace(regex, ''),
                    content: content
                  });
                }, function (_ref2) {
                  var path = _ref2.path;
                  visitFolder({
                    path: path.replace(regex, '')
                  });
                });

              case 5:
                json = _context.sent;
                json = JSON.stringify(json).replace(regex, '');
                return _context.abrupt("return", JSON.parse(json));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function copyFolderToJson(_x, _x2, _x3) {
        return _copyFolderToJson.apply(this, arguments);
      }

      return copyFolderToJson;
    }()
  }, {
    key: "_normalizePath",
    value: function _normalizePath(path) {
      return path.replace(this.workspacesPath + '/' + this.workspace + '/', '');
    }
  }, {
    key: "createWorkspace",
    value: function () {
      var _createWorkspace = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(name) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                if (!name) name = 'default_workspace';
                this.setWorkspace(name);
                _context2.next = 5;
                return (0, _get2["default"])((0, _getPrototypeOf2["default"])(WorkspaceFileProvider.prototype), "createDir", this).call(this, name);

              case 5:
                this.event.emit('createWorkspace', name);
                _context2.next = 11;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);
                throw new Error(_context2.t0);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 8]]);
      }));

      function createWorkspace(_x4) {
        return _createWorkspace.apply(this, arguments);
      }

      return createWorkspace;
    }()
  }]);
  return WorkspaceFileProvider;
}(FileProvider);

module.exports = WorkspaceFileProvider;

/***/ }),
/* 2491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _engineWeb = __webpack_require__(1133);

var _react = _interopRequireDefault(__webpack_require__(29));

var _pluginManager = __webpack_require__(2492);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _paq = window._paq = window._paq || [];

var profile = {
  name: 'pluginManager',
  displayName: 'Plugin manager',
  methods: [],
  events: [],
  icon: 'assets/img/pluginManager.webp',
  description: 'Start/stop services, modules and plugins',
  kind: 'settings',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/plugin_manager.html',
  version: packageJson.version
};

var PluginManagerComponent = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(PluginManagerComponent, _ViewPlugin);

  var _super = _createSuper(PluginManagerComponent);

  function PluginManagerComponent(appManager, engine) {
    var _this;

    (0, _classCallCheck2["default"])(this, PluginManagerComponent);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "isActive", function (name) {
      return _this.appManager.actives.includes(name);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "activateP", function (name) {
      _this.appManager.activatePlugin(name);

      _paq.push(['trackEvent', 'manager', 'activate', name]);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "activateAndRegisterLocalPlugin", /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(localPlugin) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (localPlugin) {
                  _this.engine.register(localPlugin);

                  _this.appManager.activatePlugin(localPlugin.profile.name);

                  _this.getAndFilterPlugins();

                  localStorage.setItem('plugins/local', JSON.stringify(localPlugin.profile));
                }

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "deactivateP", function (name) {
      _this.call('manager', 'deactivatePlugin', name);

      _paq.push(['trackEvent', 'manager', 'deactivate', name]);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getAndFilterPlugins", function (filter) {
      _this.filter = typeof filter === 'string' ? filter.toLowerCase() : _this.filter;

      var isFiltered = function isFiltered(profile) {
        return (profile.displayName ? profile.displayName : profile.name).toLowerCase().includes(_this.filter);
      };

      var isNotRequired = function isNotRequired(profile) {
        return !_this.appManager.isRequired(profile.name);
      };

      var isNotDependent = function isNotDependent(profile) {
        return !_this.appManager.isDependent(profile.name);
      };

      var isNotHome = function isNotHome(profile) {
        return profile.name !== 'home';
      };

      var sortByName = function sortByName(profileA, profileB) {
        var nameA = (profileA.displayName ? profileA.displayName : profileA.name).toUpperCase();
        var nameB = (profileB.displayName ? profileB.displayName : profileB.name).toUpperCase();
        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
      };

      var activatedPlugins = [];
      var deactivatedPlugins = [];

      var tempArray = _this.appManager.getAll().filter(isFiltered).filter(isNotRequired).filter(isNotDependent).filter(isNotHome).sort(sortByName);

      tempArray.forEach(function (profile) {
        if (_this.appManager.actives.includes(profile.name)) {
          activatedPlugins.push(profile);
        } else {
          deactivatedPlugins.push(profile);
        }
      });
      _this.activePlugins = activatedPlugins;
      _this.inactivePlugins = deactivatedPlugins;

      _this.renderComponent();
    });
    _this.appManager = appManager;
    _this.engine = engine;
    _this.htmlElement = document.createElement('div');

    _this.htmlElement.setAttribute('id', 'pluginManager');

    _this.filter = '';
    _this.activePlugins = [];
    _this.inactivePlugins = [];
    _this.activeProfiles = _this.appManager.actives;
    _this._paq = _paq;
    _this.dispatch = null;

    _this.listenOnEvent();

    return _this;
  }
  /**
   * Checks and returns true or false if plugin name
   * passed in exists in the actives string array in
   * RemixAppManager
   * @param {string} name name of Plugin
   */


  (0, _createClass2["default"])(PluginManagerComponent, [{
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
      this.renderComponent();
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_pluginManager.RemixUiPluginManager, {
        pluginComponent: state
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      if (this.dispatch) this.dispatch(_objectSpread(_objectSpread({}, this), {}, {
        activePlugins: this.activePlugins,
        inactivePlugins: this.inactivePlugins
      }));
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "pluginManager"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "listenOnEvent",
    value: function listenOnEvent() {
      var _this2 = this;

      this.engine.event.on('onRegistration', function () {
        return _this2.renderComponent();
      });
      this.appManager.event.on('activate', function () {
        _this2.getAndFilterPlugins();
      });
      this.appManager.event.on('deactivate', function () {
        _this2.getAndFilterPlugins();
      });
    }
  }]);
  return PluginManagerComponent;
}(_engineWeb.ViewPlugin);

module.exports = PluginManagerComponent;

/***/ }),
/* 2492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiPluginManager = __webpack_require__(2493);

Object.keys(_remixUiPluginManager).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiPluginManager[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiPluginManager[key];
    }
  });
});

/***/ }),
/* 2493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixUiPluginManager = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _ActivePluginCardContainer = _interopRequireDefault(__webpack_require__(2494));

var _InactivePluginCardContainer = _interopRequireDefault(__webpack_require__(2497));

var _rootView = _interopRequireDefault(__webpack_require__(2499));

__webpack_require__(1366);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-unused-vars */
const RemixUiPluginManager = ({
  pluginComponent
}) => {
  const [activeProfiles, setActiveProfiles] = (0, _react.useState)(pluginComponent.activePlugins);
  const [inactiveProfiles, setinactiveProfiles] = (0, _react.useState)(pluginComponent.inactivePlugins);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_rootView.default, {
    pluginComponent: pluginComponent,
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("section", {
      "data-id": "pluginManagerComponentPluginManagerSection",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_ActivePluginCardContainer.default, {
        pluginComponent: pluginComponent,
        setActiveProfiles: setActiveProfiles,
        activeProfiles: activeProfiles
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_InactivePluginCardContainer.default, {
        pluginComponent: pluginComponent,
        setInactiveProfiles: setinactiveProfiles,
        inactiveProfiles: inactiveProfiles
      })]
    })
  });
};

exports.RemixUiPluginManager = RemixUiPluginManager;

/***/ }),
/* 2494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _ActivePluginCard = _interopRequireDefault(__webpack_require__(2495));

var _moduleHeading = _interopRequireDefault(__webpack_require__(1588));

var _jsxRuntime = __webpack_require__(46);

/* eslint-disable @typescript-eslint/no-unused-vars */
function ActivePluginCardContainer({
  pluginComponent
}) {
  const deactivatePlugin = pluginName => {
    pluginComponent.deactivateP(pluginName);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.default.Fragment, {
    children: [pluginComponent.activePlugins && pluginComponent.activePlugins.length ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_moduleHeading.default, {
      headingLabel: "Active Modules",
      count: pluginComponent.activePlugins.length
    }) : null, pluginComponent.activePlugins && pluginComponent.activePlugins.map((profile, idx) => {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_ActivePluginCard.default, {
        buttonText: "Deactivate",
        profile: profile,
        deactivatePlugin: deactivatePlugin
      }, idx);
    })]
  });
}

var _default = ActivePluginCardContainer;
exports.default = _default;

/***/ }),
/* 2495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

__webpack_require__(1366);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-use-before-define
function ActivePluginCard({
  profile,
  buttonText,
  deactivatePlugin
}) {
  var _profile$maintainedBy;

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "list-group list-group-flush plugins-list-group",
    "data-id": "pluginManagerComponentActiveTile",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
      className: "list-group-item py-1 mb-1 plugins-list-group-item",
      title: profile.displayName || profile.name,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "remixui_row justify-content-between align-items-center mb-2",
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("h6", {
          className: "remixui_displayName plugin-name",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            children: [profile.displayName || profile.name, (profile === null || profile === void 0 ? void 0 : (_profile$maintainedBy = profile.maintainedBy) === null || _profile$maintainedBy === void 0 ? void 0 : _profile$maintainedBy.toLowerCase()) == "remix" && /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              "aria-hidden": "true",
              className: "px-1 text-success fas fa-check",
              title: "Maintained by Remix"
            }), profile.documentation && /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
              href: profile.documentation,
              className: "px-1",
              title: "link to documentation",
              target: "_blank",
              rel: "noreferrer",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                "aria-hidden": "true",
                className: "fas fa-book"
              })
            }), profile.version && profile.version.match(/\b(\w*alpha\w*)\b/g) ? /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
              title: "Version Alpha",
              className: "remixui_versionWarning plugin-version",
              children: "alpha"
            }) : profile.version && profile.version.match(/\b(\w*beta\w*)\b/g) ? /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
              title: "Version Beta",
              className: "remixui_versionWarning plugin-version",
              children: "beta"
            }) : null]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            onClick: () => {
              deactivatePlugin(profile.name);
            },
            className: "btn btn-secondary btn-sm",
            "data-id": `pluginManagerComponentDeactivateButton${profile.name}`,
            children: buttonText
          })]
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "remixui_description d-flex text-body plugin-text mb-2",
        children: [profile.icon ? /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
          src: profile.icon,
          className: "mr-1 mt-1 remixui_pluginIcon",
          alt: "profile icon"
        }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "remixui_descriptiontext",
          children: profile.description
        })]
      })]
    })
  });
}

var _default = ActivePluginCard;
exports.default = _default;

/***/ }),
/* 2496 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_pluginSearch {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  background-color: var(--light);\n  padding: 10px;\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0;\n  z-index: 2;\n  margin-bottom: 0px;\n}\n.remixui_pluginSearchInput {\n  height: 38px;\n}\n.remixui_pluginSearchButton {\n  font-size: 13px;\n}\n.remixui_displayName {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.remixui_pluginIcon {\n  height: 0.7rem;\n  width: 0.7rem;\n  filter: invert(0.5);\n}\n.remixui_description {\n  font-size: 13px;\n  line-height: 18px;\n}\n.remixui_descriptiontext {\n  display: block;\n}\n.remixui_descriptiontext:first-letter {\n  text-transform: uppercase;\n}\n.remixui_row {\n  display: flex;\n  flex-direction: row;\n}\n.remixui_isStuck {\n  background-color: var(--primary);\n  /* color:  */\n}\n.remixui_versionWarning {\n  padding: 4px;\n  margin: 0 8px;\n  font-weight: 700;\n  font-size: 9px;\n  line-height: 12px;\n  text-transform: uppercase;\n  cursor: default;\n  border: 1px solid;\n  border-radius: 2px;\n}\n.remixui_permissions {\n  position: -webkit-sticky;\n  position: sticky;\n  bottom: 0;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n  padding: 5px 20px;\n}\n.remixui_permissions button {\n  padding: 2px 5px;\n  cursor: pointer;\n}\n.remixui_permissionForm h4 {\n  font-size: 1.3rem;\n  text-align: center;\n}\n.remixui_permissionForm h6 {\n  font-size: 1.1rem;\n}\n.remixui_permissionForm hr {\n  width: 80%;\n}\n.remixui_permissionKey {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.remixui_permissionKey i {\n  cursor: pointer;\n}\n.remixui_checkbox {\n  display: flex;\n  align-items: center;\n}\n.remixui_checkbox label {\n  margin: 0;\n  font-size: 1rem;\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLXBsdWdpbi1tYW5hZ2VyLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGFBQWE7RUFDYixzQkFBc0I7RUFDdEIsbUJBQW1CO0VBQ25CLDhCQUE4QjtFQUM5QixhQUFhO0VBQ2Isd0JBQWdCO0VBQWhCLGdCQUFnQjtFQUNoQixNQUFNO0VBQ04sVUFBVTtFQUNWLGtCQUFrQjtBQUNwQjtBQUNBO0VBQ0UsWUFBWTtBQUNkO0FBQ0E7RUFDRSxlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsYUFBYTtFQUNiLG1CQUFtQjtFQUNuQiw4QkFBOEI7QUFDaEM7QUFDQTtFQUNFLGNBQWM7RUFDZCxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxlQUFlO0VBQ2YsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxjQUFjO0FBQ2hCO0FBQ0E7RUFDRSx5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLGFBQWE7RUFDYixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGdDQUFnQztFQUNoQyxZQUFZO0FBQ2Q7QUFDQTtFQUNFLFlBQVk7RUFDWixhQUFhO0VBQ2IsZ0JBQWdCO0VBQ2hCLGNBQWM7RUFDZCxpQkFBaUI7RUFDakIseUJBQXlCO0VBQ3pCLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsa0JBQWtCO0FBQ3BCO0FBRUE7RUFDRSx3QkFBZ0I7RUFBaEIsZ0JBQWdCO0VBQ2hCLFNBQVM7RUFDVCxhQUFhO0VBQ2IseUJBQXlCO0VBQ3pCLG1CQUFtQjtFQUNuQixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGdCQUFnQjtFQUNoQixlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxpQkFBaUI7RUFDakIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLFVBQVU7QUFDWjtBQUNBO0VBQ0UsYUFBYTtFQUNiLDhCQUE4QjtFQUM5QixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGVBQWU7QUFDakI7QUFDQTtFQUNFLGFBQWE7RUFDYixtQkFBbUI7QUFDckI7QUFDQTtFQUNFLFNBQVM7RUFDVCxlQUFlO0FBQ2pCIiwiZmlsZSI6InJlbWl4LXVpLXBsdWdpbi1tYW5hZ2VyLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5yZW1peHVpX3BsdWdpblNlYXJjaCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0KTtcbiAgcGFkZGluZzogMTBweDtcbiAgcG9zaXRpb246IHN0aWNreTtcbiAgdG9wOiAwO1xuICB6LWluZGV4OiAyO1xuICBtYXJnaW4tYm90dG9tOiAwcHg7XG59XG4ucmVtaXh1aV9wbHVnaW5TZWFyY2hJbnB1dCB7XG4gIGhlaWdodDogMzhweDtcbn1cbi5yZW1peHVpX3BsdWdpblNlYXJjaEJ1dHRvbiB7XG4gIGZvbnQtc2l6ZTogMTNweDtcbn1cbi5yZW1peHVpX2Rpc3BsYXlOYW1lIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cbi5yZW1peHVpX3BsdWdpbkljb24ge1xuICBoZWlnaHQ6IDAuN3JlbTtcbiAgd2lkdGg6IDAuN3JlbTtcbiAgZmlsdGVyOiBpbnZlcnQoMC41KTtcbn1cbi5yZW1peHVpX2Rlc2NyaXB0aW9uIHtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBsaW5lLWhlaWdodDogMThweDtcbn1cbi5yZW1peHVpX2Rlc2NyaXB0aW9udGV4dCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuLnJlbWl4dWlfZGVzY3JpcHRpb250ZXh0OmZpcnN0LWxldHRlciB7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG59XG4ucmVtaXh1aV9yb3cge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xufVxuLnJlbWl4dWlfaXNTdHVjayB7XG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByaW1hcnkpO1xuICAvKiBjb2xvcjogICovXG59XG4ucmVtaXh1aV92ZXJzaW9uV2FybmluZyB7XG4gIHBhZGRpbmc6IDRweDtcbiAgbWFyZ2luOiAwIDhweDtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgZm9udC1zaXplOiA5cHg7XG4gIGxpbmUtaGVpZ2h0OiAxMnB4O1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICBjdXJzb3I6IGRlZmF1bHQ7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiAycHg7XG59XG5cbi5yZW1peHVpX3Blcm1pc3Npb25zIHtcbiAgcG9zaXRpb246IHN0aWNreTtcbiAgYm90dG9tOiAwO1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBwYWRkaW5nOiA1cHggMjBweDtcbn1cbi5yZW1peHVpX3Blcm1pc3Npb25zIGJ1dHRvbiB7XG4gIHBhZGRpbmc6IDJweCA1cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbi5yZW1peHVpX3Blcm1pc3Npb25Gb3JtIGg0IHtcbiAgZm9udC1zaXplOiAxLjNyZW07XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cbi5yZW1peHVpX3Blcm1pc3Npb25Gb3JtIGg2IHtcbiAgZm9udC1zaXplOiAxLjFyZW07XG59XG4ucmVtaXh1aV9wZXJtaXNzaW9uRm9ybSBociB7XG4gIHdpZHRoOiA4MCU7XG59XG4ucmVtaXh1aV9wZXJtaXNzaW9uS2V5IHtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuLnJlbWl4dWlfcGVybWlzc2lvbktleSBpIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLnJlbWl4dWlfY2hlY2tib3gge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuLnJlbWl4dWlfY2hlY2tib3ggbGFiZWwge1xuICBtYXJnaW46IDA7XG4gIGZvbnQtc2l6ZTogMXJlbTtcbn1cbiJdfQ== */", '', '']]

/***/ }),
/* 2497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _InactivePluginCard = _interopRequireDefault(__webpack_require__(2498));

var _moduleHeading = _interopRequireDefault(__webpack_require__(1588));

var _jsxRuntime = __webpack_require__(46);

/* eslint-disable @typescript-eslint/no-unused-vars */
function InactivePluginCardContainer({
  pluginComponent
}) {
  const activatePlugin = pluginName => {
    pluginComponent.activateP(pluginName);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.default.Fragment, {
    children: [pluginComponent.inactivePlugins && pluginComponent.inactivePlugins.length ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_moduleHeading.default, {
      headingLabel: "Inactive Modules",
      count: pluginComponent.inactivePlugins.length
    }) : null, pluginComponent.inactivePlugins && pluginComponent.inactivePlugins.map((profile, idx) => {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_InactivePluginCard.default, {
        buttonText: "Activate",
        profile: profile,
        activatePlugin: activatePlugin
      }, idx);
    })]
  });
}

var _default = InactivePluginCardContainer;
exports.default = _default;

/***/ }),
/* 2498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

__webpack_require__(1366);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-next-line @typescript-eslint/no-unused-vars,no-use-before-define
function InactivePluginCard({
  profile,
  buttonText,
  activatePlugin
}) {
  var _profile$maintainedBy;

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "list-group list-group-flush plugins-list-group",
    "data-id": "pluginManagerComponentActiveTile",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
      className: "list-group-item py-1 mb-1 plugins-list-group-item",
      title: profile.displayName || profile.name,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "remixui_row justify-content-between align-items-center mb-2",
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("h6", {
          className: "remixui_displayName plugin-name",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            children: [profile.displayName || profile.name, (profile === null || profile === void 0 ? void 0 : (_profile$maintainedBy = profile.maintainedBy) === null || _profile$maintainedBy === void 0 ? void 0 : _profile$maintainedBy.toLowerCase()) == "remix" && /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              "aria-hidden": "true",
              className: "px-1 text-success fas fa-check",
              title: "Verified by Remix"
            }), profile.documentation && /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
              href: profile.documentation,
              className: "px-1",
              title: "link to documentation",
              target: "_blank",
              rel: "noreferrer",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                "aria-hidden": "true",
                className: "fas fa-book"
              })
            }), profile.version && profile.version.match(/\b(\w*alpha\w*)\b/g) ? /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
              title: "Version Alpha",
              className: "remixui_versionWarning plugin-version",
              children: "alpha"
            }) : profile.version && profile.version.match(/\b(\w*beta\w*)\b/g) ? /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
              title: "Version Beta",
              className: "remixui_versionWarning plugin-version",
              children: "beta"
            }) : null]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            onClick: () => {
              activatePlugin(profile.name);
            },
            className: "btn btn-success btn-sm",
            "data-id": `pluginManagerComponentActivateButton${profile.name}`,
            children: buttonText
          })]
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "remixui_description d-flex text-body plugin-text mb-2",
        children: [profile.icon ? /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
          src: profile.icon,
          className: "mr-1 mt-1 remixui_pluginIcon",
          alt: "profile icon"
        }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "remixui_descriptiontext",
          children: profile.description
        })]
      })]
    })
  });
}

var _default = InactivePluginCard;
exports.default = _default;

/***/ }),
/* 2499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _permissionsSettings = _interopRequireDefault(__webpack_require__(2500));

var _LocalPluginForm = _interopRequireDefault(__webpack_require__(2502));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-unused-vars */
function RootView({
  pluginComponent,
  children
}) {
  const [visible, setVisible] = (0, _react.useState)(true);
  const [filterPlugins, setFilterPlugin] = (0, _react.useState)('');

  const openModal = () => {
    setVisible(false);
  };

  const closeModal = () => setVisible(true);

  (0, _react.useEffect)(() => {
    pluginComponent.getAndFilterPlugins(filterPlugins);
  }, [filterPlugins]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      id: "pluginManager",
      "data-id": "pluginManagerComponentPluginManager",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("header", {
        className: "form-group remixui_pluginSearch plugins-header py-3 px-4 border-bottom",
        "data-id": "pluginManagerComponentPluginManagerHeader",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          type: "text",
          onChange: event => {
            setFilterPlugin(event.target.value.toLowerCase());
          },
          value: filterPlugins,
          className: "form-control",
          placeholder: "Search",
          "data-id": "pluginManagerComponentSearchInput"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
          onClick: openModal,
          className: "remixui_pluginSearchButton btn bg-transparent text-dark border-0 mt-2 text-underline",
          "data-id": "pluginManagerComponentPluginSearchButton",
          children: "Connect to a Local Plugin"
        })]
      }), children, /*#__PURE__*/(0, _jsxRuntime.jsx)(_permissionsSettings.default, {})]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_LocalPluginForm.default, {
      closeModal: closeModal,
      visible: visible,
      pluginManager: pluginComponent
    })]
  });
}

var _default = RootView;
exports.default = _default;

/***/ }),
/* 2500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _modalDialog = __webpack_require__(316);

var _useLocalStorage = _interopRequireDefault(__webpack_require__(2501));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-unused-vars */
// eslint-disable-line no-use-before-define

/* eslint-disable-line */
function PermisssionsSettings() {
  const [modalVisibility, setModalVisibility] = (0, _react.useState)(true);
  const [permissions, setPermissions] = (0, _useLocalStorage.default)('plugins/permissions', {});
  const [permissionCache, setpermissionCache] = (0, _react.useState)();

  const closeModal = () => setModalVisibility(true);

  const openModal = () => {
    const currentValue = JSON.parse(window.localStorage.getItem('plugins/permissions') || '{}');
    setpermissionCache(currentValue);
    setPermissions(currentValue);
    setModalVisibility(!modalVisibility);
  };

  const cancel = () => {
    setPermissions(permissionCache);
  };

  const getState = (targetPlugin, funcName, pluginName) => {
    return permissions[targetPlugin][funcName][pluginName].allow;
  };

  const handleCheckboxClick = (targetPlugin, funcName, pluginName) => {
    setPermissions(permissions => {
      permissions[targetPlugin][funcName][pluginName].allow = !permissions[targetPlugin][funcName][pluginName].allow;
      return permissions;
    });
  };

  function clearFunctionPermission(targetPlugin, funcName, pluginName) {
    setPermissions(permissions => {
      delete permissions[targetPlugin][funcName][pluginName];
      if (Object.keys(permissions[targetPlugin][funcName]).length === 0) delete permissions[targetPlugin][funcName];
      if (Object.keys(permissions[targetPlugin]).length === 0) delete permissions[targetPlugin];
      return permissions;
    });
  }

  function clearTargetPermission(targetPlugin) {
    setPermissions(permissions => {
      delete permissions[targetPlugin];
      return permissions;
    });
  }

  function RenderPluginHeader({
    headingName
  }) {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "pb-2 remixui_permissionKey",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("h3", {
        children: [headingName, " permissions:"]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        onClick: () => {
          clearTargetPermission(headingName);
        },
        className: "far fa-trash-alt",
        "data-id": `pluginManagerSettingsClearAllPermission-${headingName}`
      })]
    });
  }

  function RenderPermissions({
    targetPlugin
  }) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: Object.keys(permissions[targetPlugin]).map(funcName => {
        return Object.keys(permissions[targetPlugin][funcName]).map((pluginName, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "form-group remixui_permissionKey",
          children: permissions && Object.keys(permissions).length > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "remixui_checkbox",
              children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                className: "mr-2",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
                  type: "checkbox",
                  onChange: () => handleCheckboxClick(targetPlugin, funcName, pluginName),
                  checked: getState(targetPlugin, funcName, pluginName),
                  id: `permission-checkbox-${targetPlugin}-${funcName}-${pluginName}`,
                  "aria-describedby": `module ${pluginName} asks permission for ${funcName}`
                }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
                  className: "ml-4",
                  htmlFor: `permission-checkbox-${targetPlugin}-${funcName}-${targetPlugin}`,
                  "data-id": `permission-label-${targetPlugin}-${funcName}-${targetPlugin}`,
                  children: ["Allow ", /*#__PURE__*/(0, _jsxRuntime.jsx)("u", {
                    children: pluginName
                  }), " to call ", /*#__PURE__*/(0, _jsxRuntime.jsx)("u", {
                    children: funcName
                  })]
                })]
              })
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              onClick: () => {
                clearFunctionPermission(targetPlugin, funcName, pluginName);
              },
              className: "fa fa-trash-alt",
              "data-id": `pluginManagerSettingsRemovePermission-${targetPlugin}-${funcName}-${targetPlugin}`
            })]
          }) : null
        }, pluginName));
      })
    });
  }

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)(_modalDialog.ModalDialog, {
      id: "permissionsSettings",
      handleHide: closeModal,
      cancelFn: cancel,
      hide: modalVisibility,
      title: "Plugin Manager Permissions",
      okLabel: "OK",
      cancelLabel: "Cancel",
      children: [permissions && Object.keys(permissions).length > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsx)("h4", {
        className: "text-center",
        children: "Current Permission Settings"
      }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("h4", {
        className: "text-center",
        children: "No Permission requested yet."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("form", {
        className: "remixui_permissionForm",
        "data-id": "pluginManagerSettingsPermissionForm",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "p-2",
          children: Object.keys(permissions).map(targetPlugin => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(RenderPluginHeader, {
              headingName: targetPlugin
            }, `header-${targetPlugin}`), /*#__PURE__*/(0, _jsxRuntime.jsx)(RenderPermissions, {
              targetPlugin: targetPlugin
            }, `permissions-${targetPlugin}`)]
          }, `container-${targetPlugin}`))
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("footer", {
      className: "bg-light remixui_permissions remix-bg-opacity",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        onClick: openModal,
        className: "btn btn-primary settings-button",
        "data-id": "pluginManagerPermissionsButton",
        children: "Permissions"
      })
    })]
  });
}

var _default = PermisssionsSettings;
exports.default = _default;

/***/ }),
/* 2501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = __webpack_require__(29);

function useLocalStorage(key, initialValue) {
  // Get from local storage then
  // parse stored json or return initialValue
  const readValue = () => {
    // Prevent build error "window is undefined" but keep keep working
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key “${key}”:`, error);
      return initialValue;
    }
  }; // State to store our value
  // Pass initial state function to useState so logic is only executed once


  const [storedValue, setStoredValue] = (0, _react.useState)(readValue); // Return a wrapped version of useState's setter function that ...
  // ... persists the new value to localStorage.

  const setValue = value => {
    // Prevent build error "window is undefined" but keeps working
    if (typeof window === 'undefined') {
      console.warn(`Tried setting localStorage key “${key}” even though environment is not a client`);
    }

    try {
      // Allow value to be a function so we have the same API as useState
      const newValue = value instanceof Function ? value(storedValue) : value; // Save to local storage

      window.localStorage.setItem(key, JSON.stringify(newValue)); // Save state

      setStoredValue(newValue); // We dispatch a custom event so every useLocalStorage hook are notified

      window.dispatchEvent(new Event('local-storage'));
    } catch (error) {
      console.warn(`Error setting localStorage key “${key}”:`, error);
    }
  };

  (0, _react.useEffect)(() => {
    setStoredValue(readValue());
  }, []);
  (0, _react.useEffect)(() => {
    const handleStorageChange = () => {
      setStoredValue(readValue());
    }; // this only works for other documents, not the current one


    window.addEventListener('storage', handleStorageChange); // this is a custom event, triggered in writeValueToLocalStorage

    window.addEventListener('local-storage', handleStorageChange);
    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('local-storage', handleStorageChange);
    };
  }, []);
  return [storedValue, setValue];
}

var _default = useLocalStorage;
exports.default = _default;

/***/ }),
/* 2502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _modalDialog = __webpack_require__(316);

var _toaster = __webpack_require__(479);

var _engineWeb = __webpack_require__(1133);

var _pluginManagerReducer = __webpack_require__(2503);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const initialState = {
  name: '',
  displayName: '',
  url: '',
  type: 'iframe',
  hash: '',
  methods: [],
  location: 'sidePanel',
  canActivate: []
};
const defaultProfile = {
  methods: [],
  location: 'sidePanel',
  type: 'iframe',
  name: '',
  displayName: '',
  url: '',
  hash: ''
};

function LocalPluginForm({
  closeModal,
  visible,
  pluginManager
}) {
  const [errorMsg, dispatchToastMsg] = (0, _react.useReducer)(_pluginManagerReducer.localPluginToastReducer, '');
  const [name, setName] = (0, _react.useState)('');
  const [displayName, setDisplayName] = (0, _react.useState)('');
  const [url, setUrl] = (0, _react.useState)('');
  const [type, setType] = (0, _react.useState)('iframe');
  const [location, setLocation] = (0, _react.useState)('sidePanel');
  const [methods, setMethods] = (0, _react.useState)('');
  const [canactivate, setCanactivate] = (0, _react.useState)('');
  (0, _react.useEffect)(() => {
    const storagePlugin = localStorage.getItem('plugins/local') ? JSON.parse(localStorage.getItem('plugins/local')) : defaultProfile;
    setName(storagePlugin.name);
    setUrl(storagePlugin.url);
    setLocation(storagePlugin.location);
    setMethods(Array.isArray(storagePlugin.methods) ? storagePlugin.methods.join(',') : storagePlugin.methods);
    setType(storagePlugin.type);
    setDisplayName(storagePlugin.displayName);
    setCanactivate(Array.isArray(storagePlugin.canActivate) ? storagePlugin.canActivate.join(',') : storagePlugin.canActivate || '');
  }, []);

  const handleModalOkClick = async () => {
    try {
      if (!name) throw new Error('Plugin should have a name');

      if (pluginManager.appManager.getIds().includes(name)) {
        throw new Error('This name has already been used');
      }

      if (!location) throw new Error('Plugin should have a location');
      if (!url) throw new Error('Plugin should have an URL');
      const newMethods = typeof methods === 'string' ? methods.split(',').filter(val => val).map(val => {
        return val.trim();
      }) : [];
      const targetPlugin = {
        name: name,
        displayName: displayName,
        description: '',
        documentation: '',
        events: [],
        hash: '',
        kind: '',
        methods: newMethods,
        url: url,
        type: type,
        location: location,
        icon: 'assets/img/localPlugin.webp',
        canActivate: typeof canactivate === 'string' ? canactivate.split(',').filter(val => val).map(val => {
          return val.trim();
        }) : []
      };
      const localPlugin = type === 'iframe' ? new _engineWeb.IframePlugin(initialState) : new _engineWeb.WebsocketPlugin(initialState);
      localPlugin.profile.hash = `local-${name}`;
      targetPlugin.description = localPlugin.profile.description !== undefined ? localPlugin.profile.description : '';
      targetPlugin.events = localPlugin.profile.events !== undefined ? localPlugin.profile.events : [];
      targetPlugin.kind = localPlugin.profile.kind !== undefined ? localPlugin.profile.kind : '';
      localPlugin.profile = _objectSpread(_objectSpread({}, localPlugin.profile), targetPlugin);
      pluginManager.activateAndRegisterLocalPlugin(localPlugin);
    } catch (error) {
      const action = {
        type: 'show',
        payload: `${error.message}`
      };
      dispatchToastMsg(action);
      console.log(error);
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_modalDialog.ModalDialog, {
      handleHide: closeModal,
      id: "pluginManagerLocalPluginModalDialog",
      hide: visible,
      title: "Local Plugin",
      okLabel: "OK",
      okFn: handleModalOkClick,
      cancelLabel: "Cancel",
      cancelFn: closeModal,
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("form", {
        id: "local-plugin-form",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            htmlFor: "plugin-name",
            children: ["Plugin Name ", /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
              children: "(required)"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "form-control",
            onChange: e => setName(e.target.value),
            value: name || '',
            id: "plugin-name",
            "data-id": "localPluginName",
            placeholder: "Should be camelCase"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            htmlFor: "plugin-displayname",
            children: "Display Name"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "form-control",
            onChange: e => setDisplayName(e.target.value),
            value: displayName || '',
            id: "plugin-displayname",
            "data-id": "localPluginDisplayName",
            placeholder: "Name in the header"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            htmlFor: "plugin-methods",
            children: "Api (comma separated list of method names)"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "form-control",
            onChange: e => setMethods(e.target.value),
            value: methods || '',
            id: "plugin-methods",
            "data-id": "localPluginMethods",
            placeholder: "Methods"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            htmlFor: "plugin-methods",
            children: "Plugins it can activate (comma separated list of plugin names)"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "form-control",
            onChange: e => setCanactivate(e.target.value),
            value: canactivate || '',
            id: "plugin-canactivate",
            "data-id": "localPluginCanActivate",
            placeholder: "Plugin names"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            htmlFor: "plugin-url",
            children: ["Url ", /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
              children: "(required)"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "form-control",
            onChange: e => setUrl(e.target.value),
            value: url || '',
            id: "plugin-url",
            "data-id": "localPluginUrl",
            placeholder: "ex: https://localhost:8000"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("h6", {
          children: ["Type of connection ", /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
            children: "(required)"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-check form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "radio",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-check-input",
              type: "radio",
              name: "type",
              value: "iframe",
              id: "iframe",
              "data-id": "localPluginRadioButtoniframe",
              checked: type === 'iframe',
              onChange: e => setType(e.target.value)
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "form-check-label",
              htmlFor: "iframe",
              children: "Iframe"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "radio",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-check-input",
              type: "radio",
              name: "type",
              value: "ws",
              id: "ws",
              "data-id": "localPluginRadioButtonws",
              checked: type === 'ws',
              onChange: e => setType(e.target.value)
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "form-check-label",
              htmlFor: "ws",
              children: "Websocket"
            })]
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("h6", {
          children: ["Location in remix ", /*#__PURE__*/(0, _jsxRuntime.jsx)("small", {
            children: "(required)"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "form-check form-group",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "radio",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-check-input",
              type: "radio",
              name: "location",
              value: "sidePanel",
              id: "localPluginRadioButtonsidePanelSidePanel",
              "data-id": "localPluginRadioButtonsidePanel",
              checked: location === 'sidePanel',
              onChange: e => setLocation(e.target.value)
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "form-check-label",
              htmlFor: "sidePanel",
              children: "Side Panel"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "radio",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-check-input",
              type: "radio",
              name: "location",
              value: "mainPanel",
              id: "localPluginRadioButtonsidePanelMainPanel",
              "data-id": "localPluginRadioButtonmainPanel",
              checked: location === 'mainPanel',
              onChange: e => setLocation(e.target.value)
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "form-check-label",
              htmlFor: "mainPanel",
              children: "Main Panel"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "radio",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "form-check-input",
              type: "radio",
              name: "location",
              value: "none",
              id: "localPluginRadioButtonsidePanelNone",
              "data-id": "localPluginRadioButtonnone",
              checked: location === 'none',
              onChange: e => setLocation(e.target.value)
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "form-check-label",
              htmlFor: "none",
              children: "None"
            })]
          })]
        })]
      })
    }), errorMsg ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: errorMsg
    }) : null]
  });
}

var _default = LocalPluginForm;
exports.default = _default;

/***/ }),
/* 2503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localPluginToastReducer = localPluginToastReducer;

function localPluginToastReducer(currentState, toastAction) {
  switch (toastAction.type) {
    case 'show':
      return `Cannot create Plugin : ${toastAction.payload}`;

    default:
      return currentState;
  }
}

/***/ }),
/* 2504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _get2 = _interopRequireDefault(__webpack_require__(1197));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _solidityCompiler = __webpack_require__(1589);

var _solidityCompilerPlugin = __webpack_require__(2518);

var _engineWeb = __webpack_require__(1133);

var _remixLib = __webpack_require__(311);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'solidity',
  displayName: 'Solidity compiler',
  icon: 'assets/img/solidity.webp',
  description: 'Compile solidity contracts',
  kind: 'compiler',
  permission: true,
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/compile.html',
  version: packageJson.version,
  maintainedBy: 'Remix',
  methods: ['getCompilationResult', 'compile', 'compileWithParameters', 'setCompilerConfig', 'compileFile', 'getCompilerState']
}; // EditorApi:
// - events: ['compilationFinished'],
// - methods: ['getCompilationResult']

var CompileTab = /*#__PURE__*/function (_CompilerApiMixin) {
  (0, _inherits2["default"])(CompileTab, _CompilerApiMixin);

  var _super = _createSuper(CompileTab);

  // implements ICompilerApi
  function CompileTab(config, fileManager) {
    var _this;

    (0, _classCallCheck2["default"])(this, CompileTab);
    _this = _super.call(this, profile);
    _this.fileManager = fileManager;
    _this.config = config;
    _this.queryParams = new _remixLib.QueryParams();
    _this.compileTabLogic = new _solidityCompiler.CompileTabLogic((0, _assertThisInitialized2["default"])(_this), _this.contentImport);
    _this.compiler = _this.compileTabLogic.compiler;

    _this.compileTabLogic.init();

    _this.initCompilerApi();

    _this.el = document.createElement('div');

    _this.el.setAttribute('id', 'compileTabView');

    return _this;
  }

  (0, _createClass2["default"])(CompileTab, [{
    key: "renderComponent",
    value: function renderComponent() {// empty method, is a state update needed?
    }
  }, {
    key: "onCurrentFileChanged",
    value: function onCurrentFileChanged() {
      this.renderComponent();
    } // onResetResults () {
    //   this.renderComponent()
    // }

  }, {
    key: "onSetWorkspace",
    value: function onSetWorkspace() {
      this.renderComponent();
    }
  }, {
    key: "onFileRemoved",
    value: function onFileRemoved() {
      this.renderComponent();
    }
  }, {
    key: "onNoFileSelected",
    value: function onNoFileSelected() {
      this.renderComponent();
    }
  }, {
    key: "onFileClosed",
    value: function onFileClosed() {
      this.renderComponent();
    }
  }, {
    key: "onCompilationFinished",
    value: function onCompilationFinished() {
      this.renderComponent();
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "compileTabView"
      }, /*#__PURE__*/_react["default"].createElement(_solidityCompiler.SolidityCompiler, {
        api: this
      }));
    }
  }, {
    key: "compileWithParameters",
    value: function () {
      var _compileWithParameters = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(compilationTargets, settings) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompileTab.prototype), "compileWithParameters", this).call(this, compilationTargets, settings);

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function compileWithParameters(_x, _x2) {
        return _compileWithParameters.apply(this, arguments);
      }

      return compileWithParameters;
    }()
  }, {
    key: "getCompilationResult",
    value: function getCompilationResult() {
      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompileTab.prototype), "getCompilationResult", this).call(this);
    }
  }, {
    key: "getFileManagerMode",
    value: function getFileManagerMode() {
      return this.fileManager.mode;
    }
    /**
     * set the compiler configuration
     * This function is used by remix-plugin compiler API.
     * @param {object} settings {evmVersion, optimize, runs, version, language}
     */

  }, {
    key: "setCompilerConfig",
    value: function setCompilerConfig(settings) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompileTab.prototype), "setCompilerConfig", this).call(this, settings);
      this.renderComponent(); // @todo(#2875) should use loading compiler return value to check whether the compiler is loaded instead of "setInterval"

      var value = JSON.stringify(settings, null, '\t');
      this.call('notification', 'toast', (0, _helper.compilerConfigChangedToastMsg)(this.currentRequest.from, value));
    }
  }, {
    key: "compile",
    value: function compile(fileName) {
      this.call('notification', 'toast', (0, _helper.compileToastMsg)(this.currentRequest.from, fileName));
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompileTab.prototype), "compile", this).call(this, fileName);
    }
  }, {
    key: "compileFile",
    value: function compileFile(event) {
      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompileTab.prototype), "compileFile", this).call(this, event);
    }
  }, {
    key: "onActivation",
    value: function () {
      var _onActivation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompileTab.prototype), "onActivation", this).call(this);
                this.on('filePanel', 'workspaceInitializationCompleted', function () {
                  _this2.call('filePanel', 'registerContextMenuItem', {
                    id: 'solidity',
                    name: 'compileFile',
                    label: 'Compile',
                    type: [],
                    extension: ['.sol'],
                    path: [],
                    pattern: []
                  });
                });
                _context2.prev = 2;
                _context2.next = 5;
                return this.call('fileManager', 'file');

              case 5:
                this.currentFile = _context2.sent;
                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);

                if (!(_context2.t0.message !== 'Error: No such file or directory No file selected')) {
                  _context2.next = 12;
                  break;
                }

                throw _context2.t0;

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8]]);
      }));

      function onActivation() {
        return _onActivation.apply(this, arguments);
      }

      return onActivation;
    }()
  }, {
    key: "getCompilerParameters",
    value: function getCompilerParameters() {
      var params = this.queryParams.get();
      params.optimize = params.optimize === 'false' || params.optimize === null || params.optimize === undefined ? false : params.optimize;
      params.optimize = params.optimize === 'true' ? true : params.optimize;
      return params;
    }
  }, {
    key: "setCompilerParameters",
    value: function setCompilerParameters(params) {
      this.queryParams.update(params);
    }
  }, {
    key: "getAppParameter",
    value: function () {
      var _getAppParameter = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(name) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.call('config', 'getAppParameter', name);

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getAppParameter(_x3) {
        return _getAppParameter.apply(this, arguments);
      }

      return getAppParameter;
    }()
  }, {
    key: "setAppParameter",
    value: function () {
      var _setAppParameter = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(name, value) {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.call('config', 'setAppParameter', name, value);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setAppParameter(_x4, _x5) {
        return _setAppParameter.apply(this, arguments);
      }

      return setAppParameter;
    }()
  }]);
  return CompileTab;
}((0, _solidityCompilerPlugin.CompilerApiMixin)(_engineWeb.ViewPlugin));

module.exports = CompileTab;

/***/ }),
/* 2505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SolidityCompiler = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _compilerContainer = __webpack_require__(2506);

var _contractSelection = __webpack_require__(2511);

var _toaster = __webpack_require__(479);

var _modalDialog = __webpack_require__(316);

var _renderer = __webpack_require__(1590);

__webpack_require__(1367);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const SolidityCompiler = props => {
  const {
    api,
    api: {
      currentFile,
      compileTabLogic,
      configurationSettings
    }
  } = props;
  const [state, setState] = (0, _react.useState)({
    isHardhatProject: false,
    isTruffleProject: false,
    isFoundryProject: false,
    workspaceName: '',
    currentFile,
    configFilePath: 'compiler_config.json',
    loading: false,
    compileTabLogic: null,
    compiler: null,
    toasterMsg: '',
    modal: {
      hide: true,
      title: '',
      message: null,
      okLabel: '',
      okFn: () => {},
      cancelLabel: '',
      cancelFn: () => {},
      handleHide: null
    }
  });
  const [currentVersion, setCurrentVersion] = (0, _react.useState)('');
  const [hideWarnings, setHideWarnings] = (0, _react.useState)(false);
  const [compileErrors, setCompileErrors] = (0, _react.useState)({
    [currentFile]: api.compileErrors
  });
  const [badgeStatus, setBadgeStatus] = (0, _react.useState)({});
  const [contractsFile, setContractsFile] = (0, _react.useState)({});
  (0, _react.useEffect)(() => {
    (async () => {
      const hide = (await api.getAppParameter('hideWarnings')) || false;
      setHideWarnings(hide);
    })();
  }, []);
  (0, _react.useEffect)(() => {
    if (badgeStatus[currentFile]) {
      api.emit('statusChanged', badgeStatus[currentFile]);
    } else {
      api.emit('statusChanged', {
        key: 'none'
      });
    }
  }, [badgeStatus[currentFile], currentFile]); // Return the file name of a path: ex "browser/ballot.sol" -> "ballot.sol"

  const getFileName = path => {
    const part = path.split('/');
    return part[part.length - 1];
  };

  api.onCurrentFileChanged = currentFile => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        currentFile
      });
    });
  };

  api.onSetWorkspace = async (isLocalhost, workspaceName) => {
    const isHardhat = isLocalhost && (await compileTabLogic.isHardhatProject());
    const isTruffle = isLocalhost && (await compileTabLogic.isTruffleProject());
    const isFoundry = isLocalhost && (await compileTabLogic.isFoundryProject());
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        currentFile,
        isHardhatProject: isHardhat,
        workspaceName: workspaceName,
        isTruffleProject: isTruffle,
        isFoundryProject: isFoundry
      });
    });
  };

  api.onFileRemoved = path => {
    if (path === state.configFilePath) setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        configFilePath: ''
      });
    });
  };

  api.onNoFileSelected = () => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        currentFile: ''
      });
    });
    setCompileErrors({});
  };

  api.onCompilationFinished = compilationDetails => {
    const {
      contractMap,
      contractsDetails,
      target
    } = compilationDetails;
    const contractList = contractMap ? Object.keys(contractMap).map(key => {
      return {
        name: key,
        file: getFileName(contractMap[key].file)
      };
    }) : [];
    setContractsFile(_objectSpread(_objectSpread({}, contractsFile), {}, {
      [target]: {
        contractList,
        contractsDetails
      }
    }));
    setCompileErrors(_objectSpread(_objectSpread({}, compileErrors), {}, {
      [currentFile]: api.compileErrors
    }));
  };

  api.onFileClosed = name => {
    if (name === currentFile) {
      setCompileErrors(_objectSpread(_objectSpread({}, compileErrors), {}, {
        [currentFile]: {}
      }));
      setBadgeStatus(_objectSpread(_objectSpread({}, badgeStatus), {}, {
        [currentFile]: {
          key: 'none'
        }
      }));
    }
  };

  api.statusChanged = data => {
    setBadgeStatus(_objectSpread(_objectSpread({}, badgeStatus), {}, {
      [currentFile]: data
    }));
  };

  const setConfigFilePath = path => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        configFilePath: path
      });
    });
  };

  const toast = message => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        toasterMsg: message
      });
    });
  };

  const updateCurrentVersion = value => {
    setCurrentVersion(value);
    api.setCompilerParameters({
      version: value
    });
  };

  const modal = async (title, message, okLabel, okFn, cancelLabel, cancelFn) => {
    await setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        modal: _objectSpread(_objectSpread({}, prevState.modal), {}, {
          hide: false,
          message,
          title,
          okLabel,
          okFn,
          cancelLabel,
          cancelFn
        })
      });
    });
  };

  const handleHideModal = () => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        modal: _objectSpread(_objectSpread({}, state.modal), {}, {
          hide: true,
          message: null
        })
      });
    });
  };

  const panicMessage = message => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
      className: "fas fa-exclamation-circle remixui_panicError",
      "aria-hidden": "true"
    }), "The compiler returned with the following internal error: ", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), " ", /*#__PURE__*/(0, _jsxRuntime.jsxs)("b", {
      children: [message, ".", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "The compiler might be in a non-sane state, please be careful and do not use further compilation data to deploy to mainnet. It is heavily recommended to use another browser not affected by this issue (Firefox is known to not be affected)."]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "Please join ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
      href: "https://gitter.im/ethereum/remix",
      target: "blank",
      children: "remix gitter channel"
    }), " for more information."]
  });

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      id: "compileTabView",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_compilerContainer.CompilerContainer, {
        api: api,
        isHardhatProject: state.isHardhatProject,
        workspaceName: state.workspaceName,
        isTruffleProject: state.isTruffleProject,
        isFoundryProject: state.isFoundryProject,
        compileTabLogic: compileTabLogic,
        tooltip: toast,
        modal: modal,
        compiledFileName: currentFile,
        updateCurrentVersion: updateCurrentVersion,
        configurationSettings: configurationSettings,
        configFilePath: state.configFilePath,
        setConfigFilePath: setConfigFilePath
      }), contractsFile[currentFile] && contractsFile[currentFile].contractsDetails && /*#__PURE__*/(0, _jsxRuntime.jsx)(_contractSelection.ContractSelection, {
        api: api,
        contractsDetails: contractsFile[currentFile].contractsDetails,
        contractList: contractsFile[currentFile].contractList,
        modal: modal
      }), compileErrors[currentFile] && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "remixui_errorBlobs p-4",
        "data-id": "compiledErrors",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          "data-id": `compilationFinishedWith_${currentVersion}`
        }), compileErrors[currentFile].error && /*#__PURE__*/(0, _jsxRuntime.jsx)(_renderer.Renderer, {
          message: compileErrors[currentFile].error.formattedMessage || compileErrors[currentFile].error,
          plugin: api,
          opt: {
            type: compileErrors[currentFile].error.severity || 'error',
            errorType: compileErrors[currentFile].error.type
          }
        }), compileErrors[currentFile].error && compileErrors[currentFile].error.mode === 'panic' && modal('Error', panicMessage(compileErrors[currentFile].error.formattedMessage), 'Close', null), compileErrors[currentFile].errors && compileErrors[currentFile].errors.length && compileErrors[currentFile].errors.map((err, index) => {
          if (hideWarnings) {
            if (err.severity !== 'warning') {
              return /*#__PURE__*/(0, _jsxRuntime.jsx)(_renderer.Renderer, {
                message: err.formattedMessage,
                plugin: api,
                opt: {
                  type: err.severity,
                  errorType: err.type
                }
              }, index);
            }
          } else {
            return /*#__PURE__*/(0, _jsxRuntime.jsx)(_renderer.Renderer, {
              message: err.formattedMessage,
              plugin: api,
              opt: {
                type: err.severity,
                errorType: err.type
              }
            }, index);
          }
        })]
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: state.toasterMsg
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_modalDialog.ModalDialog, {
      id: "workspacesModalDialog",
      title: state.modal.title,
      message: state.modal.message,
      hide: state.modal.hide,
      okLabel: state.modal.okLabel,
      okFn: state.modal.okFn,
      cancelLabel: state.modal.cancelLabel,
      cancelFn: state.modal.cancelFn,
      handleHide: handleHideModal,
      children: typeof state.modal.message !== 'string' && state.modal.message
    })]
  });
};

exports.SolidityCompiler = SolidityCompiler;
var _default = SolidityCompiler;
exports.default = _default;

/***/ }),
/* 2506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CompilerContainer = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _semver = _interopRequireDefault(__webpack_require__(1231));

var _helper = __webpack_require__(1121);

var _remixSolidity = __webpack_require__(1149);

var _compiler = __webpack_require__(2507);

var _compiler2 = __webpack_require__(2508);

var _reactBootstrap = __webpack_require__(1209);

var _clipboard = __webpack_require__(1154);

var _compilerConfiguration = __webpack_require__(2509);

__webpack_require__(1367);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const defaultPath = "compiler_config.json";

const _paq = window._paq = window._paq || []; //eslint-disable-line


const CompilerContainer = props => {
  const {
    api,
    compileTabLogic,
    tooltip,
    modal,
    compiledFileName,
    updateCurrentVersion,
    configurationSettings,
    isHardhatProject,
    isTruffleProject,
    isFoundryProject,
    workspaceName,
    configFilePath,
    setConfigFilePath
  } = props; // eslint-disable-line

  const [state, setState] = (0, _react.useState)({
    hideWarnings: false,
    autoCompile: false,
    useFileConfiguration: false,
    matomoAutocompileOnce: true,
    optimize: false,
    compileTimeout: null,
    timeout: 300,
    allversions: [],
    customVersions: [],
    selectedVersion: null,
    defaultVersion: 'soljson-v0.8.7+commit.e28d00a7.js',
    // this default version is defined: in makeMockCompiler (for browser test)
    runs: '',
    compiledFileName: '',
    includeNightlies: false,
    language: 'Solidity',
    evmVersion: '',
    createFileOnce: true
  });
  const [showFilePathInput, setShowFilePathInput] = (0, _react.useState)(false);
  const [toggleExpander, setToggleExpander] = (0, _react.useState)(false);
  const [disableCompileButton, setDisableCompileButton] = (0, _react.useState)(false);
  const compileIcon = (0, _react.useRef)(null);
  const promptMessageInput = (0, _react.useRef)(null);
  const configFilePathInput = (0, _react.useRef)(null);
  const [hhCompilation, sethhCompilation] = (0, _react.useState)(false);
  const [truffleCompilation, setTruffleCompilation] = (0, _react.useState)(false);
  const [compilerContainer, dispatch] = (0, _react.useReducer)(_compiler.compilerReducer, _compiler.compilerInitialState);
  (0, _react.useEffect)(() => {
    if (workspaceName) {
      api.setAppParameter('configFilePath', defaultPath);

      if (state.useFileConfiguration) {
        api.fileExists(defaultPath).then(exists => {
          if (!exists && state.useFileConfiguration) {
            configFilePathInput.current.value = defaultPath;
            createNewConfigFile();
          }
        });
      }

      setShowFilePathInput(false);
    }
  }, [workspaceName]);
  (0, _react.useEffect)(() => {
    if (state.useFileConfiguration) {
      api.fileExists(defaultPath).then(exists => {
        if (!exists) createNewConfigFile();
      });
      setToggleExpander(true);
    }
  }, [state.useFileConfiguration]);
  (0, _react.useEffect)(() => {
    const listener = event => {
      if (configFilePathInput.current !== event.target && event.target.innerText !== "Create") {
        setShowFilePathInput(false);
        configFilePathInput.current.value = "";
        return;
      }
    };

    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);
    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  });
  (0, _react.useEffect)(() => {
    fetchAllVersion((allversions, selectedVersion, isURL) => {
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          allversions
        });
      });
      if (isURL) _updateVersionSelector(state.defaultVersion, selectedVersion);else {
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            selectedVersion
          });
        });
        updateCurrentVersion(selectedVersion);

        _updateVersionSelector(selectedVersion);
      }
    });
    const currentFileName = api.currentFile;
    currentFile(currentFileName);
    (0, _compiler2.listenToEvents)(compileTabLogic, api)(dispatch);
  }, []);
  (0, _react.useEffect)(() => {
    (async () => {
      if (compileTabLogic && compileTabLogic.compiler) {
        const autocompile = (await api.getAppParameter('autoCompile')) || false;
        const hideWarnings = (await api.getAppParameter('hideWarnings')) || false;
        const includeNightlies = (await api.getAppParameter('includeNightlies')) || false;
        const useFileConfiguration = (await api.getAppParameter('useFileConfiguration')) || false;
        let configFilePathSaved = await api.getAppParameter('configFilePath');
        if (!configFilePathSaved || configFilePathSaved == '') configFilePathSaved = defaultPath;
        setConfigFilePath(configFilePathSaved);
        setState(prevState => {
          const params = api.getCompilerParameters();
          const optimize = params.optimize;
          const runs = params.runs;
          const evmVersion = compileTabLogic.evmVersions.includes(params.evmVersion) ? params.evmVersion : 'default';
          const language = (0, _remixSolidity.getValidLanguage)(params.language);
          return _objectSpread(_objectSpread({}, prevState), {}, {
            hideWarnings: hideWarnings,
            autoCompile: autocompile,
            includeNightlies: includeNightlies,
            useFileConfiguration: useFileConfiguration,
            optimize: optimize,
            runs: runs,
            evmVersion: evmVersion !== null && evmVersion !== 'null' && evmVersion !== undefined && evmVersion !== 'undefined' ? evmVersion : 'default',
            language: language !== null ? language : 'Solidity'
          });
        });
      }
    })();
  }, [compileTabLogic]);
  (0, _react.useEffect)(() => {
    const isDisabled = !compiledFileName || compiledFileName && !isSolFileSelected(compiledFileName);
    setDisableCompileButton(isDisabled);
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        compiledFileName
      });
    });
  }, [compiledFileName]);
  (0, _react.useEffect)(() => {
    if (compilerContainer.compiler.mode) {
      switch (compilerContainer.compiler.mode) {
        case 'startingCompilation':
          startingCompilation();
          break;

        case 'compilationDuration':
          compilationDuration(compilerContainer.compiler.args[0]);
          break;

        case 'loadingCompiler':
          loadingCompiler();
          break;

        case 'compilerLoaded':
          compilerLoaded();
          break;

        case 'compilationFinished':
          compilationFinished();
          break;
      }
    }
  }, [compilerContainer.compiler.mode]);
  (0, _react.useEffect)(() => {
    if (compilerContainer.editor.mode) {
      switch (compilerContainer.editor.mode) {
        case 'sessionSwitched':
          sessionSwitched();
          (0, _compiler2.resetEditorMode)()(dispatch);
          break;

        case 'contentChanged':
          contentChanged();
          (0, _compiler2.resetEditorMode)()(dispatch);
          break;
      }
    }
  }, [compilerContainer.editor.mode]);
  (0, _react.useEffect)(() => {
    compileTabLogic.setUseFileConfiguration(state.useFileConfiguration);
    if (state.useFileConfiguration) compileTabLogic.setConfigFilePath(configFilePath);
  }, [state.useFileConfiguration]);
  (0, _react.useEffect)(() => {
    if (configurationSettings) {
      setConfiguration(configurationSettings);
    }
  }, [configurationSettings]);

  const toggleConfigType = () => {
    if (state.useFileConfiguration) if (state.createFileOnce) {
      api.fileExists(defaultPath).then(exists => {
        if (!exists || state.useFileConfiguration) createNewConfigFile();
      });
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          createFileOnce: false
        });
      });
    }
    setState(prevState => {
      api.setAppParameter('useFileConfiguration', !state.useFileConfiguration);
      return _objectSpread(_objectSpread({}, prevState), {}, {
        useFileConfiguration: !state.useFileConfiguration
      });
    });
  };

  const openFile = async () => {
    api.open(configFilePath);
  };

  const createNewConfigFile = async () => {
    let filePath = configFilePathInput.current && configFilePathInput.current.value !== '' ? configFilePathInput.current.value : configFilePath;
    if (filePath === '') filePath = defaultPath;
    if (!filePath.endsWith('.json')) filePath = filePath + '.json';
    let compilerConfig = _compilerConfiguration.configFileContent;

    if (isFoundryProject && !compilerConfig.includes('remappings')) {
      const config = JSON.parse(compilerConfig);
      config.settings.remappings = ['ds-test/=lib/forge-std/lib/ds-test/src/', 'forge-std/=lib/forge-std/src/'];
      compilerConfig = JSON.stringify(config, null, '\t');
    }

    await api.writeFile(filePath, compilerConfig);
    api.setAppParameter('configFilePath', filePath);
    setConfigFilePath(filePath);
    compileTabLogic.setConfigFilePath(filePath);
    setShowFilePathInput(false);
  };

  const handleConfigPathChange = async () => {
    if (configFilePathInput.current.value !== '') {
      if (!configFilePathInput.current.value.endsWith('.json')) configFilePathInput.current.value += '.json';

      if (await api.fileExists(configFilePathInput.current.value)) {
        api.setAppParameter('configFilePath', configFilePathInput.current.value);
        setConfigFilePath(configFilePathInput.current.value);
        compileTabLogic.setConfigFilePath(configFilePathInput.current.value);
        setShowFilePathInput(false);
      } else {
        modal('New configuration file', `The file "${configFilePathInput.current.value}" you entered does not exist. Do you want to create a new one?`, 'Create', async () => await createNewConfigFile(), 'Cancel', () => {
          setShowFilePathInput(false);
        });
      }
    }
  };

  const _retrieveVersion = version => {
    if (!version) version = state.selectedVersion;
    if (version === 'builtin') version = state.defaultVersion;
    return _semver.default.coerce(version) ? _semver.default.coerce(version).version : '';
  }; // fetching both normal and wasm builds and creating a [version, baseUrl] map


  const fetchAllVersion = async callback => {
    let selectedVersion, allVersionsWasm, isURL;
    let allVersions = [{
      path: 'builtin',
      longVersion: 'latest local version - ' + state.defaultVersion
    }]; // fetch normal builds

    const binRes = await (0, _remixSolidity.promisedMiniXhr)(`${_remixSolidity.baseURLBin}/list.json`); // fetch wasm builds

    const wasmRes = await (0, _remixSolidity.promisedMiniXhr)(`${_remixSolidity.baseURLWasm}/list.json`);

    if (binRes.event.type === 'error' && wasmRes.event.type === 'error') {
      selectedVersion = 'builtin';
      return callback(allVersions, selectedVersion);
    }

    try {
      const versions = JSON.parse(binRes.json).builds.slice().reverse();
      allVersions = [...allVersions, ...versions];
      selectedVersion = state.defaultVersion;
      if (api.getCompilerParameters().version) selectedVersion = api.getCompilerParameters().version; // Check if version is a URL and corresponding filename starts with 'soljson'

      if (selectedVersion.startsWith('https://')) {
        const urlArr = selectedVersion.split('/');
        if (urlArr[urlArr.length - 1].startsWith('soljson')) isURL = true;
      }

      if (wasmRes.event.type !== 'error') {
        allVersionsWasm = JSON.parse(wasmRes.json).builds.slice().reverse();
      }
    } catch (e) {
      tooltip('Cannot load compiler version list. It might have been blocked by an advertisement blocker. Please try deactivating any of them from this page and reload. Error: ' + e);
    } // replace in allVersions those compiler builds which exist in allVersionsWasm with new once


    if (allVersionsWasm && allVersions) {
      allVersions.forEach((compiler, index) => {
        const wasmIndex = allVersionsWasm.findIndex(wasmCompiler => {
          return wasmCompiler.longVersion === compiler.longVersion;
        });

        if (wasmIndex !== -1) {
          allVersions[index] = allVersionsWasm[wasmIndex];
          _remixSolidity.pathToURL[compiler.path] = _remixSolidity.baseURLWasm;
        } else {
          _remixSolidity.pathToURL[compiler.path] = _remixSolidity.baseURLBin;
        }
      });
    }

    callback(allVersions, selectedVersion, isURL);
  };
  /**
   * Update the compilation button with the name of the current file
   */


  const currentFile = (name = '') => {
    if (name && name !== '') {
      _setCompilerVersionFromPragma(name);
    }

    const compiledFileName = name.split('/').pop();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        compiledFileName
      });
    });
  }; // Load solc compiler version according to pragma in contract file


  const _setCompilerVersionFromPragma = filename => {
    if (!state.allversions) return;
    api.readFile(filename).then(data => {
      if (!data) return;
      const pragmaArr = data.match(/(pragma solidity (.+?);)/g);

      if (pragmaArr && pragmaArr.length === 1) {
        const pragmaStr = pragmaArr[0].replace('pragma solidity', '').trim();
        const pragma = pragmaStr.substring(0, pragmaStr.length - 1);
        const releasedVersions = state.allversions.filter(obj => !obj.prerelease).map(obj => obj.version);
        const allVersions = state.allversions.map(obj => _retrieveVersion(obj.version));

        const currentCompilerName = _retrieveVersion(state.selectedVersion); // contains only numbers part, for example '0.4.22'


        const pureVersion = _retrieveVersion(); // is nightly build newer than the last release


        const isNewestNightly = currentCompilerName.includes('nightly') && _semver.default.gt(pureVersion, releasedVersions[0]); // checking if the selected version is in the pragma range


        const isInRange = _semver.default.satisfies(pureVersion, pragma); // checking if the selected version is from official compilers list(excluding custom versions) and in range or greater


        const isOfficial = allVersions.includes(currentCompilerName);

        if (isOfficial && !isInRange && !isNewestNightly) {
          const compilerToLoad = _semver.default.maxSatisfying(releasedVersions, pragma);

          const compilerPath = state.allversions.filter(obj => !obj.prerelease && obj.version === compilerToLoad)[0].path;

          if (state.selectedVersion !== compilerPath) {
            // @ts-ignore
            api.call('notification', 'toast', `Updating compiler version to match current contract file pragma i.e ${_retrieveVersion(compilerPath)}`);
            setState(prevState => {
              return _objectSpread(_objectSpread({}, prevState), {}, {
                selectedVersion: compilerPath
              });
            });

            _updateVersionSelector(compilerPath);
          }
        }
      }
    });
  };

  const isSolFileSelected = (currentFile = '') => {
    if (!currentFile) currentFile = api.currentFile;
    if (!currentFile) return false;
    const extention = currentFile.substr(currentFile.length - 3, currentFile.length);
    return extention.toLowerCase() === 'sol' || extention.toLowerCase() === 'yul';
  };

  const sessionSwitched = () => {
    if (!compileIcon.current) return;
    scheduleCompilation();
  };

  const startingCompilation = () => {
    if (!compileIcon.current) return;
    compileIcon.current.setAttribute('title', 'compiling...');
    compileIcon.current.classList.remove('remixui_bouncingIcon');
    compileIcon.current.classList.add('remixui_spinningIcon');
  };

  const compilationDuration = speed => {
    if (speed > 1000) {
      console.log(`Last compilation took ${speed}ms. We suggest to turn off autocompilation.`);
    }
  };

  const contentChanged = () => {
    if (!compileIcon.current) return;
    scheduleCompilation();
    compileIcon.current.classList.add('remixui_bouncingIcon'); // @TODO: compileView tab
  };

  const loadingCompiler = () => {
    if (!compileIcon.current) return;
    compileIcon.current.setAttribute('title', 'compiler is loading, please wait a few moments.');
    compileIcon.current.classList.add('remixui_spinningIcon');

    _updateLanguageSelector();

    setDisableCompileButton(true);
  };

  const compilerLoaded = () => {
    if (!compileIcon.current) return;
    compileIcon.current.setAttribute('title', '');
    compileIcon.current.classList.remove('remixui_spinningIcon');
    if (state.autoCompile) compile();
    const isDisabled = !compiledFileName || compiledFileName && !isSolFileSelected(compiledFileName);
    setDisableCompileButton(isDisabled);
  };

  const compilationFinished = () => {
    if (!compileIcon.current) return;
    compileIcon.current.setAttribute('title', 'idle');
    compileIcon.current.classList.remove('remixui_spinningIcon');
    compileIcon.current.classList.remove('remixui_bouncingIcon');

    if (!state.autoCompile || state.autoCompile && state.matomoAutocompileOnce) {
      if (state.useFileConfiguration) _paq.push(['trackEvent', 'compiler', 'compiled_with_config_file']);

      _paq.push(['trackEvent', 'compiler', 'compiled_with_version', _retrieveVersion()]);

      if (state.autoCompile && state.matomoAutocompileOnce) {
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            matomoAutocompileOnce: false
          });
        });
      }
    }
  };

  const scheduleCompilation = () => {
    if (!state.autoCompile) return;
    if (state.compileTimeout) window.clearTimeout(state.compileTimeout);
    const compileTimeout = window.setTimeout(() => {
      state.autoCompile && compile();
    }, state.timeout);
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        compileTimeout
      });
    });
  };

  const compile = () => {
    const currentFile = api.currentFile;
    if (!isSolFileSelected()) return;

    _setCompilerVersionFromPragma(currentFile);

    let externalCompType;
    if (hhCompilation) externalCompType = 'hardhat';else if (truffleCompilation) externalCompType = 'truffle';
    compileTabLogic.runCompiler(externalCompType);
  };

  const compileAndRun = () => {
    const currentFile = api.currentFile;
    if (!isSolFileSelected()) return;

    _setCompilerVersionFromPragma(currentFile);

    let externalCompType;
    if (hhCompilation) externalCompType = 'hardhat';else if (truffleCompilation) externalCompType = 'truffle';
    api.runScriptAfterCompilation(currentFile);
    compileTabLogic.runCompiler(externalCompType);
  };

  const _updateVersionSelector = (version, customUrl = '') => {
    // update selectedversion of previous one got filtered out
    let selectedVersion = version;

    if (!selectedVersion || !_shouldBeAdded(selectedVersion)) {
      selectedVersion = state.defaultVersion;
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          selectedVersion
        });
      });
    }

    updateCurrentVersion(selectedVersion);
    api.setCompilerParameters({
      version: selectedVersion
    });
    let url;

    if (customUrl !== '') {
      selectedVersion = customUrl;
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          selectedVersion,
          customVersions: [...state.customVersions, selectedVersion]
        });
      });
      updateCurrentVersion(selectedVersion);
      url = customUrl;
      api.setCompilerParameters({
        version: selectedVersion
      });
    } else {
      if ((0, _helper.checkSpecialChars)(selectedVersion)) {
        return console.log('loading ' + selectedVersion + ' not allowed, special chars not allowed.');
      }

      if (selectedVersion === 'builtin' || selectedVersion.indexOf('soljson') === 0) {
        url = (0, _remixSolidity.urlFromVersion)(selectedVersion);
      } else {
        return console.log('loading ' + selectedVersion + ' not allowed, version should start with "soljson"');
      }
    } // Workers cannot load js on "file:"-URLs and we get a
    // "Uncaught RangeError: Maximum call stack size exceeded" error on Chromium,
    // resort to non-worker version in that case.


    if (selectedVersion === 'builtin') selectedVersion = state.defaultVersion;

    if (selectedVersion !== 'builtin' && (0, _remixSolidity.canUseWorker)(selectedVersion)) {
      compileTabLogic.compiler.loadVersion(true, url);
    } else {
      compileTabLogic.compiler.loadVersion(false, url);
    }
  };

  const _shouldBeAdded = version => {
    return !version.includes('nightly') || version.includes('nightly') && state.includeNightlies;
  };

  const promptCompiler = () => {
    // custom url https://solidity-blog.s3.eu-central-1.amazonaws.com/data/08preview/soljson.js
    modal('Add a custom compiler', promptMessage('URL'), 'OK', addCustomCompiler, 'Cancel', () => {});
  };

  const promptMessage = message => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        children: message
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        type: "text",
        "data-id": "modalDialogCustomPromptCompiler",
        className: "form-control",
        ref: promptMessageInput
      })]
    });
  };

  const addCustomCompiler = () => {
    const url = promptMessageInput.current.value;
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        selectedVersion: url
      });
    });

    _updateVersionSelector(state.defaultVersion, url);
  };

  const handleLoadVersion = value => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        selectedVersion: value,
        matomoAutocompileOnce: true
      });
    });
    updateCurrentVersion(value);

    _updateVersionSelector(value);

    _updateLanguageSelector();
  };

  const _updateLanguageSelector = () => {
    // This is the first version when Yul is available
    if (!_semver.default.valid(_retrieveVersion()) || _semver.default.lt(_retrieveVersion(), 'v0.5.7+commit.6da8b019.js')) {
      handleLanguageChange('Solidity');
      compileTabLogic.setLanguage('Solidity');
    }
  };

  const handleAutoCompile = e => {
    const checked = e.target.checked;
    api.setAppParameter('autoCompile', checked);
    checked && compile();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        autoCompile: checked,
        matomoAutocompileOnce: state.matomoAutocompileOnce || checked
      });
    });
  };

  const handleOptimizeChange = value => {
    const checked = !!value;
    api.setAppParameter('optimize', checked);
    compileTabLogic.setOptimize(checked);

    if (compileTabLogic.optimize) {
      compileTabLogic.setRuns(parseInt(state.runs));
    } else {
      compileTabLogic.setRuns(200);
    }

    state.autoCompile && compile();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        optimize: checked
      });
    });
  };

  const onChangeRuns = value => {
    const runs = value;
    compileTabLogic.setRuns(parseInt(runs));
    state.autoCompile && compile();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        runs
      });
    });
  };

  const handleHideWarningsChange = e => {
    const checked = e.target.checked;
    api.setAppParameter('hideWarnings', checked);
    state.autoCompile && compile();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        hideWarnings: checked
      });
    });
  };

  const handleNightliesChange = e => {
    const checked = e.target.checked;
    if (!checked) handleLoadVersion(state.defaultVersion);
    api.setAppParameter('includeNightlies', checked);
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        includeNightlies: checked
      });
    });
  };

  const handleLanguageChange = value => {
    compileTabLogic.setLanguage(value);
    state.autoCompile && compile();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        language: value
      });
    });
  };

  const handleEvmVersionChange = value => {
    if (!value) return;
    let v = value;

    if (v === 'default') {
      v = null;
    }

    compileTabLogic.setEvmVersion(v);
    state.autoCompile && compile();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        evmVersion: value
      });
    });
  };

  const updatehhCompilation = event => {
    const checked = event.target.checked;
    if (checked) setTruffleCompilation(false); // wayaround to reset the variable

    sethhCompilation(checked);
    api.setAppParameter('hardhat-compilation', checked);
  };

  const updateTruffleCompilation = event => {
    const checked = event.target.checked;
    if (checked) sethhCompilation(false); // wayaround to reset the variable

    setTruffleCompilation(checked);
    api.setAppParameter('truffle-compilation', checked);
  };
  /*
    The following functions map with the above event handlers.
    They are an external API for modifying the compiler configuration.
  */


  const setConfiguration = settings => {
    handleLoadVersion(`soljson-v${settings.version}.js`);
    handleEvmVersionChange(settings.evmVersion);
    handleLanguageChange(settings.language);
    handleOptimizeChange(settings.optimize);
    onChangeRuns(settings.runs);
  };

  const toggleConfigurations = () => {
    setToggleExpander(!toggleExpander);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("section", {
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "pt-0 remixui_compilerSection",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mb-1",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            className: "remixui_compilerLabel form-check-label",
            htmlFor: "versionSelector",
            children: ["Compiler", /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
              className: "far fa-plus btn-light border-0 p-0 mx-2 btn-sm",
              onClick: promptCompiler,
              title: "Add a custom compiler with URL"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("select", {
            value: state.selectedVersion || state.defaultVersion,
            onChange: e => handleLoadVersion(e.target.value),
            className: "custom-select",
            id: "versionSelector",
            disabled: state.allversions.length <= 0,
            children: [state.allversions.length <= 0 && /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
              disabled: true,
              "data-id": state.selectedVersion === state.defaultVersion ? 'selected' : '',
              children: state.defaultVersion
            }), state.allversions.length <= 0 && /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
              disabled: true,
              "data-id": state.selectedVersion === 'builtin' ? 'selected' : '',
              children: "builtin"
            }), state.customVersions.map((url, i) => /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
              "data-id": state.selectedVersion === url ? 'selected' : '',
              value: url,
              children: "custom"
            }, i)), state.allversions.map((build, i) => {
              return _shouldBeAdded(build.longVersion) ? /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
                value: build.path,
                "data-id": state.selectedVersion === build.path ? 'selected' : '',
                children: build.longVersion
              }, i) : null;
            })]
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mb-2 flex-row-reverse remixui_nightlyBuilds custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "mr-2 custom-control-input",
            id: "nightlies",
            type: "checkbox",
            onChange: handleNightliesChange,
            checked: state.includeNightlies
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            htmlFor: "nightlies",
            "data-id": "compilerNightliesBuild",
            className: "form-check-label custom-control-label",
            children: "Include nightly builds"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-2 remixui_compilerConfig custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "remixui_autocompile custom-control-input",
            type: "checkbox",
            onChange: handleAutoCompile,
            "data-id": "compilerContainerAutoCompile",
            id: "autoCompile",
            title: "Auto compile",
            checked: state.autoCompile
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            htmlFor: "autoCompile",
            children: "Auto compile"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-1 mb-2 remixui_compilerConfig custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "remixui_autocompile custom-control-input",
            onChange: handleHideWarningsChange,
            id: "hideWarningsBox",
            type: "checkbox",
            title: "Hide warnings",
            checked: state.hideWarnings
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            htmlFor: "hideWarningsBox",
            children: "Hide warnings"
          })]
        }), isHardhatProject && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-3 remixui_compilerConfig custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "remixui_autocompile custom-control-input",
            onChange: updatehhCompilation,
            id: "enableHardhat",
            type: "checkbox",
            title: "Enable Hardhat Compilation",
            checked: hhCompilation
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            htmlFor: "enableHardhat",
            children: "Enable Hardhat Compilation"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            className: "mt-1 text-nowrap",
            href: "https://remix-ide.readthedocs.io/en/latest/hardhat.html#enable-hardhat-compilation",
            target: '_blank',
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
              placement: 'right',
              overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
                className: "text-nowrap",
                id: "overlay-tooltip-hardhat",
                children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                  className: "border bg-light text-dark p-1 pr-3",
                  style: {
                    minWidth: '230px'
                  },
                  children: "Learn how to use Hardhat Compilation"
                })
              }),
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                style: {
                  fontSize: 'medium'
                },
                className: 'ml-2 fal fa-info-circle',
                "aria-hidden": "true"
              })
            })
          })]
        }), isTruffleProject && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-3 remixui_compilerConfig custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "remixui_autocompile custom-control-input",
            onChange: updateTruffleCompilation,
            id: "enableTruffle",
            type: "checkbox",
            title: "Enable Truffle Compilation",
            checked: truffleCompilation
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            htmlFor: "enableTruffle",
            children: "Enable Truffle Compilation"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            className: "mt-1 text-nowrap",
            href: "https://remix-ide.readthedocs.io/en/latest/truffle.html#enable-truffle-compilation",
            target: '_blank',
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
              placement: 'right',
              overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
                className: "text-nowrap",
                id: "overlay-tooltip-truffle",
                children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                  className: "border bg-light text-dark p-1 pr-3",
                  style: {
                    minWidth: '230px'
                  },
                  children: "Learn how to use Truffle Compilation"
                })
              }),
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                style: {
                  fontSize: 'medium'
                },
                className: 'ml-2 fal fa-info-circle',
                "aria-hidden": "true"
              })
            })
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex px-4 remixui_compilerConfigSection justify-content-between",
        onClick: toggleConfigurations,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "d-flex",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "mt-1 remixui_compilerConfigSection",
            children: "Advanced Configurations"
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            "data-id": "scConfigExpander",
            onClick: toggleConfigurations,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              className: !toggleExpander ? 'fas fa-angle-right' : 'fas fa-angle-down',
              "aria-hidden": "true"
            })
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: `px-4 pb-4 border-bottom flex-column ${toggleExpander ? "d-flex" : "d-none"}`,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex pb-1 remixui_compilerConfig custom-control custom-radio",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "custom-control-input",
            type: "radio",
            name: "configradio",
            value: "manual",
            onChange: toggleConfigType,
            checked: !state.useFileConfiguration,
            id: "scManualConfig"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            htmlFor: "scManualConfig",
            "data-id": "scManualConfiguration",
            children: "Compiler configuration"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: `flex-column 'd-flex'}`,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "mb-2 ml-4",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "remixui_compilerLabel form-check-label",
              htmlFor: "compilierLanguageSelector",
              children: "Language"
            }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("select", {
              onChange: e => handleLanguageChange(e.target.value),
              disabled: state.useFileConfiguration,
              value: state.language,
              className: "custom-select",
              id: "compilierLanguageSelector",
              title: "Language specification available from Compiler >= v0.5.7",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
                "data-id": state.language === 'Solidity' ? 'selected' : '',
                value: "Solidity",
                children: "Solidity"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
                "data-id": state.language === 'Yul' ? 'selected' : '',
                value: "Yul",
                children: "Yul"
              })]
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "mb-2 ml-4",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "remixui_compilerLabel form-check-label",
              htmlFor: "evmVersionSelector",
              children: "EVM Version"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("select", {
              value: state.evmVersion,
              onChange: e => handleEvmVersionChange(e.target.value),
              disabled: state.useFileConfiguration,
              className: "custom-select",
              id: "evmVersionSelector",
              children: compileTabLogic.evmVersions.map((version, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
                "data-id": state.evmVersion === version ? 'selected' : '',
                value: version,
                children: version
              }, index))
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "mt-1 mt-3 border-dark pb-3 ml-4 remixui_compilerConfig custom-control custom-checkbox",
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "justify-content-between align-items-center d-flex",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
                onChange: e => {
                  handleOptimizeChange(e.target.checked);
                },
                disabled: state.useFileConfiguration,
                className: "custom-control-input",
                id: "optimize",
                type: "checkbox",
                checked: state.optimize
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
                className: "form-check-label custom-control-label",
                htmlFor: "optimize",
                children: "Enable optimization"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
                min: "1",
                className: "custom-select ml-2 remixui_runs",
                id: "runs",
                placeholder: "200",
                value: state.runs,
                type: "number",
                title: "Estimated number of times each opcode of the deployed code will be executed across the life-time of the contract.",
                onChange: e => onChangeRuns(e.target.value),
                disabled: !state.optimize || state.useFileConfiguration
              })]
            })
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex pb-1 remixui_compilerConfig custom-control custom-radio",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "custom-control-input",
            type: "radio",
            name: "configradio",
            value: "file",
            onChange: toggleConfigType,
            checked: state.useFileConfiguration,
            id: "scFileConfig"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "form-check-label custom-control-label",
            htmlFor: "scFileConfig",
            "data-id": "scFileConfiguration",
            children: "Use configuration file"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: `pt-2 ml-4 ml-2 align-items-start justify-content-between d-flex`,
          children: [!showFilePathInput && state.useFileConfiguration && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            title: "Click to open the config file",
            onClick: configFilePath === '' ? () => {} : openFile,
            className: "py-2 remixui_compilerConfigPath",
            children: configFilePath === '' ? 'No file selected.' : configFilePath
          }), !showFilePathInput && !state.useFileConfiguration && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "py-2 text-secondary",
            children: configFilePath
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            ref: configFilePathInput,
            className: `py-0 my-0 form-control ${showFilePathInput ? "d-flex" : "d-none"}`,
            placeholder: "Enter the new path",
            title: "If the file you entered does not exist you will be able to create one in the next step.",
            disabled: !state.useFileConfiguration,
            "data-id": "scConfigFilePathInput",
            onKeyPress: event => {
              if (event.key === 'Enter') {
                handleConfigPathChange();
              }
            }
          }), !showFilePathInput && /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            disabled: !state.useFileConfiguration,
            "data-id": "scConfigChangeFilePath",
            className: "btn-secondary",
            onClick: () => {
              setShowFilePathInput(true);
            },
            children: "Change"
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "px-4",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
          id: "compileBtn",
          "data-id": "compilerContainerCompileBtn",
          className: "btn btn-primary btn-block d-block w-100 text-break remixui_disabled mb-1 mt-3",
          onClick: compile,
          disabled: configFilePath === '' && state.useFileConfiguration || disableCompileButton,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
            overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
              id: "overlay-tooltip-compile",
              children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "text-left",
                children: [!(configFilePath === '' && state.useFileConfiguration) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                  children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("b", {
                    children: "Ctrl+S"
                  }), " for compiling"]
                }), configFilePath === '' && state.useFileConfiguration && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
                  children: " No config file selected"
                })]
              })
            }),
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                ref: compileIcon,
                className: "fas fa-sync remixui_iconbtn",
                "aria-hidden": "true"
              }), "Compile ", typeof state.compiledFileName === 'string' ? (0, _helper.extractNameFromKey)(state.compiledFileName) || '<no file selected>' : '<no file selected>']
            })
          })
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex align-items-center",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            id: "compileAndRunBtn",
            "data-id": "compilerContainerCompileAndRunBtn",
            className: "btn btn-secondary btn-block d-block w-100 text-break remixui_solidityCompileAndRunButton d-inline-block remixui_disabled mb-1 mt-3",
            onClick: compileAndRun,
            disabled: configFilePath === '' && state.useFileConfiguration || disableCompileButton,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
              overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
                id: "overlay-tooltip-compile-run",
                children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                  className: "text-left",
                  children: [!(configFilePath === '' && state.useFileConfiguration) && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("b", {
                      children: "Ctrl+Shift+S"
                    }), " for compiling and script execution"]
                  }), configFilePath === '' && state.useFileConfiguration && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
                    children: " No config file selected"
                  })]
                })
              }),
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                children: "Compile and Run script"
              })
            })
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
            overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
              id: "overlay-tooltip-compile-run-doc",
              children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "text-left p-2",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
                  children: "Choose the script to execute right after compilation by adding the `dev-run-script` natspec tag, as in:"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("pre", {
                  children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("code", {
                    children: ["/**", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "* @title ContractName", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "* @dev ContractDescription", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "* @custom:dev-run-script file_path", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "*/", /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), "contract ContractName ", '{}', /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {})]
                  })
                }), "Click to know more"]
              })
            }),
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
              href: "https://remix-ide.readthedocs.io/en/latest/running_js_scripts.html#compile-a-contract-and-run-a-script-on-the-fly",
              target: "_blank",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                className: "pl-2 ml-2 mt-3 mb-1 fas fa-info text-dark"
              })
            })
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
            tip: "Click to copy the custom NatSpec tag",
            getContent: () => '@custom:dev-run-script file_path',
            direction: "top",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
              className: "btn remixui_copyButton  ml-2 mt-3 mb-1 text-dark",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                className: "remixui_copyIcon far fa-copy",
                "aria-hidden": "true"
              })
            })
          })]
        })]
      })]
    })
  });
};

exports.CompilerContainer = CompilerContainer;
var _default = CompilerContainer;
exports.default = _default;

/***/ }),
/* 2507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compilerReducer = exports.compilerInitialState = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const compilerInitialState = {
  compiler: {
    mode: '',
    args: null
  },
  editor: {
    mode: ''
  }
};
exports.compilerInitialState = compilerInitialState;

const compilerReducer = (state = compilerInitialState, action) => {
  switch (action.type) {
    case 'SET_COMPILER_MODE':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          compiler: _objectSpread(_objectSpread({}, state.compiler), {}, {
            mode: action.payload.mode,
            args: action.payload.args || null
          })
        });
      }

    case 'RESET_COMPILER_MODE':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          compiler: _objectSpread(_objectSpread({}, state.compiler), {}, {
            mode: '',
            args: null
          })
        });
      }

    case 'SET_EDITOR_MODE':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          editor: _objectSpread(_objectSpread({}, state.editor), {}, {
            mode: action.payload
          })
        });
      }

    case 'RESET_EDITOR_MODE':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          editor: _objectSpread(_objectSpread({}, state.editor), {}, {
            mode: ''
          })
        });
      }

    default:
      throw new Error();
  }
};

exports.compilerReducer = compilerReducer;

/***/ }),
/* 2508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setEditorMode = exports.setCompilerMode = exports.resetEditorMode = exports.resetCompilerMode = exports.listenToEvents = void 0;

const setEditorMode = mode => {
  return {
    type: 'SET_EDITOR_MODE',
    payload: mode
  };
};

exports.setEditorMode = setEditorMode;

const resetEditorMode = () => dispatch => {
  dispatch({
    type: 'RESET_EDITOR_MODE'
  });
};

exports.resetEditorMode = resetEditorMode;

const setCompilerMode = (mode, ...args) => {
  return {
    type: 'SET_COMPILER_MODE',
    payload: {
      mode,
      args
    }
  };
};

exports.setCompilerMode = setCompilerMode;

const resetCompilerMode = () => dispatch => {
  dispatch({
    type: 'RESET_COMPILER_MODE'
  });
};

exports.resetCompilerMode = resetCompilerMode;

const listenToEvents = (compileTabLogic, api) => dispatch => {
  api.onSessionSwitched = () => {
    dispatch(setEditorMode('sessionSwitched'));
  };

  compileTabLogic.event.on('startingCompilation', () => {
    dispatch(setCompilerMode('startingCompilation'));
  });
  compileTabLogic.compiler.event.register('compilationDuration', speed => {
    dispatch(setCompilerMode('compilationDuration', speed));
  });

  api.onContentChanged = () => {
    dispatch(setEditorMode('contentChanged'));
  };

  compileTabLogic.compiler.event.register('loadingCompiler', () => {
    dispatch(setCompilerMode('loadingCompiler'));
  });
  compileTabLogic.compiler.event.register('compilerLoaded', () => {
    dispatch(setCompilerMode('compilerLoaded'));
  });
  compileTabLogic.compiler.event.register('compilationFinished', (success, data, source, input, version) => {
    dispatch(setCompilerMode('compilationFinished', success, data, source, input, version));
  });
};

exports.listenToEvents = listenToEvents;

/***/ }),
/* 2509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configFileContent = void 0;
const configFileContent = `
{
	"language": "Solidity",
	"settings": {
		"optimizer": {
			"enabled": true,
			"runs": 200
		},
		"outputSelection": {
			"*": {
			"": ["ast"],
			"*": ["abi", "metadata", "devdoc", "userdoc", "storageLayout", "evm.legacyAssembly", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "evm.gasEstimates", "evm.assembly"]
			}
		},
		"evmVersion": "byzantium"
	}
}
`;
exports.configFileContent = configFileContent;

/***/ }),
/* 2510 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_title {\n  font-size: 1.1em;\n  font-weight: bold;\n  margin-bottom: 1em;\n}\n.remixui_panicError {\n  color: red;\n  font-size: 20px;\n}\n.remixui_crow {\n  display: flex;\n  overflow: auto;\n  clear: both;\n  padding: .2em;\n}\n.remixui_checkboxText {\n  font-weight: normal;\n}\n.remixui_crow label {\n  cursor:pointer;\n}\n.remixui_crowNoFlex {\n  overflow: auto;\n  clear: both;\n}\n.remixui_info {\n  padding: 10px;\n  word-break: break-word;\n}\n.remixui_contract {\n  display: block;\n  margin: 3% 0;\n}\n.remixui_nightlyBuilds {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n.remixui_autocompileContainer {\n  display: flex;\n  align-items: center;\n}\n.remixui_runs {\n  width: 40%;\n}\n.remixui_hideWarningsContainer {\n  display: flex;\n  align-items: center;\n}\n.remixui_autocompile {}\n.remixui_autocompileTitle {\n  font-weight: bold;\n  margin: 1% 0;\n}\n.remixui_autocompileText {\n  margin: 1% 0;\n  font-size: 12px;\n  overflow: hidden;\n  word-break: normal;\n  line-height: initial;\n}\n.remixui_warnCompilationSlow {\n  margin-left: 1%;\n}\n.remixui_compilerConfig {\n  display: flex;\n  align-items: center;\n}\n.remixui_compilerConfig label {\n  margin: 0;\n}\n.remixui_compilerSection {\n  padding: 12px 24px 16px;\n}\n.remixui_compilerConfigSection:hover {\n  cursor: pointer;\n}\n.remixui_compilerConfigSection {\n  font-size: 1rem;\n}\n.remixui_compilerConfigPath {\n  cursor: pointer;\n}\n.remixui_compilerLabel {\n  margin-bottom: 2px;\n  font-size: 11px;\n  line-height: 12px;\n  text-transform: uppercase;\n}\n.remixui_copyButton {\n  padding: 6px;\n  font-weight: bold;\n  font-size: 11px;\n  line-height: 15px;\n}\n.remixui_name {\n  display: flex;\n}\n.remixui_size {\n  display: flex;\n}\n.remixui_checkboxes {\n  display: flex;\n  width: 100%;\n  justify-content: space-between;\n  flex-wrap: wrap;\n}\n.remixui_compileButton {\n  width: 100%;\n  margin: 15px 0 10px 0;\n  font-size: 12px;\n}\n.remixui_container {\n  margin: 0;\n}\n.remixui_optimizeContainer {\n  display: flex;\n}\n.remixui_noContractAlert {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.remixui_contractHelperButtons {\n  margin-top: 6px;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  float: right;\n}\n.remixui_copyToClipboard {\n  font-size: 1rem;\n}\n.remixui_copyIcon {\n  margin-right: 5px;\n}\n.remixui_log {\n  display: flex;\n  flex-direction: column;\n  margin-bottom: 5%;\n  overflow: visible;\n}\n.remixui_key {\n  margin-right: 5px;\n  text-transform: uppercase;\n  width: 100%;\n}\n.remixui_value {\n  display: flex;\n  width: 100%;\n  margin-top: 1.5%;\n}\n.remixui_questionMark {\n  margin-left: 2%;\n  cursor: pointer;\n}\n.remixui_questionMark:hover {\n}\n.remixui_detailsJSON {\n  padding: 8px 0;\n  border: none;\n}\n.remixui_iconbtn {\n  margin-right: 0.3em;\n}\n.remixui_errorBlobs {\n  padding-left: 5px;\n  padding-right: 5px;\n  word-break: break-word;\n}\n.remixui_storageLogo {\n  width: 20px;\n  height: 20px;\n}\n.remixui_spinningIcon {\n  display: inline-block;\n  position: relative;\n  animation: spin 2s infinite linear;\n  -moz-animation: spin 2s infinite linear;\n  -o-animation: spin 2s infinite linear;\n  -webkit-animation: spin 2s infinite linear;\n}\n.remixui_solidityCompileAndRunButton {\n  width: 94%;  \n}\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n@-webkit-keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n.remixui_bouncingIcon {\n  display: inline-block;\n  position: relative;\n  -webkit-animation: bounce 2s infinite linear;\n  animation: bounce 2s infinite linear;\n}\n@-webkit-keyframes bounce {\n    0% { top: 0; }\n    50% { top: -0.2em; }\n    70% { top: -0.3em; }\n    100% { top: 0; }\n}\n@keyframes bounce {\n    0% { top: 0; }\n    50% { top: -0.2em; }\n    70% { top: -0.3em; }\n    100% { top: 0; }\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN0eWxlLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGdCQUFnQjtFQUNoQixpQkFBaUI7RUFDakIsa0JBQWtCO0FBQ3BCO0FBQ0E7RUFDRSxVQUFVO0VBQ1YsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsYUFBYTtFQUNiLGNBQWM7RUFDZCxXQUFXO0VBQ1gsYUFBYTtBQUNmO0FBQ0E7RUFDRSxtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGNBQWM7QUFDaEI7QUFDQTtFQUNFLGNBQWM7RUFDZCxXQUFXO0FBQ2I7QUFDQTtFQUNFLGFBQWE7RUFDYixzQkFBc0I7QUFDeEI7QUFDQTtFQUNFLGNBQWM7RUFDZCxZQUFZO0FBQ2Q7QUFDQTtFQUNFLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxVQUFVO0FBQ1o7QUFDQTtFQUNFLGFBQWE7RUFDYixtQkFBbUI7QUFDckI7QUFDQSxzQkFBc0I7QUFDdEI7RUFDRSxpQkFBaUI7RUFDakIsWUFBWTtBQUNkO0FBQ0E7RUFDRSxZQUFZO0VBQ1osZUFBZTtFQUNmLGdCQUFnQjtFQUNoQixrQkFBa0I7RUFDbEIsb0JBQW9CO0FBQ3RCO0FBQ0E7RUFDRSxlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxTQUFTO0FBQ1g7QUFDQTtFQUNFLHVCQUF1QjtBQUN6QjtBQUNBO0VBQ0UsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsZUFBZTtBQUNqQjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixpQkFBaUI7RUFDakIseUJBQXlCO0FBQzNCO0FBQ0E7RUFDRSxZQUFZO0VBQ1osaUJBQWlCO0VBQ2pCLGVBQWU7RUFDZixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGFBQWE7QUFDZjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsV0FBVztFQUNYLDhCQUE4QjtFQUM5QixlQUFlO0FBQ2pCO0FBQ0E7RUFDRSxXQUFXO0VBQ1gscUJBQXFCO0VBQ3JCLGVBQWU7QUFDakI7QUFDQTtFQUNFLFNBQVM7QUFDWDtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtBQUNyQjtBQUNBO0VBQ0UsZUFBZTtFQUNmLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsOEJBQThCO0VBQzlCLFlBQVk7QUFDZDtBQUNBO0VBQ0UsZUFBZTtBQUNqQjtBQUNBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLGlCQUFpQjtFQUNqQixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQix5QkFBeUI7RUFDekIsV0FBVztBQUNiO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsV0FBVztFQUNYLGdCQUFnQjtBQUNsQjtBQUNBO0VBQ0UsZUFBZTtFQUNmLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7RUFDRSxjQUFjO0VBQ2QsWUFBWTtBQUNkO0FBQ0E7RUFDRSxtQkFBbUI7QUFDckI7QUFDQTtFQUNFLGlCQUFpQjtFQUNqQixrQkFBa0I7RUFDbEIsc0JBQXNCO0FBQ3hCO0FBQ0E7RUFDRSxXQUFXO0VBQ1gsWUFBWTtBQUNkO0FBQ0E7RUFDRSxxQkFBcUI7RUFDckIsa0JBQWtCO0VBQ2xCLGtDQUFrQztFQUNsQyx1Q0FBdUM7RUFDdkMscUNBQXFDO0VBQ3JDLDBDQUEwQztBQUM1QztBQUVBO0VBQ0UsVUFBVTtBQUNaO0FBRUE7RUFDRSxLQUFLLHVCQUF1QixFQUFFO0VBQzlCLE9BQU8seUJBQXlCLEVBQUU7QUFDcEM7QUFDQTtFQUNFLEtBQUssdUJBQXVCLEVBQUU7RUFDOUIsT0FBTyx5QkFBeUIsRUFBRTtBQUNwQztBQWNBO0VBQ0UscUJBQXFCO0VBQ3JCLGtCQUFrQjtFQUdsQiw0Q0FBNEM7RUFDNUMsb0NBQW9DO0FBQ3RDO0FBRUE7SUFDSSxLQUFLLE1BQU0sRUFBRTtJQUNiLE1BQU0sV0FBVyxFQUFFO0lBQ25CLE1BQU0sV0FBVyxFQUFFO0lBQ25CLE9BQU8sTUFBTSxFQUFFO0FBQ25CO0FBbUJBO0lBQ0ksS0FBSyxNQUFNLEVBQUU7SUFDYixNQUFNLFdBQVcsRUFBRTtJQUNuQixNQUFNLFdBQVcsRUFBRTtJQUNuQixPQUFPLE1BQU0sRUFBRTtBQUNuQiIsImZpbGUiOiJzdHlsZS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXh1aV90aXRsZSB7XG4gIGZvbnQtc2l6ZTogMS4xZW07XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xuICBtYXJnaW4tYm90dG9tOiAxZW07XG59XG4ucmVtaXh1aV9wYW5pY0Vycm9yIHtcbiAgY29sb3I6IHJlZDtcbiAgZm9udC1zaXplOiAyMHB4O1xufVxuLnJlbWl4dWlfY3JvdyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG92ZXJmbG93OiBhdXRvO1xuICBjbGVhcjogYm90aDtcbiAgcGFkZGluZzogLjJlbTtcbn1cbi5yZW1peHVpX2NoZWNrYm94VGV4dCB7XG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG59XG4ucmVtaXh1aV9jcm93IGxhYmVsIHtcbiAgY3Vyc29yOnBvaW50ZXI7XG59XG4ucmVtaXh1aV9jcm93Tm9GbGV4IHtcbiAgb3ZlcmZsb3c6IGF1dG87XG4gIGNsZWFyOiBib3RoO1xufVxuLnJlbWl4dWlfaW5mbyB7XG4gIHBhZGRpbmc6IDEwcHg7XG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG59XG4ucmVtaXh1aV9jb250cmFjdCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBtYXJnaW46IDMlIDA7XG59XG4ucmVtaXh1aV9uaWdodGx5QnVpbGRzIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5yZW1peHVpX2F1dG9jb21waWxlQ29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5yZW1peHVpX3J1bnMge1xuICB3aWR0aDogNDAlO1xufVxuLnJlbWl4dWlfaGlkZVdhcm5pbmdzQ29udGFpbmVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5yZW1peHVpX2F1dG9jb21waWxlIHt9XG4ucmVtaXh1aV9hdXRvY29tcGlsZVRpdGxlIHtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIG1hcmdpbjogMSUgMDtcbn1cbi5yZW1peHVpX2F1dG9jb21waWxlVGV4dCB7XG4gIG1hcmdpbjogMSUgMDtcbiAgZm9udC1zaXplOiAxMnB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB3b3JkLWJyZWFrOiBub3JtYWw7XG4gIGxpbmUtaGVpZ2h0OiBpbml0aWFsO1xufVxuLnJlbWl4dWlfd2FybkNvbXBpbGF0aW9uU2xvdyB7XG4gIG1hcmdpbi1sZWZ0OiAxJTtcbn1cbi5yZW1peHVpX2NvbXBpbGVyQ29uZmlnIHtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5yZW1peHVpX2NvbXBpbGVyQ29uZmlnIGxhYmVsIHtcbiAgbWFyZ2luOiAwO1xufVxuLnJlbWl4dWlfY29tcGlsZXJTZWN0aW9uIHtcbiAgcGFkZGluZzogMTJweCAyNHB4IDE2cHg7XG59XG4ucmVtaXh1aV9jb21waWxlckNvbmZpZ1NlY3Rpb246aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4ucmVtaXh1aV9jb21waWxlckNvbmZpZ1NlY3Rpb24ge1xuICBmb250LXNpemU6IDFyZW07XG59XG4ucmVtaXh1aV9jb21waWxlckNvbmZpZ1BhdGgge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4ucmVtaXh1aV9jb21waWxlckxhYmVsIHtcbiAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICBmb250LXNpemU6IDExcHg7XG4gIGxpbmUtaGVpZ2h0OiAxMnB4O1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xufVxuLnJlbWl4dWlfY29weUJ1dHRvbiB7XG4gIHBhZGRpbmc6IDZweDtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIGZvbnQtc2l6ZTogMTFweDtcbiAgbGluZS1oZWlnaHQ6IDE1cHg7XG59XG4ucmVtaXh1aV9uYW1lIHtcbiAgZGlzcGxheTogZmxleDtcbn1cbi5yZW1peHVpX3NpemUge1xuICBkaXNwbGF5OiBmbGV4O1xufVxuLnJlbWl4dWlfY2hlY2tib3hlcyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHdpZHRoOiAxMDAlO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGZsZXgtd3JhcDogd3JhcDtcbn1cbi5yZW1peHVpX2NvbXBpbGVCdXR0b24ge1xuICB3aWR0aDogMTAwJTtcbiAgbWFyZ2luOiAxNXB4IDAgMTBweCAwO1xuICBmb250LXNpemU6IDEycHg7XG59XG4ucmVtaXh1aV9jb250YWluZXIge1xuICBtYXJnaW46IDA7XG59XG4ucmVtaXh1aV9vcHRpbWl6ZUNvbnRhaW5lciB7XG4gIGRpc3BsYXk6IGZsZXg7XG59XG4ucmVtaXh1aV9ub0NvbnRyYWN0QWxlcnQge1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5yZW1peHVpX2NvbnRyYWN0SGVscGVyQnV0dG9ucyB7XG4gIG1hcmdpbi10b3A6IDZweDtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBmbG9hdDogcmlnaHQ7XG59XG4ucmVtaXh1aV9jb3B5VG9DbGlwYm9hcmQge1xuICBmb250LXNpemU6IDFyZW07XG59XG4ucmVtaXh1aV9jb3B5SWNvbiB7XG4gIG1hcmdpbi1yaWdodDogNXB4O1xufVxuLnJlbWl4dWlfbG9nIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgbWFyZ2luLWJvdHRvbTogNSU7XG4gIG92ZXJmbG93OiB2aXNpYmxlO1xufVxuLnJlbWl4dWlfa2V5IHtcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gIHdpZHRoOiAxMDAlO1xufVxuLnJlbWl4dWlfdmFsdWUge1xuICBkaXNwbGF5OiBmbGV4O1xuICB3aWR0aDogMTAwJTtcbiAgbWFyZ2luLXRvcDogMS41JTtcbn1cbi5yZW1peHVpX3F1ZXN0aW9uTWFyayB7XG4gIG1hcmdpbi1sZWZ0OiAyJTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLnJlbWl4dWlfcXVlc3Rpb25NYXJrOmhvdmVyIHtcbn1cbi5yZW1peHVpX2RldGFpbHNKU09OIHtcbiAgcGFkZGluZzogOHB4IDA7XG4gIGJvcmRlcjogbm9uZTtcbn1cbi5yZW1peHVpX2ljb25idG4ge1xuICBtYXJnaW4tcmlnaHQ6IDAuM2VtO1xufVxuLnJlbWl4dWlfZXJyb3JCbG9icyB7XG4gIHBhZGRpbmctbGVmdDogNXB4O1xuICBwYWRkaW5nLXJpZ2h0OiA1cHg7XG4gIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG59XG4ucmVtaXh1aV9zdG9yYWdlTG9nbyB7XG4gIHdpZHRoOiAyMHB4O1xuICBoZWlnaHQ6IDIwcHg7XG59XG4ucmVtaXh1aV9zcGlubmluZ0ljb24ge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgYW5pbWF0aW9uOiBzcGluIDJzIGluZmluaXRlIGxpbmVhcjtcbiAgLW1vei1hbmltYXRpb246IHNwaW4gMnMgaW5maW5pdGUgbGluZWFyO1xuICAtby1hbmltYXRpb246IHNwaW4gMnMgaW5maW5pdGUgbGluZWFyO1xuICAtd2Via2l0LWFuaW1hdGlvbjogc3BpbiAycyBpbmZpbml0ZSBsaW5lYXI7XG59XG5cbi5yZW1peHVpX3NvbGlkaXR5Q29tcGlsZUFuZFJ1bkJ1dHRvbiB7XG4gIHdpZHRoOiA5NCU7ICBcbn1cblxuQGtleWZyYW1lcyBzcGluIHtcbiAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxufVxuQC13ZWJraXQta2V5ZnJhbWVzIHNwaW4ge1xuICAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9XG4gIDEwMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9XG59XG5ALW1vei1rZXlmcmFtZXMgc3BpbiB7XG4gIDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cbiAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbn1cbkAtby1rZXlmcmFtZXMgc3BpbiB7XG4gICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxufVxuQC1tcy1rZXlmcmFtZXMgc3BpbiB7XG4gIDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cbiAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbn1cblxuLnJlbWl4dWlfYm91bmNpbmdJY29uIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIC1tb3otYW5pbWF0aW9uOiBib3VuY2UgMnMgaW5maW5pdGUgbGluZWFyO1xuICAtby1hbmltYXRpb246IGJvdW5jZSAycyBpbmZpbml0ZSBsaW5lYXI7XG4gIC13ZWJraXQtYW5pbWF0aW9uOiBib3VuY2UgMnMgaW5maW5pdGUgbGluZWFyO1xuICBhbmltYXRpb246IGJvdW5jZSAycyBpbmZpbml0ZSBsaW5lYXI7XG59IFxuXG5ALXdlYmtpdC1rZXlmcmFtZXMgYm91bmNlIHtcbiAgICAwJSB7IHRvcDogMDsgfVxuICAgIDUwJSB7IHRvcDogLTAuMmVtOyB9XG4gICAgNzAlIHsgdG9wOiAtMC4zZW07IH1cbiAgICAxMDAlIHsgdG9wOiAwOyB9XG59XG5ALW1vei1rZXlmcmFtZXMgYm91bmNlIHtcbiAgICAwJSB7IHRvcDogMDsgfVxuICAgIDUwJSB7IHRvcDogLTAuMmVtOyB9XG4gICAgNzAlIHsgdG9wOiAtMC4zZW07IH1cbiAgICAxMDAlIHsgdG9wOiAwOyB9XG59XG5ALW8ta2V5ZnJhbWVzIGJvdW5jZSB7XG4gICAgMCUgeyB0b3A6IDA7IH1cbiAgICA1MCUgeyB0b3A6IC0wLjJlbTsgfVxuICAgIDcwJSB7IHRvcDogLTAuM2VtOyB9XG4gICAgMTAwJSB7IHRvcDogMDsgfVxufVxuQC1tcy1rZXlmcmFtZXMgYm91bmNlIHtcbiAgICAwJSB7IHRvcDogMDsgfVxuICAgIDUwJSB7IHRvcDogLTAuMmVtOyB9XG4gICAgNzAlIHsgdG9wOiAtMC4zZW07IH1cbiAgICAxMDAlIHsgdG9wOiAwOyB9XG59XG5Aa2V5ZnJhbWVzIGJvdW5jZSB7XG4gICAgMCUgeyB0b3A6IDA7IH1cbiAgICA1MCUgeyB0b3A6IC0wLjJlbTsgfVxuICAgIDcwJSB7IHRvcDogLTAuM2VtOyB9XG4gICAgMTAwJSB7IHRvcDogMDsgfVxufVxuIl19 */", '', '']]

/***/ }),
/* 2511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ContractSelection = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _publishToStorage = __webpack_require__(1440);

var _treeView = __webpack_require__(1187);

var _clipboard = __webpack_require__(1154);

__webpack_require__(1367);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const ContractSelection = props => {
  const {
    api,
    contractsDetails,
    contractList,
    modal
  } = props;
  const [selectedContract, setSelectedContract] = (0, _react.useState)('');
  const [storage, setStorage] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    if (contractList.length) setSelectedContract(contractList[0].name);
  }, [contractList]);

  const resetStorage = () => {
    setStorage('');
  };

  const handleContractChange = contractName => {
    setSelectedContract(contractName);
  };

  const handlePublishToStorage = type => {
    setStorage(type);
  };

  const copyABI = () => {
    return copyContractProperty('abi');
  };

  const copyContractProperty = property => {
    let content = getContractProperty(property);

    if (!content) {
      return;
    }

    try {
      if (typeof content !== 'string') {
        content = JSON.stringify(content, null, '\t');
      }
    } catch (e) {}

    return content;
  };

  const getContractProperty = property => {
    if (!selectedContract) throw new Error('No contract compiled yet');
    const contractProperties = contractsDetails[selectedContract];
    if (contractProperties && contractProperties[property]) return contractProperties[property];
    return null;
  };

  const renderData = (item, key, keyPath) => {
    const data = extractData(item);
    const children = (data.children || []).map(child => renderData(child.value, child.key, keyPath + '/' + child.key));

    if (children && children.length > 0) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: `treeViewItem${key}`,
        label: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex mt-2 flex-row remixui_label_item",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            className: "small font-weight-bold pr-1 remixui_label_key",
            children: [key, ":"]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "m-0 remixui_label_value",
            children: typeof data.self === 'boolean' ? `${data.self}` : data.self
          })]
        }),
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
          id: `treeView${key}`,
          children: children
        }, keyPath)
      }, keyPath);
    } else {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: key.toString(),
        label: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex mt-2 flex-row remixui_label_item",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            className: "small font-weight-bold pr-1 remixui_label_key",
            children: [key, ":"]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "m-0 remixui_label_value",
            children: typeof data.self === 'boolean' ? `${data.self}` : data.self
          })]
        })
      }, keyPath);
    }
  };

  const extractData = item => {
    const ret = {
      children: null,
      self: null
    };

    if (item instanceof Array) {
      ret.children = item.map((item, index) => ({
        key: index,
        value: item
      }));
      ret.self = '';
    } else if (item instanceof Object) {
      ret.children = Object.keys(item).map(key => ({
        key: key,
        value: item[key]
      }));
      ret.self = '';
    } else {
      ret.self = item;
      ret.children = [];
    }

    return ret;
  };

  const insertValue = (details, propertyName) => {
    let node;

    if (propertyName === 'web3Deploy' || propertyName === 'name' || propertyName === 'Assembly') {
      node = /*#__PURE__*/(0, _jsxRuntime.jsx)("pre", {
        children: details[propertyName]
      });
    } else if (details[propertyName] && (propertyName === 'abi' || propertyName === 'metadata')) {
      if (details[propertyName] !== '') {
        try {
          node = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            children: typeof details[propertyName] === 'object' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
              id: "treeView",
              children: Object.keys(details[propertyName]).map(innerkey => renderData(details[propertyName][innerkey], innerkey, innerkey))
            }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
              id: "treeView",
              children: Object.keys(JSON.parse(details[propertyName])).map(innerkey => renderData(JSON.parse(details[propertyName])[innerkey], innerkey, innerkey))
            })
          }); // catch in case the parsing fails.
        } catch (e) {
          node = /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            children: ["Unable to display \"$", propertyName, "\": $", e.message]
          });
        }
      } else {
        node = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          children: " - "
        });
      }
    } else {
      node = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: JSON.stringify(details[propertyName], null, 4)
      });
    }

    return /*#__PURE__*/(0, _jsxRuntime.jsx)("pre", {
      className: "remixui_value",
      children: node || ''
    });
  };

  const details = () => {
    if (!selectedContract) throw new Error('No contract compiled yet');
    const help = {
      Assembly: 'Assembly opcodes describing the contract including corresponding solidity source code',
      Opcodes: 'Assembly opcodes describing the contract',
      'Runtime Bytecode': 'Bytecode storing the state and being executed during normal contract call',
      bytecode: 'Bytecode being executed during contract creation',
      functionHashes: 'List of declared function and their corresponding hash',
      gasEstimates: 'Gas estimation for each function call',
      metadata: 'Contains all informations related to the compilation',
      metadataHash: 'Hash representing all metadata information',
      abi: 'ABI: describing all the functions (input/output params, scope, ...)',
      name: 'Name of the compiled contract',
      swarmLocation: 'Swarm url where all metadata information can be found (contract needs to be published first)',
      web3Deploy: 'Copy/paste this code to any JavaScript/Web3 console to deploy this contract'
    };
    const contractProperties = contractsDetails[selectedContract] || {};
    const log = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "remixui_detailsJSON",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
        children: Object.keys(contractProperties).map((propertyName, index) => {
          const copyDetails = /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "remixui_copyDetails",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
              content: contractProperties[propertyName],
              direction: "top"
            })
          });
          const questionMark = /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "remixui_questionMark",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              title: help[propertyName],
              className: "fas fa-question-circle",
              "aria-hidden": "true"
            })
          });
          return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "remixui_log",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
              label: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                "data-id": `remixui_treeviewitem_${propertyName}`,
                className: "remixui_key",
                children: [propertyName, " ", copyDetails, " ", questionMark]
              }),
              children: insertValue(contractProperties, propertyName)
            })
          }, index);
        })
      })
    });
    modal(selectedContract, log, 'Close', null);
  };

  const copyBytecode = () => {
    return copyContractProperty('bytecode');
  };

  return (
    /*#__PURE__*/
    // define swarm logo
    (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [contractList.length ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("section", {
        className: "remixui_compilerSection pt-3",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mb-3",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "remixui_compilerLabel form-check-label",
            htmlFor: "compiledContracts",
            children: "Contract"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("select", {
            onChange: e => handleContractChange(e.target.value),
            value: selectedContract,
            "data-id": "compiledContracts",
            id: "compiledContracts",
            className: "custom-select",
            children: contractList.map(({
              name,
              file
            }, index) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("option", {
              value: name,
              children: [name, " (", file, ")"]
            }, index))
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("article", {
          className: "mt-2 pb-0",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
            id: "publishOnIpfs",
            className: "btn btn-secondary btn-block",
            title: "Publish on Ipfs",
            onClick: () => {
              handlePublishToStorage('ipfs');
            },
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "Publish on Ipfs"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
              id: "ipfsLogo",
              className: "remixui_storageLogo ml-2",
              src: "assets/img/ipfs.webp"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
            id: "publishOnSwarm",
            className: "btn btn-secondary btn-block",
            title: "Publish on Swarm",
            onClick: () => {
              handlePublishToStorage('swarm');
            },
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "Publish on Swarm"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
              id: "swarmLogo",
              className: "remixui_storageLogo ml-2",
              src: "assets/img/swarm.webp"
            })]
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            "data-id": "compilation-details",
            className: "btn btn-secondary btn-block",
            title: "Display Contract Details",
            onClick: () => {
              details();
            },
            children: "Compilation Details"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "remixui_contractHelperButtons",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "input-group",
              children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "btn-group",
                role: "group",
                "aria-label": "Copy to Clipboard",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
                  title: "Copy ABI to clipboard",
                  getContent: copyABI,
                  direction: "top",
                  children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
                    className: "btn remixui_copyButton",
                    title: "Copy ABI to clipboard",
                    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                      className: "remixui_copyIcon far fa-copy",
                      "aria-hidden": "true"
                    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                      children: "ABI"
                    })]
                  })
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
                  title: "Copy ABI to clipboard",
                  getContent: copyBytecode,
                  direction: "top",
                  children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
                    className: "btn remixui_copyButton",
                    title: "Copy Bytecode to clipboard",
                    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                      className: "remixui_copyIcon far fa-copy",
                      "aria-hidden": "true"
                    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                      children: "Bytecode"
                    })]
                  })
                })]
              })
            })
          })]
        })]
      }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("section", {
        className: "remixui_container clearfix",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("article", {
          className: "px-2 mt-2 pb-0 d-flex w-100",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "mt-2 mx-3 w-100 alert alert-warning",
            role: "alert",
            children: "No Contract Compiled Yet"
          })
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_publishToStorage.PublishToStorage, {
        api: api,
        storage: storage,
        contract: contractsDetails[selectedContract],
        resetStorage: resetStorage
      })]
    })
  );
};

exports.ContractSelection = ContractSelection;
var _default = ContractSelection;
exports.default = _default;

/***/ }),
/* 2512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Renderer = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _remixSolidity = __webpack_require__(1149);

__webpack_require__(2513);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//eslint-disable-line
const Renderer = ({
  message,
  opt: _opt = {},
  plugin
}) => {
  const [messageText, setMessageText] = (0, _react.useState)(null);
  const [editorOptions, setEditorOptions] = (0, _react.useState)({
    useSpan: false,
    type: '',
    errFile: ''
  });
  const [classList, setClassList] = (0, _react.useState)(_opt.type === 'error' ? 'alert alert-danger' : 'alert alert-warning');
  const [close, setClose] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    if (!message) return;
    let text;

    if (typeof message === 'string') {
      text = message;
    } else if (message.innerText) {
      text = message.innerText;
    } // ^ e.g:
    // browser/gm.sol: Warning: Source file does not specify required compiler version! Consider adding "pragma solidity ^0.6.12
    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.2.0/contracts/introspection/IERC1820Registry.sol:3:1: ParserError: Source file requires different compiler version (current compiler is 0.7.4+commit.3f05b770.Emscripten.clang) - note that nightly builds are considered to be strictly less than the released version


    const positionDetails = _remixSolidity.helper.getPositionDetails(text);

    _opt.errLine = positionDetails.errLine;
    _opt.errCol = positionDetails.errCol;
    _opt.errFile = positionDetails.errFile ? positionDetails.errFile.trim() : '';
    setMessageText(text);
    setEditorOptions(_opt);
    setClose(false);
    setClassList(_opt.type === 'error' ? 'alert alert-danger' : 'alert alert-warning');
  }, [message, _opt]);

  const handleErrorClick = opt => {
    if (opt.click) {
      opt.click(message);
    } else if (opt.errFile !== undefined && opt.errLine !== undefined && opt.errCol !== undefined) {
      _errorClick(opt.errFile, opt.errLine, opt.errCol);
    }
  };

  const handleClose = () => {
    setClose(true);
  };

  const _errorClick = async (errFile, errLine, errCol) => {
    if (errFile !== (await plugin.call('config', 'getAppParameter', 'currentFile'))) {
      // TODO: refactor with this._components.contextView.jumpTo
      if (await plugin.call('fileManager', 'exists', errFile)) {
        await plugin.call('fileManager', 'open', errFile);
        await plugin.call('editor', 'gotoLine', errLine, errCol);
      }
    } else {
      await plugin.call('editor', 'gotoLine', errLine, errCol);
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
    children: messageText && !close && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: `remixui_sol ${editorOptions.type} ${classList}`,
      "data-id": editorOptions.errFile,
      onClick: () => handleErrorClick(editorOptions),
      children: [editorOptions.useSpan ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        children: [" ", messageText, " "]
      }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("pre", {
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: messageText
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "close",
        "data-id": "renderer",
        onClick: handleClose,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "fas fa-times"
        })
      })]
    })
  });
};

exports.Renderer = Renderer;

/***/ }),
/* 2513 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2514);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2514 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_sol.success,\n.remixui_sol.error,\n.remixui_sol.warning {\n    white-space: pre-line;\n    word-wrap: break-word;\n    cursor: pointer;\n    position: relative;\n    margin: 0.5em 0 1em 0;\n    border-radius: 5px;\n    line-height: 20px;\n    padding: 8px 15px;\n}\n\n.remixui_sol.success pre,\n.remixui_sol.error pre,\n.remixui_sol.warning pre {\n    white-space: pre-line;\n    overflow-y: hidden;\n    background-color: transparent;\n    margin: 0;\n    font-size: 12px;\n    border: 0 none;\n    padding: 0;\n    border-radius: 0;\n}\n\n.remixui_sol.success .close,\n.remixui_sol.error .close,\n.remixui_sol.warning .close {\n    visibility: hidden;\n    white-space: pre-line;\n    font-weight: bold;\n    position: absolute;\n    color: hsl(0, 0%, 0%); /* black in style-guide.js */\n    top: 0;\n    right: 0;\n    padding: 0.5em;\n}\n\n.remixui_sol.error {\n}\n\n.remixui_sol.warning {\n}\n\n.remixui_sol.success {\n  /* background-color:  // styles.rightPanel.message_Success_BackgroundColor; */\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbmRlcmVyLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0lBR0kscUJBQXFCO0lBQ3JCLHFCQUFxQjtJQUNyQixlQUFlO0lBQ2Ysa0JBQWtCO0lBQ2xCLHFCQUFxQjtJQUNyQixrQkFBa0I7SUFDbEIsaUJBQWlCO0lBQ2pCLGlCQUFpQjtBQUNyQjs7QUFFQTs7O0lBR0kscUJBQXFCO0lBQ3JCLGtCQUFrQjtJQUNsQiw2QkFBNkI7SUFDN0IsU0FBUztJQUNULGVBQWU7SUFDZixjQUFjO0lBQ2QsVUFBVTtJQUNWLGdCQUFnQjtBQUNwQjs7QUFFQTs7O0lBR0ksa0JBQWtCO0lBQ2xCLHFCQUFxQjtJQUNyQixpQkFBaUI7SUFDakIsa0JBQWtCO0lBQ2xCLHFCQUFxQixFQUFFLDRCQUE0QjtJQUNuRCxNQUFNO0lBQ04sUUFBUTtJQUNSLGNBQWM7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0VBQ0UsNkVBQTZFO0FBQy9FIiwiZmlsZSI6InJlbmRlcmVyLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5yZW1peHVpX3NvbC5zdWNjZXNzLFxuLnJlbWl4dWlfc29sLmVycm9yLFxuLnJlbWl4dWlfc29sLndhcm5pbmcge1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtbGluZTtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBtYXJnaW46IDAuNWVtIDAgMWVtIDA7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIHBhZGRpbmc6IDhweCAxNXB4O1xufVxuXG4ucmVtaXh1aV9zb2wuc3VjY2VzcyBwcmUsXG4ucmVtaXh1aV9zb2wuZXJyb3IgcHJlLFxuLnJlbWl4dWlfc29sLndhcm5pbmcgcHJlIHtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLWxpbmU7XG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIG1hcmdpbjogMDtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgYm9yZGVyOiAwIG5vbmU7XG4gICAgcGFkZGluZzogMDtcbiAgICBib3JkZXItcmFkaXVzOiAwO1xufVxuXG4ucmVtaXh1aV9zb2wuc3VjY2VzcyAuY2xvc2UsXG4ucmVtaXh1aV9zb2wuZXJyb3IgLmNsb3NlLFxuLnJlbWl4dWlfc29sLndhcm5pbmcgLmNsb3NlIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IHByZS1saW5lO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBjb2xvcjogaHNsKDAsIDAlLCAwJSk7IC8qIGJsYWNrIGluIHN0eWxlLWd1aWRlLmpzICovXG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIHBhZGRpbmc6IDAuNWVtO1xufVxuXG4ucmVtaXh1aV9zb2wuZXJyb3Ige1xufVxuXG4ucmVtaXh1aV9zb2wud2FybmluZyB7XG59XG5cbi5yZW1peHVpX3NvbC5zdWNjZXNzIHtcbiAgLyogYmFja2dyb3VuZC1jb2xvcjogIC8vIHN0eWxlcy5yaWdodFBhbmVsLm1lc3NhZ2VfU3VjY2Vzc19CYWNrZ3JvdW5kQ29sb3I7ICovXG59XG4iXX0= */", '', '']]

/***/ }),
/* 2515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compileTabLogic = __webpack_require__(2516);

Object.keys(_compileTabLogic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _compileTabLogic[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _compileTabLogic[key];
    }
  });
});

var _contractParser = __webpack_require__(2517);

Object.keys(_contractParser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _contractParser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _contractParser[key];
    }
  });
});

/***/ }),
/* 2516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompileTabLogic = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _remixSolidity = __webpack_require__(1149);

var _events = __webpack_require__(40);

const _paq = window._paq = window._paq || []; //eslint-disable-line


class CompileTabLogic {
  constructor(api, contentImport) {
    this.api = api;
    this.contentImport = contentImport;
    (0, _defineProperty2.default)(this, "compiler", void 0);
    (0, _defineProperty2.default)(this, "optimize", void 0);
    (0, _defineProperty2.default)(this, "runs", void 0);
    (0, _defineProperty2.default)(this, "evmVersion", void 0);
    (0, _defineProperty2.default)(this, "language", void 0);
    (0, _defineProperty2.default)(this, "compilerImport", void 0);
    (0, _defineProperty2.default)(this, "event", void 0);
    (0, _defineProperty2.default)(this, "evmVersions", void 0);
    (0, _defineProperty2.default)(this, "useFileConfiguration", void 0);
    (0, _defineProperty2.default)(this, "configFilePath", void 0);
    this.event = new _events.EventEmitter();
    this.compiler = new _remixSolidity.Compiler((url, cb) => api.resolveContentAndSave(url).then(result => cb(null, result)).catch(error => cb(error.message)));
    this.evmVersions = ['default', 'berlin', 'london', 'istanbul', 'petersburg', 'constantinople', 'byzantium', 'spuriousDragon', 'tangerineWhistle', 'homestead'];
  }

  init() {
    this.optimize = this.api.getCompilerParameters().optimize;
    this.api.setCompilerParameters({
      optimize: this.optimize
    });
    this.compiler.set('optimize', this.optimize);
    this.runs = this.api.getCompilerParameters().runs;
    this.runs = this.runs && this.runs !== 'undefined' ? this.runs : 200;
    this.api.setCompilerParameters({
      runs: this.runs
    });
    this.compiler.set('runs', this.runs);
    this.evmVersion = this.api.getCompilerParameters().evmVersion;

    if (this.evmVersion === 'undefined' || this.evmVersion === 'null' || !this.evmVersion || !this.evmVersions.includes(this.evmVersion)) {
      this.evmVersion = null;
    }

    this.api.setCompilerParameters({
      evmVersion: this.evmVersion
    });
    this.compiler.set('evmVersion', this.evmVersion);
    this.language = (0, _remixSolidity.getValidLanguage)(this.api.getCompilerParameters().language);

    if (this.language != null) {
      this.compiler.set('language', this.language);
    }
  }

  setOptimize(newOptimizeValue) {
    this.optimize = newOptimizeValue;
    this.api.setCompilerParameters({
      optimize: this.optimize
    });
    this.compiler.set('optimize', this.optimize);
  }

  setUseFileConfiguration(useFileConfiguration) {
    this.useFileConfiguration = useFileConfiguration;
    this.compiler.set('useFileConfiguration', useFileConfiguration);
  }

  setConfigFilePath(path) {
    this.configFilePath = path;
  }

  setRuns(runs) {
    this.runs = runs;
    this.api.setCompilerParameters({
      runs: this.runs
    });
    this.compiler.set('runs', this.runs);
  }

  setEvmVersion(newEvmVersion) {
    this.evmVersion = newEvmVersion;
    this.api.setCompilerParameters({
      evmVersion: this.evmVersion
    });
    this.compiler.set('evmVersion', this.evmVersion);
  }

  getCompilerState() {
    return this.compiler.state;
  }
  /**
   * Set the compiler to using Solidity or Yul (default to Solidity)
   * @params lang {'Solidity' | 'Yul'} ...
   */


  setLanguage(lang) {
    this.language = lang;
    this.api.setCompilerParameters({
      language: lang
    });
    this.compiler.set('language', lang);
  }
  /**
   * Compile a specific file of the file manager
   * @param {string} target the path to the file to compile
   */


  compileFile(target) {
    if (!target) throw new Error('No target provided for compiliation');
    return new Promise((resolve, reject) => {
      this.api.readFile(target).then(content => {
        const sources = {
          [target]: {
            content
          }
        };
        this.event.emit('removeAnnotations');
        this.event.emit('startingCompilation');

        if (this.configFilePath) {
          this.api.readFile(this.configFilePath).then(contentConfig => {
            this.compiler.set('configFileContent', contentConfig);
          });
        } // setTimeout fix the animation on chrome... (animation triggered by 'staringCompilation')


        setTimeout(() => {
          this.compiler.compile(sources, target);
          resolve(true);
        }, 100);
      }).catch(error => {
        reject(error);
      });
    });
  }

  async isHardhatProject() {
    if (this.api.getFileManagerMode() === 'localhost') {
      return (await this.api.fileExists('hardhat.config.js')) || (await this.api.fileExists('hardhat.config.ts'));
    } else return false;
  }

  async isTruffleProject() {
    if (this.api.getFileManagerMode() === 'localhost') {
      return await this.api.fileExists('truffle-config.js');
    } else return false;
  }

  async isFoundryProject() {
    if (this.api.getFileManagerMode() === 'localhost') {
      return await this.api.fileExists('foundry.toml');
    } else return false;
  }

  runCompiler(externalCompType) {
    try {
      if (this.api.getFileManagerMode() === 'localhost') {
        if (externalCompType === 'hardhat') {
          const {
            currentVersion,
            optimize,
            runs
          } = this.compiler.state;

          if (currentVersion) {
            const fileContent = `module.exports = {
              solidity: '${currentVersion.substring(0, currentVersion.indexOf('+commit'))}',
              settings: {
                optimizer: {
                  enabled: ${optimize},
                  runs: ${runs}
                }
              }
            }
            `;
            const configFilePath = 'remix-compiler.config.js';
            this.api.writeFile(configFilePath, fileContent);

            _paq.push(['trackEvent', 'compiler', 'compileWithHardhat']);

            this.api.compileWithHardhat(configFilePath).then(result => {
              this.api.logToTerminal({
                type: 'info',
                value: result
              });
            }).catch(error => {
              this.api.logToTerminal({
                type: 'error',
                value: error
              });
            });
          }
        } else if (externalCompType === 'truffle') {
          const {
            currentVersion,
            optimize,
            runs,
            evmVersion
          } = this.compiler.state;

          if (currentVersion) {
            const fileContent = `module.exports = {
              compilers: {
                solc: {
                  version: '${currentVersion.substring(0, currentVersion.indexOf('+commit'))}',
                  settings: {
                    optimizer: {
                      enabled: ${optimize},
                      runs: ${runs},
                    },
                    evmVersion: ${evmVersion}
                  }
                }
              }
            }`;
            const configFilePath = 'remix-compiler.config.js';
            this.api.writeFile(configFilePath, fileContent);

            _paq.push(['trackEvent', 'compiler', 'compileWithTruffle']);

            this.api.compileWithTruffle(configFilePath).then(result => {
              this.api.logToTerminal({
                type: 'info',
                value: result
              });
            }).catch(error => {
              this.api.logToTerminal({
                type: 'error',
                value: error
              });
            });
          }
        }
      } // TODO readd saving current file


      this.api.saveCurrentFile();
      const currentFile = this.api.currentFile;
      return this.compileFile(currentFile);
    } catch (err) {
      console.error(err);
    }
  }

}

exports.CompileTabLogic = CompileTabLogic;

/***/ }),
/* 2517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseContracts = parseContracts;

var solcTranslate = _interopRequireWildcard(__webpack_require__(1409));

var _remixLib = __webpack_require__(311);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const txHelper = _remixLib.execution.txHelper;

function parseContracts(contractName, contract, source) {
  const detail = {};
  detail.name = contractName;
  detail.metadata = contract.metadata;

  if (contract.evm.bytecode.object) {
    detail.bytecode = contract.evm.bytecode.object;
  }

  detail.abi = contract.abi;
  detail.storageLayout = contract.storageLayout;

  if (contract.evm.bytecode.object) {
    detail.bytecode = contract.evm.bytecode;
    detail.web3Deploy = gethDeploy(contractName.toLowerCase(), contract.abi, contract.evm.bytecode.object);
    detail.metadataHash = retrieveMetadataHash(contract.evm.bytecode.object);

    if (detail.metadataHash) {
      detail.swarmLocation = 'bzzr://' + detail.metadataHash;
    }
  }

  detail.functionHashes = {};

  for (const fun in contract.evm.methodIdentifiers) {
    detail.functionHashes[contract.evm.methodIdentifiers[fun]] = fun;
  }

  detail.gasEstimates = formatGasEstimates(contract.evm.gasEstimates);
  detail.devdoc = contract.devdoc;
  detail.userdoc = contract.userdoc;

  if (contract.evm.deployedBytecode && contract.evm.deployedBytecode.object.length > 0) {
    detail['Runtime Bytecode'] = contract.evm.deployedBytecode;
  }

  if (source && contract.assembly !== null) {
    detail.Assembly = solcTranslate.prettyPrintLegacyAssemblyJSON(contract.evm.legacyAssembly, source.content);
  }

  return detail;
}

const retrieveMetadataHash = function retrieveMetadataHash(bytecode) {
  let match = /a165627a7a72305820([0-9a-f]{64})0029$/.exec(bytecode);

  if (!match) {
    match = /a265627a7a72305820([0-9a-f]{64})6c6578706572696d656e74616cf50037$/.exec(bytecode);
  }

  if (match) {
    return match[1];
  }
};

const gethDeploy = function gethDeploy(contractName, jsonInterface, bytecode) {
  let code = '';
  const funABI = txHelper.getConstructorInterface(jsonInterface);
  funABI.inputs.forEach(function (inp) {
    code += 'var ' + inp.name + ' = /* var of type ' + inp.type + ' here */ ;\n';
  });
  contractName = contractName.replace(/[:./]/g, '_');
  code += 'var ' + contractName + 'Contract = new web3.eth.Contract(' + JSON.stringify(jsonInterface).replace('\n', '') + ');' + '\nvar ' + contractName + ' = ' + contractName + 'Contract.deploy({' + "\n     data: '0x" + bytecode + "', " + '\n     arguments: [';
  funABI.inputs.forEach(function (inp) {
    code += '\n          ' + inp.name + ',';
  });
  code += '\n     ]' + '\n}).send({' + '\n     from: web3.eth.accounts[0], ' + "\n     gas: '4700000'" + '\n   }, function (e, contract){' + '\n    console.log(e, contract);' + "\n    if (typeof contract.address !== 'undefined') {" + "\n         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);" + '\n    }' + '\n })';
  return code;
};

const formatGasEstimates = function formatGasEstimates(data) {
  if (!data) return {};
  if (data.creation === undefined && data.external === undefined && data.internal === undefined) return {};

  const gasToText = function gasToText(g) {
    return g === null ? 'unknown' : g;
  };

  const ret = {};
  let fun;

  if ('creation' in data) {
    ret.Creation = data.creation;
  }

  if ('external' in data) {
    ret.External = {};

    for (fun in data.external) {
      ret.External[fun] = gasToText(data.external[fun]);
    }
  }

  if ('internal' in data) {
    ret.Internal = {};

    for (fun in data.internal) {
      ret.Internal[fun] = gasToText(data.internal[fun]);
    }
  }

  return ret;
};

/***/ }),
/* 2518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _compilerApi = __webpack_require__(2519);

Object.keys(_compilerApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _compilerApi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _compilerApi[key];
    }
  });
});

/***/ }),
/* 2519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerApiMixin = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _remixSolidity = __webpack_require__(1149);

var _solidityCompiler = __webpack_require__(1589);

const CompilerApiMixin = Base => class extends Base {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "currentFile", void 0);
    (0, _defineProperty2.default)(this, "compilationDetails", void 0);
    (0, _defineProperty2.default)(this, "compileErrors", void 0);
    (0, _defineProperty2.default)(this, "compileTabLogic", void 0);
    (0, _defineProperty2.default)(this, "configurationSettings", void 0);
    (0, _defineProperty2.default)(this, "onCurrentFileChanged", void 0);
    (0, _defineProperty2.default)(this, "onSetWorkspace", void 0);
    (0, _defineProperty2.default)(this, "onFileRemoved", void 0);
    (0, _defineProperty2.default)(this, "onNoFileSelected", void 0);
    (0, _defineProperty2.default)(this, "onCompilationFinished", void 0);
    (0, _defineProperty2.default)(this, "onSessionSwitched", void 0);
    (0, _defineProperty2.default)(this, "onContentChanged", void 0);
    (0, _defineProperty2.default)(this, "onFileClosed", void 0);
    (0, _defineProperty2.default)(this, "statusChanged", void 0);
  }

  initCompilerApi() {
    this.configurationSettings = null;
    this._view = {
      warnCompilationSlow: null,
      errorContainer: null,
      contractEl: null
    };
    this.compilationDetails = {
      contractsDetails: {},
      contractMap: {}
    };
    this.data = {
      eventHandlers: {},
      loading: false
    };
    this.compileErrors = {};
    this.compiledFileName = '';
    this.currentFile = '';
  }

  onActivation() {
    this.listenToEvents();
  }

  onDeactivation() {
    this.off('editor', 'contentChanged');

    if (this.data.eventHandlers.onLoadingCompiler) {
      this.compiler.event.unregister('loadingCompiler', this.data.eventHandlers.onLoadingCompiler);
    }

    if (this.data.eventHandlers.onCompilerLoaded) {
      this.compiler.event.unregister('compilerLoaded', this.data.eventHandlers.onCompilerLoaded);
    }

    if (this.data.eventHandlers.onCompilationFinished) {
      this.compiler.event.unregister('compilationFinished', this.data.eventHandlers.onCompilationFinished);
    }

    this.off('filePanel', 'setWorkspace');
    this.off('remixd', 'rootFolderChanged');
    this.off('editor', 'sessionSwitched');

    if (this.data.eventHandlers.onStartingCompilation) {
      this.compileTabLogic.event.off('startingCompilation', this.data.eventHandlers.onStartingCompilation);
    }

    if (this.data.eventHandlers.onRemoveAnnotations) {
      this.compileTabLogic.event.off('removeAnnotations', this.data.eventHandlers.onRemoveAnnotations);
    }

    this.off('fileManager', 'currentFileChanged');
    this.off('fileManager', 'noFileSelected');
    this.off('themeModule', 'themeChanged');

    if (this.data.eventHandlers.onKeyDown) {
      window.document.removeEventListener('keydown', this.data.eventHandlers.onKeyDown);
    }
  }

  resolveContentAndSave(url) {
    return this.call('contentImport', 'resolveAndSave', url);
  }

  runScriptAfterCompilation(fileName) {
    this.call('compileAndRun', 'runScriptAfterCompilation', fileName);
  }

  compileWithHardhat(configFile) {
    return this.call('hardhat', 'compile', configFile);
  }

  compileWithTruffle(configFile) {
    return this.call('truffle', 'compile', configFile);
  }

  logToTerminal(content) {
    return this.call('terminal', 'log', content);
  }

  getCompilationResult() {
    return this.compileTabLogic.compiler.state.lastCompilationResult;
  }

  getCompilerState() {
    return this.compileTabLogic.getCompilerState();
  }
  /**
   * compile using @arg fileName.
   * The module UI will be updated accordingly to the new compilation result.
   * This function is used by remix-plugin compiler API.
   * @param {string} fileName to compile
   */


  compile(fileName) {
    this.currentFile = fileName;
    return this.compileTabLogic.compileFile(fileName);
  }

  compileFile(event) {
    if (event.path.length > 0) {
      this.currentFile = event.path[0];
      this.compileTabLogic.compileFile(event.path[0]);
    }
  }
  /**
   * compile using @arg compilationTargets and @arg settings
   * The module UI will *not* be updated, the compilation result is returned
   * This function is used by remix-plugin compiler API.
   * @param {object} map of source files.
   * @param {object} settings {evmVersion, optimize, runs, version, language}
   */


  async compileWithParameters(compilationTargets, settings) {
    const compilerState = this.getCompilerState();
    settings.version = settings.version || compilerState.currentVersion;
    const res = await (0, _remixSolidity.compile)(compilationTargets, settings, (url, cb) => this.call('contentImport', 'resolveAndSave', url).then(result => cb(null, result)).catch(error => cb(error.message)));
    return res;
  } // This function is used for passing the compiler configuration to 'remix-tests'


  getCurrentCompilerConfig() {
    const compilerState = this.getCompilerState();
    const compilerDetails = {
      currentVersion: compilerState.currentVersion,
      evmVersion: compilerState.evmVersion,
      optimize: compilerState.optimize,
      runs: compilerState.runs
    };

    if (this.data.loading) {
      compilerDetails.currentVersion = this.data.loadingUrl;
      compilerDetails.isUrl = true;
    }

    return compilerDetails;
  }
  /**
   * set the compiler configuration
   * This function is used by remix-plugin compiler API.
   * @param {object} settings {evmVersion, optimize, runs, version, language}
   */


  setCompilerConfig(settings) {
    this.configurationSettings = settings;
  }

  fileExists(fileName) {
    return this.call('fileManager', 'exists', fileName);
  }

  writeFile(fileName, content) {
    return this.call('fileManager', 'writeFile', fileName, content);
  }

  readFile(fileName) {
    return this.call('fileManager', 'readFile', fileName);
  }

  open(fileName) {
    return this.call('fileManager', 'open', fileName);
  }

  saveCurrentFile() {
    return this.call('fileManager', 'saveCurrentFile');
  }

  resetResults() {
    this.currentFile = '';
    this.compilationDetails = {
      contractsDetails: {},
      contractMap: {}
    };
    this.statusChanged({
      key: 'none'
    }); // if (this.onResetResults) this.onResetResults()
  }

  listenToEvents() {
    var _this = this;

    this.on('editor', 'contentChanged', () => {
      this.statusChanged({
        key: 'edited',
        title: 'the content has changed, needs recompilation',
        type: 'info'
      });
      if (this.onContentChanged) this.onContentChanged();
    });

    this.data.eventHandlers.onLoadingCompiler = url => {
      this.data.loading = true;
      this.data.loadingUrl = url;
      this.statusChanged({
        key: 'loading',
        title: 'loading compiler...',
        type: 'info'
      });
    };

    this.compiler.event.register('loadingCompiler', this.data.eventHandlers.onLoadingCompiler);

    this.data.eventHandlers.onCompilerLoaded = () => {
      this.data.loading = false;
      this.statusChanged({
        key: 'none'
      });
    };

    this.compiler.event.register('compilerLoaded', this.data.eventHandlers.onCompilerLoaded);

    this.data.eventHandlers.onStartingCompilation = () => {
      this.statusChanged({
        key: 'loading',
        title: 'compiling...',
        type: 'info'
      });
    };

    this.data.eventHandlers.onRemoveAnnotations = () => {
      this.call('editor', 'clearAnnotations');
    };

    this.on('filePanel', 'setWorkspace', workspace => {
      this.resetResults();
      if (this.onSetWorkspace) this.onSetWorkspace(workspace.isLocalhost, workspace.name);
    });
    this.on('fileManager', 'fileRemoved', path => {
      if (this.onFileRemoved) this.onFileRemoved(path);
    });
    this.on('remixd', 'rootFolderChanged', () => {
      this.resetResults();
      if (this.onSetWorkspace) this.onSetWorkspace(true, 'localhost');
    });
    this.on('editor', 'sessionSwitched', () => {
      if (this.onSessionSwitched) this.onSessionSwitched();
    });
    this.compileTabLogic.event.on('startingCompilation', this.data.eventHandlers.onStartingCompilation);
    this.compileTabLogic.event.on('removeAnnotations', this.data.eventHandlers.onRemoveAnnotations);

    this.data.eventHandlers.onCurrentFileChanged = name => {
      this.currentFile = name;
      if (this.onCurrentFileChanged) this.onCurrentFileChanged(name);
    };

    this.on('fileManager', 'currentFileChanged', this.data.eventHandlers.onCurrentFileChanged);

    this.data.eventHandlers.onNoFileSelected = () => {
      this.currentFile = '';
      if (this.onNoFileSelected) this.onNoFileSelected();
    };

    this.on('fileManager', 'noFileSelected', this.data.eventHandlers.onNoFileSelected);

    this.data.eventHandlers.onFileClosed = name => {
      this.onFileClosed(name);
    };

    this.on('fileManager', 'fileClosed', this.data.eventHandlers.onFileClosed);

    this.data.eventHandlers.onCompilationFinished = async function (success, data, source, input, version) {
      _this.compileErrors = data;

      if (success) {
        // forwarding the event to the appManager infra
        _this.emit('compilationFinished', source.target, source, 'soljson', data, input, version);

        if (data.errors && data.errors.length > 0) {
          _this.statusChanged({
            key: data.errors.length,
            title: `compilation finished successful with warning${data.errors.length > 1 ? 's' : ''}`,
            type: 'warning'
          });
        } else _this.statusChanged({
          key: 'succeed',
          title: 'compilation successful',
          type: 'success'
        });
      } else {
        const count = data.errors ? data.errors.filter(error => error.severity === 'error').length : 0 + (data.error ? 1 : 0);

        _this.statusChanged({
          key: count,
          title: `compilation failed with ${count} error${count > 1 ? 's' : ''}`,
          type: 'error'
        });
      } // Store the contracts and Update contract Selection


      if (success) {
        _this.compilationDetails = await _this.visitsContractApi(source, data);
      } else {
        _this.compilationDetails = {
          contractMap: {},
          contractsDetails: {},
          target: source ? source.target : null
        };
      }

      if (_this.onCompilationFinished) _this.onCompilationFinished(_this.compilationDetails); // set annotations

      if (data.errors) {
        for (const error of data.errors) {
          let pos = _remixSolidity.helper.getPositionDetails(error.formattedMessage);

          const file = pos.errFile;

          if (file) {
            pos = {
              row: pos.errLine,
              column: pos.errCol,
              text: error.formattedMessage,
              type: error.severity
            };
            await _this.call('editor', 'addAnnotation', pos, file);
          }
        }
      }
    };

    this.compiler.event.register('compilationFinished', this.data.eventHandlers.onCompilationFinished);

    this.data.eventHandlers.onThemeChanged = theme => {
      const invert = theme.quality === 'dark' ? 1 : 0;
      const img = document.getElementById('swarmLogo');

      if (img) {
        img.style.filter = `invert(${invert})`;
      }
    };

    this.on('themeModule', 'themeChanged', this.data.eventHandlers.onThemeChanged); // Run the compiler instead of trying to save the website

    this.data.eventHandlers.onKeyDown = async function (e) {
      // ctrl+s or command+s
      if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.keyCode === 83 && _this.currentFile !== '') {
        e.preventDefault();

        if (_this.currentFile && (_this.currentFile.endsWith('.sol') || _this.currentFile.endsWith('.yul'))) {
          if (await _this.getAppParameter('hardhat-compilation')) _this.compileTabLogic.runCompiler('hardhat');else if (await _this.getAppParameter('truffle-compilation')) _this.compileTabLogic.runCompiler('truffle');else _this.compileTabLogic.runCompiler(undefined);
        }
      }
    };

    window.document.addEventListener('keydown', this.data.eventHandlers.onKeyDown);
  }

  async visitsContractApi(source, data) {
    return new Promise(resolve => {
      if (!data.contracts || data.contracts && Object.keys(data.contracts).length === 0) {
        return resolve({
          contractMap: {},
          contractsDetails: {},
          target: source.target
        });
      }

      const contractMap = {};
      const contractsDetails = {};
      this.compiler.visitContracts(contract => {
        contractMap[contract.name] = contract;
        contractsDetails[contract.name] = (0, _solidityCompiler.parseContracts)(contract.name, contract.object, this.compiler.getSource(contract.file));
      });
      return resolve({
        contractMap,
        contractsDetails,
        target: source.target
      });
    });
  }

};

exports.CompilerApiMixin = CompilerApiMixin;

/***/ }),
/* 2520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _settings = __webpack_require__(2521);

var _registry = _interopRequireDefault(__webpack_require__(315));

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'settings',
  displayName: 'Settings',
  methods: ['get'],
  events: [],
  icon: 'assets/img/settings.webp',
  description: 'Remix-IDE settings',
  kind: 'settings',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/settings.html',
  version: packageJson.version,
  permission: true
};

module.exports = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(SettingsTab, _ViewPlugin);

  var _super = _createSuper(SettingsTab);

  function SettingsTab(config, editor) {
    var _this;

    (0, _classCallCheck2["default"])(this, SettingsTab);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "config", {});
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "editor", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deps", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "element", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "useMatomoAnalytics", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "dispatch", function () {});
    _this.config = config;
    _this.editor = editor;
    _this._deps = {
      themeModule: _registry["default"].getInstance().get('themeModule').api
    };
    _this.element = document.createElement('div');

    _this.element.setAttribute('id', 'settingsTab');

    _this.useMatomoAnalytics = null;
    return _this;
  }

  (0, _createClass2["default"])(SettingsTab, [{
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
      this.renderComponent();
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "settingsTab"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_settings.RemixUiSettings, {
        config: state.config,
        editor: state.editor,
        _deps: state._deps,
        useMatomoAnalytics: state.useMatomoAnalytics,
        themeModule: state._deps.themeModule
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      this.dispatch(this);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.config.get(key);
    }
  }, {
    key: "updateMatomoAnalyticsChoice",
    value: function updateMatomoAnalyticsChoice(isChecked) {
      this.config.set('settings/matomo-analytics', isChecked);
      this.useMatomoAnalytics = isChecked;
      this.dispatch(_objectSpread({}, this));
    }
  }]);
  return SettingsTab;
}(_engineWeb.ViewPlugin);

/***/ }),
/* 2521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiSettings = __webpack_require__(2522);

Object.keys(_remixUiSettings).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiSettings[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiSettings[key];
    }
  });
});

/***/ }),
/* 2522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixUiSettings = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _clipboard = __webpack_require__(1154);

var _constants = __webpack_require__(1368);

__webpack_require__(2523);

var _settingsAction = __webpack_require__(2525);

var _settingsReducer = __webpack_require__(2526);

var _toaster = __webpack_require__(479);

var _themeModule = __webpack_require__(2527);

var _githubSettings = __webpack_require__(2533);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const RemixUiSettings = props => {
  const [, dispatch] = (0, _react.useReducer)(_settingsReducer.settingReducer, _settingsReducer.initialState);
  const [state, dispatchToast] = (0, _react.useReducer)(_settingsReducer.toastReducer, _settingsReducer.toastInitialState);
  const [tokenValue, setTokenValue] = (0, _react.useState)({});
  const [themeName] = (0, _react.useState)('');
  const [privateBeeAddress, setPrivateBeeAddress] = (0, _react.useState)('');
  const [postageStampId, setPostageStampId] = (0, _react.useState)('');
  const [resetState, refresh] = (0, _react.useState)(0);
  const [ipfsUrl, setipfsUrl] = (0, _react.useState)('');
  const [ipfsPort, setipfsPort] = (0, _react.useState)('');
  const [ipfsProtocol, setipfsProtocol] = (0, _react.useState)('');
  const [ipfsProjectId, setipfsProjectId] = (0, _react.useState)('');
  const [ipfsProjectSecret, setipfsProjectSecret] = (0, _react.useState)('');

  const initValue = () => {
    const metadataConfig = props.config.get('settings/generate-contract-metadata');
    if (metadataConfig === undefined || metadataConfig === null) (0, _settingsAction.generateContractMetadat)(props.config, true, dispatch);
    const javascriptVM = props.config.get('settings/always-use-vm');
    if (javascriptVM === null || javascriptVM === undefined) (0, _settingsAction.ethereumVM)(props.config, true, dispatch);
  };

  (0, _react.useEffect)(() => initValue(), [resetState, props.config]);
  (0, _react.useEffect)(() => initValue(), []);
  (0, _react.useEffect)(() => {
    const token = props.config.get('settings/' + _constants.labels['gist'].key);

    if (token) {
      setTokenValue(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          gist: token
        });
      });
    }

    const etherscantoken = props.config.get('settings/' + _constants.labels['etherscan'].key);

    if (etherscantoken) {
      setTokenValue(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          etherscan: etherscantoken
        });
      });
    }

    const configPrivateBeeAddress = props.config.get('settings/swarm-private-bee-address');

    if (configPrivateBeeAddress) {
      setPrivateBeeAddress(configPrivateBeeAddress);
    }

    const configPostageStampId = props.config.get('settings/swarm-postage-stamp-id');

    if (configPostageStampId) {
      setPostageStampId(configPostageStampId);
    }

    const configipfsUrl = props.config.get('settings/ipfs-url');

    if (configipfsUrl) {
      setipfsUrl(configipfsUrl);
    }

    const configipfsPort = props.config.get('settings/ipfs-port');

    if (configipfsPort) {
      setipfsPort(configipfsPort);
    }

    const configipfsProtocol = props.config.get('settings/ipfs-protocol');

    if (configipfsProtocol) {
      setipfsProtocol(configipfsProtocol);
    }

    const configipfsProjectId = props.config.get('settings/ipfs-project-id');

    if (configipfsProjectId) {
      setipfsProjectId(configipfsProjectId);
    }

    const configipfsProjectSecret = props.config.get('settings/ipfs-project-secret');

    if (configipfsProjectSecret) {
      setipfsProjectSecret(configipfsProjectSecret);
    }
  }, [themeName, state.message]);
  (0, _react.useEffect)(() => {
    if (props.useMatomoAnalytics !== null) (0, _settingsAction.useMatomoAnalytics)(props.config, props.useMatomoAnalytics, dispatch);
  }, [props.useMatomoAnalytics]);

  const onchangeGenerateContractMetadata = event => {
    (0, _settingsAction.generateContractMetadat)(props.config, event.target.checked, dispatch);
  };

  const onchangeOption = event => {
    (0, _settingsAction.ethereumVM)(props.config, event.target.checked, dispatch);
  };

  const textWrapEvent = event => {
    (0, _settingsAction.textWrapEventAction)(props.config, props.editor, event.target.checked, dispatch);
  };

  const onchangePersonal = event => {
    (0, _settingsAction.personal)(props.config, event.target.checked, dispatch);
  };

  const onchangeMatomoAnalytics = event => {
    (0, _settingsAction.useMatomoAnalytics)(props.config, event.target.checked, dispatch);
  };

  const getTextClass = key => {
    if (props.config.get(key)) {
      return _constants.textDark;
    } else {
      return _constants.textSecondary;
    }
  };

  const generalConfig = () => {
    const isMetadataChecked = props.config.get('settings/generate-contract-metadata') || false;
    const isEthereumVMChecked = props.config.get('settings/always-use-vm') || false;
    const isEditorWrapChecked = props.config.get('settings/text-wrap') || false;
    const isPersonalChecked = props.config.get('settings/personal-mode') || false;
    const isMatomoChecked = props.config.get('settings/matomo-analytics') || false;
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "$border-top",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        title: "Reset to Default settings.",
        className: "d-flex justify-content-end pr-4",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
          className: "btn btn-sm btn-secondary ml-2",
          onClick: () => {
            try {
              if (window.remixFileSystem.name === 'indexedDB') {
                props.config.clear();

                try {
                  localStorage.clear(); // remove the whole storage
                } catch (e) {
                  console.log(e);
                }
              } else {
                props.config.clear(); // remove only the remix settings
              }

              refresh(resetState + 1);
            } catch (e) {
              console.log(e);
            }
          },
          children: "Reset to Default settings"
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "card-body pt-3 pb-2",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
          className: "card-title",
          children: "General settings"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-2 custom-control custom-checkbox mb-1",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            onChange: onchangeGenerateContractMetadata,
            id: "generatecontractmetadata",
            "data-id": "settingsTabGenerateContractMetadata",
            type: "checkbox",
            className: "custom-control-input",
            name: "contractMetadata",
            checked: isMetadataChecked
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: `form-check-label custom-control-label align-middle ${getTextClass('settings/generate-contract-metadata')}`,
            "data-id": "settingsTabGenerateContractMetadataLabel",
            htmlFor: "generatecontractmetadata",
            children: _constants.generateContractMetadataText
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "fmt-2 custom-control custom-checkbox mb-1",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            onChange: onchangeOption,
            className: "custom-control-input",
            id: "alwaysUseVM",
            "data-id": "settingsTabAlwaysUseVM",
            type: "checkbox",
            name: "ethereumVM",
            checked: isEthereumVMChecked
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: `form-check-label custom-control-label align-middle ${getTextClass('settings/always-use-vm')}`,
            htmlFor: "alwaysUseVM",
            children: _constants.ethereunVMText
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-2 custom-control custom-checkbox mb-1",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "editorWrap",
            className: "custom-control-input",
            type: "checkbox",
            onChange: textWrapEvent,
            checked: isEditorWrapChecked
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: `form-check-label custom-control-label align-middle ${getTextClass('settings/text-wrap')}`,
            htmlFor: "editorWrap",
            children: _constants.wordWrapText
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "custom-control custom-checkbox mb-1",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            onChange: onchangePersonal,
            id: "personal",
            type: "checkbox",
            className: "custom-control-input",
            checked: isPersonalChecked
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            className: `form-check-label custom-control-label align-middle ${getTextClass('settings/personal-mode')}`,
            htmlFor: "personal",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              className: "fas fa-exclamation-triangle text-warning",
              "aria-hidden": "true"
            }), " ", /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "   "
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "   "
            }), _constants.enablePersonalModeText, " ", _constants.warnText]
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "custom-control custom-checkbox mb-1",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            onChange: onchangeMatomoAnalytics,
            id: "settingsMatomoAnalytics",
            type: "checkbox",
            className: "custom-control-input",
            checked: isMatomoChecked
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            className: `form-check-label custom-control-label align-middle ${getTextClass('settings/matomo-analytics')}`,
            htmlFor: "settingsMatomoAnalytics",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: _constants.matomoAnalytics
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
              href: "https://medium.com/p/66ef69e14931/",
              target: "_blank",
              children: " Analytics in Remix IDE"
            }), " ", /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
              children: "&"
            }), " ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
              target: "_blank",
              href: "https://matomo.org/free-software",
              children: "Matomo"
            })]
          })]
        })]
      })]
    });
  }; // api key settings


  const saveToken = type => {
    (0, _settingsAction.saveTokenToast)(props.config, dispatchToast, tokenValue[type], _constants.labels[type].key);
  };

  const removeToken = type => {
    setTokenValue(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        [type]: ''
      });
    });
    (0, _settingsAction.removeTokenToast)(props.config, dispatchToast, _constants.labels[type].key);
  };

  const handleSaveTokenState = (0, _react.useCallback)((event, type) => {
    setTokenValue(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        [type]: event.target.value
      });
    });
  }, [tokenValue]);

  const token = type => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "border-top",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "card-body pt-3 pb-2",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        className: "card-title",
        children: _constants.labels[type].title
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "mb-1",
        children: _constants.labels[type].message1
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "",
        children: _constants.labels[type].message2
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "mb-1",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
          className: "text-primary",
          target: "_blank",
          href: _constants.labels[type].link,
          children: _constants.labels[type].link
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "TOKEN:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "text-secondary mb-0 h6",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "gistaccesstoken",
            "data-id": "settingsTabGistAccessToken",
            type: "password",
            className: "form-control",
            onChange: e => handleSaveTokenState(e, type),
            value: tokenValue[type]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex justify-content-end pt-2",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
              content: tokenValue[type],
              "data-id": "copyToClipboardCopyIcon"
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "btn btn-sm btn-primary ml-2",
              id: "savegisttoken",
              "data-id": "settingsTabSaveGistToken",
              onClick: () => saveToken(type),
              value: "Save",
              type: "button",
              disabled: tokenValue === ''
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
              className: "btn btn-sm btn-secondary ml-2",
              id: "removegisttoken",
              "data-id": "settingsTabRemoveGistToken",
              title: "Delete GitHub access token",
              onClick: () => removeToken(type),
              children: "Remove"
            })]
          })]
        })]
      })]
    })
  }); // swarm settings


  const handleSavePrivateBeeAddress = (0, _react.useCallback)(event => {
    setPrivateBeeAddress(event.target.value);
  }, [privateBeeAddress]);
  const handleSavePostageStampId = (0, _react.useCallback)(event => {
    setPostageStampId(event.target.value);
  }, [postageStampId]);

  const saveSwarmSettings = () => {
    (0, _settingsAction.saveSwarmSettingsToast)(props.config, dispatchToast, privateBeeAddress, postageStampId);
  };

  const swarmSettings = () => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "border-top",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "card-body pt-3 pb-2",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        className: "card-title",
        children: _constants.swarmSettingsTitle
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "pt-2 mb-1",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "PRIVATE BEE ADDRESS:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "swarmprivatebeeaddress",
            "data-id": "settingsPrivateBeeAddress",
            className: "form-control",
            onChange: handleSavePrivateBeeAddress,
            value: privateBeeAddress
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "POSTAGE STAMP ID:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "text-secondary mb-0 h6",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "swarmpostagestamp",
            "data-id": "settingsPostageStampId",
            className: "form-control",
            onChange: handleSavePostageStampId,
            value: postageStampId
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "d-flex justify-content-end pt-2"
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "d-flex justify-content-end pt-2",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          className: "btn btn-sm btn-primary ml-2",
          id: "saveswarmsettings",
          "data-id": "settingsTabSaveSwarmSettings",
          onClick: () => saveSwarmSettings(),
          value: "Save",
          type: "button",
          disabled: privateBeeAddress === ''
        })
      })]
    })
  }); // ipfs settings


  const handleSaveIpfsProjectId = (0, _react.useCallback)(event => {
    setipfsProjectId(event.target.value);
  }, [ipfsProjectId]);
  const handleSaveIpfsSecret = (0, _react.useCallback)(event => {
    setipfsProjectSecret(event.target.value);
  }, [ipfsProjectSecret]);
  const handleSaveIpfsUrl = (0, _react.useCallback)(event => {
    setipfsUrl(event.target.value);
  }, [ipfsUrl]);
  const handleSaveIpfsPort = (0, _react.useCallback)(event => {
    setipfsPort(event.target.value);
  }, [ipfsPort]);
  const handleSaveIpfsProtocol = (0, _react.useCallback)(event => {
    setipfsProtocol(event.target.value);
  }, [ipfsProtocol]);

  const saveIpfsSettings = () => {
    (0, _settingsAction.saveIpfsSettingsToast)(props.config, dispatchToast, ipfsUrl, ipfsProtocol, ipfsPort, ipfsProjectId, ipfsProjectSecret);
  };

  const ipfsSettings = () => /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "border-top",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "card-body pt-3 pb-2",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        className: "card-title",
        children: _constants.ipfsSettingsText
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "pt-2 mb-1",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "IPFS HOST:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            placeholder: "e.g. ipfs.infura.io",
            id: "settingsIpfsUrl",
            "data-id": "settingsIpfsUrl",
            className: "form-control",
            onChange: handleSaveIpfsUrl,
            value: ipfsUrl
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "IPFS PROTOCOL:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            placeholder: "e.g. https",
            id: "settingsIpfsProtocol",
            "data-id": "settingsIpfsProtocol",
            className: "form-control",
            onChange: handleSaveIpfsProtocol,
            value: ipfsProtocol
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "IPFS PORT:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            placeholder: "e.g. 5001",
            id: "settingsIpfsPort",
            "data-id": "settingsIpfsPort",
            className: "form-control",
            onChange: handleSaveIpfsPort,
            value: ipfsPort
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "IPFS PROJECT ID [ INFURA ]:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "settingsIpfsProjectId",
            "data-id": "settingsIpfsProjectId",
            className: "form-control",
            onChange: handleSaveIpfsProjectId,
            value: ipfsProjectId
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "IPFS PROJECT SECRET [ INFURA ]:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "settingsIpfsProjectSecret",
            "data-id": "settingsIpfsProjectSecret",
            className: "form-control",
            type: "password",
            onChange: handleSaveIpfsSecret,
            value: ipfsProjectSecret
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "d-flex justify-content-end pt-2",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          className: "btn btn-sm btn-primary ml-2",
          id: "saveIpfssettings",
          "data-id": "settingsTabSaveIpfsSettings",
          onClick: () => saveIpfsSettings(),
          value: "Save",
          type: "button"
        })
      })]
    })
  });

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [state.message ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: state.message
    }) : null, generalConfig(), /*#__PURE__*/(0, _jsxRuntime.jsx)(_githubSettings.GithubSettings, {
      saveTokenToast: (githubToken, githubUserName, githubEmail) => {
        (0, _settingsAction.saveTokenToast)(props.config, dispatchToast, githubToken, "gist-access-token");
        (0, _settingsAction.saveTokenToast)(props.config, dispatchToast, githubUserName, "github-user-name");
        (0, _settingsAction.saveTokenToast)(props.config, dispatchToast, githubEmail, "github-email");
      },
      removeTokenToast: () => {
        (0, _settingsAction.removeTokenToast)(props.config, dispatchToast, "gist-access-token");
        (0, _settingsAction.removeTokenToast)(props.config, dispatchToast, "github-user-name");
        (0, _settingsAction.removeTokenToast)(props.config, dispatchToast, "github-email");
      },
      config: props.config
    }), token('etherscan'), swarmSettings(), ipfsSettings(), /*#__PURE__*/(0, _jsxRuntime.jsx)(_themeModule.RemixUiThemeModule, {
      themeModule: props._deps.themeModule
    })]
  });
};

exports.RemixUiSettings = RemixUiSettings;

/***/ }),
/* 2523 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2524);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2524 */
/***/ (function(module, exports) {

module.exports = [[module.i, "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJyZW1peC11aS1zZXR0aW5ncy5jc3MifQ== */", '', '']]

/***/ }),
/* 2525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMatomoAnalytics = exports.textWrapEventAction = exports.saveTokenToast = exports.saveSwarmSettingsToast = exports.saveIpfsSettingsToast = exports.removeTokenToast = exports.personal = exports.generateContractMetadat = exports.ethereumVM = void 0;

var _constants = __webpack_require__(1368);

const _paq = window._paq = window._paq || []; //eslint-disable-line


const generateContractMetadat = (config, checked, dispatch) => {
  config.set('settings/generate-contract-metadata', checked);
  dispatch({
    type: 'contractMetadata',
    payload: {
      isChecked: checked,
      textClass: checked ? _constants.textDark : _constants.textSecondary
    }
  });
};

exports.generateContractMetadat = generateContractMetadat;

const ethereumVM = (config, checked, dispatch) => {
  config.set('settings/always-use-vm', checked);
  dispatch({
    type: 'ethereumVM',
    payload: {
      isChecked: checked,
      textClass: checked ? _constants.textDark : _constants.textSecondary
    }
  });
};

exports.ethereumVM = ethereumVM;

const textWrapEventAction = (config, editor, checked, dispatch) => {
  config.set('settings/text-wrap', checked);
  editor.resize(checked);
  dispatch({
    type: 'textWrap',
    payload: {
      isChecked: checked,
      textClass: checked ? _constants.textDark : _constants.textSecondary
    }
  });
};

exports.textWrapEventAction = textWrapEventAction;

const personal = (config, checked, dispatch) => {
  config.set('settings/personal-mode', checked);
  dispatch({
    type: 'personal',
    payload: {
      isChecked: checked,
      textClass: checked ? _constants.textDark : _constants.textSecondary
    }
  });
};

exports.personal = personal;

const useMatomoAnalytics = (config, checked, dispatch) => {
  config.set('settings/matomo-analytics', checked);
  dispatch({
    type: 'useMatomoAnalytics',
    payload: {
      isChecked: checked,
      textClass: checked ? _constants.textDark : _constants.textSecondary
    }
  });

  if (checked) {
    _paq.push(['forgetUserOptOut']); // @TODO remove next line when https://github.com/matomo-org/matomo/commit/9e10a150585522ca30ecdd275007a882a70c6df5 is used


    document.cookie = 'mtm_consent_removed=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
  } else {
    _paq.push(['optUserOut']);
  }
};

exports.useMatomoAnalytics = useMatomoAnalytics;

const saveTokenToast = (config, dispatch, tokenValue, key) => {
  config.set('settings/' + key, tokenValue);
  dispatch({
    type: 'save',
    payload: {
      message: 'GitHub credentials updated'
    }
  });
};

exports.saveTokenToast = saveTokenToast;

const removeTokenToast = (config, dispatch, key) => {
  config.set('settings/' + key, '');
  dispatch({
    type: 'removed',
    payload: {
      message: 'GitHub credentials removed'
    }
  });
};

exports.removeTokenToast = removeTokenToast;

const saveSwarmSettingsToast = (config, dispatch, privateBeeAddress, postageStampId) => {
  config.set('settings/swarm-private-bee-address', privateBeeAddress);
  config.set('settings/swarm-postage-stamp-id', postageStampId);
  dispatch({
    type: 'save',
    payload: {
      message: 'Swarm settings have been saved'
    }
  });
};

exports.saveSwarmSettingsToast = saveSwarmSettingsToast;

const saveIpfsSettingsToast = (config, dispatch, ipfsURL, ipfsProtocol, ipfsPort, ipfsProjectId, ipfsProjectSecret) => {
  config.set('settings/ipfs-url', ipfsURL);
  config.set('settings/ipfs-protocol', ipfsProtocol);
  config.set('settings/ipfs-port', ipfsPort);
  config.set('settings/ipfs-project-id', ipfsProjectId);
  config.set('settings/ipfs-project-secret', ipfsProjectSecret);
  dispatch({
    type: 'save',
    payload: {
      message: 'IPFS settings have been saved'
    }
  });
};

exports.saveIpfsSettingsToast = saveIpfsSettingsToast;

/***/ }),
/* 2526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toastReducer = exports.toastInitialState = exports.settingReducer = exports.initialState = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _constants = __webpack_require__(1368);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const initialState = {
  elementState: [{
    name: 'contractMetadata',
    isChecked: false,
    textClass: _constants.textSecondary
  }, {
    name: 'ethereumVM',
    isChecked: false,
    textClass: _constants.textSecondary
  }, {
    name: 'textWrap',
    isChecked: false,
    textClass: _constants.textSecondary
  }, {
    name: 'personal',
    isChecked: false,
    textClass: _constants.textSecondary
  }, {
    name: 'useMatomoAnalytics',
    isChecked: false,
    textClass: _constants.textSecondary
  }]
};
exports.initialState = initialState;

const settingReducer = (state, action) => {
  switch (action.type) {
    case 'contractMetadata':
      state.elementState.map(element => {
        if (element.name === 'contractMetadata') {
          element.isChecked = action.payload.isChecked;
          element.textClass = action.payload.textClass;
        }
      });
      return _objectSpread({}, state);

    case 'ethereumVM':
      state.elementState.map(element => {
        if (element.name === 'ethereumVM') {
          element.isChecked = action.payload.isChecked;
          element.textClass = action.payload.textClass;
        }
      });
      return _objectSpread({}, state);

    case 'textWrap':
      state.elementState.map(element => {
        if (element.name === 'textWrap') {
          element.isChecked = action.payload.isChecked;
          element.textClass = action.payload.textClass;
        }
      });
      return _objectSpread({}, state);

    case 'personal':
      state.elementState.map(element => {
        if (element.name === 'personal') {
          element.isChecked = action.payload.isChecked;
          element.textClass = action.payload.textClass;
        }
      });
      return _objectSpread({}, state);

    case 'useMatomoAnalytics':
      state.elementState.map(element => {
        if (element.name === 'useMatomoAnalytics') {
          element.isChecked = action.payload.isChecked;
          element.textClass = action.payload.textClass;
        }
      });
      return _objectSpread({}, state);

    default:
      return initialState;
  }
};

exports.settingReducer = settingReducer;
const toastInitialState = {
  message: ''
};
exports.toastInitialState = toastInitialState;

const toastReducer = (state, action) => {
  switch (action.type) {
    case 'save':
      return _objectSpread(_objectSpread({}, state), {}, {
        message: action.payload.message
      });

    case 'removed':
      return _objectSpread(_objectSpread({}, state), {}, {
        message: action.payload.message
      });

    default:
      return _objectSpread(_objectSpread({}, state), {}, {
        message: ''
      });
  }
};

exports.toastReducer = toastReducer;

/***/ }),
/* 2527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiThemeModule = __webpack_require__(2528);

Object.keys(_remixUiThemeModule).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiThemeModule[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiThemeModule[key];
    }
  });
});

var _themeModule = __webpack_require__(2532);

Object.keys(_themeModule).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _themeModule[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _themeModule[key];
    }
  });
});

/***/ }),
/* 2528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixUiThemeModule = RemixUiThemeModule;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2529);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-explicit-any */
function RemixUiThemeModule({
  themeModule
}) {
  const [themeName, setThemeName] = (0, _react.useState)('');
  (0, _react.useEffect)(() => {
    themeModule.switchTheme();
  }, [themeName, themeModule]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "border-top",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "card-body pt-3 pb-2",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        className: "card-title",
        children: "Themes"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "card-text themes-container",
        children: themeModule.getThemes() ? themeModule.getThemes().map((theme, idx) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "radio custom-control custom-radio mb-1 form-check",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            type: "radio",
            onChange: event => {
              themeModule.switchTheme(theme.name);
              setThemeName(theme.name);
            },
            className: "align-middle custom-control-input",
            name: "theme",
            id: theme.name,
            "data-id": `settingsTabTheme${theme.name}`,
            checked: themeModule.active === theme.name.toLocaleLowerCase()
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            className: "form-check-label custom-control-label",
            "data-id": `settingsTabThemeLabel${theme.name}`,
            htmlFor: theme.name,
            children: [theme.name, " (", theme.quality, ")"]
          })]
        }, idx)) : null
      })]
    })
  });
}

var _default = RemixUiThemeModule;
exports.default = _default;

/***/ }),
/* 2529 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2530);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2530 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(2531);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 2531 */,
/* 2532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 2533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GithubSettings = GithubSettings;

var _clipboard = __webpack_require__(1154);

var _react = _interopRequireWildcard(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function GithubSettings(props) {
  const [githubToken, setGithubToken] = (0, _react.useState)("");
  const [githubUserName, setGithubUsername] = (0, _react.useState)("");
  const [githubEmail, setGithubEmail] = (0, _react.useState)("");
  (0, _react.useEffect)(() => {
    if (props.config) {
      const githubToken = props.config.get('settings/gist-access-token');
      const githubUserName = props.config.get('settings/github-user-name');
      const githubEmail = props.config.get('settings/github-email');
      setGithubToken(githubToken);
      setGithubUsername(githubUserName);
      setGithubEmail(githubEmail);
    }
  }, [props.config]);

  const handleChangeTokenState = event => {
    setGithubToken(event.target.value);
  };

  const handleChangeUserNameState = event => {
    setGithubUsername(event.target.value);
  };

  const handleChangeEmailState = event => {
    setGithubEmail(event.target.value);
  }; // api key settings


  const saveGithubToken = () => {
    props.saveTokenToast(githubToken, githubUserName, githubEmail);
  };

  const removeToken = () => {
    setGithubToken('');
    setGithubUsername('');
    setGithubEmail('');
    props.removeTokenToast();
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "border-top",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "card-body pt-3 pb-2",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("h6", {
        className: "card-title",
        children: "GitHub Credentials"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "mb-1",
        children: "Manage your GitHub credentials used to publish to Gist and retrieve GitHub contents."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "",
        children: "Go to github token page (link below) to create a new token and save it in Remix. Make sure this token has only \\'create gist\\' permission."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "mb-1",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
          className: "text-primary",
          target: "_blank",
          href: "https://github.com/settings/tokens",
          children: "https://github.com/settings/tokens"
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "TOKEN:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "input-group text-secondary mb-0 h6",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "gistaccesstoken",
            "data-id": "settingsTabGistAccessToken",
            type: "password",
            className: "form-control",
            onChange: e => handleChangeTokenState(e),
            value: githubToken
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "input-group-append",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_clipboard.CopyToClipboard, {
              content: githubToken,
              "data-id": "copyToClipboardCopyIcon",
              className: "far fa-copy ml-1 p-2 mt-1",
              direction: "top"
            })
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "USERNAME:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "text-secondary mb-0 h6",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "githubusername",
            "data-id": "settingsTabGithubUsername",
            type: "text",
            className: "form-control",
            onChange: e => handleChangeUserNameState(e),
            value: githubUserName
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          children: "EMAIL:"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "text-secondary mb-0 h6",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            id: "githubemail",
            "data-id": "settingsTabGithubEmail",
            type: "text",
            className: "form-control",
            onChange: e => handleChangeEmailState(e),
            value: githubEmail
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex justify-content-end pt-2",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "btn btn-sm btn-primary ml-2",
              id: "savegisttoken",
              "data-id": "settingsTabSaveGistToken",
              onClick: saveGithubToken,
              value: "Save",
              type: "button",
              disabled: githubToken === ''
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
              className: "btn btn-sm btn-secondary ml-2",
              id: "removegisttoken",
              "data-id": "settingsTabRemoveGistToken",
              title: "Delete GitHub Credentials",
              onClick: removeToken,
              children: "Remove"
            })]
          })]
        })]
      })]
    })
  });
}

/***/ }),
/* 2534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _engineWeb = __webpack_require__(1133);

var _events = __webpack_require__(40);

var _staticAnalyser = __webpack_require__(2535);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _registry = _interopRequireDefault(__webpack_require__(315));

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var EventManager = __webpack_require__(1196);

var profile = {
  name: 'solidityStaticAnalysis',
  displayName: 'Solidity static analysis',
  methods: [],
  events: [],
  icon: 'assets/img/staticAnalysis.webp',
  description: 'Checks the contract code for security vulnerabilities and bad practices.',
  kind: 'analysis',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/static_analysis.html',
  version: packageJson.version,
  maintainedBy: 'Remix'
};

var AnalysisTab = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(AnalysisTab, _ViewPlugin);

  var _super = _createSuper(AnalysisTab);

  function AnalysisTab() {
    var _this;

    (0, _classCallCheck2["default"])(this, AnalysisTab);
    _this = _super.call(this, profile);
    _this.event = new EventManager();
    _this.events = new _events.EventEmitter();
    _this.registry = _registry["default"].getInstance();
    _this.element = document.createElement('div');

    _this.element.setAttribute('id', 'staticAnalyserView');

    _this._components = {};
    _this._components.registry = _this.registry;
    _this._deps = {
      offsetToLineColumnConverter: _this.registry.get('offsettolinecolumnconverter').api
    };
    _this.dispatch = null;
    return _this;
  }

  (0, _createClass2["default"])(AnalysisTab, [{
    key: "onActivation",
    value: function () {
      var _onActivation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _this2 = this;

        var isSolidityActive;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.call('manager', 'isActive', 'solidity');

              case 2:
                isSolidityActive = _context.sent;

                if (isSolidityActive) {
                  _context.next = 6;
                  break;
                }

                _context.next = 6;
                return this.call('manager', 'activatePlugin', 'solidity');

              case 6:
                this.renderComponent();
                this.event.register('staticAnaysisWarning', function (count) {
                  if (count > 0) {
                    _this2.emit('statusChanged', {
                      key: count,
                      title: "".concat(count, " warning").concat(count === 1 ? '' : 's'),
                      type: 'warning'
                    });
                  } else if (count === 0) {
                    _this2.emit('statusChanged', {
                      key: 'succeed',
                      title: 'no warning',
                      type: 'success'
                    });
                  } else {
                    // count ==-1 no compilation result
                    _this2.emit('statusChanged', {
                      key: 'none'
                    });
                  }
                });

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function onActivation() {
        return _onActivation.apply(this, arguments);
      }

      return onActivation;
    }()
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "staticAnalyserView"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_staticAnalyser.RemixUiStaticAnalyser, {
        registry: state.registry,
        analysisModule: state.analysisModule,
        event: state.event
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      this.dispatch({
        registry: this.registry,
        analysisModule: this,
        event: this.event
      });
    }
  }]);
  return AnalysisTab;
}(_engineWeb.ViewPlugin);

module.exports = AnalysisTab;

/***/ }),
/* 2535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiStaticAnalyser = __webpack_require__(2536);

Object.keys(_remixUiStaticAnalyser).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiStaticAnalyser[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiStaticAnalyser[key];
    }
  });
});

/***/ }),
/* 2536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RemixUiStaticAnalyser = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _StaticAnalyserButton = _interopRequireDefault(__webpack_require__(2537));

var _remixLib = __webpack_require__(311);

var _lodash = _interopRequireDefault(__webpack_require__(1361));

var _treeView = __webpack_require__(1187);

var _checkbox = __webpack_require__(2538);

var _ErrorRenderer = _interopRequireDefault(__webpack_require__(2542));

var _staticAnalysisActions = __webpack_require__(2543);

var _staticAnalysisReducer = __webpack_require__(2544);

var _reactBootstrap = __webpack_require__(1209);

var _remixAnalyzer = __webpack_require__(2545);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const _paq = window._paq = window._paq || []; //eslint-disable-line

/* eslint-disable-next-line */


const RemixUiStaticAnalyser = props => {
  const [runner] = (0, _react.useState)(new _remixAnalyzer.CodeAnalysis());

  const preProcessModules = arr => {
    return arr.map((Item, i) => {
      const itemObj = new Item();
      itemObj._index = i;
      itemObj.categoryDisplayName = itemObj.category.displayName;
      itemObj.categoryId = itemObj.category.id;
      return itemObj;
    });
  };

  const groupedModules = _remixLib.util.groupBy(preProcessModules(runner.modules()), 'categoryId');

  const getIndex = (modules, array) => {
    Object.values(modules).map(value => {
      if (Array.isArray(value)) {
        value.forEach(x => {
          array.push(x._index.toString());
        });
      } else {
        array.push(value._index.toString());
      }
    });
  };

  const groupedModuleIndex = modules => {
    const indexOfCategory = [];

    if (!_lodash.default.isEmpty(modules)) {
      getIndex(modules, indexOfCategory);
    }

    return indexOfCategory;
  };

  const [autoRun, setAutoRun] = (0, _react.useState)(true);
  const [slitherEnabled, setSlitherEnabled] = (0, _react.useState)(false);
  const [showSlither, setShowSlither] = (0, _react.useState)(false);
  let [showLibsWarning, setShowLibsWarning] = (0, _react.useState)(false); // eslint-disable-line prefer-const

  const [categoryIndex, setCategoryIndex] = (0, _react.useState)(groupedModuleIndex(groupedModules));
  const [warningState, setWarningState] = (0, _react.useState)({});
  const warningContainer = (0, _react.useRef)(null);
  const allWarnings = (0, _react.useRef)({});
  const [state, dispatch] = (0, _react.useReducer)(_staticAnalysisReducer.analysisReducer, _staticAnalysisReducer.initialState);
  (0, _react.useEffect)(() => {
    (0, _staticAnalysisActions.compilation)(props.analysisModule, dispatch);
  }, [props]);
  (0, _react.useEffect)(() => {
    setWarningState({});

    const runAnalysis = async () => {
      await run(state.data, state.source, state.file);
    };

    if (autoRun) {
      if (state.data !== null) {
        runAnalysis().catch(console.error);
      }
    } else {
      props.event.trigger('staticAnaysisWarning', []);
    }

    return () => {};
  }, [state]);
  (0, _react.useEffect)(() => {
    props.analysisModule.on('filePanel', 'setWorkspace', currentWorkspace => {
      // Reset warning state
      setWarningState([]); // Reset badge

      props.event.trigger('staticAnaysisWarning', []); // Reset state

      dispatch({
        type: '',
        payload: {}
      }); // Show 'Enable Slither Analysis' checkbox

      if (currentWorkspace && currentWorkspace.isLocalhost === true) setShowSlither(true);else {
        setShowSlither(false);
        setSlitherEnabled(false);
      }
    });
    props.analysisModule.on('manager', 'pluginDeactivated', plugin => {
      // Hide 'Enable Slither Analysis' checkbox
      if (plugin.name === 'remixd') {
        // Reset warning state
        setWarningState([]); // Reset badge

        props.event.trigger('staticAnaysisWarning', []); // Reset state

        dispatch({
          type: '',
          payload: {}
        });
        setShowSlither(false);
        setSlitherEnabled(false);
      }
    });
    return () => {};
  }, [props]);

  const message = (name, warning, more, fileName, locationString) => {
    return `
    <span className='d-flex flex-column'>
    <span className='h6 font-weight-bold'>${name}</span>
    ${warning}
    ${more ? /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
        href: more,
        target: "_blank",
        children: "more"
      })
    }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      children: " "
    })}
    <span className="" title={Position in ${fileName}}>Pos: ${locationString}</span>
    </span>`;
  };

  const filterWarnings = () => {
    let newWarningState = {};
    let newWarningCount = 0;

    if (showLibsWarning) {
      for (const category in allWarnings.current) newWarningCount = newWarningCount + allWarnings.current[category].length;

      newWarningState = allWarnings.current;
    } else {
      for (const category in allWarnings.current) {
        const warnings = allWarnings.current[category];
        newWarningState[category] = [];

        for (const warning of warnings) {
          if (!warning.options.isLibrary) {
            newWarningCount++;
            newWarningState[category].push(warning);
          }
        }
      }
    }

    props.event.trigger('staticAnaysisWarning', [newWarningCount]);
    setWarningState(newWarningState);
  };

  const showWarnings = (warningMessage, groupByKey) => {
    const resultArray = [];
    warningMessage.map(x => {
      resultArray.push(x);
    });

    function groupBy(objectArray, property) {
      return objectArray.reduce((acc, obj) => {
        const key = obj[property];

        if (!acc[key]) {
          acc[key] = [];
        } // Add object to list for given key's value


        acc[key].push(obj);
        return acc;
      }, {});
    }

    const groupedCategory = groupBy(resultArray, groupByKey);
    allWarnings.current = groupedCategory;
    filterWarnings();
  };

  const run = async (lastCompilationResult, lastCompilationSource, currentFile) => {
    if (state.data !== null) {
      if (lastCompilationResult && (categoryIndex.length > 0 || slitherEnabled)) {
        const warningMessage = [];
        const warningErrors = []; // Remix Analysis

        _paq.push(['trackEvent', 'solidityStaticAnalyzer', 'analyzeWithRemixAnalyzer']);

        const results = runner.run(lastCompilationResult, categoryIndex);

        for (const result of results) {
          let moduleName;
          Object.keys(groupedModules).map(key => {
            groupedModules[key].forEach(el => {
              if (el.name === result.name) {
                moduleName = groupedModules[key][0].categoryDisplayName;
              }
            });
          });

          for (const item of result.report) {
            let location = {};
            let locationString = 'not available';
            let column = 0;
            let row = 0;
            let fileName = currentFile;
            let isLibrary = false;

            if (item.location) {
              const split = item.location.split(':');
              const file = split[2];
              location = {
                start: parseInt(split[0]),
                length: parseInt(split[1])
              };
              location = props.analysisModule._deps.offsetToLineColumnConverter.offsetToLineColumn(location, parseInt(file), lastCompilationSource.sources, lastCompilationResult.sources);
              row = location.start.line;
              column = location.start.column;
              locationString = row + 1 + ':' + column + ':';
              fileName = Object.keys(lastCompilationResult.sources)[file];
            }

            if (fileName !== currentFile) {
              const {
                file,
                provider
              } = await props.analysisModule.call('fileManager', 'getPathFromUrl', fileName);
              if (file.startsWith('.deps') || provider.type === 'localhost' && file.startsWith('localhost/node_modules')) isLibrary = true;
            }

            const msg = message(result.name, item.warning, item.more, fileName, locationString);
            const options = {
              type: 'warning',
              useSpan: true,
              errFile: fileName,
              fileName,
              isLibrary,
              errLine: row,
              errCol: column,
              item: item,
              name: result.name,
              locationString,
              more: item.more,
              location: location
            };
            warningErrors.push(options);
            warningMessage.push({
              msg,
              options,
              hasWarning: true,
              warningModuleName: moduleName
            });
          }
        } // Slither Analysis


        if (slitherEnabled) {
          try {
            const compilerState = await props.analysisModule.call('solidity', 'getCompilerState');
            const {
              currentVersion,
              optimize,
              evmVersion
            } = compilerState;
            await props.analysisModule.call('terminal', 'log', {
              type: 'info',
              value: '[Slither Analysis]: Running...'
            });

            _paq.push(['trackEvent', 'solidityStaticAnalyzer', 'analyzeWithSlither']);

            const result = await props.analysisModule.call('slither', 'analyse', state.file, {
              currentVersion,
              optimize,
              evmVersion
            });

            if (result.status) {
              props.analysisModule.call('terminal', 'log', {
                type: 'info',
                value: `[Slither Analysis]: Analysis Completed!! ${result.count} warnings found.`
              });
              const report = result.data;

              for (const item of report) {
                let location = {};
                let locationString = 'not available';
                let column = 0;
                let row = 0;
                let fileName = currentFile;
                let isLibrary = false;

                if (item.sourceMap && item.sourceMap.length) {
                  let path = item.sourceMap[0].source_mapping.filename_relative;
                  let fileIndex = Object.keys(lastCompilationResult.sources).indexOf(path);

                  if (fileIndex === -1) {
                    path = await props.analysisModule.call('fileManager', 'getUrlFromPath', path);
                    fileIndex = Object.keys(lastCompilationResult.sources).indexOf(path.file);
                  }

                  if (fileIndex >= 0) {
                    location = {
                      start: item.sourceMap[0].source_mapping.start,
                      length: item.sourceMap[0].source_mapping.length
                    };
                    location = props.analysisModule._deps.offsetToLineColumnConverter.offsetToLineColumn(location, fileIndex, lastCompilationSource.sources, lastCompilationResult.sources);
                    row = location.start.line;
                    column = location.start.column;
                    locationString = row + 1 + ':' + column + ':';
                    fileName = Object.keys(lastCompilationResult.sources)[fileIndex];
                  }
                }

                if (fileName !== currentFile) {
                  const {
                    file,
                    provider
                  } = await props.analysisModule.call('fileManager', 'getPathFromUrl', fileName);
                  if (file.startsWith('.deps') || provider.type === 'localhost' && file.startsWith('localhost/node_modules')) isLibrary = true;
                }

                const msg = message(item.title, item.description, item.more, fileName, locationString);
                const options = {
                  type: 'warning',
                  useSpan: true,
                  errFile: fileName,
                  fileName,
                  isLibrary,
                  errLine: row,
                  errCol: column,
                  item: {
                    warning: item.description
                  },
                  name: item.title,
                  locationString,
                  more: item.more,
                  location: location
                };
                warningErrors.push(options);
                warningMessage.push({
                  msg,
                  options,
                  hasWarning: true,
                  warningModuleName: 'Slither Analysis'
                });
              }

              showWarnings(warningMessage, 'warningModuleName');
            }
          } catch (error) {
            props.analysisModule.call('terminal', 'log', {
              type: 'error',
              value: '[Slither Analysis]: Error occured! See remixd console for details.'
            });
            showWarnings(warningMessage, 'warningModuleName');
          }
        } else showWarnings(warningMessage, 'warningModuleName');
      } else {
        if (categoryIndex.length) {
          warningContainer.current.innerText = 'No compiled AST available';
        }

        props.event.trigger('staticAnaysisWarning', [-1]);
      }
    }
  };

  const handleCheckAllModules = groupedModules => {
    const index = groupedModuleIndex(groupedModules);

    if (index.every(el => categoryIndex.includes(el))) {
      setCategoryIndex(categoryIndex.filter(el => {
        return !index.includes(el);
      }));
    } else {
      setCategoryIndex(_lodash.default.uniq([...categoryIndex, ...index]));
    }
  };

  const handleCheckOrUncheckCategory = category => {
    const index = groupedModuleIndex(category);

    if (index.every(el => categoryIndex.includes(el))) {
      setCategoryIndex(categoryIndex.filter(el => {
        return !index.includes(el);
      }));
    } else {
      setCategoryIndex(_lodash.default.uniq([...categoryIndex, ...index]));
    }
  };

  const handleSlitherEnabled = () => {
    if (slitherEnabled) {
      setSlitherEnabled(false);
    } else {
      setSlitherEnabled(true);
    }
  };

  const handleAutoRun = () => {
    if (autoRun) {
      setAutoRun(false);
    } else {
      setAutoRun(true);
    }
  };

  const handleCheckSingle = (event, _index) => {
    _index = _index.toString();

    if (categoryIndex.includes(_index)) {
      setCategoryIndex(categoryIndex.filter(val => val !== _index));
    } else {
      setCategoryIndex(_lodash.default.uniq([...categoryIndex, _index]));
    }
  };

  const handleShowLibsWarning = () => {
    if (showLibsWarning) {
      showLibsWarning = false;
      setShowLibsWarning(false);
    } else {
      showLibsWarning = true;
      setShowLibsWarning(true);
    }

    filterWarnings();
  };

  const categoryItem = (categoryId, item, i) => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "form-check",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_checkbox.RemixUiCheckbox, {
        categoryId: categoryId,
        id: `staticanalysismodule_${categoryId}_${i}`,
        inputType: "checkbox",
        name: "checkSingleEntry",
        itemName: item.name,
        label: item.description,
        onClick: event => handleCheckSingle(event, item._index),
        checked: categoryIndex.includes(item._index.toString()),
        onChange: () => {}
      })
    }, i);
  };

  const categorySection = (category, categoryId, i) => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "block",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
          children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_treeView.TreeViewItem, {
            label: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              htmlFor: `heading${categoryId}`,
              style: {
                cursor: 'pointer'
              },
              className: "pl-3 card-header h6 d-flex justify-content-between font-weight-bold px-1 py-2 w-100",
              "data-bs-toggle": "collapse",
              "data-bs-expanded": "false",
              "data-bs-controls": `heading${categoryId}`,
              "data-bs-target": `#heading${categoryId}`,
              children: category[0].categoryDisplayName
            }),
            expand: false,
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_checkbox.RemixUiCheckbox, {
                onClick: () => handleCheckOrUncheckCategory(category),
                id: categoryId,
                inputType: "checkbox",
                label: `Select ${category[0].categoryDisplayName}`,
                name: "checkCategoryEntry",
                checked: category.map(x => x._index.toString()).every(el => categoryIndex.includes(el)),
                onChange: () => {}
              })
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "w-100 d-block px-2 my-1 entries collapse multi-collapse",
              id: `heading${categoryId}`,
              children: category.map((item, i) => {
                return categoryItem(categoryId, item, i);
              })
            })]
          })
        })
      })
    }, i);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "analysis_3ECCBV px-3 pb-1",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "my-2 d-flex flex-column align-items-left",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex justify-content-between",
        id: "staticanalysisButton",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_checkbox.RemixUiCheckbox, {
          id: "checkAllEntries",
          inputType: "checkbox",
          title: "Select all Remix analysis modules",
          checked: Object.values(groupedModules).map(value => {
            return value.map(x => {
              return x._index.toString();
            });
          }).flat().every(el => categoryIndex.includes(el)),
          label: "Select all",
          onClick: () => handleCheckAllModules(groupedModules),
          onChange: () => {}
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_checkbox.RemixUiCheckbox, {
          id: "autorunstaticanalysis",
          inputType: "checkbox",
          title: "Run static analysis after the compilation",
          onClick: handleAutoRun,
          checked: autoRun,
          label: "Autorun",
          onChange: () => {}
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_StaticAnalyserButton.default, {
          buttonText: "Run",
          onClick: async () => await run(state.data, state.source, state.file),
          disabled: (state.data === null || categoryIndex.length === 0) && !slitherEnabled
        })]
      }), showSlither && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex mt-2",
        id: "enableSlitherAnalysis",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_checkbox.RemixUiCheckbox, {
          id: "enableSlither",
          inputType: "checkbox",
          onClick: handleSlitherEnabled,
          checked: slitherEnabled,
          label: "Enable Slither Analysis",
          onChange: () => {}
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
          className: "mt-1 text-nowrap",
          href: "https://remix-ide.readthedocs.io/en/latest/slither.html#enable-slither-analysis",
          target: '_blank',
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.OverlayTrigger, {
            placement: 'right',
            overlay: /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Tooltip, {
              className: "text-nowrap",
              id: "overlay-tooltip",
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                className: "border bg-light text-dark p-1 pr-3",
                style: {
                  minWidth: '230px'
                },
                children: "Learn how to use Slither Analysis"
              })
            }),
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              style: {
                fontSize: 'medium'
              },
              className: 'fal fa-info-circle ml-3',
              "aria-hidden": "true"
            })
          })
        })]
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      id: "staticanalysismodules",
      className: "list-group list-group-flush",
      children: Object.keys(groupedModules).map((categoryId, i) => {
        const category = groupedModules[categoryId];
        return categorySection(category, categoryId, i);
      })
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "mt-2 p-2 d-flex border-top flex-column",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        children: "Last results for:"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "text-break break-word word-break font-weight-bold",
        id: "staticAnalysisCurrentFile",
        children: state.file
      })]
    }), Object.entries(warningState).length > 0 && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      id: "staticanalysisresult",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_checkbox.RemixUiCheckbox, {
        id: "showLibWarnings",
        name: "showLibWarnings",
        categoryId: "showLibWarnings",
        title: "when checked, the results are also displayed for external contract libraries",
        inputType: "checkbox",
        checked: showLibsWarning,
        label: "Show warnings for external libraries",
        onClick: handleShowLibsWarning,
        onChange: () => {}
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "mb-4",
        children: Object.entries(warningState).map((element, index) => /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          children: [element[1]['length'] > 0 ? /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "text-dark h6",
            children: element[0]
          }) : null, element[1]['map']((x, i) => // eslint-disable-line dot-notation
          x.hasWarning ?
          /*#__PURE__*/
          // eslint-disable-next-line  dot-notation
          (0, _jsxRuntime.jsx)("div", {
            "data-id": `staticAnalysisModule${x.warningModuleName}${i}`,
            id: `staticAnalysisModule${x.warningModuleName}${i}`,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_ErrorRenderer.default, {
              name: `staticAnalysisModule${x.warningModuleName}${i}`,
              message: x.msg,
              opt: x.options,
              warningErrors: x.warningErrors,
              editor: props.analysisModule
            })
          }, i) : null)]
        }, index))
      })]
    })]
  });
};

exports.RemixUiStaticAnalyser = RemixUiStaticAnalyser;
var _default = RemixUiStaticAnalyser;
exports.default = _default;

/***/ }),
/* 2537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

const StaticAnalyserButton = ({
  onClick,
  buttonText,
  disabled
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
    className: "btn btn-sm w-25 btn-primary",
    onClick: onClick,
    disabled: disabled,
    children: buttonText
  });
};

var _default = StaticAnalyserButton;
exports.default = _default;

/***/ }),
/* 2538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiCheckbox = __webpack_require__(2539);

Object.keys(_remixUiCheckbox).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiCheckbox[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiCheckbox[key];
    }
  });
});

/***/ }),
/* 2539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RemixUiCheckbox = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

__webpack_require__(2540);

var _jsxRuntime = __webpack_require__(46);

//eslint-disable-line
const RemixUiCheckbox = ({
  id,
  label,
  onClick,
  inputType,
  name,
  checked,
  onChange,
  itemName,
  categoryId,
  title,
  visibility,
  display: _display = 'flex'
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "listenOnNetwork_2A0YE0 custom-control custom-checkbox",
    title: title,
    style: {
      display: _display,
      alignItems: 'center',
      visibility: visibility
    },
    onClick: onClick,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
      id: id,
      type: inputType,
      onChange: onChange,
      style: {
        verticalAlign: 'bottom'
      },
      name: name,
      className: "custom-control-input",
      checked: checked
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
      className: "form-check-label custom-control-label",
      id: `heading${categoryId}`,
      style: {
        paddingTop: '0.15rem'
      },
      children: [name ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "font-weight-bold",
        children: itemName
      }) : '', label]
    })]
  });
};

exports.RemixUiCheckbox = RemixUiCheckbox;
var _default = RemixUiCheckbox;
exports.default = _default;

/***/ }),
/* 2540 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2541);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2541 */
/***/ (function(module, exports) {

module.exports = [[module.i, "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJyZW1peC11aS1jaGVja2JveC5jc3MifQ== */", '', '']]

/***/ }),
/* 2542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

const ErrorRenderer = ({
  message,
  opt,
  editor,
  name
}) => {
  const getPositionDetails = msg => {
    const result = {}; // To handle some compiler warning without location like SPDX license warning etc

    if (!msg.includes(':')) return {
      errLine: -1,
      errCol: -1,
      errFile: msg
    }; // extract line / column

    let position = msg.match(/^(.*?):([0-9]*?):([0-9]*?)?/);
    result.errLine = position ? parseInt(position[2]) - 1 : -1;
    result.errCol = position ? parseInt(position[3]) : -1; // extract file

    position = msg.match(/^(https:.*?|http:.*?|.*?):/);
    result.errFile = position ? position[1] : '';
    return result;
  };

  const handlePointToErrorOnClick = async (location, fileName) => {
    await editor.call('editor', 'discardHighlight');
    await editor.call('editor', 'highlight', location, fileName, '', {
      focus: true
    });
  };

  if (!message) return;
  let position = getPositionDetails(message);

  if (!position.errFile || opt.errorType && opt.errorType === position.errFile) {
    // Updated error reported includes '-->' before file details
    const errorDetails = message.split('-->'); // errorDetails[1] will have file details

    if (errorDetails.length > 1) position = getPositionDetails(errorDetails[1]);
  }

  opt.errLine = position.errLine;
  opt.errCol = position.errCol;
  opt.errFile = position.errFile.trim();
  const classList = opt.type === 'error' ? 'alert alert-danger' : 'alert alert-warning';
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: `sol ${opt.type} ${classList}`,
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        className: "d-flex flex-column",
        "data-id": `${name}Button`,
        onClick: async () => await handlePointToErrorOnClick(opt.location, opt.fileName),
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "h6 font-weight-bold",
          children: opt.name
        }), opt.item.warning, opt.item.more ? /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            href: opt.item.more,
            target: "_blank",
            children: "more"
          })
        }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: " "
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          title: `Position in ${opt.errFile}`,
          children: ["Pos: ", opt.locationString]
        })]
      })
    })
  });
};

var _default = ErrorRenderer;
exports.default = _default;

/***/ }),
/* 2543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compilation = void 0;

//eslint-disable-line
const compilation = (analysisModule, dispatch) => {
  if (analysisModule) {
    analysisModule.on('solidity', 'compilationFinished', (file, source, languageVersion, data, input, version) => {
      if (languageVersion.indexOf('soljson') !== 0) return;
      dispatch({
        type: 'compilationFinished',
        payload: {
          file,
          source,
          languageVersion,
          data,
          input,
          version
        }
      });
    });
  }
};

exports.compilation = compilation;

/***/ }),
/* 2544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialState = exports.analysisReducer = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const initialState = {
  file: null,
  source: null,
  languageVersion: null,
  data: null
};
exports.initialState = initialState;

const analysisReducer = (state, action) => {
  switch (action.type) {
    case 'compilationFinished':
      return _objectSpread(_objectSpread({}, state), {}, {
        file: action.payload.file,
        source: action.payload.source,
        languageVersion: action.payload.languageVersion,
        data: action.payload.data,
        input: action.payload.input,
        version: action.payload.version
      });

    default:
      return initialState;
  }
};

exports.analysisReducer = analysisReducer;

/***/ }),
/* 2545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CodeAnalysis = void 0;

var solidity_analyzer_1 = __webpack_require__(2546);

Object.defineProperty(exports, "CodeAnalysis", {
  enumerable: true,
  get: function () {
    return __importDefault(solidity_analyzer_1).default;
  }
});

/***/ }),
/* 2546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const remix_astwalker_1 = __webpack_require__(1180);

const list_1 = (0, tslib_1.__importDefault)(__webpack_require__(2547));

class staticAnalysisRunner {
  /**
   * Run analysis (Used by IDE)
   * @param compilationResult contract compilation result
   * @param toRun module indexes (compiled from remix IDE)
   * @param callback callback
   */
  run(compilationResult, toRun) {
    const modules = toRun.map(i => {
      const Module = this.modules()[i];
      const m = new Module();
      return {
        name: m.name,
        mod: m
      };
    });
    return this.runWithModuleList(compilationResult, modules);
  }
  /**
   * Run analysis passing list of modules to run
   * @param compilationResult contract compilation result
   * @param modules analysis module
   * @param callback callback
   */


  runWithModuleList(compilationResult, modules) {
    let reports = []; // Also provide convenience analysis via the AST walker.

    const walker = new remix_astwalker_1.AstWalker();

    for (const k in compilationResult.sources) {
      walker.walkFull(compilationResult.sources[k].ast, node => {
        modules.map(item => {
          if (item.mod.visit !== undefined) {
            try {
              item.mod.visit(node);
            } catch (e) {
              reports.push({
                name: item.name,
                report: [{
                  warning: 'INTERNAL ERROR in module ' + item.name + ' ' + e.message,
                  error: e.stack
                }]
              });
            }
          }
        });
        return true;
      });
    } // Here, modules can just collect the results from the AST walk,
    // but also perform new analysis.


    reports = reports.concat(modules.map(item => {
      let report = null;

      try {
        report = item.mod.report(compilationResult);
      } catch (e) {
        report = [{
          warning: 'INTERNAL ERROR in module ' + item.name + ' ' + e.message,
          error: e.stack
        }];
      }

      return {
        name: item.name,
        report: report
      };
    }));
    return reports;
  }
  /**
   * Get list of all analysis modules
   */


  modules() {
    return list_1.default;
  }

}

exports.default = staticAnalysisRunner;

/***/ }),
/* 2547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const txOrigin_1 = (0, tslib_1.__importDefault)(__webpack_require__(2548));
const gasCosts_1 = (0, tslib_1.__importDefault)(__webpack_require__(2549));
const thisLocal_1 = (0, tslib_1.__importDefault)(__webpack_require__(2550));
const checksEffectsInteraction_1 = (0, tslib_1.__importDefault)(__webpack_require__(2551));
const constantFunctions_1 = (0, tslib_1.__importDefault)(__webpack_require__(2552));
const similarVariableNames_1 = (0, tslib_1.__importDefault)(__webpack_require__(2553));
const inlineAssembly_1 = (0, tslib_1.__importDefault)(__webpack_require__(2556));
const blockTimestamp_1 = (0, tslib_1.__importDefault)(__webpack_require__(2557));
const lowLevelCalls_1 = (0, tslib_1.__importDefault)(__webpack_require__(2558));
const blockBlockhash_1 = (0, tslib_1.__importDefault)(__webpack_require__(2559));
const noReturn_1 = (0, tslib_1.__importDefault)(__webpack_require__(2560));
const selfdestruct_1 = (0, tslib_1.__importDefault)(__webpack_require__(2561));
const guardConditions_1 = (0, tslib_1.__importDefault)(__webpack_require__(2562));
const deleteDynamicArrays_1 = (0, tslib_1.__importDefault)(__webpack_require__(2563));
const assignAndCompare_1 = (0, tslib_1.__importDefault)(__webpack_require__(2564));
const erc20Decimals_1 = (0, tslib_1.__importDefault)(__webpack_require__(2565));
const stringBytesLength_1 = (0, tslib_1.__importDefault)(__webpack_require__(2566));
const deleteFromDynamicArray_1 = (0, tslib_1.__importDefault)(__webpack_require__(2567));
const forLoopIteratesOverDynamicArray_1 = (0, tslib_1.__importDefault)(__webpack_require__(2568));
const etherTransferInLoop_1 = (0, tslib_1.__importDefault)(__webpack_require__(2569));
const intDivisionTruncate_1 = (0, tslib_1.__importDefault)(__webpack_require__(2570));
exports.default = [txOrigin_1.default, gasCosts_1.default, thisLocal_1.default, checksEffectsInteraction_1.default, erc20Decimals_1.default, constantFunctions_1.default, similarVariableNames_1.default, inlineAssembly_1.default, blockTimestamp_1.default, lowLevelCalls_1.default, blockBlockhash_1.default, noReturn_1.default, selfdestruct_1.default, guardConditions_1.default, deleteDynamicArrays_1.default, assignAndCompare_1.default, stringBytesLength_1.default, deleteFromDynamicArray_1.default, forLoopIteratesOverDynamicArray_1.default, etherTransferInLoop_1.default, intDivisionTruncate_1.default];

/***/ }),
/* 2548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class txOrigin {
  constructor() {
    this.txOriginNodes = [];
    this.name = 'Transaction origin: ';
    this.description = '\'tx.origin\' used';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((0, staticAnalysisCommon_1.isTxOriginAccess)(node)) this.txOriginNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.txOriginNodes.map((item, i) => {
      return {
        warning: `Use of tx.origin: "tx.origin" is useful only in very exceptional cases. 
                  If you use it for authentication, you usually want to replace it by "msg.sender", because otherwise any contract you call can act on your behalf.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#tx-origin`
      };
    });
  }

}

exports.default = txOrigin;

/***/ }),
/* 2549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class gasCosts {
  constructor() {
    this.name = 'Gas costs: ';
    this.description = 'Too high gas requirement of functions';
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.warningNodes = [];
  }

  visit(node) {
    if (node.nodeType === 'FunctionDefinition' && node.kind !== 'constructor' && node.implemented || node.nodeType === 'VariableDeclaration' && (0, staticAnalysisCommon_1.isVariableTurnedIntoGetter)(node)) {
      this.warningNodes.push(node);
    }
  }

  report(compilationResults) {
    const report = [];
    const methodsWithSignature = this.warningNodes.map(node => {
      let signature;

      if (node.nodeType === 'FunctionDefinition') {
        const functionName = (0, staticAnalysisCommon_1.getFunctionDefinitionName)(node);
        signature = staticAnalysisCommon_1.helpers.buildAbiSignature(functionName, (0, staticAnalysisCommon_1.getMethodParamsSplittedTypeDesc)(node, compilationResults.contracts));
      } else {
        signature = node.name + '()';
      }

      return {
        name: node.name,
        src: node.src,
        signature: signature
      };
    });

    for (const method of methodsWithSignature) {
      for (const filename in compilationResults.contracts) {
        for (const contractName in compilationResults.contracts[filename]) {
          const contract = compilationResults.contracts[filename][contractName];
          const methodGas = this.checkMethodGas(contract, method.signature);

          if (methodGas && methodGas.isInfinite) {
            if (methodGas.isFallback) {
              report.push({
                warning: `Fallback function of contract ${contractName} requires too much gas (${methodGas.msg}). 
                If the fallback function requires more than 2300 gas, the contract cannot receive Ether.`,
                location: method.src
              });
            } else {
              report.push({
                warning: `Gas requirement of function ${contractName}.${method.name} ${methodGas.msg}: 
                If the gas requirement of a function is higher than the block gas limit, it cannot be executed.
                Please avoid loops in your functions or actions that modify large areas of storage
                (this includes clearing or copying arrays in storage)`,
                location: method.src
              });
            }
          } else continue;
        }
      }
    }

    return report;
  }

  checkMethodGas(contract, methodSignature) {
    if (contract.evm && contract.evm.gasEstimates && contract.evm.gasEstimates.external) {
      if (methodSignature === '()') {
        const fallback = contract.evm.gasEstimates.external[''];

        if (fallback !== undefined && (fallback === null || parseInt(fallback) >= 2100 || fallback === 'infinite')) {
          return {
            isInfinite: true,
            isFallback: true,
            msg: fallback
          };
        }
      } else {
        const gas = contract.evm.gasEstimates.external[methodSignature];
        const gasString = gas === null ? 'unknown or not constant' : 'is ' + gas;

        if (gas === null || parseInt(gas) >= 3000000 || gas === 'infinite') {
          return {
            isInfinite: true,
            isFallback: false,
            msg: gasString
          };
        }
      }
    }
  }

}

exports.default = gasCosts;

/***/ }),
/* 2550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class thisLocal {
  constructor() {
    this.warningNodes = [];
    this.name = 'This on local calls: ';
    this.description = 'Invocation of local functions via \'this\'';
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'MemberAccess' && (0, staticAnalysisCommon_1.isThisLocalCall)(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.warningNodes.map(function (item, i) {
      return {
        warning: 'Use of "this" for local functions: Never use "this" to call functions in the same contract, it only consumes more gas than normal local calls.',
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/control-structures.html#external-function-calls`
      };
    });
  }

}

exports.default = thisLocal;

/***/ }),
/* 2551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const functionCallGraph_1 = __webpack_require__(1591);

const abstractAstView_1 = (0, tslib_1.__importDefault)(__webpack_require__(1205));

class checksEffectsInteraction {
  constructor() {
    this.name = 'Check-effects-interaction: ';
    this.description = 'Potential reentrancy bugs';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => node.nodeType === 'FunctionCall' && ((0, staticAnalysisCommon_1.isInteraction)(node) || (0, staticAnalysisCommon_1.isLocalCallGraphRelevantNode)(node)) || (node.nodeType === 'Assignment' || node.nodeType === 'UnaryOperation' || node.nodeType === 'InlineAssembly') && (0, staticAnalysisCommon_1.isEffect)(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    const callGraph = (0, functionCallGraph_1.buildGlobalFuncCallGraph)(contracts);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        func['changesState'] = this.checkIfChangesState((0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, func.node, func.parameters), this.getContext(callGraph, contract, func));
      });
      contract.functions.forEach(func => {
        if (this.isPotentialVulnerableFunction(func, this.getContext(callGraph, contract, func))) {
          const funcName = (0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, func.node, func.parameters);
          let comments = hasModifiers ? 'Note: Modifiers are currently not considered by this static analysis.' : '';
          comments += multipleContractsWithSameName ? 'Note: Import aliases are currently not supported by this static analysis.' : '';
          warnings.push({
            warning: `Potential violation of Checks-Effects-Interaction pattern in ${funcName}: Could potentially lead to re-entrancy vulnerability. ${comments}`,
            location: func.node.src,
            more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#re-entrancy`
          });
        }
      });
    });
    return warnings;
  }

  getContext(callGraph, currentContract, func) {
    return {
      callGraph: callGraph,
      currentContract: currentContract,
      stateVariables: this.getStateVariables(currentContract, func)
    };
  }

  getStateVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables.filter(staticAnalysisCommon_1.isStorageVariableDeclaration));
  }

  isPotentialVulnerableFunction(func, context) {
    let isPotentialVulnerable = false;
    let interaction = false;
    func.relevantNodes.forEach(node => {
      if ((0, staticAnalysisCommon_1.isInteraction)(node)) {
        interaction = true;
      } else if (interaction && ((0, staticAnalysisCommon_1.isWriteOnStateVariable)(node, context.stateVariables) || this.isLocalCallWithStateChange(node, context))) {
        isPotentialVulnerable = true;
      }
    });
    return isPotentialVulnerable;
  }

  isLocalCallWithStateChange(node, context) {
    if ((0, staticAnalysisCommon_1.isLocalCallGraphRelevantNode)(node)) {
      const func = (0, functionCallGraph_1.resolveCallGraphSymbol)(context.callGraph, (0, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent)(context.currentContract.node, node));
      return !func || func && func.node['changesState'];
    }

    return false;
  }

  checkIfChangesState(startFuncName, context) {
    return (0, functionCallGraph_1.analyseCallGraph)(context.callGraph, startFuncName, context, (node, context) => (0, staticAnalysisCommon_1.isWriteOnStateVariable)(node, context.stateVariables));
  }

}

exports.default = checksEffectsInteraction;

/***/ }),
/* 2552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const functionCallGraph_1 = __webpack_require__(1591);

const abstractAstView_1 = (0, tslib_1.__importDefault)(__webpack_require__(1205));

class constantFunctions {
  constructor() {
    this.name = 'Constant/View/Pure functions: ';
    this.description = 'Potentially constant/view/pure functions';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => (0, staticAnalysisCommon_1.isLowLevelCall)(node) || (0, staticAnalysisCommon_1.isTransfer)(node) || (0, staticAnalysisCommon_1.isExternalDirectCall)(node) || (0, staticAnalysisCommon_1.isEffect)(node) || (0, staticAnalysisCommon_1.isLocalCallGraphRelevantNode)(node) || node.nodeType === 'InlineAssembly' || node.nodeType === 'NewExpression' || (0, staticAnalysisCommon_1.isSelfdestructCall)(node) || (0, staticAnalysisCommon_1.isDeleteUnaryOperation)(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    const callGraph = (0, functionCallGraph_1.buildGlobalFuncCallGraph)(contracts);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        if ((0, staticAnalysisCommon_1.isPayableFunction)(func.node) || (0, staticAnalysisCommon_1.isConstructor)(func.node)) {
          func['potentiallyshouldBeConst'] = false;
        } else {
          func['potentiallyshouldBeConst'] = this.checkIfShouldBeConstant((0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, func.node, func.parameters), this.getContext(callGraph, contract, func));
        }
      });
      contract.functions.filter(func => (0, staticAnalysisCommon_1.hasFunctionBody)(func.node)).forEach(func => {
        if ((0, staticAnalysisCommon_1.isConstantFunction)(func.node) !== func['potentiallyshouldBeConst']) {
          const funcName = (0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, func.node, func.parameters);
          let comments = hasModifiers ? 'Note: Modifiers are currently not considered by this static analysis.' : '';
          comments += multipleContractsWithSameName ? 'Note: Import aliases are currently not supported by this static analysis.' : '';

          if (func['potentiallyshouldBeConst']) {
            warnings.push({
              warning: `${funcName} : Potentially should be constant/view/pure but is not. ${comments}`,
              location: func.node.src,
              more: `https://solidity.readthedocs.io/en/${version}/contracts.html#view-functions`
            });
          } else {
            warnings.push({
              warning: `${funcName} : Is constant but potentially should not be. ${comments}`,
              location: func.node.src,
              more: `https://solidity.readthedocs.io/en/${version}/contracts.html#view-functions`
            });
          }
        }
      });
    });
    return warnings;
  }

  getContext(callGraph, currentContract, func) {
    return {
      callGraph: callGraph,
      currentContract: currentContract,
      stateVariables: this.getStateVariables(currentContract, func)
    };
  }

  getStateVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables.filter(staticAnalysisCommon_1.isStorageVariableDeclaration));
  }

  checkIfShouldBeConstant(startFuncName, context) {
    return !(0, functionCallGraph_1.analyseCallGraph)(context.callGraph, startFuncName, context, this.isConstBreaker.bind(this));
  }

  isConstBreaker(node, context) {
    return (0, staticAnalysisCommon_1.isWriteOnStateVariable)(node, context.stateVariables) || (0, staticAnalysisCommon_1.isLowLevelCall)(node) || (0, staticAnalysisCommon_1.isTransfer)(node) || this.isCallOnNonConstExternalInterfaceFunction(node, context) || (0, staticAnalysisCommon_1.isCallToNonConstLocalFunction)(node) || node.nodeType === 'InlineAssembly' || node.nodeType === 'NewExpression' || (0, staticAnalysisCommon_1.isSelfdestructCall)(node) || (0, staticAnalysisCommon_1.isDeleteUnaryOperation)(node);
  }

  isCallOnNonConstExternalInterfaceFunction(node, context) {
    if ((0, staticAnalysisCommon_1.isExternalDirectCall)(node)) {
      const func = (0, functionCallGraph_1.resolveCallGraphSymbol)(context.callGraph, (0, staticAnalysisCommon_1.getFullQualifiedFunctionCallIdent)(context.currentContract.node, node));
      return !func || func && !(0, staticAnalysisCommon_1.isConstantFunction)(func.node.node);
    }

    return false;
  }

}

exports.default = constantFunctions;

/***/ }),
/* 2553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));
const abstractAstView_1 = (0, tslib_1.__importDefault)(__webpack_require__(1205));

const fast_levenshtein_1 = __webpack_require__(2554);

const remix_lib_1 = __webpack_require__(311);

const remix_astwalker_1 = __webpack_require__(1180);

class similarVariableNames {
  constructor() {
    this.name = 'Similar variable names: ';
    this.description = 'Variable names are too similar';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default(); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.visit = this.abstractAst.build_visit(node => false);
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    const hasModifiers = contracts.some(item => item.modifiers.length > 0);
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        const funcName = (0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, func.node, func.parameters);
        let hasModifiersComments = '';

        if (hasModifiers) {
          hasModifiersComments = 'Note: Modifiers are currently not considered by this static analysis.';
        }

        let multipleContractsWithSameNameComments = '';

        if (multipleContractsWithSameName) {
          multipleContractsWithSameNameComments = 'Note: Import aliases are currently not supported by this static analysis.';
        }

        const vars = this.getFunctionVariables(contract, func).map(staticAnalysisCommon_1.getDeclaredVariableName);
        this.findSimilarVarNames(vars).map(sim => {
          // check if function is implemented
          if (func.node.implemented) {
            const astWalker = new remix_astwalker_1.AstWalker();
            const functionBody = func.node.body; // Walk through all statements of function

            astWalker.walk(functionBody, node => {
              // check if these is an identifier node which is one of the tracked similar variables
              if ((node.nodeType === 'Identifier' || node.nodeType === 'VariableDeclaration') && (node.name === sim.var1 || node.name === sim.var2)) {
                warnings.push({
                  warning: `${funcName} : Variables have very similar names "${sim.var1}" and "${sim.var2}". ${hasModifiersComments} ${multipleContractsWithSameNameComments}`,
                  location: node.src
                });
              }

              return true;
            });
          }
        });
      });
    });
    return warnings;
  }

  findSimilarVarNames(vars) {
    const similar = [];
    const comb = {};
    vars.map(varName1 => vars.map(varName2 => {
      if (varName1.length > 1 && varName2.length > 1 && varName2 !== varName1 && !this.isCommonPrefixedVersion(varName1, varName2) && !this.isCommonNrSuffixVersion(varName1, varName2) && !(comb[varName1 + ';' + varName2] || comb[varName2 + ';' + varName1])) {
        comb[varName1 + ';' + varName2] = true;
        const distance = (0, fast_levenshtein_1.get)(varName1, varName2);
        if (distance <= 2) similar.push({
          var1: varName1,
          var2: varName2,
          distance: distance
        });
      }
    }));
    return similar;
  }

  isCommonPrefixedVersion(varName1, varName2) {
    return varName1.startsWith('_') && varName1.slice(1) === varName2 || varName2.startsWith('_') && varName2.slice(1) === varName1;
  }

  isCommonNrSuffixVersion(varName1, varName2) {
    const ref = '^' + remix_lib_1.util.escapeRegExp(varName1.slice(0, -1)) + '[0-9]*$';
    return varName2.match(ref) != null;
  }

  getFunctionVariables(contract, func) {
    return contract.stateVariables.concat(func.localVariables);
  }

}

exports.default = similarVariableNames;

/***/ }),
/* 2554 */,
/* 2555 */,
/* 2556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class inlineAssembly {
  constructor() {
    this.inlineAssNodes = [];
    this.name = 'Inline assembly: ';
    this.description = 'Inline assembly used';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'InlineAssembly') this.inlineAssNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.inlineAssNodes.map(node => {
      return {
        warning: `The Contract uses inline assembly, this is only advised in rare cases. 
                  Additionally static analysis modules do not parse inline Assembly, this can lead to wrong analysis results.`,
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/assembly.html`
      };
    });
  }

}

exports.default = inlineAssembly;

/***/ }),
/* 2557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class blockTimestamp {
  constructor() {
    this.warningNowNodes = [];
    this.warningblockTimestampNodes = [];
    this.name = 'Block timestamp: ';
    this.description = 'Can be influenced by miners';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'Identifier' && (0, staticAnalysisCommon_1.isNowAccess)(node)) this.warningNowNodes.push(node);else if (node.nodeType === 'MemberAccess' && (0, staticAnalysisCommon_1.isBlockTimestampAccess)(node)) this.warningblockTimestampNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.warningNowNodes.map((item, i) => {
      return {
        warning: `Use of "now": "now" does not mean current time. "now" is an alias for "block.timestamp". 
                  "block.timestamp" can be influenced by miners to a certain degree, be careful.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/units-and-global-variables.html?highlight=block.timestamp#block-and-transaction-properties`
      };
    }).concat(this.warningblockTimestampNodes.map(item => {
      return {
        warning: `Use of "block.timestamp": "block.timestamp" can be influenced by miners to a certain degree. 
                  That means that a miner can "choose" the block.timestamp, to a certain degree, to change the outcome of a transaction in the mined block.`,
        location: item.src,
        more: `https://solidity.readthedocs.io/en/${version}/units-and-global-variables.html?highlight=block.timestamp#block-and-transaction-properties`
      };
    }));
  }

}

exports.default = blockTimestamp;

/***/ }),
/* 2558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class lowLevelCalls {
  constructor() {
    this.llcNodes = [];
    this.name = 'Low level calls: ';
    this.description = 'Should only be used by experienced devs';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((0, staticAnalysisCommon_1.isLLCall)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALL
      });
    } else if ((0, staticAnalysisCommon_1.isLLDelegatecall)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL
      });
    } else if ((0, staticAnalysisCommon_1.isLLSend)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.SEND
      });
    } else if ((0, staticAnalysisCommon_1.isLLDelegatecall04)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL
      });
    } else if ((0, staticAnalysisCommon_1.isLLSend04)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.SEND
      });
    } else if ((0, staticAnalysisCommon_1.isLLCall04)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALL
      });
    } else if ((0, staticAnalysisCommon_1.isLLCallcode)(node)) {
      this.llcNodes.push({
        node: node,
        type: staticAnalysisCommon_1.lowLevelCallTypes.CALLCODE
      });
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.llcNodes.map((item, i) => {
      let text = '';
      let morehref = '';

      switch (item.type) {
        case staticAnalysisCommon_1.lowLevelCallTypes.CALL:
          text = `Use of "call": should be avoided whenever possible. 
                  It can lead to unexpected behavior if return value is not handled properly. 
                  Please use Direct Calls via specifying the called contract's interface.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/control-structures.html?#external-function-calls`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.CALLCODE:
          text = `Use of "callcode": should be avoided whenever possible. 
                  External code, that is called can change the state of the calling contract and send ether from the caller's balance. 
                  If this is wanted behaviour, use the Solidity library feature if possible.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/contracts.html#libraries`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.DELEGATECALL:
          text = `Use of "delegatecall": should be avoided whenever possible. 
                  External code, that is called can change the state of the calling contract and send ether from the caller's balance. 
                  If this is wanted behaviour, use the Solidity library feature if possible.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/contracts.html#libraries`;
          break;

        case staticAnalysisCommon_1.lowLevelCallTypes.SEND:
          text = `Use of "send": "send" does not throw an exception when not successful, make sure you deal with the failure case accordingly. 
                  Use "transfer" whenever failure of the ether transfer should rollback the whole transaction. 
                  Note: if you "send/transfer" ether to a contract the fallback function is called, the callees fallback function is very limited due to the limited amount of gas provided by "send/transfer". 
                  No state changes are possible but the callee can log the event or revert the transfer. "send/transfer" is syntactic sugar for a "call" to the fallback function with 2300 gas and a specified ether value.`;
          morehref = `https://solidity.readthedocs.io/en/${version}/security-considerations.html#sending-and-receiving-ether`;
          break;
      }

      return {
        warning: text,
        more: morehref,
        location: item.node.src
      };
    });
  }

}

exports.default = lowLevelCalls;

/***/ }),
/* 2559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class blockBlockhash {
  constructor() {
    this.warningNodes = [];
    this.name = 'Block hash: ';
    this.description = 'Can be influenced by miners';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if (node.nodeType === 'FunctionCall' && (0, staticAnalysisCommon_1.isBlockBlockHashAccess)(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: `Use of "blockhash": "blockhash(uint blockNumber)" is used to access the last 256 block hashes. 
                  A miner computes the block hash by "summing up" the information in the current block mined. 
                  By "summing up" the information cleverly, a miner can try to influence the outcome of a transaction in the current block. 
                  This is especially easy if there are only a small number of equally likely outcomes.`,
        location: item.src
      };
    });
  }

}

exports.default = blockBlockhash;

/***/ }),
/* 2560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));
const abstractAstView_1 = (0, tslib_1.__importDefault)(__webpack_require__(1205));

class noReturn {
  constructor() {
    this.name = 'No return: ';
    this.description = 'Function with \'returns\' not returning';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => node.nodeType === 'Return' || node.nodeType === 'Assignment');
    this.report = this.abstractAst.build_report(this._report.bind(this));
  }

  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    contracts.forEach(contract => {
      contract.functions.filter(func => (0, staticAnalysisCommon_1.hasFunctionBody)(func.node)).forEach(func => {
        const funcName = (0, staticAnalysisCommon_1.getFullQuallyfiedFuncDefinitionIdent)(contract.node, func.node, func.parameters);

        if (this.hasNamedAndUnnamedReturns(func)) {
          warnings.push({
            warning: `${funcName}: Mixing of named and unnamed return parameters is not advised.`,
            location: func.node.src
          });
        } else if (this.shouldReturn(func) && !(this.hasReturnStatement(func) || this.hasNamedReturns(func) && this.hasAssignToAllNamedReturns(func))) {
          warnings.push({
            warning: `${funcName}: Defines a return type but never explicitly returns a value.`,
            location: func.node.src
          });
        }
      });
    });
    return warnings;
  }

  shouldReturn(func) {
    return func.returns.length > 0;
  }

  hasReturnStatement(func) {
    return func.relevantNodes.filter(n => n.nodeType === 'Return').length > 0;
  }

  hasAssignToAllNamedReturns(func) {
    const namedReturns = func.returns.filter(n => n.name.length > 0).map(n => n.name);
    const assignedVars = func.relevantNodes.filter(n => n.nodeType === 'Assignment').map(staticAnalysisCommon_1.getEffectedVariableName);
    const diff = namedReturns.filter(e => !assignedVars.includes(e));
    return diff.length === 0;
  }

  hasNamedReturns(func) {
    return func.returns.filter(n => n.name.length > 0).length > 0;
  }

  hasNamedAndUnnamedReturns(func) {
    return func.returns.filter(n => n.name.length === 0).length > 0 && this.hasNamedReturns(func);
  }

}

exports.default = noReturn;

/***/ }),
/* 2561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));
const abstractAstView_1 = (0, tslib_1.__importDefault)(__webpack_require__(1205));

class selfdestruct {
  constructor() {
    this.name = 'Selfdestruct: ';
    this.description = 'Contracts using destructed contract can be broken';
    this.category = categories_1.default.SECURITY;
    this.algorithm = algorithmCategories_1.default.HEURISTIC;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default();
    this.visit = this.abstractAst.build_visit(node => (0, staticAnalysisCommon_1.isStatement)(node) || node.nodeType === 'FunctionCall' && (0, staticAnalysisCommon_1.isSelfdestructCall)(node));
    this.report = this.abstractAst.build_report(this._report.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _report(contracts, multipleContractsWithSameName, version) {
    const warnings = [];
    contracts.forEach(contract => {
      contract.functions.forEach(func => {
        let hasSelf = false;
        func.relevantNodes.forEach(node => {
          if ((0, staticAnalysisCommon_1.isSelfdestructCall)(node)) {
            warnings.push({
              warning: 'Use of selfdestruct: Can block calling contracts unexpectedly. Be especially careful if this contract is planned to be used by other contracts (i.e. library contracts, interactions). Selfdestruction of the callee contract can leave callers in an inoperable state.',
              location: node.src,
              more: 'https://paritytech.io/blog/security-alert.html'
            });
            hasSelf = true;
          }

          if ((0, staticAnalysisCommon_1.isStatement)(node) && hasSelf) {
            warnings.push({
              warning: 'Use of selfdestruct: No code after selfdestruct is executed. Selfdestruct is a terminal.',
              location: node.src,
              more: `https://solidity.readthedocs.io/en/${version}/introduction-to-smart-contracts.html#deactivate-and-self-destruct`
            });
            hasSelf = false;
          }
        });
      });
    });
    return warnings;
  }

}

exports.default = selfdestruct;

/***/ }),
/* 2562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class guardConditions {
  constructor() {
    this.guards = [];
    this.name = 'Guard conditions: ';
    this.description = 'Ensure appropriate use of require/assert';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((0, staticAnalysisCommon_1.isRequireCall)(node) || (0, staticAnalysisCommon_1.isAssertCall)(node)) this.guards.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.guards.map(node => {
      return {
        warning: 'Use "assert(x)" if you never ever want x to be false, not in any circumstance (apart from a bug in your code). Use "require(x)" if x can be false, due to e.g. invalid input or a failing external component.',
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/control-structures.html#error-handling-assert-require-revert-and-exceptions`
      };
    });
  }

}

exports.default = guardConditions;

/***/ }),
/* 2563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class deleteDynamicArrays {
  constructor() {
    this.rel = [];
    this.name = 'Delete dynamic array: ';
    this.description = 'Use require/assert to ensure complete deletion';
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((0, staticAnalysisCommon_1.isDeleteOfDynamicArray)(node)) this.rel.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.rel.map(node => {
      return {
        warning: 'The "delete" operation when applied to a dynamically sized array in Solidity generates code to delete each of the elements contained. If the array is large, this operation can surpass the block gas limit and raise an OOG exception. Also nested dynamically sized objects can produce the same results.',
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/types.html#delete`
      };
    });
  }

}

exports.default = deleteDynamicArrays;

/***/ }),
/* 2564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class assignAndCompare {
  constructor() {
    this.warningNodes = [];
    this.name = 'Result not used: ';
    this.description = 'The result of an operation not used';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((node === null || node === void 0 ? void 0 : node.nodeType) && (0, staticAnalysisCommon_1.isSubScopeWithTopLevelUnAssignedBinOp)(node)) (0, staticAnalysisCommon_1.getUnAssignedTopLevelBinOps)(node).forEach(n => this.warningNodes.push(n));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: 'A binary operation yields a value that is not used further. This is often caused by confusing assignment (=) and comparison (==).',
        location: item.src
      };
    });
  }

}

exports.default = assignAndCompare;

/***/ }),
/* 2565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));
const abstractAstView_1 = (0, tslib_1.__importDefault)(__webpack_require__(1205));

class erc20Decimals {
  constructor() {
    this.name = 'ERC20: ';
    this.description = '\'decimals\' should be \'uint8\'';
    this.category = categories_1.default.ERC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.abstractAst = new abstractAstView_1.default(); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    this.visit = this.abstractAst.build_visit(node => false);
    this.report = this.abstractAst.build_report(this._report.bind(this));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  _report(contracts, multipleContractsWithSameName) {
    const warnings = [];
    contracts.forEach(contract => {
      const contractAbiSignatures = contract.functions.map(f => staticAnalysisCommon_1.helpers.buildAbiSignature((0, staticAnalysisCommon_1.getFunctionDefinitionName)(f.node), f.parameters));

      if (this.isERC20(contractAbiSignatures)) {
        const decimalsVar = contract.stateVariables.filter(stateVar => (0, staticAnalysisCommon_1.getDeclaredVariableName)(stateVar) === 'decimals' && ((0, staticAnalysisCommon_1.getDeclaredVariableType)(stateVar) !== 'uint8' || stateVar.visibility !== 'public'));
        const decimalsFun = contract.functions.filter(f => (0, staticAnalysisCommon_1.getFunctionDefinitionName)(f.node) === 'decimals' && (f.returns.length === 0 || f.returns.length > 1 || f.returns.length === 1 && (f.returns[0].type !== 'uint8' || f.node.visibility !== 'public')));

        if (decimalsVar.length > 0) {
          for (const node of decimalsVar) {
            warnings.push({
              warning: 'ERC20 contract\'s "decimals" variable should be "uint8" type',
              location: node.src,
              more: 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals'
            });
          }
        } else if (decimalsFun.length > 0) {
          for (const fn of decimalsFun) {
            warnings.push({
              warning: 'ERC20 contract\'s "decimals" function should have "uint8" as return type',
              location: fn.node.src,
              more: 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals'
            });
          }
        }
      }
    });
    return warnings;
  }

  isERC20(funSignatures) {
    return funSignatures.includes('totalSupply()') && funSignatures.includes('balanceOf(address)') && funSignatures.includes('transfer(address,uint256)') && funSignatures.includes('transferFrom(address,address,uint256)') && funSignatures.includes('approve(address,uint256)') && funSignatures.includes('allowance(address,address)');
  }

}

exports.default = erc20Decimals;

/***/ }),
/* 2566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class stringBytesLength {
  constructor() {
    this.name = 'String length: ';
    this.description = 'Bytes length != String length';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
    this.stringToBytesConversions = [];
    this.bytesLengthChecks = [];
  }

  visit(node) {
    if (node.nodeType === 'FunctionCall' && (0, staticAnalysisCommon_1.isStringToBytesConversion)(node)) this.stringToBytesConversions.push(node);else if (node.nodeType === 'MemberAccess' && (0, staticAnalysisCommon_1.isBytesLengthCheck)(node)) this.bytesLengthChecks.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);

    if (this.stringToBytesConversions.length > 0 && this.bytesLengthChecks.length > 0) {
      return [{
        warning: '"bytes" and "string" lengths are not the same since strings are assumed to be UTF-8 encoded (according to the ABI defintion) therefore one character is not nessesarily encoded in one byte of data.',
        location: this.bytesLengthChecks[0].src,
        more: `https://solidity.readthedocs.io/en/${version}/abi-spec.html#argument-encoding`
      }];
    } else {
      return [];
    }
  }

}

exports.default = stringBytesLength;

/***/ }),
/* 2567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class deleteFromDynamicArray {
  constructor() {
    this.relevantNodes = [];
    this.name = 'Delete from dynamic array: ';
    this.description = '\'delete\' leaves a gap in array';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((0, staticAnalysisCommon_1.isDeleteFromDynamicArray)(node) && !(0, staticAnalysisCommon_1.isMappingIndexAccess)(node.subExpression)) this.relevantNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.relevantNodes.map(node => {
      return {
        warning: 'Using "delete" on an array leaves a gap. The length of the array remains the same. If you want to remove the empty position you need to shift items manually and update the "length" property.',
        location: node.src,
        more: 'https://github.com/miguelmota/solidity-idiosyncrasies#examples'
      };
    });
  }

}

exports.default = deleteFromDynamicArray;

/***/ }),
/* 2568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class forLoopIteratesOverDynamicArray {
  constructor() {
    this.relevantNodes = [];
    this.name = 'For loop over dynamic array: ';
    this.description = 'Iterations depend on dynamic array\'s size';
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    const {
      condition
    } = node; // Check if condition is `i < array.length - 1`

    if (condition && condition.nodeType === 'BinaryOperation' && condition.rightExpression.nodeType === 'BinaryOperation' && (0, staticAnalysisCommon_1.isDynamicArrayLengthAccess)(condition.rightExpression.leftExpression) || // or condition is `i < array.length`
    condition && condition.nodeType === 'BinaryOperation' && (0, staticAnalysisCommon_1.isDynamicArrayLengthAccess)(condition.rightExpression)) {
      this.relevantNodes.push(node);
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.relevantNodes.map(node => {
      return {
        warning: 'Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully. Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. \n Additionally, using unbounded loops incurs in a lot of avoidable gas costs. Carefully test how many items at maximum you can pass to such functions to make it successful.',
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#gas-limit-and-loops`
      };
    });
  }

}

exports.default = forLoopIteratesOverDynamicArray;

/***/ }),
/* 2569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));
const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

const staticAnalysisCommon_1 = __webpack_require__(1122);

class etherTransferInLoop {
  constructor() {
    this.relevantNodes = [];
    this.name = 'Ether transfer in loop: ';
    this.description = 'Transferring Ether in a for/while/do-while loop';
    this.category = categories_1.default.GAS;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    let transferNodes = [];

    if ((0, staticAnalysisCommon_1.isLoop)(node)) {
      if (node.body && node.body.nodeType === 'Block') {
        transferNodes = node.body.statements.filter(child => child.nodeType === 'ExpressionStatement' && child.expression.nodeType === 'FunctionCall' && (0, staticAnalysisCommon_1.isTransfer)(child.expression.expression));
      } else if (node.body && node.body.nodeType === 'ExpressionStatement' && node.body.expression.nodeType === 'FunctionCall' && (0, staticAnalysisCommon_1.isTransfer)(node.body.expression.expression)) {
        transferNodes.push(node.body);
      } // When loop body is described without braces


      if (transferNodes.length > 0) {
        this.relevantNodes.push(...transferNodes);
      }
    }
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    const version = (0, staticAnalysisCommon_1.getCompilerVersion)(compilationResults.contracts);
    return this.relevantNodes.map(node => {
      return {
        warning: 'Ether payout should not be done in a loop: Due to the block gas limit, transactions can only consume a certain amount of gas. The number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. If required then make sure that number of iterations are low and you trust each address involved.',
        location: node.src,
        more: `https://solidity.readthedocs.io/en/${version}/security-considerations.html#gas-limit-and-loops`
      };
    });
  }

}

exports.default = etherTransferInLoop;

/***/ }),
/* 2570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

const categories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1127));

const staticAnalysisCommon_1 = __webpack_require__(1122);

const algorithmCategories_1 = (0, tslib_1.__importDefault)(__webpack_require__(1128));

class intDivisionTruncate {
  constructor() {
    this.warningNodes = [];
    this.name = 'Data truncated: ';
    this.description = 'Division on int/uint values truncates the result';
    this.category = categories_1.default.MISC;
    this.algorithm = algorithmCategories_1.default.EXACT;
    this.version = {
      start: '0.4.12'
    };
  }

  visit(node) {
    if ((0, staticAnalysisCommon_1.isIntDivision)(node)) this.warningNodes.push(node);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  report(compilationResults) {
    return this.warningNodes.map(item => {
      return {
        warning: 'Division of integer values yields an integer value again. That means e.g. 10 / 100 = 0 instead of 0.1 since the result is an integer again. This does not hold for division of (only) literal values since those yield rational constants.',
        location: item.src
      };
    });
  }

}

exports.default = intDivisionTruncate;

/***/ }),
/* 2571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerTab = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _debuggerUi = __webpack_require__(2572);

var _debuggerPlugin = __webpack_require__(2619);

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var remixBleach = _interopRequireWildcard(__webpack_require__(2621));

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var css = __webpack_require__(2623);

var profile = {
  name: 'debugger',
  displayName: 'Debugger',
  methods: ['debug', 'getTrace'],
  events: [],
  icon: 'assets/img/debuggerLogo.webp',
  description: 'Debug transactions',
  kind: 'debugging',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/debugger.html',
  version: packageJson.version,
  maintainedBy: 'Remix'
};

var DebuggerTab = /*#__PURE__*/function (_DebuggerApiMixin) {
  (0, _inherits2["default"])(DebuggerTab, _DebuggerApiMixin);

  var _super = _createSuper(DebuggerTab);

  function DebuggerTab() {
    var _this;

    (0, _classCallCheck2["default"])(this, DebuggerTab);
    _this = _super.call(this, profile);
    _this.el = document.createElement('div');

    _this.el.setAttribute('id', 'debugView');

    _this.el.classList.add(css.debuggerTabView);

    _this.initDebuggerApi();

    return _this;
  }

  (0, _createClass2["default"])(DebuggerTab, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      this.on('fetchAndCompile', 'compiling', function (settings) {
        settings = JSON.stringify(settings, null, '\t');

        _this2.call('notification', 'toast', (0, _helper.compilingToastMsg)(settings));
      });
      this.on('fetchAndCompile', 'compilationFailed', function (data) {
        _this2.call('notification', 'toast', (0, _helper.compilationFinishedToastMsg)());
      });
      this.on('fetchAndCompile', 'notFound', function (contractAddress) {
        _this2.call('notification', 'toast', (0, _helper.notFoundToastMsg)(contractAddress));
      });
      this.on('fetchAndCompile', 'usingLocalCompilation', function (contractAddress) {
        _this2.call('notification', 'toast', (0, _helper.localCompilationToastMsg)());
      });
      this.on('fetchAndCompile', 'sourceVerificationNotAvailable', function () {
        _this2.call('notification', 'toast', (0, _helper.sourceVerificationNotAvailableToastMsg)());
      });
      return /*#__PURE__*/_react["default"].createElement("div", {
        className: css.debuggerTabView,
        id: "debugView"
      }, /*#__PURE__*/_react["default"].createElement(_debuggerUi.DebuggerUI, {
        debuggerAPI: this
      }));
    }
  }, {
    key: "showMessage",
    value: function showMessage(title, message) {
      try {
        this.call('notification', 'alert', {
          id: 'debuggerTabShowMessage',
          title: title,
          message: remixBleach.sanitize(message)
        });
      } catch (e) {
        console.log(e);
      }
    }
  }]);
  return DebuggerTab;
}((0, _debuggerPlugin.DebuggerApiMixin)(_engineWeb.ViewPlugin));

exports.DebuggerTab = DebuggerTab;

/***/ }),
/* 2572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debuggerUi = __webpack_require__(2573);

Object.keys(_debuggerUi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _debuggerUi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _debuggerUi[key];
    }
  });
});

var _idebuggerApi = __webpack_require__(2618);

Object.keys(_idebuggerApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _idebuggerApi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _idebuggerApi[key];
    }
  });
});

/***/ }),
/* 2573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DebuggerUI = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _txBrowser = _interopRequireDefault(__webpack_require__(2574));

var _stepManager = _interopRequireDefault(__webpack_require__(2577));

var _vmDebugger = _interopRequireDefault(__webpack_require__(2582));

var _vmDebuggerHead = _interopRequireDefault(__webpack_require__(2593));

var _remixDebug = __webpack_require__(1217);

var _toaster = __webpack_require__(479);

var _helper = __webpack_require__(1121);

__webpack_require__(2616);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const _paq = window._paq = window._paq || [];

const DebuggerUI = props => {
  const debuggerModule = props.debuggerAPI;
  const [state, setState] = (0, _react.useState)({
    isActive: false,
    debugger: null,
    currentReceipt: {
      contractAddress: null,
      to: null
    },
    currentBlock: null,
    currentTransaction: null,
    blockNumber: null,
    txNumber: '',
    debugging: false,
    opt: {
      debugWithGeneratedSources: false,
      debugWithLocalNode: false
    },
    toastMessage: '',
    validationError: '',
    txNumberIsEmpty: true,
    isLocalNodeUsed: false,
    sourceLocationStatus: ''
  });
  (0, _react.useEffect)(() => {
    return unLoad();
  }, []);
  debuggerModule.onDebugRequested((hash, web3) => {
    if (hash) debug(hash, web3);
  });
  debuggerModule.onRemoveHighlights(async () => {
    await debuggerModule.discardHighlight();
  });
  (0, _react.useEffect)(() => {
    const setEditor = () => {
      debuggerModule.onBreakpointCleared((fileName, row) => {
        if (state.debugger) state.debugger.breakPointManager.remove({
          fileName: fileName,
          row: row
        });
      });
      debuggerModule.onBreakpointAdded((fileName, row) => {
        if (state.debugger) state.debugger.breakPointManager.add({
          fileName: fileName,
          row: row
        });
      });
      debuggerModule.onEditorContentChanged(() => {
        if (state.debugger) unLoad();
      });
    };

    setEditor();

    const providerChanged = () => {
      debuggerModule.onEnvChanged(provider => {
        setState(prevState => {
          const isLocalNodeUsed = provider !== 'vm' && provider !== 'injected';
          return _objectSpread(_objectSpread({}, prevState), {}, {
            isLocalNodeUsed: isLocalNodeUsed
          });
        });
      });
    };

    providerChanged();
  }, [state.debugger]);

  const listenToEvents = (debuggerInstance, currentReceipt) => {
    if (!debuggerInstance) return;
    debuggerInstance.event.register('debuggerStatus', async isActive => {
      await debuggerModule.discardHighlight();
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          isActive
        });
      });
    });
    debuggerInstance.event.register('locatingBreakpoint', async isActive => {
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          sourceLocationStatus: 'Locating breakpoint, this might take a while...'
        });
      });
    });
    debuggerInstance.event.register('noBreakpointHit', async isActive => {
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          sourceLocationStatus: ''
        });
      });
    });
    debuggerInstance.event.register('newSourceLocation', async (lineColumnPos, rawLocation, generatedSources, address) => {
      if (!lineColumnPos) {
        await debuggerModule.discardHighlight();
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            sourceLocationStatus: 'Source location not available, neither in Sourcify nor in Etherscan. Please make sure the Etherscan api key is provided in the settings.'
          });
        });
        return;
      }

      const contracts = await debuggerModule.fetchContractAndCompile(address || currentReceipt.contractAddress || currentReceipt.to, currentReceipt);

      if (contracts) {
        let path = contracts.getSourceName(rawLocation.file);

        if (!path) {
          // check in generated sources
          for (const source of generatedSources) {
            if (source.id === rawLocation.file) {
              path = `browser/.debugger/generated-sources/${source.name}`;
              let content;

              try {
                content = await debuggerModule.getFile(path);
              } catch (e) {
                const message = 'Unable to fetch generated sources, the file probably doesn\'t exist yet.';
                console.log(message, ' ', e);
              }

              if (content !== source.contents) {
                await debuggerModule.setFile(path, source.contents);
              }

              break;
            }
          }
        }

        if (path) {
          setState(prevState => {
            return _objectSpread(_objectSpread({}, prevState), {}, {
              sourceLocationStatus: ''
            });
          });
          await debuggerModule.discardHighlight();
          await debuggerModule.highlight(lineColumnPos, path);
        }
      }
    });
    debuggerInstance.event.register('debuggerUnloaded', () => unLoad());
  };

  const requestDebug = (blockNumber, txNumber, tx) => {
    startDebugging(blockNumber, txNumber, tx);
  };

  const updateTxNumberFlag = empty => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        txNumberIsEmpty: empty,
        validationError: ''
      });
    });
  };

  const unloadRequested = (blockNumber, txIndex, tx) => {
    unLoad();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        sourceLocationStatus: ''
      });
    });
  };

  const unLoad = () => {
    if (state.debugger) state.debugger.unload();
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        isActive: false,
        debugger: null,
        currentReceipt: {
          contractAddress: null,
          to: null
        },
        currentBlock: null,
        currentTransaction: null,
        blockNumber: null,
        ready: {
          vmDebugger: false,
          vmDebuggerHead: false
        },
        debugging: false
      });
    });
  };

  const startDebugging = async (blockNumber, txNumber, tx, optWeb3) => {
    if (state.debugger) unLoad();
    if (!txNumber) return;
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        txNumber: txNumber,
        sourceLocationStatus: ''
      });
    });

    if (!(0, _helper.isValidHash)(txNumber)) {
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          validationError: 'Invalid transaction hash.'
        });
      });
      return;
    }

    const web3 = optWeb3 || (state.opt.debugWithLocalNode ? await debuggerModule.web3() : await debuggerModule.getDebugWeb3());

    try {
      const networkId = await web3.eth.net.getId();

      _paq.push(['trackEvent', 'debugger', 'startDebugging', networkId]);

      if (networkId === 42) {
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            validationError: 'Unfortunately, the Kovan network is not supported.'
          });
        });
        return;
      }
    } catch (e) {
      console.error(e);
    }

    let currentReceipt;
    let currentBlock;
    let currentTransaction;

    try {
      currentReceipt = await web3.eth.getTransactionReceipt(txNumber);
      currentBlock = await web3.eth.getBlock(currentReceipt.blockHash);
      currentTransaction = await web3.eth.getTransaction(txNumber);
    } catch (e) {
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          validationError: e.message
        });
      });
      console.log(e.message);
    }

    const debuggerInstance = new _remixDebug.TransactionDebugger({
      web3,
      offsetToLineColumnConverter: debuggerModule.offsetToLineColumnConverter,
      compilationResult: async address => {
        try {
          const ret = await debuggerModule.fetchContractAndCompile(address, currentReceipt);
          return ret;
        } catch (e) {
          // debuggerModule.showMessage('Debugging error', 'Unable to fetch a transaction.')
          console.error(e);
        }

        return null;
      },
      debugWithGeneratedSources: state.opt.debugWithGeneratedSources
    });
    setTimeout(async () => {
      try {
        await debuggerInstance.debug(blockNumber, txNumber, tx, () => {
          listenToEvents(debuggerInstance, currentReceipt);
          setState(prevState => {
            return _objectSpread(_objectSpread({}, prevState), {}, {
              blockNumber,
              txNumber,
              debugging: true,
              currentReceipt,
              currentBlock,
              currentTransaction,
              debugger: debuggerInstance,
              toastMessage: `debugging ${txNumber}`,
              validationError: ''
            });
          });
        });
      } catch (error) {
        unLoad();
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            validationError: error.message || error
          });
        });
      }
    }, 300);
  };

  const debug = (txHash, web3) => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        validationError: '',
        txNumber: txHash,
        sourceLocationStatus: ''
      });
    });
    startDebugging(null, txHash, null, web3);
  };

  const stepManager = {
    jumpTo: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpTo.bind(state.debugger.step_manager) : null,
    stepOverBack: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepOverBack.bind(state.debugger.step_manager) : null,
    stepIntoBack: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepIntoBack.bind(state.debugger.step_manager) : null,
    stepIntoForward: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepIntoForward.bind(state.debugger.step_manager) : null,
    stepOverForward: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.stepOverForward.bind(state.debugger.step_manager) : null,
    jumpOut: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpOut.bind(state.debugger.step_manager) : null,
    jumpPreviousBreakpoint: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpPreviousBreakpoint.bind(state.debugger.step_manager) : null,
    jumpNextBreakpoint: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpNextBreakpoint.bind(state.debugger.step_manager) : null,
    jumpToException: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.jumpToException.bind(state.debugger.step_manager) : null,
    traceLength: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.traceLength : null,
    registerEvent: state.debugger && state.debugger.step_manager ? state.debugger.step_manager.event.register.bind(state.debugger.step_manager.event) : null
  };
  const vmDebugger = {
    registerEvent: state.debugger && state.debugger.vmDebuggerLogic ? state.debugger.vmDebuggerLogic.event.register.bind(state.debugger.vmDebuggerLogic.event) : null,
    triggerEvent: state.debugger && state.debugger.vmDebuggerLogic ? state.debugger.vmDebuggerLogic.event.trigger.bind(state.debugger.vmDebuggerLogic.event) : null
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: state.toastMessage
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "px-2",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
          className: "my-2 debuggerLabel",
          children: "Debugger Configuration"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-2 mb-2 debuggerConfig custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "custom-control-input",
            id: "debugGeneratedSourcesInput",
            onChange: ({
              target: {
                checked
              }
            }) => {
              setState(prevState => {
                return _objectSpread(_objectSpread({}, prevState), {}, {
                  opt: _objectSpread(_objectSpread({}, prevState.opt), {}, {
                    debugWithGeneratedSources: checked
                  })
                });
              });
            },
            type: "checkbox",
            title: "Debug with generated sources"
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
            "data-id": "debugGeneratedSourcesLabel",
            className: "form-check-label custom-control-label",
            htmlFor: "debugGeneratedSourcesInput",
            children: ["Use generated sources (Solidity ", '>=', " v0.7.2)"]
          })]
        }), state.isLocalNodeUsed && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "mt-2 mb-2 debuggerConfig custom-control custom-checkbox",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            className: "custom-control-input",
            id: "debugWithLocalNodeInput",
            onChange: ({
              target: {
                checked
              }
            }) => {
              setState(prevState => {
                return _objectSpread(_objectSpread({}, prevState), {}, {
                  opt: _objectSpread(_objectSpread({}, prevState.opt), {}, {
                    debugWithLocalNode: checked
                  })
                });
              });
            },
            type: "checkbox",
            title: "Force the debugger to use the current local node"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            "data-id": "debugLocaNodeLabel",
            className: "form-check-label custom-control-label",
            htmlFor: "debugWithLocalNodeInput",
            children: "Force using local node"
          })]
        }), state.validationError && /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          className: "w-100 py-1 text-danger validationError",
          children: state.validationError
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_txBrowser.default, {
        requestDebug: requestDebug,
        unloadRequested: unloadRequested,
        updateTxNumberFlag: updateTxNumberFlag,
        transactionNumber: state.txNumber,
        debugging: state.debugging
      }), state.debugging && state.sourceLocationStatus && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "text-warning",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "fas fa-exclamation-triangle",
          "aria-hidden": "true"
        }), " ", state.sourceLocationStatus]
      }), !state.debugging && /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "fas fa-info-triangle",
          "aria-hidden": "true"
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          children: ["When Debugging with a transaction hash, if the contract is verified, Remix will try to fetch the source code from Sourcify or Etherscan. Put in your Etherscan API key in the Remix settings. For supported networks, please see: ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            href: "https://sourcify.dev",
            target: "__blank",
            children: "https://sourcify.dev"
          }), " & ", /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
            href: "https://sourcify.dev",
            target: "__blank",
            children: "https://etherscan.io/contractsVerified"
          })]
        })]
      }), state.debugging && /*#__PURE__*/(0, _jsxRuntime.jsx)(_stepManager.default, {
        stepManager: stepManager
      }), state.debugging && /*#__PURE__*/(0, _jsxRuntime.jsx)(_vmDebuggerHead.default, {
        vmDebugger: vmDebugger
      })]
    }), state.debugging && /*#__PURE__*/(0, _jsxRuntime.jsx)(_vmDebugger.default, {
      vmDebugger: vmDebugger,
      currentBlock: state.currentBlock,
      currentReceipt: state.currentReceipt,
      currentTransaction: state.currentTransaction
    })]
  });
};

exports.DebuggerUI = DebuggerUI;
var _default = DebuggerUI;
exports.default = _default;

/***/ }),
/* 2574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TxBrowser = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2575);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const TxBrowser = ({
  requestDebug,
  updateTxNumberFlag,
  unloadRequested,
  transactionNumber,
  debugging
}) => {
  const [state, setState] = (0, _react.useState)({
    txNumber: ''
  });
  const inputValue = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        txNumber: transactionNumber
      });
    });
  }, [transactionNumber]);

  const handleSubmit = () => {
    if (debugging) {
      unload();
    } else {
      requestDebug(undefined, state.txNumber);
    }
  };

  const unload = () => {
    unloadRequested();
  };

  const txInputChanged = value => {
    // todo check validation of txnumber in the input element, use
    // required
    // oninvalid="setCustomValidity('Please provide a valid transaction number, must start with 0x and have length of 22')"
    // pattern="^0[x,X]+[0-9a-fA-F]{22}"
    // this.state.txNumberInput.setCustomValidity('')
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        txNumber: value
      });
    });
  };

  const txInputOnInput = () => {
    updateTxNumberFlag(!inputValue.current.value);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "container px-0",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "txContainer",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "py-1 d-flex justify-content-center w-100 input-group",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          ref: inputValue,
          value: state.txNumber,
          className: "form-control m-0 txinput",
          id: "txinput",
          type: "text",
          onChange: ({
            target: {
              value
            }
          }) => txInputChanged(value),
          onInput: txInputOnInput,
          placeholder: 'Transaction hash, should start with 0x',
          "data-id": "debuggerTransactionInput",
          disabled: debugging
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "d-flex justify-content-center w-100 btn-group py-1",
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
          className: "btn btn-primary btn-sm txbutton",
          id: "load",
          title: debugging ? 'Stop debugging' : 'Start debugging',
          onClick: handleSubmit,
          "data-id": "debuggerTransactionStartButton",
          disabled: !state.txNumber,
          children: [debugging ? 'Stop' : 'Start', " debugging"]
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      id: "error"
    })]
  });
};

exports.TxBrowser = TxBrowser;
var _default = TxBrowser;
exports.default = _default;

/***/ }),
/* 2575 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2576);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2576 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".container {\n    display: flex;\n    flex-direction: column;\n}\n.txContainer {\n    display: flex;\n    flex-direction: column;\n}\n.txinput {\n    width: inherit;\n    font-size: small;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.txbutton {\n    width: inherit;\n}\n.txbutton:hover {\n}\n.vmargin {\n    margin-top: 10px;\n    margin-bottom: 10px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInR4LWJyb3dzZXIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtBQUMxQjtBQUNBO0lBQ0ksYUFBYTtJQUNiLHNCQUFzQjtBQUMxQjtBQUNBO0lBQ0ksY0FBYztJQUNkLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsZ0JBQWdCO0lBQ2hCLHVCQUF1QjtBQUMzQjtBQUNBO0lBQ0ksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtJQUNJLGdCQUFnQjtJQUNoQixtQkFBbUI7QUFDdkIiLCJmaWxlIjoidHgtYnJvd3Nlci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG4udHhDb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cbi50eGlucHV0IHtcbiAgICB3aWR0aDogaW5oZXJpdDtcbiAgICBmb250LXNpemU6IHNtYWxsO1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbn1cbi50eGJ1dHRvbiB7XG4gICAgd2lkdGg6IGluaGVyaXQ7XG59XG4udHhidXR0b246aG92ZXIge1xufVxuLnZtYXJnaW4ge1xuICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbn0iXX0= */", '', '']]

/***/ }),
/* 2577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StepManager = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _slider = _interopRequireDefault(__webpack_require__(2578));

var _buttonNavigator = _interopRequireDefault(__webpack_require__(2579));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// eslint-disable-line
const StepManager = ({
  stepManager: {
    jumpTo,
    traceLength,
    stepIntoBack,
    stepIntoForward,
    stepOverBack,
    stepOverForward,
    jumpOut,
    jumpNextBreakpoint,
    jumpPreviousBreakpoint,
    jumpToException,
    registerEvent
  }
}) => {
  const [state, setState] = (0, _react.useState)({
    sliderValue: 0,
    revertWarning: '',
    stepState: '',
    jumpOutDisabled: true
  });
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('revertWarning', setRevertWarning);
    registerEvent && registerEvent('stepChanged', updateStep);
  }, [registerEvent]);

  const setRevertWarning = warning => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        revertWarning: warning
      });
    });
  };

  const updateStep = (step, stepState, jumpOutDisabled) => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        sliderValue: step,
        stepState,
        jumpOutDisabled
      });
    });
  };

  const {
    sliderValue,
    revertWarning,
    stepState,
    jumpOutDisabled
  } = state;
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "py-1",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_slider.default, {
      jumpTo: jumpTo,
      sliderValue: sliderValue,
      traceLength: traceLength
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_buttonNavigator.default, {
      stepIntoBack: stepIntoBack,
      stepIntoForward: stepIntoForward,
      stepOverBack: stepOverBack,
      stepOverForward: stepOverForward,
      revertedReason: revertWarning,
      stepState: stepState,
      jumpOutDisabled: jumpOutDisabled,
      jumpOut: jumpOut,
      jumpNextBreakpoint: jumpNextBreakpoint,
      jumpPreviousBreakpoint: jumpPreviousBreakpoint,
      jumpToException: jumpToException
    })]
  });
};

exports.StepManager = StepManager;
var _default = StepManager;
exports.default = _default;

/***/ }),
/* 2578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Slider = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const Slider = ({
  jumpTo,
  sliderValue,
  traceLength
}) => {
  const onChangeId = (0, _react.useRef)(null);
  const slider = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    setValue(sliderValue);
  }, [sliderValue]);

  const setValue = value => {
    if (value === slider.current.value) return;
    slider.current.value = value;

    if (onChangeId.current) {
      clearTimeout(onChangeId.current);
    }

    (value => {
      onChangeId.current = setTimeout(() => {
        jumpTo && jumpTo(value);
      }, 100);
    })(value);
  };

  const handleChange = e => {
    setValue(parseInt(e.target.value));
  };

  if (slider.current) slider.current.internal_onmouseup = handleChange;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
      id: "slider",
      "data-id": "slider",
      className: "w-100 my-0",
      ref: slider,
      type: "range",
      min: 0,
      max: traceLength ? traceLength - 1 : 0,
      onMouseUp: handleChange,
      disabled: traceLength ? traceLength === 0 : true
    })
  });
};

exports.Slider = Slider;
var _default = Slider;
exports.default = _default;

/***/ }),
/* 2579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ButtonNavigation = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2580);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const ButtonNavigation = ({
  stepOverBack,
  stepIntoBack,
  stepIntoForward,
  stepOverForward,
  jumpOut,
  jumpPreviousBreakpoint,
  jumpNextBreakpoint,
  jumpToException,
  revertedReason,
  stepState,
  jumpOutDisabled
}) => {
  const [state, setState] = (0, _react.useState)({
    intoBackDisabled: true,
    overBackDisabled: true,
    intoForwardDisabled: true,
    overForwardDisabled: true,
    jumpOutDisabled: true,
    jumpNextBreakpointDisabled: true,
    jumpPreviousBreakpointDisabled: true
  });
  (0, _react.useEffect)(() => {
    stepChanged(stepState, jumpOutDisabled);
  }, [stepState, jumpOutDisabled]);

  const reset = () => {
    setState(() => {
      return {
        intoBackDisabled: true,
        overBackDisabled: true,
        intoForwardDisabled: true,
        overForwardDisabled: true,
        jumpOutDisabled: true,
        jumpNextBreakpointDisabled: true,
        jumpPreviousBreakpointDisabled: true
      };
    });
  };

  const stepChanged = (stepState, jumpOutDisabled) => {
    if (stepState === 'invalid') {
      // TODO: probably not necessary, already implicit done in the next steps
      reset();
      return;
    }

    setState(() => {
      return {
        intoBackDisabled: stepState === 'initial',
        overBackDisabled: stepState === 'initial',
        jumpPreviousBreakpointDisabled: stepState === 'initial',
        intoForwardDisabled: stepState === 'end',
        overForwardDisabled: stepState === 'end',
        jumpNextBreakpointDisabled: stepState === 'end',
        jumpOutDisabled: jumpOutDisabled !== null && jumpOutDisabled !== undefined ? jumpOutDisabled : true
      };
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "buttons",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "stepButtons btn-group py-1",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        id: "overback",
        className: "btn btn-primary btn-sm navigator stepButton fas fa-reply",
        title: "Step over back",
        onClick: () => {
          stepOverBack && stepOverBack();
        },
        disabled: state.overBackDisabled
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        id: "intoback",
        "data-id": "buttonNavigatorIntoBack",
        className: "btn btn-primary btn-sm navigator stepButton fas fa-level-up-alt",
        title: "Step back",
        onClick: () => {
          stepIntoBack && stepIntoBack();
        },
        disabled: state.intoBackDisabled
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        id: "intoforward",
        "data-id": "buttonNavigatorIntoForward",
        className: "btn btn-primary btn-sm navigator stepButton fas fa-level-down-alt",
        title: "Step into",
        onClick: () => {
          stepIntoForward && stepIntoForward();
        },
        disabled: state.intoForwardDisabled
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        id: "overforward",
        className: "btn btn-primary btn-sm navigator stepButton fas fa-share",
        title: "Step over forward",
        onClick: () => {
          stepOverForward && stepOverForward();
        },
        disabled: state.overForwardDisabled
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "jumpButtons btn-group py-1",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        className: "btn btn-primary btn-sm navigator jumpButton fas fa-step-backward",
        id: "jumppreviousbreakpoint",
        "data-id": "buttonNavigatorJumpPreviousBreakpoint",
        title: "Jump to the previous breakpoint",
        onClick: () => {
          jumpPreviousBreakpoint && jumpPreviousBreakpoint();
        },
        disabled: state.jumpPreviousBreakpointDisabled
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        className: "btn btn-primary btn-sm navigator jumpButton fas fa-eject",
        id: "jumpout",
        title: "Jump out",
        onClick: () => {
          jumpOut && jumpOut();
        },
        disabled: state.jumpOutDisabled
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
        className: "btn btn-primary btn-sm navigator jumpButton fas fa-step-forward",
        id: "jumpnextbreakpoint",
        "data-id": "buttonNavigatorJumpNextBreakpoint",
        title: "Jump to the next breakpoint",
        onClick: () => {
          jumpNextBreakpoint && jumpNextBreakpoint();
        },
        disabled: state.jumpNextBreakpointDisabled
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      id: "reverted",
      style: {
        display: revertedReason === '' ? 'none' : 'block'
      },
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "text-warning",
        children: "This call has reverted, state changes made during the call will be reverted."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "text-warning",
        id: "outofgas",
        style: {
          display: revertedReason === 'outofgas' ? 'inline' : 'none'
        },
        children: "This call will run out of gas."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "text-warning",
        id: "parenthasthrown",
        style: {
          display: revertedReason === 'parenthasthrown' ? 'inline' : 'none'
        },
        children: "The parent call will throw an exception"
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "text-warning",
        children: ["Click ", /*#__PURE__*/(0, _jsxRuntime.jsx)("u", {
          "data-id": "debugGoToRevert",
          className: "cursorPointerRemixDebugger",
          role: "button",
          onClick: () => {
            jumpToException && jumpToException();
          },
          children: "here"
        }), " to jump where the call reverted."]
      })]
    })]
  });
};

exports.ButtonNavigation = ButtonNavigation;
var _default = ButtonNavigation;
exports.default = _default;

/***/ }),
/* 2580 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2581);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2581 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".buttons {\n    display: flex;\n    flex-wrap: wrap;\n}\n.stepButtons {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n}\n.stepButton {\n}\n.jumpButtons {\n    width: 100%;\n    display: flex;\n    justify-content: center;\n}\n.jumpButton {\n}\n.navigator {\n}\n.navigator:hover {\n}\n.cursorPointerRemixDebugger {\n    cursor: pointer;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJ1dHRvbi1uYXZpZ2F0b3IuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksYUFBYTtJQUNiLGVBQWU7QUFDbkI7QUFDQTtJQUNJLFdBQVc7SUFDWCxhQUFhO0lBQ2IsdUJBQXVCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0lBQ0ksV0FBVztJQUNYLGFBQWE7SUFDYix1QkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtJQUNJLGVBQWU7QUFDbkIiLCJmaWxlIjoiYnV0dG9uLW5hdmlnYXRvci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuYnV0dG9ucyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG59XG4uc3RlcEJ1dHRvbnMge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uc3RlcEJ1dHRvbiB7XG59XG4uanVtcEJ1dHRvbnMge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG4uanVtcEJ1dHRvbiB7XG59XG4ubmF2aWdhdG9yIHtcbn1cbi5uYXZpZ2F0b3I6aG92ZXIge1xufVxuXG4uY3Vyc29yUG9pbnRlclJlbWl4RGVidWdnZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbn0iXX0= */", '', '']]

/***/ }),
/* 2582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VmDebugger = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _calldataPanel = _interopRequireDefault(__webpack_require__(2583));

var _memoryPanel = _interopRequireDefault(__webpack_require__(2587));

var _callstackPanel = _interopRequireDefault(__webpack_require__(2588));

var _stackPanel = _interopRequireDefault(__webpack_require__(2589));

var _storagePanel = _interopRequireDefault(__webpack_require__(2590));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _fullStoragesChanges = _interopRequireDefault(__webpack_require__(2591));

var _globalVariables = _interopRequireDefault(__webpack_require__(2592));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const VmDebugger = ({
  vmDebugger: {
    registerEvent
  },
  currentBlock,
  currentReceipt,
  currentTransaction
}) => {
  const [calldataPanel, setCalldataPanel] = (0, _react.useState)(null);
  const [memoryPanel, setMemoryPanel] = (0, _react.useState)(null);
  const [callStackPanel, setCallStackPanel] = (0, _react.useState)(null);
  const [stackPanel, setStackPanel] = (0, _react.useState)(null);
  const [storagePanel, setStoragePanel] = (0, _react.useState)({
    calldata: null,
    header: null
  });
  const [returnValuesPanel, setReturnValuesPanel] = (0, _react.useState)(null);
  const [fullStoragesChangesPanel, setFullStoragesChangesPanel] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('traceManagerCallDataUpdate', calldata => {
      setCalldataPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerMemoryUpdate', calldata => {
      setMemoryPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerCallStackUpdate', calldata => {
      setCallStackPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerStackUpdate', calldata => {
      setStackPanel(() => calldata);
    });
    registerEvent && registerEvent('traceManagerStorageUpdate', (calldata, header) => {
      setStoragePanel(() => {
        return {
          calldata,
          header
        };
      });
    });
    registerEvent && registerEvent('traceReturnValueUpdate', calldata => {
      setReturnValuesPanel(() => calldata);
    });
    registerEvent && registerEvent('traceAddressesUpdate', calldata => {
      setFullStoragesChangesPanel(() => {
        return {};
      });
    });
    registerEvent && registerEvent('traceStorageUpdate', calldata => {
      setFullStoragesChangesPanel(() => calldata);
    });
  }, [registerEvent]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "vmdebugger",
    className: "px-2",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_stackPanel.default, {
        calldata: stackPanel
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_memoryPanel.default, {
        calldata: memoryPanel
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_storagePanel.default, {
        calldata: storagePanel.calldata,
        header: storagePanel.header
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_callstackPanel.default, {
        calldata: callStackPanel
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_calldataPanel.default, {
        calldata: calldataPanel
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_globalVariables.default, {
        block: currentBlock,
        receipt: currentReceipt,
        tx: currentTransaction
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
        dropdownName: "Return Value",
        calldata: returnValuesPanel || {}
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_fullStoragesChanges.default, {
        calldata: fullStoragesChangesPanel
      })]
    })
  });
};

exports.VmDebugger = VmDebugger;
var _default = VmDebugger;
exports.default = _default;

/***/ }),
/* 2583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CalldataPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const CalldataPanel = ({
  calldata
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "calldatapanel",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      dropdownName: "Call Data",
      calldata: calldata || {}
    })
  });
};

exports.CalldataPanel = CalldataPanel;
var _default = CalldataPanel;
exports.default = _default;

/***/ }),
/* 2584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = exports.initialState = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const initialState = {
  calldata: {},
  isRequesting: false,
  isSuccessful: false,
  hasError: null
};
exports.initialState = initialState;

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_CALLDATA_REQUEST':
      return _objectSpread(_objectSpread({}, state), {}, {
        isRequesting: true,
        isSuccessful: false,
        hasError: null
      });

    case 'FETCH_CALLDATA_SUCCESS':
      return {
        calldata: action.payload,
        isRequesting: false,
        isSuccessful: true,
        hasError: null
      };

    case 'FETCH_CALLDATA_ERROR':
      return _objectSpread(_objectSpread({}, state), {}, {
        isRequesting: false,
        isSuccessful: false,
        hasError: action.payload
      });

    case 'UPDATE_CALLDATA_REQUEST':
      return _objectSpread(_objectSpread({}, state), {}, {
        isRequesting: true,
        isSuccessful: false,
        hasError: null
      });

    case 'UPDATE_CALLDATA_SUCCESS':
      return {
        calldata: mergeLocals(action.payload, state.calldata),
        isRequesting: false,
        isSuccessful: true,
        hasError: null
      };

    case 'UPDATE_CALLDATA_ERROR':
      return _objectSpread(_objectSpread({}, state), {}, {
        isRequesting: false,
        isSuccessful: false,
        hasError: action.payload
      });

    default:
      throw new Error();
  }
};

exports.reducer = reducer;

function mergeLocals(locals1, locals2) {
  Object.keys(locals2).map(item => {
    if (locals2[item].cursor && parseInt(locals2[item].cursor) < parseInt(locals1[item].cursor)) {
      locals2[item] = _objectSpread(_objectSpread({}, locals1[item]), {}, {
        value: [...locals2[item].value, ...locals1[item].value]
      });
    }
  });
  return locals2;
}

/***/ }),
/* 2585 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2586);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2586 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".title {\n    display: flex;\n    align-items: center;\n  }\n  .name {\n    font-weight: bold;\n  }\n  .nameDetail {\n    font-weight: bold;\n    margin-left: 3px;\n  }\n  .icon {\n    margin-right: 5%;\n  }\n  .eyeButton {\n    margin: 3px;\n  }\n  .dropdownpanel {\n    width: 100%;\n    word-break: break-word;\n  }\n  .dropdownrawcontent {\n    padding: 2px;\n    word-break: break-word;\n  }\n  .message {\n    padding: 2px;\n    word-break: break-word;\n  }\n  .refresh {\n    display: none;\n    margin-left: 4px;\n    margin-top: 4px; \n    -webkit-animation: spin 2s linear infinite; \n            animation: spin 2s linear infinite;\n  }\n  .cursor_pointer {\n    cursor: pointer;\n  }\n  @-webkit-keyframes spin {\n    to { -webkit-transform: rotate(359deg); }\n  }\n  @keyframes spin {\n    to {transform:rotate(359deg);}\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRyb3Bkb3duLXBhbmVsLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLGFBQWE7SUFDYixtQkFBbUI7RUFDckI7RUFDQTtJQUNFLGlCQUFpQjtFQUNuQjtFQUNBO0lBQ0UsaUJBQWlCO0lBQ2pCLGdCQUFnQjtFQUNsQjtFQUNBO0lBQ0UsZ0JBQWdCO0VBQ2xCO0VBQ0E7SUFDRSxXQUFXO0VBQ2I7RUFDQTtJQUNFLFdBQVc7SUFDWCxzQkFBc0I7RUFDeEI7RUFDQTtJQUNFLFlBQVk7SUFDWixzQkFBc0I7RUFDeEI7RUFDQTtJQUNFLFlBQVk7SUFDWixzQkFBc0I7RUFDeEI7RUFDQTtJQUNFLGFBQWE7SUFDYixnQkFBZ0I7SUFDaEIsZUFBZTtJQUNmLDBDQUFrQztZQUFsQyxrQ0FBa0M7RUFDcEM7RUFDQTtJQUNFLGVBQWU7RUFDakI7RUFJQTtJQUNFLEtBQUssaUNBQWlDLEVBQUU7RUFDMUM7RUFDQTtJQUNFLElBQUksd0JBQXdCLENBQUM7RUFDL0IiLCJmaWxlIjoiZHJvcGRvd24tcGFuZWwuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnRpdGxlIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgLm5hbWUge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICB9XG4gIC5uYW1lRGV0YWlsIHtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBtYXJnaW4tbGVmdDogM3B4O1xuICB9XG4gIC5pY29uIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDUlO1xuICB9XG4gIC5leWVCdXR0b24ge1xuICAgIG1hcmdpbjogM3B4O1xuICB9XG4gIC5kcm9wZG93bnBhbmVsIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICB9XG4gIC5kcm9wZG93bnJhd2NvbnRlbnQge1xuICAgIHBhZGRpbmc6IDJweDtcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICB9XG4gIC5tZXNzYWdlIHtcbiAgICBwYWRkaW5nOiAycHg7XG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgfVxuICAucmVmcmVzaCB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xuICAgIG1hcmdpbi10b3A6IDRweDsgXG4gICAgYW5pbWF0aW9uOiBzcGluIDJzIGxpbmVhciBpbmZpbml0ZTtcbiAgfVxuICAuY3Vyc29yX3BvaW50ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxuICBALW1vei1rZXlmcmFtZXMgc3BpbiB7XG4gICAgdG8geyAtbW96LXRyYW5zZm9ybTogcm90YXRlKDM1OWRlZyk7IH1cbiAgfVxuICBALXdlYmtpdC1rZXlmcmFtZXMgc3BpbiB7XG4gICAgdG8geyAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM1OWRlZyk7IH1cbiAgfVxuICBAa2V5ZnJhbWVzIHNwaW4ge1xuICAgIHRvIHt0cmFuc2Zvcm06cm90YXRlKDM1OWRlZyk7fVxuICB9Il19 */", '', '']]

/***/ }),
/* 2587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MemoryPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const MemoryPanel = ({
  calldata
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
    hexHighlight: true,
    bodyStyle: {
      fontFamily: 'monospace'
    },
    dropdownName: "Memory",
    calldata: calldata || {}
  });
};

exports.MemoryPanel = MemoryPanel;
var _default = MemoryPanel;
exports.default = _default;

/***/ }),
/* 2588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CallstackPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const CallstackPanel = ({
  calldata
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "callstackpanel",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      dropdownName: "Call Stack",
      calldata: calldata || {}
    })
  });
};

exports.CallstackPanel = CallstackPanel;
var _default = CallstackPanel;
exports.default = _default;

/***/ }),
/* 2589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StackPanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const StackPanel = ({
  calldata
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "stackpanel",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      hexHighlight: true,
      bodyStyle: {
        fontFamily: 'monospace'
      },
      dropdownName: "Stack",
      calldata: calldata || {}
    })
  });
};

exports.StackPanel = StackPanel;
var _default = StackPanel;
exports.default = _default;

/***/ }),
/* 2590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StoragePanel = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const StoragePanel = ({
  calldata,
  header
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "storagepanel",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      dropdownName: "Storage",
      calldata: calldata || {},
      header: header
    })
  });
};

exports.StoragePanel = StoragePanel;
var _default = StoragePanel;
exports.default = _default;

/***/ }),
/* 2591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FullStoragesChanges = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = __webpack_require__(1148);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const FullStoragesChanges = ({
  calldata
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "fullstorageschangespanel",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.DropdownPanel, {
      dropdownName: "Full Storage Changes",
      calldata: calldata || {}
    })
  });
};

exports.FullStoragesChanges = FullStoragesChanges;
var _default = FullStoragesChanges;
exports.default = _default;

/***/ }),
/* 2592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.GlobalVariables = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _web = _interopRequireDefault(__webpack_require__(1125));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
const GlobalVariables = ({
  block,
  receipt,
  tx
}) => {
  // see https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties
  const globals = {
    'block.chainid': tx.chainId,
    'block.coinbase': block.miner,
    'block.difficulty': block.difficulty,
    'block.gaslimit': block.gasLimit,
    'block.number': block.number,
    'block.timestamp': block.timestamp,
    'msg.sender': tx.from,
    'msg.sig': tx.input.substring(0, 10),
    'msg.value': tx.value + ' Wei',
    'tx.origin': tx.from
  };

  if (block.baseFeePerGas) {
    globals['block.basefee'] = _web.default.utils.toBN(block.baseFeePerGas).toString(10) + ` Wei (${block.baseFeePerGas})`;
  }

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "globalvariable",
    "data-id": "globalvariable",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      hexHighlight: false,
      bodyStyle: {
        fontFamily: 'monospace'
      },
      dropdownName: "Global Variables",
      calldata: globals || {}
    })
  });
};

exports.GlobalVariables = GlobalVariables;
var _default = GlobalVariables;
exports.default = _default;

/***/ }),
/* 2593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VmDebuggerHead = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _codeListView = _interopRequireDefault(__webpack_require__(2594));

var _functionPanel = _interopRequireDefault(__webpack_require__(2612));

var _stepDetail = _interopRequireDefault(__webpack_require__(2613));

var _solidityState = _interopRequireDefault(__webpack_require__(2614));

var _solidityLocals = _interopRequireDefault(__webpack_require__(2615));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// eslint-disable-line
const VmDebuggerHead = ({
  vmDebugger: {
    registerEvent,
    triggerEvent
  }
}) => {
  const [functionPanel, setFunctionPanel] = (0, _react.useState)(null);
  const [stepDetail, setStepDetail] = (0, _react.useState)({
    'vm trace step': '-',
    'execution step': '-',
    'add memory': '',
    gas: '',
    'remaining gas': '-',
    'loaded address': '-'
  });
  const [solidityState, setSolidityState] = (0, _react.useState)({
    calldata: null,
    message: null
  });
  const [solidityLocals, setSolidityLocals] = (0, _react.useState)({
    calldata: null,
    message: null
  });
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('functionsStackUpdate', stack => {
      if (stack === null || stack.length === 0) return;
      const functions = [];

      for (const func of stack) {
        functions.push(func.functionDefinition.name + '(' + func.inputs.join(', ') + ')');
      }

      setFunctionPanel(() => functions);
    });
    registerEvent && registerEvent('traceUnloaded', () => {
      setStepDetail(() => {
        return {
          'vm trace step': '-',
          'execution step': '-',
          'add memory': '',
          gas: '',
          'remaining gas': '-',
          'loaded address': '-'
        };
      });
    });
    registerEvent && registerEvent('newTraceLoaded', () => {
      setStepDetail(() => {
        return {
          'vm trace step': '-',
          'execution step': '-',
          'add memory': '',
          gas: '',
          'remaining gas': '-',
          'loaded address': '-'
        };
      });
    });
    registerEvent && registerEvent('traceCurrentStepUpdate', (error, step) => {
      setStepDetail(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          'execution step': error ? '-' : step
        });
      });
    });
    registerEvent && registerEvent('traceMemExpandUpdate', (error, addmem) => {
      setStepDetail(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          'add memory': error ? '-' : addmem
        });
      });
    });
    registerEvent && registerEvent('traceStepCostUpdate', (error, gas) => {
      setStepDetail(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          gas: error ? '-' : gas
        });
      });
    });
    registerEvent && registerEvent('traceCurrentCalledAddressAtUpdate', (error, address) => {
      setStepDetail(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          'loaded address': error ? '-' : address
        });
      });
    });
    registerEvent && registerEvent('traceRemainingGasUpdate', (error, remainingGas) => {
      setStepDetail(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          'remaining gas': error ? '-' : remainingGas
        });
      });
    });
    registerEvent && registerEvent('indexUpdate', index => {
      setStepDetail(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          'vm trace step': index
        });
      });
    });
    registerEvent && registerEvent('solidityState', calldata => {
      setSolidityState(() => {
        return _objectSpread(_objectSpread({}, solidityState), {}, {
          calldata
        });
      });
    });
    registerEvent && registerEvent('solidityStateMessage', message => {
      setSolidityState(() => {
        return _objectSpread(_objectSpread({}, solidityState), {}, {
          message
        });
      });
    });
    registerEvent && registerEvent('solidityLocals', calldata => {
      setSolidityLocals(() => {
        return _objectSpread(_objectSpread({}, solidityLocals), {}, {
          calldata
        });
      });
    });
    registerEvent && registerEvent('solidityLocalsMessage', message => {
      setSolidityLocals(() => {
        return _objectSpread(_objectSpread({}, solidityLocals), {}, {
          message
        });
      });
    });
  }, [registerEvent]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "vmheadView",
    className: "mt-1 px-0",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "d-flex flex-column",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "w-100",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_functionPanel.default, {
          data: functionPanel
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_solidityLocals.default, {
          data: solidityLocals.calldata,
          message: solidityLocals.message,
          registerEvent: registerEvent,
          triggerEvent: triggerEvent
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_solidityState.default, {
          calldata: solidityState.calldata,
          message: solidityState.message
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "w-100",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_codeListView.default, {
          registerEvent: registerEvent
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "w-100",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_stepDetail.default, {
          stepDetail: stepDetail
        })
      })]
    })
  });
};

exports.VmDebuggerHead = VmDebuggerHead;
var _default = VmDebuggerHead;
exports.default = _default;

/***/ }),
/* 2594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CodeListView = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _assemblyItems = _interopRequireDefault(__webpack_require__(2595));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const CodeListView = ({
  registerEvent
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "asmcodes",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_assemblyItems.default, {
      registerEvent: registerEvent
    })
  });
};

exports.CodeListView = CodeListView;
var _default = CodeListView;
exports.default = _default;

/***/ }),
/* 2595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AssemblyItems = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _assemblyItems = __webpack_require__(2596);

__webpack_require__(2610);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const AssemblyItems = ({
  registerEvent
}) => {
  const [assemblyItems, dispatch] = (0, _react.useReducer)(_assemblyItems.reducer, _assemblyItems.initialState);
  const [absoluteSelectedIndex, setAbsoluteSelectedIndex] = (0, _react.useState)(0);
  const [selectedItem, setSelectedItem] = (0, _react.useState)(0);
  const [nextSelectedItems, setNextSelectedItems] = (0, _react.useState)([1]);
  const [returnInstructionIndexes, setReturnInstructionIndexes] = (0, _react.useState)([]);
  const [outOfGasInstructionIndexes, setOutOfGasInstructionIndexes] = (0, _react.useState)([]);
  const refs = (0, _react.useRef)({});
  const asmItemsRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    registerEvent && registerEvent('codeManagerChanged', (code, address, index, nextIndexes, returnInstructionIndexes, outOfGasInstructionIndexes) => {
      dispatch({
        type: 'FETCH_OPCODES_SUCCESS',
        payload: {
          code,
          address,
          index,
          nextIndexes,
          returnInstructionIndexes,
          outOfGasInstructionIndexes
        }
      });
    });
  }, []);
  (0, _react.useEffect)(() => {
    if (absoluteSelectedIndex !== assemblyItems.index) {
      clearItems();
      indexChanged(assemblyItems.index);
      nextIndexesChanged(assemblyItems.nextIndexes);
      returnIndexes(assemblyItems.returnInstructionIndexes);
      outOfGasIndexes(assemblyItems.outOfGasInstructionIndexes);
    }
  }, [assemblyItems.opCodes.index]);

  const clearItem = currentItem => {
    if (currentItem) {
      currentItem.removeAttribute('selected');
      currentItem.removeAttribute('style');

      if (currentItem.firstChild) {
        currentItem.firstChild.removeAttribute('style');
      }
    }
  };

  const clearItems = () => {
    clearItem(refs.current[selectedItem] ? refs.current[selectedItem] : null);

    if (nextSelectedItems) {
      nextSelectedItems.map(index => {
        clearItem(refs.current[index] ? refs.current[index] : null);
      });
    }

    returnInstructionIndexes.map(index => {
      if (index < 0) return;
      clearItem(refs.current[index] ? refs.current[index] : null);
    });
    outOfGasInstructionIndexes.map(index => {
      if (index < 0) return;
      clearItem(refs.current[index] ? refs.current[index] : null);
    });
  };

  const indexChanged = index => {
    if (index < 0) return;
    const codeView = asmItemsRef.current;
    const currentItem = codeView.children[index];

    if (currentItem) {
      currentItem.style.setProperty('background-color', 'var(--primary)');
      currentItem.style.setProperty('color', 'var(--light)');
      currentItem.setAttribute('selected', 'selected');
      codeView.scrollTop = currentItem.offsetTop - parseInt(codeView.offsetTop);
    }

    setSelectedItem(index);
    setAbsoluteSelectedIndex(assemblyItems.opCodes.index);
  };

  const nextIndexesChanged = indexes => {
    indexes.map(index => {
      if (index < 0) return;
      const codeView = asmItemsRef.current;
      const currentItem = codeView.children[index];

      if (currentItem) {
        currentItem.style.setProperty('color', 'var(--primary)');
        currentItem.style.setProperty('font-weight', 'bold');
        currentItem.setAttribute('selected', 'selected');
      }
    });
    setNextSelectedItems(indexes);
  };

  const returnIndexes = indexes => {
    indexes.map(index => {
      if (index < 0) return;
      const codeView = asmItemsRef.current;
      const currentItem = codeView.children[index];

      if (currentItem) {
        currentItem.style.setProperty('border-style', 'dotted');
        currentItem.setAttribute('selected', 'selected');
      }
    });
    setReturnInstructionIndexes(indexes);
  };

  const outOfGasIndexes = indexes => {
    indexes.map(index => {
      if (index < 0) return;
      const codeView = asmItemsRef.current;
      const currentItem = codeView.children[index];

      if (currentItem) {
        currentItem.style.setProperty('border-color', 'var(--danger)');
        currentItem.style.setProperty('border-style', 'dotted');
        currentItem.setAttribute('selected', 'selected');
      }
    });
    setOutOfGasInstructionIndexes(indexes);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "border rounded px-1 mt-1 bg-light",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "dropdownpanel",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "dropdowncontent",
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "pl-2 my-1 small instructions",
          "data-id": "asmitems",
          id: "asmitems",
          ref: asmItemsRef,
          children: assemblyItems.display.map((item, i) => {
            return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
              className: "px-1",
              ref: ref => {
                refs.current[i] = ref;
              },
              children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                children: item
              })
            }, i);
          })
        })
      })
    })
  });
};

exports.AssemblyItems = AssemblyItems;
var _default = AssemblyItems;
exports.default = _default;

/***/ }),
/* 2596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = exports.initialState = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _deepEqual = _interopRequireDefault(__webpack_require__(1369));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const initialState = {
  opCodes: {
    code: [],
    index: 0,
    address: ''
  },
  display: [],
  index: 0,
  nextIndexes: [-1],
  returnInstructionIndexes: [],
  outOfGasInstructionIndexes: [],
  top: 0,
  bottom: 0,
  isRequesting: false,
  isSuccessful: false,
  hasError: null
};
exports.initialState = initialState;

const reducedOpcode = (opCodes, payload) => {
  const length = 100;
  let bottom = opCodes.index - 10;
  bottom = bottom < 0 ? 0 : bottom;
  const top = bottom + length;
  return {
    index: opCodes.index - bottom,
    nextIndexes: opCodes.nextIndexes.map(index => index - bottom),
    display: opCodes.code.slice(bottom, top),
    returnInstructionIndexes: payload.returnInstructionIndexes.map(index => index.instructionIndex - bottom),
    outOfGasInstructionIndexes: payload.outOfGasInstructionIndexes.map(index => index.instructionIndex - bottom)
  };
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_OPCODES_REQUEST':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          isRequesting: true,
          isSuccessful: false,
          hasError: null
        });
      }

    case 'FETCH_OPCODES_SUCCESS':
      {
        const opCodes = action.payload.address === state.opCodes.address ? _objectSpread(_objectSpread({}, state.opCodes), {}, {
          index: action.payload.index,
          nextIndexes: action.payload.nextIndexes
        }) : (0, _deepEqual.default)(action.payload.code, state.opCodes.code) ? state.opCodes : action.payload;
        const reduced = reducedOpcode(opCodes, action.payload);
        return {
          opCodes,
          display: reduced.display,
          index: reduced.index,
          nextIndexes: reduced.nextIndexes,
          isRequesting: false,
          isSuccessful: true,
          hasError: null,
          returnInstructionIndexes: reduced.returnInstructionIndexes,
          outOfGasInstructionIndexes: reduced.outOfGasInstructionIndexes
        };
      }

    case 'FETCH_OPCODES_ERROR':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          isRequesting: false,
          isSuccessful: false,
          hasError: action.payload
        });
      }

    default:
      throw new Error();
  }
};

exports.reducer = reducer;

/***/ }),
/* 2597 */,
/* 2598 */,
/* 2599 */,
/* 2600 */,
/* 2601 */,
/* 2602 */,
/* 2603 */,
/* 2604 */,
/* 2605 */,
/* 2606 */,
/* 2607 */,
/* 2608 */,
/* 2609 */,
/* 2610 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2611);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2611 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".instructions {\n    overflow-y: scroll;\n    max-height: 130px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2VtYmx5LWl0ZW1zLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLGtCQUFrQjtJQUNsQixpQkFBaUI7QUFDckIiLCJmaWxlIjoiYXNzZW1ibHktaXRlbXMuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmluc3RydWN0aW9ucyB7XG4gICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICAgIG1heC1oZWlnaHQ6IDEzMHB4O1xufSJdfQ== */", '', '']]

/***/ }),
/* 2612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FunctionPanel = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _deepEqual = _interopRequireDefault(__webpack_require__(1369));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const FunctionPanel = ({
  data
}) => {
  const [calldata, setCalldata] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    if (!(0, _deepEqual.default)(calldata, data)) setCalldata(data);
  }, [data]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "FunctionPanel",
    "data-id": "functionPanel",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      dropdownName: "Function Stack",
      calldata: calldata || {}
    })
  });
};

exports.FunctionPanel = FunctionPanel;
var _default = FunctionPanel;
exports.default = _default;

/***/ }),
/* 2613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StepDetail = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
const StepDetail = ({
  stepDetail
}) => {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "stepdetail",
    "data-id": "stepdetail",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      hexHighlight: false,
      dropdownName: "Step details",
      calldata: stepDetail || {}
    })
  });
};

exports.StepDetail = StepDetail;
var _default = StepDetail;
exports.default = _default;

/***/ }),
/* 2614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SolidityState = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _solidityTypeFormatter = __webpack_require__(1600);

var _jsxRuntime = __webpack_require__(46);

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const SolidityState = ({
  calldata,
  message
}) => {
  const formatSelf = (key, data) => {
    try {
      let color = 'var(--primary)';

      if (data.isArray || data.isStruct || data.isMapping) {
        color = 'var(--info)';
      } else if (data.type.indexOf('uint') === 0 || data.type.indexOf('int') === 0 || data.type.indexOf('bool') === 0 || data.type.indexOf('enum') === 0) {
        color = 'var(--green)';
      } else if (data.type === 'string') {
        color = 'var(--teal)';
      } else if (data.self == 0x0) {
        // eslint-disable-line
        color = 'var(--gray)';
      }

      return /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
        className: "mb-0",
        style: {
          color: data.isProperty ? 'var(--info)' : '',
          whiteSpace: 'pre-wrap'
        },
        children: [' ' + key, ":", /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "mb-0",
          style: {
            color
          },
          children: ' ' + data.self
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          style: {
            fontStyle: 'italic'
          },
          children: data.isProperty || !data.type ? '' : ' ' + data.type
        })]
      });
    } catch (e) {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {});
    }
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "soliditystate",
    "data-id": "soliditystate",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      dropdownName: "Solidity State",
      calldata: calldata || {},
      formatSelfFunc: formatSelf,
      extractFunc: _solidityTypeFormatter.extractData
    })
  });
};

exports.SolidityState = SolidityState;
var _default = SolidityState;
exports.default = _default;

/***/ }),
/* 2615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SolidityLocals = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _dropdownPanel = _interopRequireDefault(__webpack_require__(1148));

var _solidityTypeFormatter = __webpack_require__(1600);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const SolidityLocals = ({
  data,
  message,
  registerEvent,
  triggerEvent
}) => {
  const [calldata, setCalldata] = (0, _react.useState)(null);
  (0, _react.useEffect)(() => {
    data && setCalldata(data);
  }, [data]);

  const formatSelf = (key, data) => {
    let color = 'var(--primary)';

    if (data.isArray || data.isStruct || data.isMapping) {
      color = 'var(--info)';
    } else if (data.type.indexOf('uint') === 0 || data.type.indexOf('int') === 0 || data.type.indexOf('bool') === 0 || data.type.indexOf('enum') === 0) {
      color = 'var(--green)';
    } else if (data.type === 'string') {
      color = 'var(--teal)';
    } else if (data.self == 0x0) {
      // eslint-disable-line
      color = 'var(--gray)';
    }

    if (data.type === 'string') {
      data.self = JSON.stringify(data.self);
    }

    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("label", {
      className: "mb-0",
      style: {
        color: data.isProperty ? 'var(--info)' : '',
        whiteSpace: 'pre-wrap'
      },
      children: [' ' + key, ":", /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        className: "mb-0",
        style: {
          color
        },
        children: ' ' + data.self
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        style: {
          fontStyle: 'italic'
        },
        children: data.isProperty || !data.type ? '' : ' ' + data.type
      })]
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    id: "soliditylocals",
    "data-id": "solidityLocals",
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_dropdownPanel.default, {
      dropdownName: "Solidity Locals",
      dropdownMessage: message,
      calldata: calldata || {},
      extractFunc: _solidityTypeFormatter.extractData,
      formatSelfFunc: formatSelf,
      registerEvent: registerEvent,
      triggerEvent: triggerEvent,
      loadMoreEvent: "solidityLocalsLoadMore",
      loadMoreCompletedEvent: "solidityLocalsLoadMoreCompleted"
    })
  });
};

exports.SolidityLocals = SolidityLocals;
var _default = SolidityLocals;
exports.default = _default;

/***/ }),
/* 2616 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2617);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2617 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".statusMessage {\n  margin-left: 15px;\n}\n.debuggerLabel {\n  margin-bottom: 2px;\n  font-size: 11px;\n  line-height: 12px;\n  text-transform: uppercase;\n}\n.debuggerConfig {\n  display: flex;\n  align-items: center;\n}\n.debuggerConfig label {\n  margin: 0;\n}\n.validationError {\n  overflow-wrap: break-word;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlYnVnZ2VyLXVpLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0Usa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixpQkFBaUI7RUFDakIseUJBQXlCO0FBQzNCO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxTQUFTO0FBQ1g7QUFDQTtFQUNFLHlCQUF5QjtBQUMzQiIsImZpbGUiOiJkZWJ1Z2dlci11aS5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuc3RhdHVzTWVzc2FnZSB7XG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xufVxuLmRlYnVnZ2VyTGFiZWwge1xuICBtYXJnaW4tYm90dG9tOiAycHg7XG4gIGZvbnQtc2l6ZTogMTFweDtcbiAgbGluZS1oZWlnaHQ6IDEycHg7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG59XG4uZGVidWdnZXJDb25maWcge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuLmRlYnVnZ2VyQ29uZmlnIGxhYmVsIHtcbiAgbWFyZ2luOiAwO1xufVxuLnZhbGlkYXRpb25FcnJvciB7XG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XG59Il19 */", '', '']]

/***/ }),
/* 2618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 2619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debuggerApi = __webpack_require__(2620);

Object.keys(_debuggerApi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _debuggerApi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _debuggerApi[key];
    }
  });
});

/***/ }),
/* 2620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerApiMixin = exports.CompilerAbstract = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _web = _interopRequireDefault(__webpack_require__(1125));

var _remixDebug = _interopRequireWildcard(__webpack_require__(1217));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DebuggerApiMixin = Base => class extends Base {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "initialWeb3", void 0);
  }

  initDebuggerApi() {
    this.debugHash = null;
    const self = this;
    this.web3Provider = {
      sendAsync(payload, callback) {
        self.call('web3Provider', 'sendAsync', payload).then(result => callback(null, result)).catch(e => callback(e));
      }

    };
    this._web3 = new _web.default(this.web3Provider); // this._web3 can be overwritten and reset to initial value in 'debug' method

    this.initialWeb3 = this._web3;

    _remixDebug.default.init.extendWeb3(this._web3);

    this.offsetToLineColumnConverter = {
      async offsetToLineColumn(rawLocation, file, sources, asts) {
        return await self.call('offsetToLineColumnConverter', 'offsetToLineColumn', rawLocation, file, sources, asts);
      }

    };
  } // on()
  // call()
  // onDebugRequested()
  // onRemoveHighlights()


  web3() {
    return this._web3;
  }

  async discardHighlight() {
    await this.call('editor', 'discardHighlight');
  }

  async highlight(lineColumnPos, path) {
    await this.call('editor', 'highlight', lineColumnPos, path, '', {
      focus: true
    });
  }

  async getFile(path) {
    return await this.call('fileManager', 'getFile', path);
  }

  async setFile(path, content) {
    await this.call('fileManager', 'setFile', path, content);
  }

  onBreakpointCleared(listener) {
    this.onBreakpointClearedListener = listener;
  }

  onBreakpointAdded(listener) {
    this.onBreakpointAddedListener = listener;
  }

  onEditorContentChanged(listener) {
    this.onEditorContentChangedListener = listener;
  }

  onEnvChanged(listener) {
    this.onEnvChangedListener = listener;
  }

  onDebugRequested(listener) {
    this.onDebugRequestedListener = listener;
  }

  onRemoveHighlights(listener) {
    this.onRemoveHighlightsListener = listener;
  }

  async fetchContractAndCompile(address, receipt) {
    const target = address && _remixDebug.default.traceHelper.isContractCreation(address) ? receipt.contractAddress : address;
    const targetAddress = target || receipt.contractAddress || receipt.to;
    const codeAtAddress = await this._web3.eth.getCode(targetAddress);
    const output = await this.call('fetchAndCompile', 'resolve', targetAddress, codeAtAddress, '.debug');

    if (output) {
      return new CompilerAbstract(output.languageversion, output.data, output.source);
    }

    return null;
  }

  async getDebugWeb3() {
    let web3;
    let network;

    try {
      network = await this.call('network', 'detectNetwork');
    } catch (e) {
      web3 = this.web3();
    }

    if (!web3) {
      const webDebugNode = _remixDebug.default.init.web3DebugNode(network.name);

      web3 = !webDebugNode ? this.web3() : webDebugNode;
    }

    _remixDebug.default.init.extendWeb3(web3);

    return web3;
  }

  async getTrace(hash) {
    var _this = this;

    if (!hash) return;
    const web3 = await this.getDebugWeb3();
    const currentReceipt = await web3.eth.getTransactionReceipt(hash);
    const debug = new _remixDebug.TransactionDebugger({
      web3,
      offsetToLineColumnConverter: this.offsetToLineColumnConverter,
      compilationResult: async function (address) {
        try {
          return await _this.fetchContractAndCompile(address, currentReceipt);
        } catch (e) {
          console.error(e);
        }

        return null;
      },
      debugWithGeneratedSources: false
    });
    return await debug.debugger.traceManager.getTrace(hash);
  }

  debug(hash, web3) {
    try {
      this.call('fetchAndCompile', 'clearCache');
    } catch (e) {
      console.error(e);
    }

    this.debugHash = hash;
    if (web3) this._web3 = web3;else this._web3 = this.initialWeb3;

    _remixDebug.default.init.extendWeb3(this._web3);

    if (this.onDebugRequestedListener) this.onDebugRequestedListener(hash, web3);
  }

  onActivation() {
    this.on('editor', 'breakpointCleared', (fileName, row) => {
      if (this.onBreakpointClearedListener) this.onBreakpointClearedListener(fileName, row);
    });
    this.on('editor', 'breakpointAdded', (fileName, row) => {
      if (this.onBreakpointAddedListener) this.onBreakpointAddedListener(fileName, row);
    });
    this.on('editor', 'contentChanged', () => {
      if (this.onEditorContentChangedListener) this.onEditorContentChangedListener();
    });
    this.on('network', 'providerChanged', provider => {
      if (this.onEnvChangedListener) this.onEnvChangedListener(provider);
    });
  }

  onDeactivation() {
    if (this.onRemoveHighlightsListener) this.onRemoveHighlightsListener();
    this.off('editor', 'breakpointCleared');
    this.off('editor', 'breakpointAdded');
    this.off('editor', 'contentChanged');
  }

  showMessage(title, message) {}

};

exports.DebuggerApiMixin = DebuggerApiMixin;

class CompilerAbstract {
  // this is a subset of /remix-ide/src/app/compiler/compiler-abstract.js
  constructor(languageversion, data, source) {
    (0, _defineProperty2.default)(this, "languageversion", void 0);
    (0, _defineProperty2.default)(this, "data", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    this.languageversion = languageversion;
    this.data = data;
    this.source = source; // source code
  }

  getSourceName(fileIndex) {
    if (this.data && this.data.sources) {
      return Object.keys(this.data.sources)[fileIndex];
    } else if (Object.keys(this.source.sources).length === 1) {
      // if we don't have ast, we return the only one filename present.
      const sourcesArray = Object.keys(this.source.sources);
      return sourcesArray[0];
    }

    return null;
  }

}

exports.CompilerAbstract = CompilerAbstract;

/***/ }),
/* 2621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(219);

var he = _interopRequireWildcard(__webpack_require__(2622));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * remixBleach
 * a minimal html sanitizer
 * credits to cam@onswipe.com
 */
var remixBleach = {
  matcher: /<\/?([a-zA-Z0-9]+)*(.*?)\/?>/igm,
  whitelist: ['a', 'b', 'p', 'em', 'strong'],
  analyze: function analyze(html) {
    html = String(html) || '';
    var matches = [];
    var match; // extract all tags

    var _loop = function _loop() {
      var attrr = match[2].split(' ');
      var attrs = []; // extract attributes from the tag

      attrr.shift();
      attrr.forEach(function (attr) {
        attr = attr.split('=');
        var attrName = attr[0];
        var attrValue = attr.length > 1 ? attr.slice(1).join('=') : null; // remove quotes from attributes

        if (attrValue && attrValue.charAt(0).match(/'|"/)) attrValue = attrValue.slice(1);
        if (attrValue && attrValue.charAt(attrValue.length - 1).match(/'|"/)) attrValue = attrValue.slice(0, -1);
        attr = {
          name: attrName,
          value: attrValue
        };
        if (!attr.value) delete attr.value;
        if (attr.name) attrs.push(attr);
      });
      tag = {
        full: match[0],
        name: match[1],
        attr: attrs
      };
      matches.push(tag);
    };

    while ((match = remixBleach.matcher.exec(html)) != null) {
      var tag;

      _loop();
    }

    return matches;
  },
  sanitize: function sanitize(html, options) {
    html = String(html) || '';
    options = options || {};
    var mode = options.mode || 'white';
    var list = options.list || remixBleach.whitelist;
    var matches = remixBleach.analyze(html);

    if (mode === 'white' && list.indexOf('script') === -1 || mode === 'black' && list.indexOf('script') !== -1) {
      html = html.replace(/<script(.*?)>(.*?[\r\n])*?(.*?)(.*?[\r\n])*?<\/script>/gim, '');
    }

    if (mode === 'white' && list.indexOf('style') === -1 || mode === 'black' && list.indexOf('style') !== -1) {
      html = html.replace(/<style(.*?)>(.*?[\r\n])*?(.*?)(.*?[\r\n])*?<\/style>/gim, '');
    }

    matches.forEach(function (tag) {
      if (mode === 'white') {
        if (list.indexOf(tag.name) === -1) {
          html = html.replace(tag.full, '');
        }
      } else if (mode === 'black') {
        if (list.indexOf(tag.name) !== -1) {
          html = html.replace(tag.full, '');
        }
      } else {
        throw new Error('Unknown sanitization mode "' + mode + '"');
      }
    });
    if (options.encode_entities) html = he.encode(html);
    return html;
  }
};
module.exports = remixBleach;

/***/ }),
/* 2622 */,
/* 2623 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _taggedTemplateLiteral2 = _interopRequireDefault(__webpack_require__(2624));

var _templateObject;

var csjs = __webpack_require__(2625);

var css = csjs(_templateObject || (_templateObject = (0, _taggedTemplateLiteral2["default"])(["\n  .debuggerTabView {\n    padding: 2%;\n  }\n  .debugger {\n    margin-bottom: 1%;\n  }\n"])));
module.exports = css;

/***/ }),
/* 2624 */,
/* 2625 */,
/* 2626 */,
/* 2627 */,
/* 2628 */,
/* 2629 */,
/* 2630 */,
/* 2631 */,
/* 2632 */,
/* 2633 */,
/* 2634 */,
/* 2635 */,
/* 2636 */,
/* 2637 */,
/* 2638 */,
/* 2639 */,
/* 2640 */,
/* 2641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _solidityUnitTesting = __webpack_require__(2642);

var _engineWeb = __webpack_require__(1133);

var _helper = _interopRequireDefault(__webpack_require__(1310));

var _remixSolidity = __webpack_require__(1149);

var _helper2 = __webpack_require__(1121);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _require = __webpack_require__(2647),
    UnitTestRunner = _require.UnitTestRunner,
    assertLibCode = _require.assertLibCode;

var profile = {
  name: 'solidityUnitTesting',
  displayName: 'Solidity unit testing',
  methods: ['testFromPath', 'testFromSource', 'setTestFolderPath', 'getTestlibs', 'createTestLibs'],
  events: [],
  icon: 'assets/img/unitTesting.webp',
  description: 'Write and run unit tests for your contracts in Solidity',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/unittesting.html',
  maintainedBy: 'Remix'
};

module.exports = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(TestTab, _ViewPlugin);

  var _super = _createSuper(TestTab);

  function TestTab(fileManager, offsetToLineColumnConverter, filePanel, compileTab, appManager, contentImport) {
    var _this;

    (0, _classCallCheck2["default"])(this, TestTab);
    _this = _super.call(this, profile);
    _this.compileTab = compileTab;
    _this.contentImport = contentImport;
    _this.fileManager = fileManager;
    _this.filePanel = filePanel;
    _this.appManager = appManager;
    _this.testRunner = new UnitTestRunner();
    _this.testTabLogic = new _solidityUnitTesting.TestTabLogic(_this.fileManager, _helper["default"]);
    _this.offsetToLineColumnConverter = offsetToLineColumnConverter;
    _this.allFilesInvolved = ['.deps/remix-tests/remix_tests.sol', '.deps/remix-tests/remix_accounts.sol'];
    _this.element = document.createElement('div');
    _this.dispatch = null;
    return _this;
  }

  (0, _createClass2["default"])(TestTab, [{
    key: "onActivationInternal",
    value: function onActivationInternal() {
      this.listenToEvents();
      this.call('filePanel', 'registerContextMenuItem', {
        id: 'solidityUnitTesting',
        name: 'setTestFolderPath',
        label: 'Set path for Unit Testing',
        type: ['folder'],
        extension: [],
        path: [],
        pattern: []
      });
    }
  }, {
    key: "setTestFolderPath",
    value: function () {
      var _setTestFolderPath = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(event) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (event.path.length > 0) {
                  this.renderComponent(event.path[0]);
                }

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setTestFolderPath(_x) {
        return _setTestFolderPath.apply(this, arguments);
      }

      return setTestFolderPath;
    }()
  }, {
    key: "getTestlibs",
    value: function getTestlibs() {
      return {
        assertLibCode: assertLibCode,
        accountsLibCode: this.testRunner.accountsLibCode
      };
    }
  }, {
    key: "createTestLibs",
    value: function () {
      var _createTestLibs = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var provider;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.fileManager.currentFileProvider();

              case 2:
                provider = _context2.sent;

                if (!provider) {
                  _context2.next = 8;
                  break;
                }

                _context2.next = 6;
                return provider.addExternal('.deps/remix-tests/remix_tests.sol', assertLibCode, 'remix_tests.sol');

              case 6:
                _context2.next = 8;
                return provider.addExternal('.deps/remix-tests/remix_accounts.sol', this.testRunner.accountsLibCode, 'remix_accounts.sol');

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createTestLibs() {
        return _createTestLibs.apply(this, arguments);
      }

      return createTestLibs;
    }()
  }, {
    key: "onActivation",
    value: function () {
      var _onActivation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        var isSolidityActive;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.call('manager', 'isActive', 'solidity');

              case 2:
                isSolidityActive = _context3.sent;

                if (isSolidityActive) {
                  _context3.next = 6;
                  break;
                }

                _context3.next = 6;
                return this.call('manager', 'activatePlugin', 'solidity');

              case 6:
                _context3.next = 8;
                return this.testRunner.init();

              case 8:
                _context3.next = 10;
                return this.createTestLibs();

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function onActivation() {
        return _onActivation.apply(this, arguments);
      }

      return onActivation;
    }()
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      this.off('filePanel', 'newTestFileCreated');
      this.off('filePanel', 'setWorkspace'); // 'currentFileChanged' event is added more than once

      this.fileManager.events.removeAllListeners('currentFileChanged');
    }
  }, {
    key: "listenToEvents",
    value: function listenToEvents() {
      var _this2 = this;

      this.on('filePanel', 'workspaceCreated', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _this2.createTestLibs();

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      })));
      this.testRunner.event.on('compilationFinished', function (success, data, source, input, version) {
        if (success) {
          var _this2$allFilesInvolv;

          (_this2$allFilesInvolv = _this2.allFilesInvolved).push.apply(_this2$allFilesInvolv, (0, _toConsumableArray2["default"])(Object.keys(data.sources))); // forwarding the event to the appManager infra
          // This is listened by compilerArtefacts to show data while debugging


          _this2.emit('compilationFinished', source.target, source, 'soljson', data, input, version);
        }
      });
    }
  }, {
    key: "testFromPath",
    value: function () {
      var _testFromPath = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(path) {
        var fileContent;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.fileManager.readFile(path);

              case 2:
                fileContent = _context5.sent;
                return _context5.abrupt("return", this.testFromSource(fileContent, path));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function testFromPath(_x2) {
        return _testFromPath.apply(this, arguments);
      }

      return testFromPath;
    }()
    /*
      Test is not associated with the UI
    */

  }, {
    key: "testFromSource",
    value: function testFromSource(content) {
      var _this3 = this;

      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'browser/unit_test.sol';
      return new Promise(function (resolve, reject) {
        var runningTest = {};
        runningTest[path] = {
          content: content
        };

        var _this3$compileTab$get = _this3.compileTab.getCurrentCompilerConfig(),
            currentVersion = _this3$compileTab$get.currentVersion,
            evmVersion = _this3$compileTab$get.evmVersion,
            optimize = _this3$compileTab$get.optimize,
            runs = _this3$compileTab$get.runs;

        var currentCompilerUrl = (0, _remixSolidity.urlFromVersion)(currentVersion);
        var compilerConfig = {
          currentCompilerUrl: currentCompilerUrl,
          evmVersion: evmVersion,
          optimize: optimize,
          usingWorker: (0, _remixSolidity.canUseWorker)(currentVersion),
          runs: runs
        };

        _this3.testRunner.runTestSources(runningTest, compilerConfig, function () {
          /* Do nothing. */
        }, function () {
          /* Do nothing. */
        }, null, function (error, result) {
          if (error) return reject(error);
          resolve(result);
        }, function (url, cb) {
          return _this3.contentImport.resolveAndSave(url).then(function (result) {
            return cb(null, result);
          })["catch"](function (error) {
            return cb(error.message);
          });
        });
      });
    }
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
      this.renderComponent('tests');
    }
  }, {
    key: "render",
    value: function render() {
      this.onActivationInternal();
      return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement(_helper2.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_solidityUnitTesting.SolidityUnitTesting, {
        testTab: state.testTab,
        helper: state.helper,
        initialPath: state.testDirPath
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(testDirPath) {
      this.dispatch({
        testTab: this,
        helper: _helper["default"],
        testDirPath: testDirPath
      });
    }
  }]);
  return TestTab;
}(_engineWeb.ViewPlugin);

/***/ }),
/* 2642 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _solidityUnitTesting = __webpack_require__(2643);

Object.keys(_solidityUnitTesting).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _solidityUnitTesting[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _solidityUnitTesting[key];
    }
  });
});

var _testTabLogic = __webpack_require__(2646);

Object.keys(_testTabLogic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _testTabLogic[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _testTabLogic[key];
    }
  });
});

/***/ }),
/* 2643 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SolidityUnitTesting = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _async = __webpack_require__(222);

var _remixSolidity = __webpack_require__(1149);

var _renderer = __webpack_require__(1590);

var _toaster = __webpack_require__(479);

var _util = __webpack_require__(313);

__webpack_require__(2644);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const _paq = window._paq = window._paq || []; // eslint-disable-line @typescript-eslint/no-explicit-any


const SolidityUnitTesting = props => {
  // eslint-disable-line @typescript-eslint/no-explicit-any
  const {
    helper,
    testTab,
    initialPath
  } = props;
  const {
    testTabLogic
  } = testTab;
  const [toasterMsg, setToasterMsg] = (0, _react.useState)('');
  const [disableCreateButton, setDisableCreateButton] = (0, _react.useState)(true);
  const [disableGenerateButton, setDisableGenerateButton] = (0, _react.useState)(false);
  const [disableStopButton, setDisableStopButton] = (0, _react.useState)(true);
  const [disableRunButton, setDisableRunButton] = (0, _react.useState)(false);
  const [runButtonTitle, setRunButtonTitle] = (0, _react.useState)('Run tests');
  const [stopButtonLabel, setStopButtonLabel] = (0, _react.useState)('Stop');
  const [checkSelectAll, setCheckSelectAll] = (0, _react.useState)(true);
  const [testsOutput, setTestsOutput] = (0, _react.useState)([]);
  const [testsExecutionStoppedHidden, setTestsExecutionStoppedHidden] = (0, _react.useState)(true);
  const [progressBarHidden, setProgressBarHidden] = (0, _react.useState)(true);
  const [testsExecutionStoppedErrorHidden, setTestsExecutionStoppedErrorHidden] = (0, _react.useState)(true);
  let [testFiles, setTestFiles] = (0, _react.useState)([]); // eslint-disable-line

  const [pathOptions, setPathOptions] = (0, _react.useState)(['']);
  const [inputPathValue, setInputPathValue] = (0, _react.useState)('tests');
  let [readyTestsNumber, setReadyTestsNumber] = (0, _react.useState)(0); // eslint-disable-line

  let [runningTestsNumber, setRunningTestsNumber] = (0, _react.useState)(0); // eslint-disable-line

  const areTestsRunning = (0, _react.useRef)(false);
  const hasBeenStopped = (0, _react.useRef)(false);
  const isDebugging = (0, _react.useRef)(false);
  const allTests = (0, _react.useRef)([]);
  const selectedTests = (0, _react.useRef)([]);
  const currentTestFiles = (0, _react.useRef)([]); // stores files for which tests have been run

  const currentErrors = (0, _react.useRef)([]); // eslint-disable-line @typescript-eslint/no-explicit-any

  const defaultPath = 'tests';
  let runningTestFileName;
  const filesContent = {};
  const testsResultByFilename = {}; // eslint-disable-line @typescript-eslint/no-explicit-any

  const trimTestDirInput = input => {
    if (input.includes('/')) return input.split('/').map(e => e.trim()).join('/');else return input.trim();
  };

  const clearResults = () => {
    setProgressBarHidden(true);
    testTab.call('editor', 'clearAnnotations');
    setTestsOutput([]);
    setTestsExecutionStoppedHidden(true);
    setTestsExecutionStoppedErrorHidden(true);
  };

  const updateForNewCurrent = async (file = null) => {
    // Ensure that when someone clicks on compilation error and that opens a new file
    // Test result, which is compilation error in this case, is not cleared
    if (currentErrors.current) {
      if (Array.isArray(currentErrors.current) && currentErrors.current.length > 0) {
        const errFiles = currentErrors.current.map(err => {
          if (err.sourceLocation && err.sourceLocation.file) return err.sourceLocation.file;
        }); // eslint-disable-line

        if (errFiles.includes(file)) return;
      } else if (currentErrors.current.sourceLocation && currentErrors.current.sourceLocation.file && currentErrors.current.sourceLocation.file === file) return;
    } // if current file is changed while debugging and one of the files imported in test file are opened
    // do not clear the test results in SUT plugin


    if (isDebugging.current && testTab.allFilesInvolved.includes(file) || currentTestFiles.current.includes(file)) return;
    allTests.current = [];
    updateTestFileList();
    clearResults();

    try {
      const tests = await testTabLogic.getTests();
      allTests.current = tests;
      selectedTests.current = [...allTests.current];
      updateTestFileList();
      if (!areTestsRunning.current) await updateRunAction(file);
    } catch (e) {
      // eslint-disable-line @typescript-eslint/no-explicit-any
      console.log(e);
      setToasterMsg(e);
    }
  };
  /**
  * Changes the current path of Unit Testing Plugin
  * @param path - the path from where UT plugin takes _test.sol files to run
  */


  const setCurrentPath = async path => {
    testTabLogic.setCurrentPath(path);
    setInputPathValue(path);
    updateDirList(path);
    await updateForNewCurrent();
  };

  (0, _react.useEffect)(() => {
    if (initialPath) setCurrentPath(initialPath);
  }, [initialPath]); // eslint-disable-line react-hooks/exhaustive-deps

  (0, _react.useEffect)(() => {
    testTab.on('filePanel', 'newTestFileCreated', async file => {
      try {
        const tests = await testTabLogic.getTests();
        allTests.current = tests;
        selectedTests.current = [...allTests.current];
        updateTestFileList();
      } catch (e) {
        console.log(e);
        allTests.current.push(file);
        selectedTests.current.push(file);
      }
    });
    testTab.on('filePanel', 'setWorkspace', async () => {
      await setCurrentPath(defaultPath);
    });
    testTab.fileManager.events.on('noFileSelected', async () => {
      await updateForNewCurrent();
    });
    testTab.fileManager.events.on('currentFileChanged', async file => await updateForNewCurrent(file));
  }, []); // eslint-disable-line

  const updateDirList = path => {
    testTabLogic.dirList(path).then(options => {
      setPathOptions(options);
    });
  };

  const handleTestDirInput = async e => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    let testDirInput = trimTestDirInput(e.target.value);
    testDirInput = helper.removeMultipleSlashes(testDirInput);
    setInputPathValue(testDirInput);

    if (testDirInput) {
      if (testDirInput.endsWith('/') && testDirInput !== '/') {
        testDirInput = helper.removeTrailingSlashes(testDirInput);

        if (testTabLogic.currentPath === testDirInput.substr(0, testDirInput.length - 1)) {
          setDisableCreateButton(true);
          setDisableGenerateButton(true);
        }

        updateDirList(testDirInput);
      } else {
        // If there is no matching folder in the workspace with entered text, enable Create button
        if (await testTabLogic.pathExists(testDirInput)) {
          setDisableCreateButton(true);
          setDisableGenerateButton(false);
        } else {
          // Enable Create button
          setDisableCreateButton(false); // Disable Generate button because dir does not exist

          setDisableGenerateButton(true);
        }

        await setCurrentPath(testDirInput);
      }
    } else {
      await setCurrentPath('/');
      setDisableCreateButton(true);
      setDisableGenerateButton(false);
    }
  };

  const handleCreateFolder = async () => {
    let inputPath = trimTestDirInput(inputPathValue);
    let path = helper.removeMultipleSlashes(inputPath);
    if (path !== '/') path = helper.removeTrailingSlashes(path);
    if (inputPath === '') inputPath = defaultPath;
    setInputPathValue(path);
    await testTabLogic.generateTestFolder(inputPath);
    setToasterMsg('Folder created successfully');
    setDisableCreateButton(true);
    setDisableGenerateButton(false);
    testTabLogic.setCurrentPath(inputPath);
    await updateRunAction();
    await updateForNewCurrent();
    pathOptions.push(inputPath);
    setPathOptions(pathOptions);
  };

  const cleanFileName = (fileName, testSuite) => {
    return fileName ? fileName.replace(/\//g, '_').replace(/\./g, '_') + testSuite : fileName;
  };

  const startDebug = async (txHash, web3) => {
    isDebugging.current = true;
    if (!(await testTab.appManager.isActive('debugger'))) await testTab.appManager.activatePlugin('debugger');
    testTab.call('menuicons', 'select', 'debugger');
    testTab.call('debugger', 'debug', txHash, web3);
  };

  const printHHLogs = (logsArr, testName) => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    let finalLogs = `<b>${testName}:</b>\n`;

    for (const log of logsArr) {
      let formattedLog; // Hardhat implements the same formatting options that can be found in Node.js' console.log,
      // which in turn uses util.format: https://nodejs.org/dist/latest-v12.x/docs/api/util.html#util_util_format_format_args
      // For example: console.log("Name: %s, Age: %d", remix, 6) will log 'Name: remix, Age: 6'
      // We check first arg to determine if 'util.format' is needed

      if (typeof log[0] === 'string' && (log[0].includes('%s') || log[0].includes('%d'))) {
        formattedLog = (0, _util.format)(log[0], ...log.slice(1));
      } else {
        formattedLog = log.join(' ');
      }

      finalLogs = finalLogs + '&emsp;' + formattedLog + '\n';
    }

    _paq.push(['trackEvent', 'solidityUnitTesting', 'hardhat', 'console.log']);

    testTab.call('terminal', 'log', {
      type: 'info',
      value: finalLogs
    });
  };

  const discardHighlight = async () => {
    await testTab.call('editor', 'discardHighlight');
  };

  const highlightLocation = async (location, fileName) => {
    if (location) {
      const split = location.split(':');
      const file = split[2];
      const parsedLocation = {
        start: parseInt(split[0]),
        length: parseInt(split[1])
      };
      const locationToHighlight = testTab.offsetToLineColumnConverter.offsetToLineColumnWithContent(parsedLocation, parseInt(file), filesContent[fileName].content);
      await testTab.call('editor', 'discardHighlight');
      await testTab.call('editor', 'highlight', locationToHighlight, fileName, '', {
        focus: true
      });
    }
  };

  const renderContract = (filename, contract, index, withoutLabel = false) => {
    if (withoutLabel) {
      const contractCard = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        id: runningTestFileName,
        "data-id": "testTabSolidityUnitTestsOutputheader",
        className: "pt-1",
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          className: "font-weight-bold",
          children: [contract ? contract : '', " (", filename, ")"]
        })
      });
      setTestsOutput(prevCards => [...prevCards, contractCard]);
      return;
    }

    let label;

    if (index > -1) {
      const className = "alert-danger d-inline-block mb-1 mr-1 p-1 failed_" + runningTestFileName;
      label = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: className,
        title: "At least one contract test failed",
        children: "FAIL"
      });
    } else {
      const className = "alert-success d-inline-block mb-1 mr-1 p-1 passed_" + runningTestFileName;
      label = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: className,
        title: "All contract tests passed",
        children: "PASS"
      });
    } // show contract and file name with label


    const ContractCard = /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      id: runningTestFileName,
      "data-id": "testTabSolidityUnitTestsOutputheader",
      className: "pt-1",
      children: [label, /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
        className: "font-weight-bold",
        children: [contract, " (", filename, ")"]
      })]
    });
    setTestsOutput(prevCards => {
      const index = prevCards.findIndex(card => card.props.id === runningTestFileName);
      prevCards[index] = ContractCard;
      return prevCards;
    });
  };

  const renderTests = (tests, contract, filename) => {
    const index = tests.findIndex(test => test.type === 'testFailure'); // show filename and contract

    renderContract(filename, contract, index); // show tests

    for (const test of tests) {
      if (!test.rendered) {
        let debugBtn;

        if (test.debugTxHash) {
          const {
            web3,
            debugTxHash
          } = test;
          debugBtn = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            id: test.value.replaceAll(' ', '_'),
            className: "btn border btn btn-sm ml-1",
            style: {
              cursor: 'pointer'
            },
            title: "Start debugging",
            onClick: () => startDebug(debugTxHash, web3),
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              className: "fas fa-bug"
            })
          });
        }

        if (test.type === 'testPass') {
          if (test.hhLogs && test.hhLogs.length) printHHLogs(test.hhLogs, test.value);
          const testPassCard = /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            id: runningTestFileName,
            "data-id": "testTabSolidityUnitTestsOutputheader",
            className: "testPass testLog bg-light mb-2 px-2 text-success border-0",
            onClick: () => discardHighlight(),
            children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "d-flex my-1 align-items-start justify-content-between",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                children: [" \u2713 ", test.value]
              }), debugBtn]
            })
          });
          setTestsOutput(prevCards => [...prevCards, testPassCard]);
          test.rendered = true;
        } else if (test.type === 'testFailure') {
          if (test.hhLogs && test.hhLogs.length) printHHLogs(test.hhLogs, test.value);

          if (!test.assertMethod) {
            const testFailCard1 = /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "bg-light mb-2 px-2 testLog d-flex flex-column text-danger border-0",
              id: "UTContext" + test.context,
              onClick: () => {
                if (test.location) highlightLocation(test.location, test.filename);
              },
              children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "d-flex my-1 align-items-start justify-content-between",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                  children: [" \u2718 ", test.value]
                }), debugBtn]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                className: "text-dark",
                children: "Error Message:"
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                className: "pb-2 text-break",
                children: ["\"", test.errMsg, "\""]
              })]
            });
            setTestsOutput(prevCards => [...prevCards, testFailCard1]);
          } else {
            const preposition = test.assertMethod === 'equal' || test.assertMethod === 'notEqual' ? 'to' : '';
            const method = test.assertMethod === 'ok' ? '' : test.assertMethod;
            const expected = test.assertMethod === 'ok' ? '\'true\'' : test.expected;
            const testFailCard2 = /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: "bg-light mb-2 px-2 testLog d-flex flex-column text-danger border-0",
              id: "UTContext" + test.context,
              onClick: () => {
                if (test.location) highlightLocation(test.location, test.filename);
              },
              children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "d-flex my-1 align-items-start justify-content-between",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                  children: [" \u2718 ", test.value]
                }), debugBtn]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                className: "text-dark",
                children: "Error Message:"
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                className: "pb-2 text-break",
                children: ["\"", test.errMsg, "\""]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                className: "text-dark",
                children: "Assertion:"
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                className: "d-flex flex-wrap",
                children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                  children: "Expected value should be"
                }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
                  className: "mx-1 font-weight-bold",
                  children: method
                }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                  children: [preposition, " ", expected]
                })]
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                className: "text-dark",
                children: "Received value:"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                children: test.returned
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                className: "text-dark text-sm pb-2",
                children: "Skipping the remaining tests of the function."
              })]
            });
            setTestsOutput(prevCards => [...prevCards, testFailCard2]);
          }

          test.rendered = true;
        } else if (test.type === 'logOnly') {
          if (test.hhLogs && test.hhLogs.length) printHHLogs(test.hhLogs, test.value);
          test.rendered = true;
        }
      }
    }
  };

  const showTestsResult = () => {
    const filenames = Object.keys(testsResultByFilename);
    currentTestFiles.current = filenames;

    for (const filename of filenames) {
      const fileTestsResult = testsResultByFilename[filename];
      const contracts = Object.keys(fileTestsResult);

      for (const contract of contracts) {
        if (contract && contract !== 'summary' && contract !== 'errors') {
          runningTestFileName = cleanFileName(filename, contract);
          const tests = fileTestsResult[contract];

          if (tests !== null && tests !== void 0 && tests.length) {
            renderTests(tests, contract, filename);
          } else {
            // show only contract and file name
            renderContract(filename, contract, -1, true);
          }
        } else if (contract === 'errors' && fileTestsResult['errors']) {
          const errors = fileTestsResult['errors'];

          if (errors && errors.errors) {
            errors.errors.forEach(err => {
              // eslint-disable-line @typescript-eslint/no-explicit-any
              const errorCard = /*#__PURE__*/(0, _jsxRuntime.jsx)(_renderer.Renderer, {
                message: err.formattedMessage || err.message,
                plugin: testTab,
                opt: {
                  type: err.severity,
                  errorType: err.type
                }
              });
              setTestsOutput(prevCards => [...prevCards, errorCard]);
            });
          } else if (errors && Array.isArray(errors) && (errors[0].message || errors[0].formattedMessage)) {
            errors.forEach(err => {
              const errorCard = /*#__PURE__*/(0, _jsxRuntime.jsx)(_renderer.Renderer, {
                message: err.formattedMessage || err.message,
                plugin: testTab,
                opt: {
                  type: err.severity,
                  errorType: err.type
                }
              });
              setTestsOutput(prevCards => [...prevCards, errorCard]);
            });
          } else if (errors && !errors.errors && !Array.isArray(errors)) {
            // To track error like this: https://github.com/ethereum/remix/pull/1438
            const errorCard = /*#__PURE__*/(0, _jsxRuntime.jsx)(_renderer.Renderer, {
              message: errors.formattedMessage || errors.message,
              plugin: testTab,
              opt: {
                type: 'error'
              }
            });
            setTestsOutput(prevCards => [...prevCards, errorCard]);
          }
        }
      } // show summary


      const testSummary = fileTestsResult['summary'];

      if (testSummary && testSummary.filename && !testSummary.rendered) {
        const summaryCard = /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex alert-secondary mb-3 p-3 flex-column",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            className: "font-weight-bold",
            children: ["Result for ", testSummary.filename]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            className: "text-success",
            children: ["Passed: ", testSummary.passed]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            className: "text-danger",
            children: ["Failed: ", testSummary.failed]
          }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
            children: ["Time Taken: ", testSummary.timeTaken, "s"]
          })]
        });
        setTestsOutput(prevCards => [...prevCards, summaryCard]);
        fileTestsResult['summary']['rendered'] = true;
      }
    }
  };

  const testCallback = result => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    if (result.filename) {
      if (!testsResultByFilename[result.filename]) {
        testsResultByFilename[result.filename] = {};
        testsResultByFilename[result.filename]['summary'] = {};
      }

      if (result.type === 'contract') {
        testsResultByFilename[result.filename][result.value] = {};
        testsResultByFilename[result.filename][result.value] = [];
      } else {
        // Set that this test is not rendered on UI
        result.rendered = false;
        testsResultByFilename[result.filename][result.context].push(result);
      }

      showTestsResult();
    }
  };

  const resultsCallback = (_err, result, cb) => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    // total stats for the test
    // result.passingNum
    // result.failureNum
    // result.timePassed
    cb();
  };

  const updateFinalResult = (_errors, result, filename) => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    ++readyTestsNumber;
    setReadyTestsNumber(readyTestsNumber);

    if (!result && _errors && (_errors.errors || Array.isArray(_errors) && (_errors[0].message || _errors[0].formattedMessage))) {
      // show only file name
      renderContract(filename, null, -1, true);
      currentErrors.current = _errors.errors;
    }

    if (result) {
      const totalTime = parseFloat(result.totalTime).toFixed(2);
      const testsSummary = {
        filename,
        passed: result.totalPassing,
        failed: result.totalFailing,
        timeTaken: totalTime,
        rendered: false
      };
      testsResultByFilename[filename]['summary'] = testsSummary;
      showTestsResult();
    } else if (_errors) {
      if (!testsResultByFilename[filename]) {
        testsResultByFilename[filename] = {};
      }

      testsResultByFilename[filename]['errors'] = _errors;
      setTestsExecutionStoppedErrorHidden(false);
      showTestsResult();
    }

    if (hasBeenStopped.current && readyTestsNumber !== runningTestsNumber) {
      // if all tests has been through before stopping no need to print this.
      setTestsExecutionStoppedHidden(false);
    }

    if (_errors || hasBeenStopped.current || readyTestsNumber === runningTestsNumber) {
      var _selectedTests$curren;

      // All tests are ready or the operation has been canceled or there was a compilation error in one of the test files.
      setDisableStopButton(true);
      setStopButtonLabel('Stop');

      if (((_selectedTests$curren = selectedTests.current) === null || _selectedTests$curren === void 0 ? void 0 : _selectedTests$curren.length) !== 0) {
        setDisableRunButton(false);
      }

      areTestsRunning.current = false;
    }
  };

  const runTest = (testFilePath, callback) => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    isDebugging.current = false;

    if (hasBeenStopped.current) {
      updateFinalResult(null, null, testFilePath);
      return;
    }

    testTab.fileManager.readFile(testFilePath).then(content => {
      const runningTests = {};
      runningTests[testFilePath] = {
        content
      };
      filesContent[testFilePath] = {
        content
      };
      const {
        currentVersion,
        evmVersion,
        optimize,
        runs,
        isUrl
      } = testTab.compileTab.getCurrentCompilerConfig();
      const currentCompilerUrl = isUrl ? currentVersion : (0, _remixSolidity.urlFromVersion)(currentVersion);
      const compilerConfig = {
        currentCompilerUrl,
        evmVersion,
        optimize,
        usingWorker: (0, _remixSolidity.canUseWorker)(currentVersion),
        runs
      };

      const deployCb = async (file, contractAddress) => {
        const compilerData = await testTab.call('compilerArtefacts', 'getCompilerAbstract', file);
        await testTab.call('compilerArtefacts', 'addResolvedContract', contractAddress, compilerData);
      };

      testTab.testRunner.runTestSources(runningTests, compilerConfig, result => testCallback(result), // eslint-disable-line @typescript-eslint/no-explicit-any
      (_err, result, cb) => resultsCallback(_err, result, cb), // eslint-disable-line @typescript-eslint/no-explicit-any
      deployCb, (error, result) => {
        // eslint-disable-line @typescript-eslint/no-explicit-any
        updateFinalResult(error, result, testFilePath);
        callback(error);
      }, (url, cb) => {
        // eslint-disable-line @typescript-eslint/no-explicit-any
        return testTab.contentImport.resolveAndSave(url).then(result => cb(null, result)).catch(error => cb(error.message)); // eslint-disable-line @typescript-eslint/no-explicit-any
      }, {
        testFilePath
      });
    }).catch(error => {
      console.log(error);
      if (error) return; // eslint-disable-line
    });
  };

  const runTests = () => {
    areTestsRunning.current = true;
    hasBeenStopped.current = false;
    readyTestsNumber = 0;
    setReadyTestsNumber(readyTestsNumber);
    runningTestsNumber = selectedTests.current.length;
    setRunningTestsNumber(runningTestsNumber);
    setDisableStopButton(false);
    clearResults();
    setProgressBarHidden(false);
    const tests = selectedTests.current;
    if (!tests || !tests.length) return;else setProgressBarHidden(false);

    _paq.push(['trackEvent', 'solidityUnitTesting', 'runTests']);

    (0, _async.eachOfSeries)(tests, (value, key, callback) => {
      // eslint-disable-line @typescript-eslint/no-explicit-any
      if (hasBeenStopped.current) return;
      runTest(value, callback);
    });
  };

  const updateRunAction = async (currentFile = null) => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    const isSolidityActive = await testTab.appManager.isActive('solidity');

    if (!isSolidityActive || !selectedTests.current.length) {
      setDisableRunButton(true);

      if (!currentFile || currentFile && currentFile.split('.').pop().toLowerCase() !== 'sol') {
        setRunButtonTitle('No solidity file selected');
      } else {
        setRunButtonTitle('The "Solidity Plugin" should be activated');
      }
    } else setDisableRunButton(false);
  };

  const stopTests = () => {
    hasBeenStopped.current = true;
    setStopButtonLabel('Stopping');
    setDisableStopButton(true);
    setDisableRunButton(true);
  };

  const getCurrentSelectedTests = () => {
    const selectedTestsList = testFiles.filter(testFileObj => testFileObj.checked);
    return selectedTestsList.map(testFileObj => testFileObj.fileName);
  };

  const toggleCheckbox = (eChecked, index) => {
    testFiles[index].checked = eChecked;
    setTestFiles([...testFiles]);
    selectedTests.current = getCurrentSelectedTests();

    if (eChecked) {
      setCheckSelectAll(true);
      setDisableRunButton(false);

      if ((readyTestsNumber === runningTestsNumber || hasBeenStopped.current) && stopButtonLabel.trim() === 'Stop') {
        setRunButtonTitle('Run tests');
      }
    } else if (!selectedTests.current.length) {
      setCheckSelectAll(false);
      setDisableRunButton(true);
      setRunButtonTitle('No test file selected');
    } else setCheckSelectAll(false);
  };

  const checkAll = event => {
    // eslint-disable-line @typescript-eslint/no-explicit-any
    testFiles.forEach(testFileObj => testFileObj.checked = event.target.checked);
    setTestFiles([...testFiles]);
    setCheckSelectAll(event.target.checked);

    if (event.target.checked) {
      selectedTests.current = getCurrentSelectedTests();
      setDisableRunButton(false);
    } else {
      selectedTests.current = [];
      setDisableRunButton(true);
    }
  };

  const updateTestFileList = () => {
    var _allTests$current;

    if ((_allTests$current = allTests.current) !== null && _allTests$current !== void 0 && _allTests$current.length) {
      testFiles = allTests.current.map(testFile => {
        return {
          'fileName': testFile,
          'checked': true
        };
      });
      setCheckSelectAll(true);
    } else testFiles = [];

    setTestFiles([...testFiles]);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "px-2",
    id: "testView",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: toasterMsg
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "infoBox",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        className: "text-lg",
        children: " Test your smart contract in Solidity."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("p", {
        children: " Select directory to load and generate test files."
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        children: "Test directory:"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "d-flex p-2",
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("datalist", {
            id: "utPathList",
            children: pathOptions.map(function (path) {
              return /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
                children: path
              }, path);
            })
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
            list: "utPathList",
            className: "inputFolder custom-select",
            id: "utPath",
            "data-id": "uiPathInput",
            name: "utPath",
            value: inputPathValue,
            title: "Press 'Enter' to change the path for test files.",
            style: {
              backgroundImage: "var(--primary)"
            },
            onKeyDown: () => {
              if (inputPathValue === '/') setInputPathValue('');
            },
            onChange: handleTestDirInput,
            onClick: () => {
              if (inputPathValue === '/') setInputPathValue('');
            }
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
            className: "btn border ml-2",
            "data-id": "testTabGenerateTestFolder",
            title: "Create a test folder",
            disabled: disableCreateButton,
            onClick: handleCreateFolder,
            children: "Create"
          })]
        })
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex p-2",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("button", {
          className: "btn border w-50",
          "data-id": "testTabGenerateTestFile",
          title: "Generate a sample test file",
          disabled: disableGenerateButton,
          onClick: async () => {
            await testTabLogic.generateTestFile(err => {
              if (err) setToasterMsg(err);
            }); // eslint-disable-line @typescript-eslint/no-explicit-any

            await updateForNewCurrent();
          },
          children: "Generate"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("a", {
          className: "btn border text-decoration-none pr-0 d-flex w-50 ml-2",
          title: "Check out documentation.",
          target: "__blank",
          href: "https://remix-ide.readthedocs.io/en/latest/unittesting.html#test-directory",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "btn p-1 ml-2 m-0",
            children: "How to use..."
          })
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex p-2",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
          id: "runTestsTabRunAction",
          title: runButtonTitle,
          "data-id": "testTabRunTestsTabRunAction",
          className: "w-50 btn btn-primary",
          disabled: disableRunButton,
          onClick: runTests,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "fas fa-play ml-2"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "labelOnBtn btn btn-primary p-1 ml-2 m-0",
            children: "Run"
          })]
        }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("button", {
          id: "runTestsTabStopAction",
          "data-id": "testTabRunTestsTabStopAction",
          className: "w-50 pl-2 ml-2 btn btn-secondary",
          disabled: disableStopButton,
          title: "Stop running tests",
          onClick: stopTests,
          children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            className: "fas fa-stop ml-2"
          }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            className: "labelOnBtn btn btn-secondary p-1 ml-2 m-0",
            id: "runTestsTabStopActionLabel",
            children: stopButtonLabel
          })]
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex align-items-center mx-3 pb-2 mt-2 border-bottom",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
          id: "checkAllTests",
          type: "checkbox",
          "data-id": "testTabCheckAllTests",
          onClick: checkAll,
          checked: checkSelectAll,
          onChange: () => {} // eslint-disable-line

        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "text-nowrap pl-2 mb-0",
          htmlFor: "checkAllTests",
          children: " Select all "
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "testList py-2 mt-0 border-bottom",
        children: [testFiles.length ? testFiles.map((testFileObj, index) => {
          const elemId = `singleTest${testFileObj.fileName}`;
          return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "d-flex align-items-center py-1",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              className: "singleTest",
              id: elemId,
              onChange: e => toggleCheckbox(e.target.checked, index),
              type: "checkbox",
              checked: testFileObj.checked
            }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "singleTestLabel text-nowrap pl-2 mb-0",
              htmlFor: elemId,
              children: testFileObj.fileName
            })]
          }, index);
        }) : "No test file available", " "]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "align-items-start flex-column mt-2 mx-3 mb-0",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
          className: "text-info h6",
          hidden: progressBarHidden,
          children: ["Progress: ", readyTestsNumber, " finished (of ", runningTestsNumber, ")"]
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "text-warning h6",
          "data-id": "testTabTestsExecutionStopped",
          hidden: testsExecutionStoppedHidden,
          children: "The test execution has been stopped"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
          className: "text-danger h6",
          "data-id": "testTabTestsExecutionStoppedError",
          hidden: testsExecutionStoppedErrorHidden,
          children: "The test execution has been stopped because of error(s) in your test file"
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "mx-3 mb-2 pb-4 border-primary",
        id: "solidityUnittestsOutput",
        "data-id": "testTabSolidityUnitTestsOutput",
        children: testsOutput
      })]
    })]
  });
};

exports.SolidityUnitTesting = SolidityUnitTesting;
var _default = SolidityUnitTesting;
exports.default = _default;

/***/ }),
/* 2644 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2645);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2645 */
/***/ (function(module, exports) {

module.exports = [[module.i, "\n  .infoBox  {\n    margin: 5%;\n  }\n  .testList {\n    line-height: 2em;\n    display: flex;\n    flex-direction: column;\n    margin: 5%;\n    max-height: 300px;\n    overflow-y: auto;\n  }\n  .container {\n    padding-bottom: 5%;\n    max-height: 300px;\n    overflow-y: auto;\n  }\n  .summaryTitle {\n    font-weight: bold;\n  }\n  .testPass {\n  }\n  .testLog {\n    margin-bottom: 1%;\n    border-radius: 4px;\n    padding: 1% 1% 1% 5%;\n  }\n  .title {\n    font-size: 1.1em;\n    font-weight: bold;\n    margin-bottom: 1em;\n  }\n  .label {\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n  }\n  .labelOnBtn {\n    border: hidden;\n  }\n  .inputFolder {\n    width: 80%;\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN0eWxlLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0VBQ0U7SUFDRSxVQUFVO0VBQ1o7RUFDQTtJQUNFLGdCQUFnQjtJQUNoQixhQUFhO0lBQ2Isc0JBQXNCO0lBQ3RCLFVBQVU7SUFDVixpQkFBaUI7SUFDakIsZ0JBQWdCO0VBQ2xCO0VBQ0E7SUFDRSxrQkFBa0I7SUFDbEIsaUJBQWlCO0lBQ2pCLGdCQUFnQjtFQUNsQjtFQUNBO0lBQ0UsaUJBQWlCO0VBQ25CO0VBQ0E7RUFDQTtFQUNBO0lBQ0UsaUJBQWlCO0lBQ2pCLGtCQUFrQjtJQUNsQixvQkFBb0I7RUFDdEI7RUFDQTtJQUNFLGdCQUFnQjtJQUNoQixpQkFBaUI7SUFDakIsa0JBQWtCO0VBQ3BCO0VBQ0E7SUFDRSxhQUFhO0lBQ2IsbUJBQW1CO0lBQ25CLG1CQUFtQjtFQUNyQjtFQUNBO0lBQ0UsY0FBYztFQUNoQjtFQUNBO0lBQ0UsVUFBVTtFQUNaIiwiZmlsZSI6InN0eWxlLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAuaW5mb0JveCAge1xuICAgIG1hcmdpbjogNSU7XG4gIH1cbiAgLnRlc3RMaXN0IHtcbiAgICBsaW5lLWhlaWdodDogMmVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBtYXJnaW46IDUlO1xuICAgIG1heC1oZWlnaHQ6IDMwMHB4O1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gIH1cbiAgLmNvbnRhaW5lciB7XG4gICAgcGFkZGluZy1ib3R0b206IDUlO1xuICAgIG1heC1oZWlnaHQ6IDMwMHB4O1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gIH1cbiAgLnN1bW1hcnlUaXRsZSB7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIH1cbiAgLnRlc3RQYXNzIHtcbiAgfVxuICAudGVzdExvZyB7XG4gICAgbWFyZ2luLWJvdHRvbTogMSU7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIHBhZGRpbmc6IDElIDElIDElIDUlO1xuICB9XG4gIC50aXRsZSB7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBtYXJnaW4tYm90dG9tOiAxZW07XG4gIH1cbiAgLmxhYmVsIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgfVxuICAubGFiZWxPbkJ0biB7XG4gICAgYm9yZGVyOiBoaWRkZW47XG4gIH1cbiAgLmlucHV0Rm9sZGVyIHtcbiAgICB3aWR0aDogODAlO1xuICB9Il19 */", '', '']]

/***/ }),
/* 2646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TestTabLogic = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _path = _interopRequireDefault(__webpack_require__(1124));

class TestTabLogic {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(fileManager, helper) {
    (0, _defineProperty2.default)(this, "fileManager", void 0);
    (0, _defineProperty2.default)(this, "currentPath", void 0);
    (0, _defineProperty2.default)(this, "helper", void 0);
    this.fileManager = fileManager;
    this.helper = helper;
    this.currentPath = '/tests';
  }

  setCurrentPath(path) {
    if (path === '/') {
      this.currentPath = '/';
      return;
    }

    if (path.indexOf('/') === 0) return;
    this.currentPath = this.helper.removeMultipleSlashes(this.helper.removeTrailingSlashes(path));
  }

  async generateTestFolder(path) {
    // Todo move this check to File Manager after refactoring
    // Checking to ignore the value which contains only whitespaces
    if (!path || !/\S/.test(path)) return;
    path = this.helper.removeMultipleSlashes(path);
    const fileProvider = this.fileManager.fileProviderOf(path.split('/')[0]);
    if (!(await fileProvider.exists(path))) fileProvider.createDir(path);
  }

  async pathExists(path) {
    // Checking to ignore the value which contains only whitespaces
    if (!path || !/\S/.test(path)) return;
    const fileProvider = this.fileManager.fileProviderOf(path.split('/')[0]);
    return await fileProvider.exists(path);
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  async generateTestFile(errorCb) {
    var _this = this;

    let fileName = this.fileManager.currentFile();
    const hasCurrent = !!fileName && this.fileManager.currentFile().split('.').pop().toLowerCase() === 'sol';
    if (!hasCurrent) fileName = this.currentPath + '/newFile.sol';
    const fileProvider = await this.fileManager.fileProviderOf(this.currentPath);
    if (!fileProvider) return;
    const splittedFileName = fileName.split('/');
    const fileNameToImport = !hasCurrent ? fileName : this.currentPath + '/' + splittedFileName[splittedFileName.length - 1];
    this.helper.createNonClashingNameWithPrefix(fileNameToImport, fileProvider, '_test', async function (error, newFile) {
      if (error) return errorCb('Failed to create file. ' + newFile + ' ' + error);

      try {
        await fileProvider.set(newFile, _this.generateTestContractSample(hasCurrent, fileName));
        await _this.fileManager.open(newFile);
        await _this.fileManager.syncEditor(newFile);
      } catch (e) {
        return errorCb('Failed to create test file ' + newFile);
      }
    });
  }

  dirList(path) {
    return this.fileManager.dirList(path);
  }

  isRemixDActive() {
    return this.fileManager.isRemixDActive();
  }

  async getTests() {
    if (!this.currentPath) return [];
    const provider = this.fileManager.fileProviderOf(this.currentPath);
    if (!provider) return [];
    const tests = [];
    let files = [];

    try {
      if (await this.fileManager.exists(this.currentPath)) files = await this.fileManager.readdir(this.currentPath);
    } catch (e) {
      // eslint-disable-line @typescript-eslint/no-explicit-any
      throw e.message;
    }

    for (const file in files) {
      const filepath = provider && provider.type ? provider.type + '/' + file : file;
      if (/.(_test.sol)$/.exec(file)) tests.push(filepath);
    }

    return tests;
  } // @todo(#2758): If currently selected file is compiled and compilation result is available,
  // 'contractName' should be <compiledContractName> + '_testSuite'


  generateTestContractSample(hasCurrent, fileToImport, contractName = 'testSuite') {
    let relative = _path.default.relative(this.currentPath, _path.default.dirname(fileToImport));

    if (relative === '') relative = '.';
    const comment = hasCurrent ? `import "${relative}/${_path.default.basename(fileToImport)}";` : '// <import file to test>';
    return `// SPDX-License-Identifier: GPL-3.0
        
pragma solidity >=0.4.22 <0.9.0;

// This import is automatically injected by Remix
import "remix_tests.sol"; 

// This import is required to use custom transaction context
// Although it may fail compilation in 'Solidity Compiler' plugin
// But it will work fine in 'Solidity Unit Testing' plugin
import "remix_accounts.sol";
${comment}

// File name has to end with '_test.sol', this file can contain more than one testSuite contracts
contract ${contractName} {

    /// 'beforeAll' runs before all other tests
    /// More special functions are: 'beforeEach', 'beforeAll', 'afterEach' & 'afterAll'
    function beforeAll() public {
        // <instantiate contract>
        Assert.equal(uint(1), uint(1), "1 should be equal to 1");
    }

    function checkSuccess() public {
        // Use 'Assert' methods: https://remix-ide.readthedocs.io/en/latest/assert_library.html
        Assert.ok(2 == 2, 'should be true');
        Assert.greaterThan(uint(2), uint(1), "2 should be greater than to 1");
        Assert.lesserThan(uint(2), uint(3), "2 should be lesser than to 3");
    }

    function checkSuccess2() public pure returns (bool) {
        // Use the return value (true or false) to test the contract
        return true;
    }
    
    function checkFailure() public {
        Assert.notEqual(uint(1), uint(1), "1 should not be equal to 1");
    }

    /// Custom Transaction Context: https://remix-ide.readthedocs.io/en/latest/unittesting.html#customization
    /// #sender: account-1
    /// #value: 100
    function checkSenderAndValue() public payable {
        // account index varies 0-9, value is in wei
        Assert.equal(msg.sender, TestsAccounts.getAccount(1), "Invalid sender");
        Assert.equal(msg.value, 100, "Invalid value");
    }
}
    `;
  }

}

exports.TestTabLogic = TestTabLogic;

/***/ }),
/* 2647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeTestAccountsContract = exports.assertLibCode = exports.runTest = exports.UnitTestRunner = exports.runTestFiles = void 0;

const tslib_1 = __webpack_require__(23);

var runTestFiles_1 = __webpack_require__(2648);

Object.defineProperty(exports, "runTestFiles", {
  enumerable: true,
  get: function () {
    return runTestFiles_1.runTestFiles;
  }
});

var runTestSources_1 = __webpack_require__(2758);

Object.defineProperty(exports, "UnitTestRunner", {
  enumerable: true,
  get: function () {
    return runTestSources_1.UnitTestRunner;
  }
});

var testRunner_1 = __webpack_require__(1375);

Object.defineProperty(exports, "runTest", {
  enumerable: true,
  get: function () {
    return testRunner_1.runTest;
  }
});
(0, tslib_1.__exportStar)(__webpack_require__(1627), exports);
exports.assertLibCode = __webpack_require__(1387); // eslint-disable-line

var compiler_1 = __webpack_require__(1378);

Object.defineProperty(exports, "writeTestAccountsContract", {
  enumerable: true,
  get: function () {
    return compiler_1.writeTestAccountsContract;
  }
});

/***/ }),
/* 2648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runTestFiles = void 0;

const tslib_1 = __webpack_require__(23);

const async_1 = (0, tslib_1.__importDefault)(__webpack_require__(222));
const fileSystem_1 = (0, tslib_1.__importDefault)(__webpack_require__(1603));

const testRunner_1 = __webpack_require__(1375);

const colors_1 = (0, tslib_1.__importDefault)(__webpack_require__(1376));

const compiler_1 = __webpack_require__(1378);

const deployer_1 = __webpack_require__(1630);
/**
 * @dev run test contract files (used for CLI)
 * @param filepath Path of file
 * @param isDirectory True, if path is a directory
 * @param web3 Web3
 * @param finalCallback optional callback to run finally
 * @param opts Options
 */
// eslint-disable-next-line @typescript-eslint/no-empty-function


function runTestFiles(filepath, isDirectory, web3, compilerConfig, finalCallback = () => {}, opts) {
  opts = opts || {};
  compilerConfig = compilerConfig || {};
  const sourceASTs = {};

  const {
    Signale
  } = __webpack_require__(1388); // eslint-disable-line
  // signale configuration


  const options = {
    types: {
      result: {
        badge: '\t✓',
        label: '',
        color: 'greenBright'
      },
      name: {
        badge: '\n\t◼',
        label: '',
        color: 'white'
      },
      error: {
        badge: '\t✘',
        label: '',
        color: 'redBright'
      }
    }
  };
  const signale = new Signale(options);
  let accounts = opts['accounts'] || null;
  async_1.default.waterfall([function getAccountList(next) {
    if (accounts) return next(null);
    web3.eth.getAccounts((_err, _accounts) => {
      accounts = _accounts;
      next(null);
    });
  }, function compile(next) {
    (0, compiler_1.compileFileOrFiles)(filepath, isDirectory, {
      accounts
    }, compilerConfig, next);
  }, function deployAllContracts(compilationResult, asts, next) {
    // Extract AST of test contract file source
    for (const filename in asts) {
      if (filename.endsWith('_test.sol')) {
        sourceASTs[filename] = asts[filename].ast;
      }
    }

    (0, deployer_1.deployAll)(compilationResult, web3, accounts, false, null, (err, contracts) => {
      if (err) {
        // If contract deployment fails because of 'Out of Gas' error, try again with double gas
        // This is temporary, should be removed when remix-tests will have a dedicated UI to
        // accept deployment params from UI
        if (err.message.includes('The contract code couldn\'t be stored, please check your gas limit')) {
          (0, deployer_1.deployAll)(compilationResult, web3, accounts, true, null, (error, contracts) => {
            if (error) next([{
              message: 'contract deployment failed after trying twice: ' + error.message,
              severity: 'error'
            }]); // IDE expects errors in array
            else next(null, compilationResult, contracts);
          });
        } else {
          next([{
            message: 'contract deployment failed: ' + err.message,
            severity: 'error'
          }]);
        } // IDE expects errors in array

      } else {
        next(null, compilationResult, contracts);
      }
    });
  }, function determineTestContractsToRun(compilationResult, contracts, next) {
    const contractsToTest = [];
    const contractsToTestDetails = [];

    const gatherContractsFrom = function (filename) {
      if (!filename.endsWith('_test.sol')) {
        return;
      }

      try {
        Object.keys(compilationResult[filename]).forEach(contractName => {
          contractsToTest.push(contractName);
          contractsToTestDetails.push(compilationResult[filename][contractName]);
        });
      } catch (e) {
        console.error(e);
      }
    };

    if (isDirectory) {
      fileSystem_1.default.walkSync(filepath, foundpath => {
        gatherContractsFrom(foundpath);
      });
    } else {
      gatherContractsFrom(filepath);
    }

    next(null, contractsToTest, contractsToTestDetails, contracts);
  }, function runTests(contractsToTest, contractsToTestDetails, contracts, next) {
    let totalPassing = 0;
    let totalFailing = 0;
    let totalTime = 0;
    const errors = [];

    const _testCallback = function (err, result) {
      if (err) throw err;

      if (result.type === 'contract') {
        signale.name(result.value.white);
      } else if (result.type === 'testPass') {
        signale.result(result.value);
      } else if (result.type === 'testFailure') {
        signale.error(result.value.red);
        errors.push(result);
      }
    };

    const _resultsCallback = (_err, result, cb) => {
      totalPassing += result.passingNum;
      totalFailing += result.failureNum;
      totalTime += result.timePassed;
      cb();
    };

    async_1.default.eachOfLimit(contractsToTest, 1, (contractName, index, cb) => {
      try {
        const fileAST = sourceASTs[contracts[contractName]['filename']];
        (0, testRunner_1.runTest)(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, {
          accounts
        }, _testCallback, (err, result) => {
          if (err) {
            console.log(err);
            return cb(err);
          }

          _resultsCallback(null, result, cb);
        });
      } catch (e) {
        console.error(e);
      }
    }, function (err) {
      if (err) {
        return next(err);
      }

      console.log('\n');

      if (totalPassing > 0) {
        console.log(colors_1.default.green(totalPassing + ' passing ') + colors_1.default.grey('(' + totalTime + 's)'));
      }

      if (totalFailing > 0) {
        console.log(colors_1.default.red(totalFailing + ' failing'));
      }

      console.log('');
      errors.forEach((error, index) => {
        console.log('  ' + (index + 1) + ') ' + colors_1.default.bold(error.context + ': ') + error.value);
        console.log('');
        console.log(colors_1.default.red('\t error: ' + error.errMsg));
        console.log(colors_1.default.green('\t expected value to be ' + error.assertMethod + ' to: ' + error.expected));
        console.log(colors_1.default.red('\t returned: ' + error.returned));
      });
      console.log('');
      next();
    });
  }], finalCallback);
}

exports.runTestFiles = runTestFiles;

/***/ }),
/* 2649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const assertionEvents = [{
  name: 'AssertionEvent',
  params: ['bool', 'string', 'string']
}, {
  name: 'AssertionEventUint',
  params: ['bool', 'string', 'string', 'uint256', 'uint256']
}, {
  name: 'AssertionEventInt',
  params: ['bool', 'string', 'string', 'int256', 'int256']
}, {
  name: 'AssertionEventBool',
  params: ['bool', 'string', 'string', 'bool', 'bool']
}, {
  name: 'AssertionEventAddress',
  params: ['bool', 'string', 'string', 'address', 'address']
}, {
  name: 'AssertionEventBytes32',
  params: ['bool', 'string', 'string', 'bytes32', 'bytes32']
}, {
  name: 'AssertionEventString',
  params: ['bool', 'string', 'string', 'string', 'string']
}, {
  name: 'AssertionEventUintInt',
  params: ['bool', 'string', 'string', 'uint256', 'int256']
}, {
  name: 'AssertionEventIntUint',
  params: ['bool', 'string', 'string', 'int256', 'uint256']
}];
exports.default = assertionEvents;

/***/ }),
/* 2650 */,
/* 2651 */,
/* 2652 */,
/* 2653 */,
/* 2654 */,
/* 2655 */,
/* 2656 */,
/* 2657 */,
/* 2658 */,
/* 2659 */,
/* 2660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

const tslib_1 = __webpack_require__(23);

const colors_1 = (0, tslib_1.__importDefault)(__webpack_require__(1376));
const winston_1 = (0, tslib_1.__importDefault)(__webpack_require__(2661));
const time_stamp_1 = (0, tslib_1.__importDefault)(__webpack_require__(1548));
const color_support_1 = (0, tslib_1.__importDefault)(__webpack_require__(1549));

function hasFlag(flag) {
  return typeof process !== 'undefined' && process.argv.indexOf('--' + flag) !== -1;
}

function addColor(str) {
  if (hasFlag('no-color')) {
    return str;
  }

  if (hasFlag('color')) {
    return colors_1.default.gray(str);
  }

  if ((0, color_support_1.default)()) {
    return colors_1.default.gray(str);
  }

  return str;
}

function getTimestamp() {
  return '[' + addColor((0, time_stamp_1.default)('HH:mm:ss')) + ']';
} // create winston logger format


const logFmt = winston_1.default.format.printf(info => {
  return `${getTimestamp()} ${info.level}: ${info.message}`;
});

class Log {
  constructor() {
    this.logger = winston_1.default.createLogger({
      level: 'info',
      transports: [new winston_1.default.transports.Console()],
      format: winston_1.default.format.combine(winston_1.default.format.colorize({
        all: true
      }), logFmt)
    });
  }

  setVerbosity(v) {
    this.logger.configure({
      level: v,
      transports: [new winston_1.default.transports.Console()],
      format: winston_1.default.format.combine(winston_1.default.format.colorize({
        all: true
      }), logFmt)
    });
  }

}

module.exports = Log;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 2661 */,
/* 2662 */,
/* 2663 */,
/* 2664 */,
/* 2665 */,
/* 2666 */,
/* 2667 */,
/* 2668 */,
/* 2669 */,
/* 2670 */,
/* 2671 */,
/* 2672 */,
/* 2673 */,
/* 2674 */,
/* 2675 */,
/* 2676 */,
/* 2677 */,
/* 2678 */,
/* 2679 */,
/* 2680 */,
/* 2681 */,
/* 2682 */,
/* 2683 */,
/* 2684 */,
/* 2685 */,
/* 2686 */,
/* 2687 */,
/* 2688 */,
/* 2689 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2690 */,
/* 2691 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2692 */,
/* 2693 */,
/* 2694 */,
/* 2695 */,
/* 2696 */,
/* 2697 */,
/* 2698 */,
/* 2699 */,
/* 2700 */,
/* 2701 */,
/* 2702 */,
/* 2703 */,
/* 2704 */,
/* 2705 */,
/* 2706 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2707 */,
/* 2708 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2709 */,
/* 2710 */,
/* 2711 */,
/* 2712 */,
/* 2713 */,
/* 2714 */,
/* 2715 */,
/* 2716 */,
/* 2717 */,
/* 2718 */,
/* 2719 */,
/* 2720 */,
/* 2721 */,
/* 2722 */,
/* 2723 */,
/* 2724 */,
/* 2725 */,
/* 2726 */,
/* 2727 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = `// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.4.22 <0.9.0;

library TestsAccounts {
    function getAccount(uint index) pure public returns (address) {
        >accounts<
        return accounts[index];
    }
}
`;

/***/ }),
/* 2728 */,
/* 2729 */,
/* 2730 */,
/* 2731 */,
/* 2732 */,
/* 2733 */,
/* 2734 */,
/* 2735 */,
/* 2736 */,
/* 2737 */,
/* 2738 */,
/* 2739 */,
/* 2740 */,
/* 2741 */,
/* 2742 */,
/* 2743 */,
/* 2744 */,
/* 2745 */,
/* 2746 */,
/* 2747 */,
/* 2748 */,
/* 2749 */,
/* 2750 */,
/* 2751 */,
/* 2752 */,
/* 2753 */,
/* 2754 */,
/* 2755 */,
/* 2756 */,
/* 2757 */,
/* 2758 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnitTestRunner = void 0;

const tslib_1 = __webpack_require__(23);

const async_1 = (0, tslib_1.__importDefault)(__webpack_require__(222));

const compiler_1 = __webpack_require__(1378);

const deployer_1 = __webpack_require__(1630);

const testRunner_1 = __webpack_require__(1375);

const web3_1 = (0, tslib_1.__importDefault)(__webpack_require__(1125));

const events_1 = __webpack_require__(40);

const remix_simulator_1 = __webpack_require__(1547);

__webpack_require__(1376);

class UnitTestRunner {
  constructor() {
    this.event = new events_1.EventEmitter();
  }

  init(web3 = null, accounts = null) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      this.web3 = yield this.createWeb3Provider(web3);
      this.testsAccounts = accounts || (yield this.web3.eth.getAccounts());
      this.accountsLibCode = (0, compiler_1.writeTestAccountsContract)(this.testsAccounts);
    });
  }

  createWeb3Provider(optWeb3) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      const web3 = optWeb3 || new web3_1.default();
      const provider = new remix_simulator_1.Provider();
      yield provider.init();
      web3.setProvider(provider);
      (0, remix_simulator_1.extend)(web3);
      return web3;
    });
  }
  /**
   * @dev Run tests from source of a test contract file (used for IDE)
   * @param contractSources Sources of contract
   * @param compilerConfig current compiler configuration
   * @param testCallback Test callback
   * @param resultCallback Result Callback
   * @param finalCallback Final Callback
   * @param importFileCb Import file callback
   * @param opts Options
   */


  runTestSources(contractSources, newCompilerConfig, testCallback, resultCallback, deployCb, finalCallback, importFileCb, opts) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
      opts = opts || {};
      const sourceASTs = {};
      if (opts.web3 || opts.accounts) this.init(opts.web3, opts.accounts);
      async_1.default.waterfall([next => {
        (0, compiler_1.compileContractSources)(contractSources, newCompilerConfig, importFileCb, this, {
          accounts: this.testsAccounts,
          testFilePath: opts.testFilePath,
          event: this.event
        }, next);
      }, (compilationResult, asts, next) => {
        for (const filename in asts) {
          if (filename.endsWith('_test.sol')) {
            sourceASTs[filename] = asts[filename].ast;
          }
        }

        (0, deployer_1.deployAll)(compilationResult, this.web3, this.testsAccounts, false, deployCb, (err, contracts) => {
          if (err) {
            // If contract deployment fails because of 'Out of Gas' error, try again with double gas
            // This is temporary, should be removed when remix-tests will have a dedicated UI to
            // accept deployment params from UI
            if (err.message.includes('The contract code couldn\'t be stored, please check your gas limit')) {
              (0, deployer_1.deployAll)(compilationResult, this.web3, this.testsAccounts, true, deployCb, (error, contracts) => {
                if (error) next([{
                  message: 'contract deployment failed after trying twice: ' + error.message,
                  severity: 'error'
                }]); // IDE expects errors in array
                else next(null, compilationResult, contracts);
              });
            } else {
              next([{
                message: 'contract deployment failed: ' + err.message,
                severity: 'error'
              }]);
            } // IDE expects errors in array

          } else {
            next(null, compilationResult, contracts);
          }
        });
      }, function determineTestContractsToRun(compilationResult, contracts, next) {
        const contractsToTest = [];
        const contractsToTestDetails = [];

        for (const filename in compilationResult) {
          if (!filename.endsWith('_test.sol')) {
            continue;
          }

          Object.keys(compilationResult[filename]).forEach(contractName => {
            contractsToTestDetails.push(compilationResult[filename][contractName]);
            contractsToTest.push(contractName);
          });
        }

        next(null, contractsToTest, contractsToTestDetails, contracts);
      }, (contractsToTest, contractsToTestDetails, contracts, next) => {
        let totalPassing = 0;
        let totalFailing = 0;
        let totalTime = 0;
        const errors = []; // eslint-disable-next-line handle-callback-err

        const _testCallback = function (err, result) {
          if (result.type === 'testFailure') {
            errors.push(result);
          }

          testCallback(result);
        };

        const _resultsCallback = function (_err, result, cb) {
          resultCallback(_err, result, () => {}); // eslint-disable-line @typescript-eslint/no-empty-function

          totalPassing += result.passingNum;
          totalFailing += result.failureNum;
          totalTime += result.timePassed;
          cb();
        };

        async_1.default.eachOfLimit(contractsToTest, 1, (contractName, index, cb) => {
          const fileAST = sourceASTs[contracts[contractName]['filename']];
          (0, testRunner_1.runTest)(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, {
            accounts: this.testsAccounts,
            web3: this.web3
          }, _testCallback, (err, result) => {
            if (err) {
              return cb(err);
            }

            _resultsCallback(null, result, cb);
          });
        }, function (err) {
          if (err) {
            return next(err);
          }

          const finalResults = {
            totalPassing: 0,
            totalFailing: 0,
            totalTime: 0,
            errors: []
          };
          finalResults.totalPassing = totalPassing || 0;
          finalResults.totalFailing = totalFailing || 0;
          finalResults.totalTime = totalTime || 0;
          finalResults.errors = [];
          errors.forEach((error, _index) => {
            finalResults.errors.push({
              context: error.context,
              value: error.value,
              message: error.errMsg
            });
          });
          next(null, finalResults);
        });
      }], finalCallback);
    });
  }

}

exports.UnitTestRunner = UnitTestRunner;

/***/ }),
/* 2759 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _react = _interopRequireDefault(__webpack_require__(29));

var _workspace = __webpack_require__(2760);

var _registry = _interopRequireDefault(__webpack_require__(315));

var _remixdHandle = __webpack_require__(2837);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _require = __webpack_require__(2839),
    GitHandle = _require.GitHandle;

var _require2 = __webpack_require__(2840),
    HardhatHandle = _require2.HardhatHandle;

var _require3 = __webpack_require__(2841),
    TruffleHandle = _require3.TruffleHandle;

var _require4 = __webpack_require__(2842),
    SlitherHandle = _require4.SlitherHandle;
/*
  Overview of APIs:
   * fileManager: @args fileProviders (browser, shared-folder, swarm, github, etc ...) & config & editor
      - listen on browser & localhost file provider (`fileRenamed` & `fileRemoved`)
      - update the tabs, switchFile
      - trigger `currentFileChanged`
      - set the current file in the config
   * fileProvider: currently browser, swarm, localhost, github, gist
      - link to backend
      - provide properties `type`, `readonly`
      - provide API `resolveDirectory`, `remove`, `exists`, `rename`, `get`, `set`
      - trigger `fileExternallyChanged`, `fileRemoved`, `fileRenamed`, `fileRenamedError`, `fileAdded`
   * file-explorer: treeview @args fileProvider
      - listen on events triggered by fileProvider
      - call fileProvider API
*/


var profile = {
  name: 'filePanel',
  displayName: 'File explorer',
  methods: ['createNewFile', 'uploadFile', 'getCurrentWorkspace', 'getWorkspaces', 'createWorkspace', 'setWorkspace', 'registerContextMenuItem', 'renameWorkspace', 'deleteWorkspace'],
  events: ['setWorkspace', 'workspaceRenamed', 'workspaceDeleted', 'workspaceCreated'],
  icon: 'assets/img/fileManager.webp',
  description: 'Remix IDE file explorer',
  kind: 'fileexplorer',
  location: 'sidePanel',
  documentation: 'https://remix-ide.readthedocs.io/en/latest/file_explorer.html',
  version: packageJson.version,
  maintainedBy: 'Remix'
};

module.exports = /*#__PURE__*/function (_ViewPlugin) {
  (0, _inherits2["default"])(Filepanel, _ViewPlugin);

  var _super = _createSuper(Filepanel);

  function Filepanel(appManager) {
    var _this;

    (0, _classCallCheck2["default"])(this, Filepanel);
    _this = _super.call(this, profile);
    _this.registry = _registry["default"].getInstance();
    _this.fileProviders = _this.registry.get('fileproviders').api;
    _this.fileManager = _this.registry.get('filemanager').api;
    _this.el = document.createElement('div');

    _this.el.setAttribute('id', 'fileExplorerView');

    _this.remixdHandle = new _remixdHandle.RemixdHandle(_this.fileProviders.localhost, appManager);
    _this.gitHandle = new GitHandle();
    _this.hardhatHandle = new HardhatHandle();
    _this.truffleHandle = new TruffleHandle();
    _this.slitherHandle = new SlitherHandle();
    _this.workspaces = [];
    _this.appManager = appManager;
    _this.currentWorkspaceMetadata = {};
    return _this;
  }

  (0, _createClass2["default"])(Filepanel, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "fileExplorerView"
      }, /*#__PURE__*/_react["default"].createElement(_workspace.FileSystemProvider, {
        plugin: this
      }));
    }
    /**
     * @param item { id: string, name: string, type?: string[], path?: string[], extension?: string[], pattern?: string[] }
     * @param callback (...args) => void
     */

  }, {
    key: "registerContextMenuItem",
    value: function registerContextMenuItem(item) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.emit('registerContextMenuItemReducerEvent', item, function (err, data) {
          if (err) reject(err);else resolve(data);
        });
      });
    }
  }, {
    key: "removePluginActions",
    value: function removePluginActions(plugin) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        _this3.emit('removePluginActionsReducerEvent', plugin, function (err, data) {
          if (err) reject(err);else resolve(data);
        });
      });
    }
  }, {
    key: "getCurrentWorkspace",
    value: function getCurrentWorkspace() {
      return this.currentWorkspaceMetadata;
    }
  }, {
    key: "getWorkspaces",
    value: function getWorkspaces() {
      return this.workspaces;
    }
  }, {
    key: "setWorkspaces",
    value: function setWorkspaces(workspaces) {
      this.workspaces = workspaces;
    }
  }, {
    key: "createNewFile",
    value: function createNewFile() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var provider = _this4.fileManager.currentFileProvider();

        var dir = provider.workspace || '/';

        _this4.emit('createNewFileInputReducerEvent', dir, function (err, data) {
          if (err) reject(err);else resolve(data);
        });
      });
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(target) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var provider = _this5.fileManager.currentFileProvider();

        var dir = provider.workspace || '/';
        return _this5.emit('uploadFileReducerEvent', dir, target, function (err, data) {
          if (err) reject(err);else resolve(data);
        });
      });
    }
  }, {
    key: "createWorkspace",
    value: function createWorkspace(workspaceName, workspaceTemplateName, isEmpty) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        _this6.emit('createWorkspaceReducerEvent', workspaceName, workspaceTemplateName, isEmpty, function (err, data) {
          if (err) reject(err);else resolve(data || true);
        });
      });
    }
  }, {
    key: "renameWorkspace",
    value: function renameWorkspace(oldName, workspaceName) {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        _this7.emit('renameWorkspaceReducerEvent', oldName, workspaceName, function (err, data) {
          if (err) reject(err);else resolve(data || true);
        });
      });
    }
  }, {
    key: "deleteWorkspace",
    value: function deleteWorkspace(workspaceName) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        _this8.emit('deleteWorkspaceReducerEvent', workspaceName, function (err, data) {
          if (err) reject(err);else resolve(data || true);
        });
      });
    }
  }, {
    key: "setWorkspace",
    value: function setWorkspace(workspace) {
      var workspaceProvider = this.fileProviders.workspace;
      this.currentWorkspaceMetadata = {
        name: workspace.name,
        isLocalhost: workspace.isLocalhost,
        absolutePath: "".concat(workspaceProvider.workspacesPath, "/").concat(workspace.name)
      };

      if (workspace.name !== " - connect to localhost - ") {
        localStorage.setItem('currentWorkspace', workspace.name);
      }

      this.emit('setWorkspace', workspace);
    }
  }, {
    key: "workspaceRenamed",
    value: function workspaceRenamed(oldName, workspaceName) {
      this.emit('workspaceRenamed', oldName, workspaceName);
    }
  }, {
    key: "workspaceDeleted",
    value: function workspaceDeleted(workspace) {
      this.emit('workspaceDeleted', workspace);
    }
  }, {
    key: "workspaceCreated",
    value: function workspaceCreated(workspace) {
      this.emit('workspaceCreated', workspace);
    }
    /** end section */

  }]);
  return Filepanel;
}(_engineWeb.ViewPlugin);

/***/ }),
/* 2760 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _FileSystemProvider = __webpack_require__(2761);

Object.keys(_FileSystemProvider).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _FileSystemProvider[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _FileSystemProvider[key];
    }
  });
});

var _contexts = __webpack_require__(1389);

Object.keys(_contexts).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _contexts[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _contexts[key];
    }
  });
});

/***/ }),
/* 2761 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileSystemProvider = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _modalDialog = __webpack_require__(316);

var _toaster = __webpack_require__(479);

var _contexts = __webpack_require__(1389);

var _workspace = __webpack_require__(2762);

var _actions = __webpack_require__(2763);

var _remixUiWorkspace = __webpack_require__(2824);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const FileSystemProvider = props => {
  const {
    plugin
  } = props;
  const [fs, fsDispatch] = (0, _react.useReducer)(_workspace.browserReducer, _workspace.browserInitialState);
  const [focusModal, setFocusModal] = (0, _react.useState)({
    hide: true,
    title: '',
    message: '',
    okLabel: '',
    okFn: () => {},
    cancelLabel: '',
    cancelFn: () => {}
  });
  const [modals, setModals] = (0, _react.useState)([]);
  const [focusToaster, setFocusToaster] = (0, _react.useState)('');
  const [toasters, setToasters] = (0, _react.useState)([]);

  const dispatchInitWorkspace = async () => {
    await (0, _actions.initWorkspace)(plugin)(fsDispatch);
  };

  const dispatchFetchDirectory = async path => {
    await (0, _actions.fetchDirectory)(path);
  };

  const dispatchAddInputField = async (path, type) => {
    await (0, _actions.addInputField)(type, path);
  };

  const dispatchRemoveInputField = async path => {
    await (0, _actions.removeInputField)(path);
  };

  const dispatchCreateWorkspace = async (workspaceName, workspaceTemplateName) => {
    await (0, _actions.createWorkspace)(workspaceName, workspaceTemplateName);
  };

  const dispatchFetchWorkspaceDirectory = async path => {
    await (0, _actions.fetchWorkspaceDirectory)(path);
  };

  const dispatchSwitchToWorkspace = async name => {
    await (0, _actions.switchToWorkspace)(name);
  };

  const dispatchRenameWorkspace = async (oldName, workspaceName) => {
    await (0, _actions.renameWorkspace)(oldName, workspaceName);
  };

  const dispatchDeleteWorkspace = async workspaceName => {
    await (0, _actions.deleteWorkspace)(workspaceName);
  };

  const dispatchPublishToGist = async (path, type) => {
    await (0, _actions.publishToGist)(path, type);
  };

  const dispatchUploadFile = async (target, targetFolder) => {
    await (0, _actions.uploadFile)(target, targetFolder);
  };

  const dispatchCreateNewFile = async (path, rootDir) => {
    await (0, _actions.createNewFile)(path, rootDir);
  };

  const dispatchSetFocusElement = async elements => {
    await (0, _actions.setFocusElement)(elements);
  };

  const dispatchCreateNewFolder = async (path, rootDir) => {
    await (0, _actions.createNewFolder)(path, rootDir);
  };

  const dispatchDeletePath = async path => {
    await (0, _actions.deletePath)(path);
  };

  const dispatchRenamePath = async (oldPath, newPath) => {
    await (0, _actions.renamePath)(oldPath, newPath);
  };

  const dispatchCopyFile = async (src, dest) => {
    await (0, _actions.copyFile)(src, dest);
  };

  const dispatchCopyFolder = async (src, dest) => {
    await (0, _actions.copyFolder)(src, dest);
  };

  const dispatchRunScript = async path => {
    await (0, _actions.runScript)(path);
  };

  const dispatchEmitContextMenuEvent = async cmd => {
    await (0, _actions.emitContextMenuEvent)(cmd);
  };

  const dispatchHandleClickFile = async (path, type) => {
    await (0, _actions.handleClickFile)(path, type);
  };

  const dispatchHandleExpandPath = async paths => {
    await (0, _actions.handleExpandPath)(paths);
  };

  const dispatchHandleDownloadFiles = async () => {
    await (0, _actions.handleDownloadFiles)();
  };

  const dispatchHandleRestoreBackup = async () => {
    await (0, _actions.restoreBackupZip)();
  };

  const dispatchCloneRepository = async url => {
    await (0, _actions.cloneRepository)(url);
  };

  (0, _react.useEffect)(() => {
    dispatchInitWorkspace();
  }, []);
  (0, _react.useEffect)(() => {
    if (modals.length > 0) {
      setFocusModal(() => {
        const focusModal = {
          hide: false,
          title: modals[0].title,
          message: modals[0].message,
          okLabel: modals[0].okLabel,
          okFn: modals[0].okFn,
          cancelLabel: modals[0].cancelLabel,
          cancelFn: modals[0].cancelFn
        };
        return focusModal;
      });
      const modalList = modals.slice();
      modalList.shift();
      setModals(modalList);
    }
  }, [modals]);
  (0, _react.useEffect)(() => {
    if (toasters.length > 0) {
      setFocusToaster(() => {
        return toasters[0];
      });
      const toasterList = toasters.slice();
      toasterList.shift();
      setToasters(toasterList);
    }
  }, [toasters]);
  (0, _react.useEffect)(() => {
    if (fs.notification.title) {
      modal(fs.notification.title, fs.notification.message, fs.notification.labelOk, fs.notification.actionOk, fs.notification.labelCancel, fs.notification.actionCancel);
    }
  }, [fs.notification]);
  (0, _react.useEffect)(() => {
    if (fs.popup) {
      toast(fs.popup);
    }
  }, [fs.popup]);

  const handleHideModal = () => {
    setFocusModal(modal => {
      return _objectSpread(_objectSpread({}, modal), {}, {
        hide: true,
        message: null
      });
    });
  };

  const modal = (title, message, okLabel, okFn, cancelLabel, cancelFn) => {
    setModals(modals => {
      modals.push({
        message,
        title,
        okLabel,
        okFn,
        cancelLabel,
        cancelFn
      });
      return [...modals];
    });
  };

  const handleToaster = () => {
    setFocusToaster('');
    (0, _actions.clearPopUp)();
  };

  const toast = toasterMsg => {
    setToasters(messages => {
      messages.push(toasterMsg);
      return [...messages];
    });
  };

  const value = {
    fs,
    modal,
    toast,
    dispatchInitWorkspace,
    dispatchFetchDirectory,
    dispatchAddInputField,
    dispatchRemoveInputField,
    dispatchCreateWorkspace,
    dispatchFetchWorkspaceDirectory,
    dispatchSwitchToWorkspace,
    dispatchRenameWorkspace,
    dispatchDeleteWorkspace,
    dispatchPublishToGist,
    dispatchUploadFile,
    dispatchCreateNewFile,
    dispatchSetFocusElement,
    dispatchCreateNewFolder,
    dispatchDeletePath,
    dispatchRenamePath,
    dispatchCopyFile,
    dispatchCopyFolder,
    dispatchRunScript,
    dispatchEmitContextMenuEvent,
    dispatchHandleClickFile,
    dispatchHandleExpandPath,
    dispatchHandleDownloadFiles,
    dispatchHandleRestoreBackup,
    dispatchCloneRepository
  };
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_contexts.FileSystemContext.Provider, {
    value: value,
    children: [fs.initializingFS && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "text-center py-5",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: "fas fa-spinner fa-pulse fa-2x"
      })
    }), !fs.initializingFS && /*#__PURE__*/(0, _jsxRuntime.jsx)(_remixUiWorkspace.Workspace, {}), /*#__PURE__*/(0, _jsxRuntime.jsx)(_modalDialog.ModalDialog, _objectSpread(_objectSpread({
      id: "fileSystem"
    }, focusModal), {}, {
      handleHide: handleHideModal
    })), /*#__PURE__*/(0, _jsxRuntime.jsx)(_toaster.Toaster, {
      message: focusToaster,
      handleHide: handleToaster
    })]
  });
};

exports.FileSystemProvider = FileSystemProvider;
var _default = FileSystemProvider;
exports.default = _default;

/***/ }),
/* 2762 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.browserReducer = exports.browserInitialState = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _helper = __webpack_require__(1121);

var _ = _interopRequireWildcard(__webpack_require__(1361));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const browserInitialState = {
  browser: {
    currentWorkspace: '',
    workspaces: [],
    files: {},
    expandPath: [],
    isRequestingDirectory: false,
    isSuccessfulDirectory: false,
    isRequestingWorkspace: false,
    isSuccessfulWorkspace: false,
    isRequestingCloning: false,
    isSuccessfulCloning: false,
    error: null,
    contextMenu: {
      registeredMenuItems: [],
      removedMenuItems: [],
      error: null
    }
  },
  localhost: {
    sharedFolder: '',
    files: {},
    expandPath: [],
    isRequestingDirectory: false,
    isSuccessfulDirectory: false,
    isRequestingLocalhost: false,
    isSuccessfulLocalhost: false,
    error: null,
    contextMenu: {
      registeredMenuItems: [],
      removedMenuItems: [],
      error: null
    }
  },
  mode: 'browser',
  notification: {
    title: '',
    message: '',
    actionOk: () => {},
    actionCancel: () => {},
    labelOk: '',
    labelCancel: ''
  },
  readonly: false,
  popup: '',
  focusEdit: '',
  focusElement: [],
  initializingFS: true
};
exports.browserInitialState = browserInitialState;

const browserReducer = (state = browserInitialState, action) => {
  switch (action.type) {
    case 'SET_CURRENT_WORKSPACE':
      {
        const payload = action.payload;
        const workspaces = state.browser.workspaces.find(({
          name
        }) => name === payload.name) ? state.browser.workspaces : [...state.browser.workspaces, action.payload];
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            currentWorkspace: payload.name,
            workspaces: workspaces.filter(workspace => workspace)
          })
        });
      }

    case 'SET_WORKSPACES':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            workspaces: payload.filter(workspace => workspace)
          })
        });
      }

    case 'SET_MODE':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          mode: payload
        });
      }

    case 'FETCH_DIRECTORY_REQUEST':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingDirectory: state.mode === 'browser',
            isSuccessfulDirectory: false,
            error: null
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingDirectory: state.mode === 'localhost',
            isSuccessfulDirectory: false,
            error: null
          })
        });
      }

    case 'FETCH_DIRECTORY_SUCCESS':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fetchDirectoryContent(state, payload) : state.browser.files,
            isRequestingDirectory: false,
            isSuccessfulDirectory: true,
            error: null
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fetchDirectoryContent(state, payload) : state.localhost.files,
            isRequestingDirectory: false,
            isSuccessfulDirectory: true,
            error: null
          })
        });
      }

    case 'FETCH_DIRECTORY_ERROR':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingDirectory: false,
            isSuccessfulDirectory: false,
            error: state.mode === 'browser' ? action.payload : null
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingDirectory: false,
            isSuccessfulDirectory: false,
            error: state.mode === 'localhost' ? action.payload : null
          })
        });
      }

    case 'FETCH_WORKSPACE_DIRECTORY_REQUEST':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingWorkspace: state.mode === 'browser',
            isSuccessfulWorkspace: false,
            error: null
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingWorkspace: state.mode === 'localhost',
            isSuccessfulWorkspace: false,
            error: null
          })
        });
      }

    case 'FETCH_WORKSPACE_DIRECTORY_SUCCESS':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fetchWorkspaceDirectoryContent(state, payload) : state.browser.files,
            isRequestingWorkspace: false,
            isSuccessfulWorkspace: true,
            error: null
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fetchWorkspaceDirectoryContent(state, payload) : state.localhost.files,
            isRequestingWorkspace: false,
            isSuccessfulWorkspace: true,
            error: null,
            sharedFolder: null
          })
        });
      }

    case 'FETCH_WORKSPACE_DIRECTORY_ERROR':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingWorkspace: false,
            isSuccessfulWorkspace: false,
            error: state.mode === 'browser' ? action.payload : null
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingWorkspace: false,
            isSuccessfulWorkspace: false,
            error: state.mode === 'localhost' ? action.payload : null
          })
        });
      }

    case 'DISPLAY_NOTIFICATION':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          notification: {
            title: payload.title,
            message: payload.message,
            actionOk: payload.actionOk || browserInitialState.notification.actionOk,
            actionCancel: payload.actionCancel || browserInitialState.notification.actionCancel,
            labelOk: payload.labelOk,
            labelCancel: payload.labelCancel
          }
        });
      }

    case 'HIDE_NOTIFICATION':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          notification: browserInitialState.notification
        });
      }

    case 'FILE_ADDED_SUCCESS':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fileAdded(state, payload) : state.browser.files,
            expandPath: state.mode === 'browser' ? [...new Set([...state.browser.expandPath, payload])] : state.browser.expandPath
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fileAdded(state, payload) : state.localhost.files,
            expandPath: state.mode === 'localhost' ? [...new Set([...state.localhost.expandPath, payload])] : state.localhost.expandPath
          })
        });
      }

    case 'FOLDER_ADDED_SUCCESS':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fetchDirectoryContent(state, payload) : state.browser.files,
            expandPath: state.mode === 'browser' ? [...new Set([...state.browser.expandPath, payload.folderPath])] : state.browser.expandPath
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fetchDirectoryContent(state, payload) : state.localhost.files,
            expandPath: state.mode === 'localhost' ? [...new Set([...state.localhost.expandPath, payload.folderPath])] : state.localhost.expandPath
          })
        });
      }

    case 'FILE_REMOVED_SUCCESS':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fileRemoved(state, payload) : state.browser.files,
            expandPath: state.mode === 'browser' ? [...state.browser.expandPath.filter(path => path !== payload)] : state.browser.expandPath
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fileRemoved(state, payload) : state.localhost.files,
            expandPath: state.mode === 'localhost' ? [...state.browser.expandPath.filter(path => path !== payload)] : state.localhost.expandPath
          })
        });
      }

    case 'ROOT_FOLDER_CHANGED':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            sharedFolder: payload,
            files: {}
          })
        });
      }

    case 'ADD_INPUT_FIELD':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fetchDirectoryContent(state, payload) : state.browser.files
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fetchDirectoryContent(state, payload) : state.localhost.files
          }),
          focusEdit: payload.path + '/' + 'blank'
        });
      }

    case 'REMOVE_INPUT_FIELD':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? removeInputField(state, payload.path) : state.browser.files
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? removeInputField(state, payload.path) : state.localhost.files
          }),
          focusEdit: null
        });
      }

    case 'SET_READ_ONLY_MODE':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          readonly: payload
        });
      }

    case 'FILE_RENAMED_SUCCESS':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            files: state.mode === 'browser' ? fetchDirectoryContent(state, payload, payload.oldPath) : state.browser.files
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            files: state.mode === 'localhost' ? fetchDirectoryContent(state, payload, payload.oldPath) : state.localhost.files
          })
        });
      }

    case 'CREATE_WORKSPACE_REQUEST':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingWorkspace: true,
            isSuccessfulWorkspace: false,
            error: null
          })
        });
      }

    case 'CREATE_WORKSPACE_SUCCESS':
      {
        const payload = action.payload;
        const workspaces = state.browser.workspaces.find(({
          name
        }) => name === payload.name) ? state.browser.workspaces : [...state.browser.workspaces, action.payload];
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            currentWorkspace: payload.name,
            workspaces: workspaces.filter(workspace => workspace),
            isRequestingWorkspace: false,
            isSuccessfulWorkspace: true,
            error: null
          })
        });
      }

    case 'CREATE_WORKSPACE_ERROR':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingWorkspace: false,
            isSuccessfulWorkspace: false,
            error: action.payload
          })
        });
      }

    case 'RENAME_WORKSPACE':
      {
        const payload = action.payload;
        let renamedWorkspace;
        const workspaces = state.browser.workspaces.filter(({
          name,
          isGitRepo
        }) => {
          if (name && name !== payload.oldName) {
            return true;
          } else {
            renamedWorkspace = {
              name: payload.workspaceName,
              isGitRepo
            };
            return false;
          }
        });
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            currentWorkspace: payload.workspaceName,
            workspaces: [...workspaces, renamedWorkspace],
            expandPath: []
          })
        });
      }

    case 'DELETE_WORKSPACE':
      {
        const payload = action.payload;
        const workspaces = state.browser.workspaces.filter(({
          name
        }) => name && name !== payload);
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            workspaces: workspaces
          })
        });
      }

    case 'DISPLAY_POPUP_MESSAGE':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          popup: payload
        });
      }

    case 'HIDE_POPUP_MESSAGE':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          popup: ''
        });
      }

    case 'SET_FOCUS_ELEMENT':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          focusElement: payload
        });
      }

    case 'REMOVE_FOCUS_ELEMENT':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          focusElement: state.focusElement.filter(element => element.key !== payload)
        });
      }

    case 'SET_CONTEXT_MENU_ITEM':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            contextMenu: addContextMenuItem(state, payload)
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            contextMenu: addContextMenuItem(state, payload)
          })
        });
      }

    case 'REMOVE_CONTEXT_MENU_ITEM':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            contextMenu: removeContextMenuItem(state, payload)
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            contextMenu: removeContextMenuItem(state, payload)
          })
        });
      }

    case 'SET_EXPAND_PATH':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            expandPath: payload
          }),
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            expandPath: payload
          })
        });
      }

    case 'LOAD_LOCALHOST_REQUEST':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingLocalhost: true,
            isSuccessfulLocalhost: false,
            error: null
          })
        });
      }

    case 'LOAD_LOCALHOST_SUCCESS':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingLocalhost: false,
            isSuccessfulLocalhost: true,
            error: null
          })
        });
      }

    case 'LOAD_LOCALHOST_ERROR':
      {
        const payload = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          localhost: _objectSpread(_objectSpread({}, state.localhost), {}, {
            isRequestingLocalhost: false,
            isSuccessfulLocalhost: false,
            error: payload
          })
        });
      }

    case 'CLONE_REPOSITORY_REQUEST':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingCloning: true,
            isSuccessfulCloning: false
          })
        });
      }

    case 'CLONE_REPOSITORY_SUCCESS':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingCloning: false,
            isSuccessfulCloning: true
          })
        });
      }

    case 'CLONE_REPOSITORY_FAILED':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          browser: _objectSpread(_objectSpread({}, state.browser), {}, {
            isRequestingCloning: false,
            isSuccessfulCloning: false
          })
        });
      }

    case 'FS_INITIALIZATION_COMPLETED':
      {
        return _objectSpread(_objectSpread({}, state), {}, {
          initializingFS: false
        });
      }

    default:
      throw new Error();
  }
};

exports.browserReducer = browserReducer;

const fileAdded = (state, path) => {
  let files = state.mode === 'browser' ? state.browser.files : state.localhost.files;

  const _path = splitPath(state, path);

  files = _.setWith(files, _path, {
    path: path,
    name: (0, _helper.extractNameFromKey)(path),
    isDirectory: false,
    type: 'file'
  }, Object);
  return files;
};

const fileRemoved = (state, path) => {
  const files = state.mode === 'browser' ? state.browser.files : state.localhost.files;

  const _path = splitPath(state, path);

  _.unset(files, _path);

  return files;
};

const removeInputField = (state, path) => {
  let files = state.mode === 'browser' ? state.browser.files : state.localhost.files;
  const root = state.mode === 'browser' ? state.browser.currentWorkspace : state.mode;

  if (path === root) {
    delete files[root][path + '/' + 'blank'];
    return files;
  }

  const _path = splitPath(state, path);

  const prevFiles = _.get(files, _path);

  if (prevFiles) {
    prevFiles.child && prevFiles.child[path + '/' + 'blank'] && delete prevFiles.child[path + '/' + 'blank'];
    files = _.setWith(files, _path, {
      isDirectory: true,
      path,
      name: (0, _helper.extractNameFromKey)(path),
      type: (0, _helper.extractNameFromKey)(path).indexOf('gist-') === 0 ? 'gist' : 'folder',
      child: prevFiles ? prevFiles.child : {}
    }, Object);
  }

  return files;
}; // IDEA: Modify function to remove blank input field without fetching content


const fetchDirectoryContent = (state, payload, deletePath) => {
  if (!payload.fileTree) return state.mode === 'browser' ? state.browser.files : state[state.mode].files;

  if (state.mode === 'browser') {
    if (payload.path === state.browser.currentWorkspace) {
      let files = normalize(payload.fileTree, payload.path, payload.type);
      files = _.merge(files, state.browser.files[state.browser.currentWorkspace]);
      if (deletePath) delete files[deletePath];
      return {
        [state.browser.currentWorkspace]: files
      };
    } else {
      let files = state.browser.files;

      const _path = splitPath(state, payload.path);

      let prevFiles = _.get(files, _path);

      if (!prevFiles) {
        const object = {};
        let o = object;

        for (const pa of _path) {
          o = o[pa] = {};
        }

        files = _.defaultsDeep(files, object);
        prevFiles = _.get(files, _path);
      }

      if (prevFiles) {
        prevFiles.child = _.merge(normalize(payload.fileTree, payload.path, payload.type), prevFiles.child);

        if (deletePath) {
          if (deletePath.endsWith('/blank')) delete prevFiles.child[deletePath];else {
            deletePath = (0, _helper.extractNameFromKey)(deletePath);
            delete prevFiles.child[deletePath];
          }
        }

        files = _.setWith(files, _path, prevFiles, Object);
      } else if (payload.fileTree && payload.path) {
        files = {
          [payload.path]: normalize(payload.fileTree, payload.path, payload.type)
        };
      }

      return files;
    }
  } else {
    if (payload.path === '/') {
      const files = normalize(payload.fileTree, payload.path, payload.type);
      return {
        [state.mode]: files
      };
    } else if (payload.path === state.mode) {
      let files = normalize(payload.fileTree, payload.path, payload.type);
      files = _.merge(files, state[state.mode].files[state.mode]);
      if (deletePath) delete files[deletePath];
      return {
        [state.mode]: files
      };
    } else {
      let files = state.localhost.files;

      const _path = splitPath(state, payload.path);

      const prevFiles = _.get(files, _path);

      if (prevFiles) {
        prevFiles.child = _.merge(normalize(payload.fileTree, payload.path, payload.type), prevFiles.child);

        if (deletePath) {
          if (deletePath.endsWith('/blank')) delete prevFiles.child[deletePath];else {
            deletePath = (0, _helper.extractNameFromKey)(deletePath);
            delete prevFiles.child[deletePath];
          }
        }

        files = _.setWith(files, _path, prevFiles, Object);
      } else {
        files = {
          [payload.path]: normalize(payload.fileTree, payload.path, payload.type)
        };
      }

      return files;
    }
  }
};

const fetchWorkspaceDirectoryContent = (state, payload) => {
  if (state.mode === 'browser') {
    const files = normalize(payload.fileTree, payload.path);
    return {
      [payload.path]: files
    };
  } else {
    return fetchDirectoryContent(state, payload);
  }
};

const normalize = (filesList, directory, newInputType) => {
  const folders = {};
  const files = {};
  Object.keys(filesList || {}).forEach(key => {
    key = key.replace(/^\/|\/$/g, ''); // remove first and last slash

    let path = key;
    path = path.replace(/^\/|\/$/g, ''); // remove first and last slash

    if (filesList[key].isDirectory) {
      folders[(0, _helper.extractNameFromKey)(key)] = {
        path,
        name: (0, _helper.extractNameFromKey)(path),
        isDirectory: filesList[key].isDirectory,
        type: (0, _helper.extractNameFromKey)(path).indexOf('gist-') === 0 ? 'gist' : 'folder'
      };
    } else {
      files[(0, _helper.extractNameFromKey)(key)] = {
        path,
        name: (0, _helper.extractNameFromKey)(path),
        isDirectory: filesList[key].isDirectory,
        type: 'file'
      };
    }
  });

  if (newInputType === 'folder') {
    const path = directory + '/blank';
    folders[path] = {
      path: path,
      name: '',
      isDirectory: true,
      type: 'folder'
    };
  } else if (newInputType === 'file') {
    const path = directory + '/blank';
    files[path] = {
      path: path,
      name: '',
      isDirectory: false,
      type: 'file'
    };
  }

  return Object.assign({}, folders, files);
};

const splitPath = (state, path) => {
  const root = state.mode === 'browser' ? state.browser.currentWorkspace : 'localhost';
  const pathArr = (path || '').split('/').filter(value => value);
  if (pathArr[0] !== root) pathArr.unshift(root);

  const _path = pathArr.map((key, index) => index > 1 ? ['child', key] : key).reduce((acc, cur) => {
    return Array.isArray(cur) ? [...acc, ...cur] : [...acc, cur];
  }, []);

  return _path;
};

const addContextMenuItem = (state, item) => {
  let registeredItems = state[state.mode].contextMenu.registeredMenuItems;
  let removedItems = state[state.mode].contextMenu.removedMenuItems;
  let error = null;

  if (registeredItems.filter(o => {
    return o.id === item.id && o.name === item.name;
  }).length) {
    error = `Action ${item.name} already exists on ${item.id}`;
    return {
      registeredMenuItems: registeredItems,
      removedMenuItems: removedItems,
      error
    };
  }

  registeredItems = [...registeredItems, item];
  removedItems = removedItems.filter(menuItem => item.id !== menuItem.id);
  return {
    registeredMenuItems: registeredItems,
    removedMenuItems: removedItems,
    error
  };
};

const removeContextMenuItem = (state, plugin) => {
  let registeredItems = state[state.mode].contextMenu.registeredMenuItems;
  const removedItems = state[state.mode].contextMenu.removedMenuItems;
  const error = null;
  registeredItems = registeredItems.filter(item => {
    if (item.id !== plugin.name || item.sticky === true) return true;else {
      removedItems.push(item);
      return false;
    }
  });
  return {
    registeredMenuItems: registeredItems,
    removedMenuItems: removedItems,
    error
  };
};

/***/ }),
/* 2763 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  initWorkspace: true,
  fetchDirectory: true,
  removeInputField: true,
  publishToGist: true,
  clearPopUp: true,
  createNewFile: true,
  setFocusElement: true,
  createNewFolder: true,
  deletePath: true,
  renamePath: true,
  copyFile: true,
  copyFolder: true,
  runScript: true,
  emitContextMenuEvent: true,
  handleClickFile: true,
  handleExpandPath: true,
  handleDownloadFiles: true,
  restoreBackupZip: true
};
exports.setFocusElement = exports.runScript = exports.restoreBackupZip = exports.renamePath = exports.removeInputField = exports.publishToGist = exports.initWorkspace = exports.handleExpandPath = exports.handleDownloadFiles = exports.handleClickFile = exports.fetchDirectory = exports.emitContextMenuEvent = exports.deletePath = exports.createNewFolder = exports.createNewFile = exports.copyFolder = exports.copyFile = exports.clearPopUp = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _helper = __webpack_require__(1121);

var _gists = _interopRequireDefault(__webpack_require__(2764));

var _payload = __webpack_require__(1391);

var _events = __webpack_require__(2789);

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _events[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _events[key];
    }
  });
});

var _workspace = __webpack_require__(1633);

Object.keys(_workspace).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _workspace[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _workspace[key];
    }
  });
});

var _remixLib = __webpack_require__(311);

var _corePlugin = __webpack_require__(1253);

var _jszip = _interopRequireDefault(__webpack_require__(489));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const queryParams = new _remixLib.QueryParams();

const _paq = window._paq = window._paq || [];

let plugin, dispatch;

const basicWorkspaceInit = async (workspaces, workspaceProvider) => {
  if (workspaces.length === 0) {
    await (0, _workspace.createWorkspaceTemplate)('default_workspace', 'remixDefault');
    plugin.setWorkspace({
      name: 'default_workspace',
      isLocalhost: false
    });
    dispatch((0, _payload.setCurrentWorkspace)({
      name: 'default_workspace',
      isGitRepo: false
    }));
    await (0, _workspace.loadWorkspacePreset)('remixDefault');
  } else {
    if (workspaces.length > 0) {
      const workspace = workspaces[workspaces.length - 1];
      const workspaceName = (workspace || {}).name;
      workspaceProvider.setWorkspace(workspaceName);
      plugin.setWorkspace({
        name: workspaceName,
        isLocalhost: false
      });
      dispatch((0, _payload.setCurrentWorkspace)(workspace));
    }
  }
};

const initWorkspace = filePanelPlugin => async reducerDispatch => {
  if (filePanelPlugin) {
    plugin = filePanelPlugin;
    dispatch = reducerDispatch;
    (0, _workspace.setPlugin)(plugin, dispatch);
    const workspaceProvider = filePanelPlugin.fileProviders.workspace;
    const localhostProvider = filePanelPlugin.fileProviders.localhost;
    const params = queryParams.get();
    const workspaces = (await (0, _workspace.getWorkspaces)()) || [];
    dispatch((0, _payload.setWorkspaces)(workspaces));

    if (params.gist) {
      await (0, _workspace.createWorkspaceTemplate)('gist-sample', 'gist-template');
      plugin.setWorkspace({
        name: 'gist-sample',
        isLocalhost: false
      });
      dispatch((0, _payload.setCurrentWorkspace)({
        name: 'gist-sample',
        isGitRepo: false
      }));
      await (0, _workspace.loadWorkspacePreset)('gist-template');
    } else if (params.code || params.url) {
      await (0, _workspace.createWorkspaceTemplate)('code-sample', 'code-template');
      plugin.setWorkspace({
        name: 'code-sample',
        isLocalhost: false
      });
      dispatch((0, _payload.setCurrentWorkspace)({
        name: 'code-sample',
        isGitRepo: false
      }));
      const filePath = await (0, _workspace.loadWorkspacePreset)('code-template');
      plugin.on('editor', 'editorMounted', async () => await plugin.fileManager.openFile(filePath));
    } else if (params.address) {
      if (params.address.startsWith('0x') && params.address.length === 42) {
        const contractAddress = params.address;
        plugin.call('notification', 'toast', `Looking for contract(s) verified on different networks of Etherscan for contract address ${contractAddress} .....`);
        let data;
        let count = 0;

        try {
          let etherscanKey = await plugin.call('config', 'getAppParameter', 'etherscan-access-token');
          if (!etherscanKey) etherscanKey = '2HKUX5ZVASZIKWJM8MIQVCRUVZ6JAWT531';
          const networks = [{
            id: 1,
            name: 'mainnet'
          }, {
            id: 3,
            name: 'ropsten'
          }, {
            id: 4,
            name: 'rinkeby'
          }, {
            id: 42,
            name: 'kovan'
          }, {
            id: 5,
            name: 'goerli'
          }];
          let found = false;
          const foundOnNetworks = [];

          for (const network of networks) {
            const target = `/${network.name}/${contractAddress}`;

            try {
              data = await (0, _corePlugin.fetchContractFromEtherscan)(plugin, network, contractAddress, target, etherscanKey);
            } catch (error) {
              if ((error.message.startsWith('contract not verified on Etherscan') || error.message.startsWith('unable to retrieve contract data')) && network.id !== 5) continue;else {
                if (!found) await basicWorkspaceInit(workspaces, workspaceProvider);
                break;
              }
            }

            found = true;
            foundOnNetworks.push(network.name);
            await (0, _workspace.createWorkspaceTemplate)('etherscan-code-sample', 'code-template');
            plugin.setWorkspace({
              name: 'etherscan-code-sample',
              isLocalhost: false
            });
            dispatch((0, _payload.setCurrentWorkspace)({
              name: 'etherscan-code-sample',
              isGitRepo: false
            }));
            let filePath;
            count = count + Object.keys(data.compilationTargets).length;

            for (filePath in data.compilationTargets) await workspaceProvider.set(filePath, data.compilationTargets[filePath]['content']);

            plugin.on('editor', 'editorMounted', async () => await plugin.fileManager.openFile(filePath));
          }

          plugin.call('notification', 'toast', `Added ${count} verified contract${count === 1 ? '' : 's'} from ${foundOnNetworks.join(',')} network${foundOnNetworks.length === 1 ? '' : 's'} of Etherscan for contract address ${contractAddress} !!`);
        } catch (error) {
          await basicWorkspaceInit(workspaces, workspaceProvider);
        }
      } else await basicWorkspaceInit(workspaces, workspaceProvider);
    } else if (localStorage.getItem("currentWorkspace")) {
      const index = workspaces.findIndex(element => element.name == localStorage.getItem("currentWorkspace"));

      if (index !== -1) {
        const name = localStorage.getItem("currentWorkspace");
        workspaceProvider.setWorkspace(name);
        plugin.setWorkspace({
          name: name,
          isLocalhost: false
        });
        dispatch((0, _payload.setCurrentWorkspace)({
          name: name,
          isGitRepo: false
        }));
      }
    } else {
      await basicWorkspaceInit(workspaces, workspaceProvider);
    }

    (0, _events.listenOnPluginEvents)(plugin);
    (0, _events.listenOnProviderEvents)(workspaceProvider)(dispatch);
    (0, _events.listenOnProviderEvents)(localhostProvider)(dispatch);
    dispatch((0, _payload.setMode)('browser'));
    plugin.setWorkspaces(await (0, _workspace.getWorkspaces)());
    dispatch((0, _payload.fsInitializationCompleted)());
    plugin.emit('workspaceInitializationCompleted');
  }
};

exports.initWorkspace = initWorkspace;

const fetchDirectory = async path => {
  const provider = plugin.fileManager.currentFileProvider();
  const promise = new Promise(resolve => {
    provider.resolveDirectory(path, (error, fileTree) => {
      if (error) console.error(error);
      resolve(fileTree);
    });
  });
  dispatch((0, _payload.fetchDirectoryRequest)(promise));
  promise.then(fileTree => {
    dispatch((0, _payload.fetchDirectorySuccess)(path, fileTree));
  }).catch(error => {
    dispatch((0, _payload.fetchDirectoryError)({
      error
    }));
  });
  return promise;
};

exports.fetchDirectory = fetchDirectory;

const removeInputField = async path => {
  dispatch((0, _payload.removeInputFieldSuccess)(path));
};

exports.removeInputField = removeInputField;

const publishToGist = async (path, type) => {
  // If 'id' is not defined, it is not a gist update but a creation so we have to take the files from the browser explorer.
  const folder = path || '/';
  const id = type === 'gist' ? (0, _helper.extractNameFromKey)(path).split('-')[1] : null;

  try {
    const packaged = await packageGistFiles(folder); // check for token

    const config = plugin.registry.get('config').api;
    const accessToken = config.get('settings/gist-access-token');

    if (!accessToken) {
      dispatch((0, _payload.displayNotification)('Authorize Token', 'Remix requires an access token (which includes gists creation permission). Please go to the settings tab to create one.', 'Close', null, () => {}));
    } else {
      const params = queryParams.get();
      const description = 'Created using remix-ide: Realtime Ethereum Contract Compiler and Runtime. \n Load this file by pasting this gists URL or ID at https://remix.ethereum.org/#version=' + params.version + '&optimize=' + params.optimize + '&runs=' + params.runs + '&gist=';
      const gists = new _gists.default({
        token: accessToken
      });

      if (id) {
        const originalFileList = await getOriginalFiles(id); // Telling the GIST API to remove files

        const updatedFileList = Object.keys(packaged);
        const allItems = Object.keys(originalFileList).filter(fileName => updatedFileList.indexOf(fileName) === -1).reduce((acc, deleteFileName) => _objectSpread(_objectSpread({}, acc), {}, {
          [deleteFileName]: null
        }), originalFileList); // adding new files

        updatedFileList.forEach(file => {
          const _items = file.split('/');

          const _fileName = _items[_items.length - 1];
          allItems[_fileName] = packaged[file];
        });
        dispatch((0, _payload.displayPopUp)('Saving gist (' + id + ') ...'));
        gists.edit({
          description: description,
          public: true,
          files: allItems,
          id: id
        }, (error, result) => {
          handleGistResponse(error, result);

          if (!error) {
            for (const key in allItems) {
              if (allItems[key] === null) delete allItems[key];
            }
          }
        });
      } else {
        // id is not existing, need to create a new gist
        dispatch((0, _payload.displayPopUp)('Creating a new gist ...'));
        gists.create({
          description: description,
          public: true,
          files: packaged
        }, (error, result) => {
          handleGistResponse(error, result);
        });
      }
    }
  } catch (error) {
    console.log(error);
    dispatch((0, _payload.displayNotification)('Publish to gist Failed', 'Failed to create gist: ' + error.message, 'Close', null, async () => {}));
  }
};

exports.publishToGist = publishToGist;

const clearPopUp = async () => {
  dispatch((0, _payload.hidePopUp)());
};

exports.clearPopUp = clearPopUp;

const createNewFile = async (path, rootDir) => {
  const fileManager = plugin.fileManager;
  const newName = await (0, _helper.createNonClashingNameAsync)(path, fileManager);
  const createFile = await fileManager.writeFile(newName, '');

  if (!createFile) {
    return dispatch((0, _payload.displayPopUp)('Failed to create file ' + newName));
  } else {
    const _path = newName.indexOf(rootDir + '/') === 0 ? newName.replace(rootDir + '/', '') : newName;

    await fileManager.open(_path);
    setFocusElement([{
      key: _path,
      type: 'file'
    }]);
  }
};

exports.createNewFile = createNewFile;

const setFocusElement = async elements => {
  dispatch((0, _payload.focusElement)(elements));
};

exports.setFocusElement = setFocusElement;

const createNewFolder = async (path, rootDir) => {
  const fileManager = plugin.fileManager;
  const dirName = path + '/';
  const exists = await fileManager.exists(dirName);

  if (exists) {
    return dispatch((0, _payload.displayNotification)('Failed to create folder', `A folder ${(0, _helper.extractNameFromKey)(path)} already exists at this location. Please choose a different name.`, 'Close', null, () => {}));
  }

  await fileManager.mkdir(dirName);
  path = path.indexOf(rootDir + '/') === 0 ? path.replace(rootDir + '/', '') : path;
  dispatch((0, _payload.focusElement)([{
    key: path,
    type: 'folder'
  }]));
};

exports.createNewFolder = createNewFolder;

const deletePath = async path => {
  const fileManager = plugin.fileManager;

  for (const p of path) {
    try {
      await fileManager.remove(p);
    } catch (e) {
      const isDir = await fileManager.isDirectory(p);
      dispatch((0, _payload.displayPopUp)(`Failed to remove ${isDir ? 'folder' : 'file'} ${p}.`));
    }
  }
};

exports.deletePath = deletePath;

const renamePath = async (oldPath, newPath) => {
  const fileManager = plugin.fileManager;
  const exists = await fileManager.exists(newPath);

  if (exists) {
    dispatch((0, _payload.displayNotification)('Rename File Failed', `A file or folder ${(0, _helper.extractNameFromKey)(newPath)} already exists at this location. Please choose a different name.`, 'Close', null, () => {}));
  } else {
    await fileManager.rename(oldPath, newPath);
  }
};

exports.renamePath = renamePath;

const copyFile = async (src, dest) => {
  const fileManager = plugin.fileManager;

  try {
    await fileManager.copyFile(src, dest);
  } catch (error) {
    dispatch((0, _payload.displayPopUp)('Oops! An error ocurred while performing copyFile operation.' + error));
  }
};

exports.copyFile = copyFile;

const copyFolder = async (src, dest) => {
  const fileManager = plugin.fileManager;

  try {
    await fileManager.copyDir(src, dest);
  } catch (error) {
    dispatch((0, _payload.displayPopUp)('Oops! An error ocurred while performing copyDir operation.' + error));
  }
};

exports.copyFolder = copyFolder;

const runScript = async path => {
  const provider = plugin.fileManager.currentFileProvider();
  provider.get(path, (error, content) => {
    if (error) {
      return dispatch((0, _payload.displayPopUp)(error));
    }

    plugin.call('scriptRunner', 'execute', content, path);
  });
};

exports.runScript = runScript;

const emitContextMenuEvent = async cmd => {
  await plugin.call(cmd.id, cmd.name, cmd);
};

exports.emitContextMenuEvent = emitContextMenuEvent;

const handleClickFile = async (path, type) => {
  await plugin.fileManager.open(path);
  dispatch((0, _payload.focusElement)([{
    key: path,
    type
  }]));
};

exports.handleClickFile = handleClickFile;

const handleExpandPath = paths => {
  dispatch((0, _payload.setExpandPath)(paths));
};

exports.handleExpandPath = handleExpandPath;

const handleDownloadFiles = async () => {
  try {
    plugin.call('notification', 'toast', 'preparing files for download, please wait..');
    const zip = new _jszip.default();
    zip.file("readme.txt", "This is a Remix backup file.\nThis zip should be used by the restore backup tool in Remix.\nThe .workspaces directory contains your workspaces.");
    const browserProvider = plugin.fileManager.getProvider('browser');
    await browserProvider.copyFolderToJson('/', ({
      path,
      content
    }) => {
      zip.file(path, content);
    });
    zip.generateAsync({
      type: 'blob'
    }).then(function (blob) {
      const today = new Date();
      const date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
      const time = today.getHours() + 'h' + today.getMinutes() + 'min';
      saveAs(blob, `remix-backup-at-${time}-${date}.zip`);

      _paq.push(['trackEvent', 'Backup', 'download', 'home']);
    }).catch(e => {
      _paq.push(['trackEvent', 'Backup', 'error', e.message]);

      plugin.call('notification', 'toast', e.message);
    });
  } catch (e) {
    plugin.call('notification', 'toast', e.message);
  }
};

exports.handleDownloadFiles = handleDownloadFiles;

const restoreBackupZip = async () => {
  await plugin.appManager.activatePlugin(['restorebackupzip']);
  await plugin.call('mainPanel', 'showContent', 'restorebackupzip');

  _paq.push(['trackEvent', 'pluginManager', 'userActivate', 'restorebackupzip']);
};

exports.restoreBackupZip = restoreBackupZip;

const packageGistFiles = async directory => {
  const workspaceProvider = plugin.fileProviders.workspace;
  const isFile = await workspaceProvider.isFile(directory);
  return new Promise((resolve, reject) => {
    const ret = {};

    if (isFile) {
      try {
        workspaceProvider.get(directory, (error, content) => {
          if (error) throw new Error('An error ocurred while getting file content. ' + directory);

          if (/^\s+$/.test(content) || !content.length) {
            content = '// this line is added to create a gist. Empty file is not allowed.';
          }

          directory = directory.replace(/\//g, '...');
          ret[directory] = {
            content
          };
          return resolve(ret);
        });
      } catch (e) {
        return reject(e);
      }
    } else {
      try {
        (async () => {
          await workspaceProvider.copyFolderToJson(directory, ({
            path,
            content
          }) => {
            if (/^\s+$/.test(content) || !content.length) {
              content = '// this line is added to create a gist. Empty file is not allowed.';
            }

            if (path.indexOf('gist-') === 0) {
              path = path.split('/');
              path.shift();
              path = path.join('/');
            }

            path = path.replace(/\//g, '...');
            ret[path] = {
              content
            };
          });
          resolve(ret);
        })();
      } catch (e) {
        return reject(e);
      }
    }
  });
};

const handleGistResponse = (error, data) => {
  if (error) {
    dispatch((0, _payload.displayNotification)('Publish to gist Failed', 'Failed to manage gist: ' + error, 'Close', null));
  } else {
    if (data.html_url) {
      dispatch((0, _payload.displayNotification)('Gist is ready', `The gist is at ${data.html_url}. Would you like to open it in a new window?`, 'OK', 'Cancel', () => {
        window.open(data.html_url, '_blank');
      }, () => {}));
    } else {
      const _error = JSON.stringify(data.errors, null, '\t') || '';

      const message = data.message === 'Not Found' ? data.message + '. Please make sure the API token has right to create a gist.' : data.message;
      dispatch((0, _payload.displayNotification)('Publish to gist Failed', message + ' ' + data.documentation_url + ' ' + _error, 'Close', null));
    }
  }
};
/**
   * This function is to get the original content of given gist
   * @params id is the gist id to fetch
   */


const getOriginalFiles = async id => {
  if (!id) {
    return [];
  }

  const url = `https://api.github.com/gists/${id}`;
  const res = await fetch(url);
  const data = await res.json();
  return data.files || [];
};

const saveAs = (blob, name) => {
  const node = document.createElement('a');
  node.download = name;
  node.rel = 'noopener';
  node.href = URL.createObjectURL(blob);
  setTimeout(function () {
    URL.revokeObjectURL(node.href);
  }, 4E4); // 40s

  setTimeout(function () {
    try {
      node.dispatchEvent(new MouseEvent('click'));
    } catch (e) {
      const evt = document.createEvent('MouseEvents');
      evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }, 0); // 40s
};

/***/ }),
/* 2764 */,
/* 2765 */,
/* 2766 */,
/* 2767 */,
/* 2768 */,
/* 2769 */,
/* 2770 */,
/* 2771 */,
/* 2772 */,
/* 2773 */,
/* 2774 */,
/* 2775 */,
/* 2776 */,
/* 2777 */,
/* 2778 */,
/* 2779 */,
/* 2780 */,
/* 2781 */,
/* 2782 */,
/* 2783 */,
/* 2784 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 2785 */,
/* 2786 */,
/* 2787 */,
/* 2788 */,
/* 2789 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listenOnProviderEvents = exports.listenOnPluginEvents = void 0;

var _helper = __webpack_require__(1121);

var _payload = __webpack_require__(1391);

var _workspace = __webpack_require__(1633);

const LOCALHOST = ' - connect to localhost - ';
let plugin, dispatch;

const listenOnPluginEvents = filePanelPlugin => {
  plugin = filePanelPlugin;
  plugin.on('filePanel', 'createWorkspaceReducerEvent', (name, workspaceTemplateName, isEmpty = false, cb) => {
    (0, _workspace.createWorkspace)(name, workspaceTemplateName, isEmpty, cb);
  });
  plugin.on('filePanel', 'renameWorkspaceReducerEvent', (oldName, workspaceName, cb) => {
    (0, _workspace.renameWorkspace)(oldName, workspaceName, cb);
  });
  plugin.on('filePanel', 'deleteWorkspaceReducerEvent', (workspaceName, cb) => {
    (0, _workspace.deleteWorkspace)(workspaceName, cb);
  });
  plugin.on('filePanel', 'registerContextMenuItemReducerEvent', (item, cb) => {
    registerContextMenuItem(item, cb);
  });
  plugin.on('filePanel', 'removePluginActionsReducerEvent', (plugin, cb) => {
    removePluginActions(plugin, cb);
  });
  plugin.on('filePanel', 'createNewFileInputReducerEvent', (path, cb) => {
    (0, _workspace.addInputField)('file', path, cb);
  });
  plugin.on('filePanel', 'uploadFileReducerEvent', (dir, target, cb) => {
    (0, _workspace.uploadFile)(target, dir, cb);
  });
  plugin.on('remixd', 'rootFolderChanged', async path => {
    rootFolderChanged(path);
  });
  plugin.on('fileManager', 'rootFolderChanged', async path => {
    rootFolderChanged(path);
  });
  plugin.on('fileManager', 'fileClosed', async file => {
    dispatch((0, _payload.removeFocus)(file));
  });
  plugin.on('fileManager', 'currentFileChanged', async file => {
    const paths = file.split('/');
    if (paths.length && paths[0] === '') paths.shift();
    let currentCheck = '';

    for (const value of paths) {
      currentCheck = currentCheck + '/' + value;
      await folderAdded(currentCheck);
    }
  });
};

exports.listenOnPluginEvents = listenOnPluginEvents;

const listenOnProviderEvents = provider => reducerDispatch => {
  dispatch = reducerDispatch;
  provider.event.on('fileAdded', filePath => {
    fileAdded(filePath);
  });
  provider.event.on('folderAdded', folderPath => {
    if (folderPath.indexOf('/.workspaces') === 0) return;
    folderAdded(folderPath);
  });
  provider.event.on('fileRemoved', removePath => {
    fileRemoved(removePath);
  });
  provider.event.on('fileRenamed', oldPath => {
    fileRenamed(oldPath);
  });
  provider.event.on('disconnected', async () => {
    plugin.fileManager.setMode('browser');
    dispatch((0, _payload.setMode)('browser'));
    dispatch((0, _payload.loadLocalhostError)('Remixd disconnected!'));
    const workspaceProvider = plugin.fileProviders.workspace;
    await (0, _workspace.switchToWorkspace)(workspaceProvider.workspace);
  });
  provider.event.on('connected', () => {
    plugin.fileManager.setMode('localhost');
    dispatch((0, _payload.setMode)('localhost'));
    (0, _workspace.fetchWorkspaceDirectory)('/');
    dispatch((0, _payload.loadLocalhostSuccess)());
  });
  provider.event.on('loadingLocalhost', async () => {
    await (0, _workspace.switchToWorkspace)(LOCALHOST);
    dispatch((0, _payload.loadLocalhostRequest)());
  });
  provider.event.on('fileExternallyChanged', (path, content) => {
    const config = plugin.registry.get('config').api;
    const editor = plugin.registry.get('editor').api;

    if (config.get('currentFile') === path && editor.currentContent() !== content) {
      if (provider.isReadOnly(path)) return editor.setText(content);
      dispatch((0, _payload.displayNotification)(path + ' changed', 'This file has been changed outside of Remix IDE.', 'Replace by the new content', 'Keep the content displayed in Remix', () => {
        editor.setText(content);
      }));
    }
  });
  provider.event.on('fileRenamedError', () => {
    dispatch((0, _payload.displayNotification)('File Renamed Failed', '', 'Ok', 'Cancel'));
  });
  provider.event.on('readOnlyModeChanged', mode => {
    dispatch((0, _payload.setReadOnlyMode)(mode));
  });
};

exports.listenOnProviderEvents = listenOnProviderEvents;

const registerContextMenuItem = (item, cb) => {
  if (!item) {
    cb && cb(new Error('Invalid register context menu argument'));
    return dispatch((0, _payload.displayPopUp)('Invalid register context menu argument'));
  }

  if (!item.name || !item.id) {
    cb && cb(new Error('Item name and id is mandatory'));
    return dispatch((0, _payload.displayPopUp)('Item name and id is mandatory'));
  }

  if (!item.type && !item.path && !item.extension && !item.pattern) {
    cb && cb(new Error('Invalid file matching criteria provided'));
    return dispatch((0, _payload.displayPopUp)('Invalid file matching criteria provided'));
  }

  dispatch((0, _payload.setContextMenuItem)(item));
  cb && cb(null, item);
};

const removePluginActions = (plugin, cb) => {
  dispatch((0, _payload.removeContextMenuItem)(plugin));
  cb && cb(null, true);
};

const fileAdded = async filePath => {
  await dispatch((0, _payload.fileAddedSuccess)(filePath));

  if (filePath.includes('_test.sol')) {
    plugin.emit('newTestFileCreated', filePath);
  }
};

const folderAdded = async folderPath => {
  const provider = plugin.fileManager.currentFileProvider();
  const path = (0, _helper.extractParentFromKey)(folderPath) || provider.workspace || provider.type || '';
  const promise = new Promise(resolve => {
    provider.resolveDirectory(path, (error, fileTree) => {
      if (error) console.error(error);
      resolve(fileTree);
    });
  });
  promise.then(files => {
    folderPath = folderPath.replace(/^\/+/, '');
    dispatch((0, _payload.folderAddedSuccess)(path, folderPath, files));
  }).catch(error => {
    console.error(error);
  });
  return promise;
};

const fileRemoved = async removePath => {
  await dispatch((0, _payload.fileRemovedSuccess)(removePath));
};

const fileRenamed = async oldPath => {
  const provider = plugin.fileManager.currentFileProvider();
  const path = (0, _helper.extractParentFromKey)(oldPath) || provider.workspace || provider.type || '';
  const promise = new Promise(resolve => {
    provider.resolveDirectory(path, (error, fileTree) => {
      if (error) console.error(error);
      resolve(fileTree);
    });
  });
  promise.then(files => {
    dispatch((0, _payload.fileRenamedSuccess)(path, oldPath, files));
  }).catch(error => {
    console.error(error);
  });
};

const rootFolderChanged = async path => {
  await dispatch((0, _payload.rootFolderChangedSuccess)(path));
};

/***/ }),
/* 2790 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ozerc721 = exports.zeroxErc20 = exports.ozerc20 = exports.blank = exports.remixDefault = void 0;

var remixDefault_1 = __webpack_require__(2791);

Object.defineProperty(exports, "remixDefault", {
  enumerable: true,
  get: function () {
    return remixDefault_1.default;
  }
});

var blank_1 = __webpack_require__(2802);

Object.defineProperty(exports, "blank", {
  enumerable: true,
  get: function () {
    return blank_1.default;
  }
});

var ozerc20_1 = __webpack_require__(2803);

Object.defineProperty(exports, "ozerc20", {
  enumerable: true,
  get: function () {
    return ozerc20_1.default;
  }
});

var zeroxErc20_1 = __webpack_require__(2810);

Object.defineProperty(exports, "zeroxErc20", {
  enumerable: true,
  get: function () {
    return zeroxErc20_1.default;
  }
});

var ozerc721_1 = __webpack_require__(2817);

Object.defineProperty(exports, "ozerc721", {
  enumerable: true,
  get: function () {
    return ozerc721_1.default;
  }
});

/***/ }),
/* 2791 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

exports.default = () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
  return {
    // @ts-ignore
    'contracts/1_Storage.sol': (yield Promise.resolve().then(() => __webpack_require__(2792))).default,
    // @ts-ignore
    'contracts/2_Owner.sol': (yield Promise.resolve().then(() => __webpack_require__(2793))).default,
    // @ts-ignore
    'contracts/3_Ballot.sol': (yield Promise.resolve().then(() => __webpack_require__(2794))).default,
    // @ts-ignore
    'scripts/deploy_with_ethers.ts': (yield Promise.resolve().then(() => __webpack_require__(2795))).default,
    // @ts-ignore
    'scripts/deploy_with_web3.ts': (yield Promise.resolve().then(() => __webpack_require__(2796))).default,
    // @ts-ignore
    'scripts/ethers-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2797))).default,
    // @ts-ignore
    'scripts/web3-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2798))).default,
    // @ts-ignore
    'tests/Ballot_test.sol': (yield Promise.resolve().then(() => __webpack_require__(2799))).default,
    // @ts-ignore
    'tests/storage.test.js': (yield Promise.resolve().then(() => __webpack_require__(2800))).default,
    // @ts-ignore
    'README.txt': (yield Promise.resolve().then(() => __webpack_require__(2801))).default
  };
});

/***/ }),
/* 2792 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Storage\n * @dev Store & retrieve value in a variable\n * @custom:dev-run-script ./scripts/deploy_with_ethers.ts\n */\ncontract Storage {\n\n    uint256 number;\n\n    /**\n     * @dev Store value in variable\n     * @param num value to store\n     */\n    function store(uint256 num) public {\n        number = num;\n    }\n\n    /**\n     * @dev Return value \n     * @return value of 'number'\n     */\n    function retrieve() public view returns (uint256){\n        return number;\n    }\n}");

/***/ }),
/* 2793 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Owner {\n\n    address private owner;\n\n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n\n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        console.log(\"Owner contract deployed by:\", msg.sender);\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n} ");

/***/ }),
/* 2794 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/** \n * @title Ballot\n * @dev Implements voting process along with vote delegation\n */\ncontract Ballot {\n\n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    struct Proposal {\n        // If you can limit the length to a certain number of bytes, \n        // always use one of bytes1 to bytes32 because they are much cheaper\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    mapping(address => Voter) public voters;\n\n    Proposal[] public proposals;\n\n    /** \n     * @dev Create a new ballot to choose one of 'proposalNames'.\n     * @param proposalNames names of proposals\n     */\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // 'Proposal({...})' creates a temporary\n            // Proposal object and 'proposals.push(...)'\n            // appends it to the end of 'proposals'.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n\n    /** \n     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.\n     * @param voter address of voter\n     */\n    function giveRightToVote(address voter) public {\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /**\n     * @dev Delegate your vote to the voter 'to'.\n     * @param to address to which vote is delegated\n     */\n    function delegate(address to) public {\n        Voter storage sender = voters[msg.sender];\n        require(!sender.voted, \"You already voted.\");\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n        sender.voted = true;\n        sender.delegate = to;\n        Voter storage delegate_ = voters[to];\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /**\n     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.\n     * @param proposal index of proposal in the proposals array\n     */\n    function vote(uint proposal) public {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If 'proposal' is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /** \n     * @dev Computes the winning proposal taking all previous votes into account.\n     * @return winningProposal_ index of winning proposal in the proposals array\n     */\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    /** \n     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then\n     * @return winnerName_ the name of the winner\n     */\n    function winnerName() public view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}");

/***/ }),
/* 2795 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// This script can be used to deploy the \"Storage\" contract using ethers.js library.\n// Please make sure to compile \"./contracts/1_Storage.sol\" file before running this script.\n// And use Right click -> \"Run\" from context menu of the file to run the script. Shortcut: Ctrl+Shift+S\n\nimport { deploy } from './ethers-lib'\n\n(async () => {\n    try {\n        const result = await deploy('Storage', [])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()");

/***/ }),
/* 2796 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// This script can be used to deploy the \"Storage\" contract using Web3 library.\n// Please make sure to compile \"./contracts/1_Storage.sol\" file before running this script.\n// And use Right click -> \"Run\" from context menu of the file to run the script. Shortcut: Ctrl+Shift+S\n\nimport { deploy } from './web3-lib'\n\n(async () => {\n    try {\n        const result = await deploy('Storage', [])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n})()");

/***/ }),
/* 2797 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { ethers } from 'ethers'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {Number} accountIndex account index from the exposed account\n * @return {Contract} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, accountIndex?: number): Promise<ethers.Contract> => {    \n\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json` // Change this for different path\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n    // 'web3Provider' is a remix global variable object\n    \n    const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner(accountIndex)\n\n    const factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer)\n\n    const contract = await factory.deploy(...args)   \n\n    // The contract is NOT deployed yet; we must wait until it is mined\n    await contract.deployed()\n    return contract\n}");

/***/ }),
/* 2798 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import Web3 from 'web3'\nimport { Contract, ContractSendMethod, Options } from 'web3-eth-contract'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {string} from account used to send the transaction\n * @param {number} gas gas limit\n * @return {Options} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, from?: string, gas?: number): Promise<Options> => {\n\n    const web3 = new Web3(web3Provider)\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json`\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n\n    const accounts = await web3.eth.getAccounts()\n\n    const contract: Contract  = new web3.eth.Contract(metadata.abi)\n\n    const contractSend: ContractSendMethod = contract.deploy({\n        data: metadata.data.bytecode.object,\n        arguments: args\n    })\n\n    const newContractInstance = await contractSend.send({\n        from: from || accounts[0],\n        gas: gas || 1500000\n    })\n    return newContractInstance.options    \n}");

/***/ }),
/* 2799 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\nimport \"remix_tests.sol\"; // this import is automatically injected by Remix.\nimport \"hardhat/console.sol\";\nimport \"../contracts/3_Ballot.sol\";\n\ncontract BallotTest {\n\n    bytes32[] proposalNames;\n\n    Ballot ballotToTest;\n    function beforeAll () public {\n        proposalNames.push(bytes32(\"candidate1\"));\n        ballotToTest = new Ballot(proposalNames);\n    }\n\n    function checkWinningProposal () public {\n        console.log(\"Running checkWinningProposal\");\n        ballotToTest.vote(0);\n        Assert.equal(ballotToTest.winningProposal(), uint(0), \"proposal at index 0 should be the winning proposal\");\n        Assert.equal(ballotToTest.winnerName(), bytes32(\"candidate1\"), \"candidate1 should be the winner name\");\n    }\n\n    function checkWinninProposalWithReturnValue () public view returns (bool) {\n        return ballotToTest.winningProposal() == 0;\n    }\n}");

/***/ }),
/* 2800 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// Right click on the script name and hit \"Run\" to execute\nconst { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"Storage\", function () {\n  it(\"test initial value\", async function () {\n    const Storage = await ethers.getContractFactory(\"Storage\");\n    const storage = await Storage.deploy();\n    await storage.deployed();\n    console.log('storage deployed at:'+ storage.address)\n    expect((await storage.retrieve()).toNumber()).to.equal(0);\n  });\n   it(\"test updating and retrieving updated value\", async function () {\n    const Storage = await ethers.getContractFactory(\"Storage\");\n    const storage = await Storage.deploy();\n    await storage.deployed();\n    const storage2 = await ethers.getContractAt(\"Storage\", storage.address);\n    const setValue = await storage2.store(56);\n    await setValue.wait();\n    expect((await storage2.retrieve()).toNumber()).to.equal(56);\n  });\n});");

/***/ }),
/* 2801 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("REMIX DEFAULT WORKSPACE\n\nRemix default workspace is present when:\ni. Remix loads for the very first time \nii. A new workspace is created with 'Default' template\niii. There are no files existing in the File Explorer\n\nThis workspace contains 3 directories:\n\n1. 'contracts': Holds three contracts with increasing levels of complexity.\n2. 'scripts': Contains four typescript files to deploy a contract. It is explained below.\n3. 'tests': Contains one Solidity test file for 'Ballot' contract & one JS test file for 'Storage' contract.\n\nSCRIPTS\n\nThe 'scripts' folder has four typescript files which help to deploy the 'Storage' contract using 'web3.js' and 'ethers.js' libraries.\n\nFor the deployment of any other contract, just update the contract's name from 'Storage' to the desired contract and provide constructor arguments accordingly \nin the file `deploy_with_ethers.ts` or  `deploy_with_web3.ts`\n\nIn the 'tests' folder there is a script containing Mocha-Chai unit tests for 'Storage' contract.\n\nTo run a script, right click on file name in the file explorer and click 'Run'. Remember, Solidity file must already be compiled.\nOutput from script will appear in remix terminal.\n\nPlease note, require/import is supported in a limited manner for Remix supported modules.\nFor now, modules supported by Remix are ethers, web3, swarmgw, chai, multihashes, remix and hardhat only for hardhat.ethers object/plugin.\nFor unsupported modules, an error like this will be thrown: '<module_name> module require is not supported by Remix IDE' will be shown.\n");

/***/ }),
/* 2802 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

exports.default = () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
  return {};
});

/***/ }),
/* 2803 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

exports.default = () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
  return {
    // @ts-ignore
    'contracts/SampleERC20.sol': (yield Promise.resolve().then(() => __webpack_require__(2804))).default,
    // @ts-ignore
    'scripts/deploy_with_ethers.ts': (yield Promise.resolve().then(() => __webpack_require__(2805))).default,
    // @ts-ignore
    'scripts/deploy_with_web3.ts': (yield Promise.resolve().then(() => __webpack_require__(2806))).default,
    // @ts-ignore
    'scripts/ethers-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2807))).default,
    // @ts-ignore
    'scripts/web3-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2808))).default,
    // @ts-ignore
    'tests/SampleERC20_test.sol': (yield Promise.resolve().then(() => __webpack_require__(2809))).default
  };
});

/***/ }),
/* 2804 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title SampleERC20\n * @dev Create a sample ERC20 standard token\n */\ncontract SampleERC20 is ERC20 {\n\n    constructor(string memory tokenName, string memory tokenSymbol) ERC20(tokenName, tokenSymbol) {}\n}");

/***/ }),
/* 2805 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { deploy } from './ethers-lib'\n\n(async () => {\n    try {\n        const result = await deploy('SampleERC20', ['testToken', 'TST'])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()");

/***/ }),
/* 2806 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { deploy } from './web3-lib'\n\n(async () => {\n    try {\n        const result = await deploy('SampleERC20', ['testToken', 'TST'])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n})()");

/***/ }),
/* 2807 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { ethers } from 'ethers'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {Number} accountIndex account index from the exposed account\n * @return {Contract} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, accountIndex?: number): Promise<ethers.Contract> => {    \n\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json` // Change this for different path\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n    // 'web3Provider' is a remix global variable object\n    \n    const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner(accountIndex)\n\n    const factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer)\n\n    const contract = await factory.deploy(...args)   \n\n    // The contract is NOT deployed yet; we must wait until it is mined\n    await contract.deployed()\n    return contract\n}");

/***/ }),
/* 2808 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import Web3 from 'web3'\nimport { Contract, ContractSendMethod, Options } from 'web3-eth-contract'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {string} from account used to send the transaction\n * @param {number} gas gas limit\n * @return {Options} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, from?: string, gas?: number): Promise<Options> => {\n\n    const web3 = new Web3(web3Provider)\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json`\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n\n    const accounts = await web3.eth.getAccounts()\n\n    const contract: Contract  = new web3.eth.Contract(metadata.abi)\n\n    const contractSend: ContractSendMethod = contract.deploy({\n        data: metadata.data.bytecode.object,\n        arguments: args\n    })\n\n    const newContractInstance = await contractSend.send({\n        from: from || accounts[0],\n        gas: gas || 1500000\n    })\n    return newContractInstance.options    \n}");

/***/ }),
/* 2809 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\nimport \"remix_tests.sol\";\nimport \"../contracts/SampleERC20.sol\";\n\ncontract SampleERC20Test {\n\n    SampleERC20 s;\n    function beforeAll () public {\n        s = new SampleERC20(\"TestToken\", \"TST\");\n    }\n\n    function testTokenNameAndSymbol () public {\n        Assert.equal(s.name(), \"TestToken\", \"token name did not match\");\n        Assert.equal(s.symbol(), \"TST\", \"token symbol did not match\");\n    }\n}");

/***/ }),
/* 2810 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

exports.default = () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
  return {
    // @ts-ignore
    'contracts/SampleERC20.sol': (yield Promise.resolve().then(() => __webpack_require__(2811))).default,
    // @ts-ignore
    'scripts/deploy_with_ethers.ts': (yield Promise.resolve().then(() => __webpack_require__(2812))).default,
    // @ts-ignore
    'scripts/deploy_with_web3.ts': (yield Promise.resolve().then(() => __webpack_require__(2813))).default,
    // @ts-ignore
    'scripts/ethers-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2814))).default,
    // @ts-ignore
    'scripts/web3-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2815))).default,
    // @ts-ignore
    'tests/SampleERC20_test.sol': (yield Promise.resolve().then(() => __webpack_require__(2816))).default
  };
});

/***/ }),
/* 2811 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.5.9;\n\nimport \"@0x/contracts-erc20/contracts/src/ERC20Token.sol\";\n\n/**\n * @title SampleERC20\n * @dev Create a sample ERC20 standard token\n */\ncontract SampleERC20 is ERC20Token {\n\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n\n    constructor (\n        string memory _name,\n        string memory _symbol,\n        uint256 _decimals,\n        uint256 _totalSupply\n    )\n        public\n    {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        _totalSupply = _totalSupply;\n        balances[msg.sender] = _totalSupply;\n    }\n}");

/***/ }),
/* 2812 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { deploy } from './ethers-lib'\n\n(async () => {\n    try {\n        const result = await deploy('SampleERC20', [\"TestToken\", \"TST\", 18, 1000])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()");

/***/ }),
/* 2813 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { deploy } from './web3-lib'\n\n(async () => {\n    try {\n        const result = await deploy('SampleERC20', [\"TestToken\", \"TST\", 18, 1000])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n})()");

/***/ }),
/* 2814 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { ethers } from 'ethers'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {Number} accountIndex account index from the exposed account\n * @return {Contract} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, accountIndex?: number): Promise<ethers.Contract> => {    \n\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json` // Change this for different path\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n    // 'web3Provider' is a remix global variable object\n    \n    const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner(accountIndex)\n\n    const factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer)\n\n    const contract = await factory.deploy(...args)   \n\n    // The contract is NOT deployed yet; we must wait until it is mined\n    await contract.deployed()\n    return contract\n}");

/***/ }),
/* 2815 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import Web3 from 'web3'\nimport { Contract, ContractSendMethod, Options } from 'web3-eth-contract'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {string} from account used to send the transaction\n * @param {number} gas gas limit\n * @return {Options} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, from?: string, gas?: number): Promise<Options> => {\n\n    const web3 = new Web3(web3Provider)\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json`\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n\n    const accounts = await web3.eth.getAccounts()\n\n    const contract: Contract  = new web3.eth.Contract(metadata.abi)\n\n    const contractSend: ContractSendMethod = contract.deploy({\n        data: metadata.data.bytecode.object,\n        arguments: args\n    })\n\n    const newContractInstance = await contractSend.send({\n        from: from || accounts[0],\n        gas: gas || 1500000\n    })\n    return newContractInstance.options    \n}");

/***/ }),
/* 2816 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.5.9;\nimport \"remix_tests.sol\";\nimport \"../contracts/SampleERC20.sol\";\n\ncontract SampleERC20Test {\n\n    SampleERC20 s;\n    function beforeAll () public {\n        s = new SampleERC20(\"TestToken\", \"TST\", 18, 1000);\n    }\n\n    function testTokenNameAndSymbol () public {\n        Assert.equal(s.name(), \"TestToken\", \"token name did not match\");\n        Assert.equal(s.symbol(), \"TST\", \"token symbol did not match\");\n    }\n}");

/***/ }),
/* 2817 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

const tslib_1 = __webpack_require__(23);

exports.default = () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
  return {
    // @ts-ignore
    'contracts/SampleERC721.sol': (yield Promise.resolve().then(() => __webpack_require__(2818))).default,
    // @ts-ignore
    'scripts/deploy_with_ethers.ts': (yield Promise.resolve().then(() => __webpack_require__(2819))).default,
    // @ts-ignore
    'scripts/deploy_with_web3.ts': (yield Promise.resolve().then(() => __webpack_require__(2820))).default,
    // @ts-ignore
    'scripts/ethers-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2821))).default,
    // @ts-ignore
    'scripts/web3-lib.ts': (yield Promise.resolve().then(() => __webpack_require__(2822))).default,
    // @ts-ignore
    'tests/SampleERC721_test.sol': (yield Promise.resolve().then(() => __webpack_require__(2823))).default
  };
});

/***/ }),
/* 2818 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n/**\n * @title SampleERC721\n * @dev Create a sample ERC721 standard token\n */\ncontract SampleERC721 is ERC721 {\n\n    constructor(string memory tokenName, string memory tokenSymbol) ERC721(tokenName, tokenSymbol) {}\n}");

/***/ }),
/* 2819 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { deploy } from './ethers-lib'\n\n(async () => {\n    try {\n        const result = await deploy('SampleERC721', ['testNFT', 'TNFT'])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n  })()");

/***/ }),
/* 2820 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { deploy } from './web3-lib'\n\n(async () => {\n    try {\n        const result = await deploy('SampleERC721', ['testToken', 'TST'])\n        console.log(`address: ${result.address}`)\n    } catch (e) {\n        console.log(e.message)\n    }\n})()");

/***/ }),
/* 2821 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import { ethers } from 'ethers'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {Number} accountIndex account index from the exposed account\n * @return {Contract} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, accountIndex?: number): Promise<ethers.Contract> => {    \n\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json` // Change this for different path\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n    // 'web3Provider' is a remix global variable object\n    \n    const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner(accountIndex)\n\n    const factory = new ethers.ContractFactory(metadata.abi, metadata.data.bytecode.object, signer)\n\n    const contract = await factory.deploy(...args)   \n\n    // The contract is NOT deployed yet; we must wait until it is mined\n    await contract.deployed()\n    return contract\n}");

/***/ }),
/* 2822 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("import Web3 from 'web3'\nimport { Contract, ContractSendMethod, Options } from 'web3-eth-contract'\n\n/**\n * Deploy the given contract\n * @param {string} contractName name of the contract to deploy\n * @param {Array<any>} args list of constructor' parameters\n * @param {string} from account used to send the transaction\n * @param {number} gas gas limit\n * @return {Options} deployed contract\n */\nexport const deploy = async (contractName: string, args: Array<any>, from?: string, gas?: number): Promise<Options> => {\n\n    const web3 = new Web3(web3Provider)\n    console.log(`deploying ${contractName}`)\n    // Note that the script needs the ABI which is generated from the compilation artifact.\n    // Make sure contract is compiled and artifacts are generated\n    const artifactsPath = `browser/contracts/artifacts/${contractName}.json`\n\n    const metadata = JSON.parse(await remix.call('fileManager', 'getFile', artifactsPath))\n\n    const accounts = await web3.eth.getAccounts()\n\n    const contract: Contract  = new web3.eth.Contract(metadata.abi)\n\n    const contractSend: ContractSendMethod = contract.deploy({\n        data: metadata.data.bytecode.object,\n        arguments: args\n    })\n\n    const newContractInstance = await contractSend.send({\n        from: from || accounts[0],\n        gas: gas || 1500000\n    })\n    return newContractInstance.options    \n}");

/***/ }),
/* 2823 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\nimport \"remix_tests.sol\";\nimport \"../contracts/SampleERC721.sol\";\n\ncontract SampleERC721Test {\n\n    SampleERC721 s;\n    function beforeAll () public {\n        s = new SampleERC721(\"TestNFT\", \"TNFT\");\n    }\n\n    function testTokenNameAndSymbol () public {\n        Assert.equal(s.name(), \"TestNFT\", \"token name did not match\");\n        Assert.equal(s.symbol(), \"TNFT\", \"token symbol did not match\");\n    }\n}");

/***/ }),
/* 2824 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Workspace = Workspace;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _reactBootstrap = __webpack_require__(1209);

var _helper = __webpack_require__(1121);

var _fileExplorer = __webpack_require__(2825);

var _contexts = __webpack_require__(1389);

__webpack_require__(2835);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
// eslint-disable-line
const canUpload = window.File || window.FileReader || window.FileList || window.Blob;

function Workspace() {
  const LOCALHOST = ' - connect to localhost - ';
  const NO_WORKSPACE = ' - none - ';
  const [currentWorkspace, setCurrentWorkspace] = (0, _react.useState)(NO_WORKSPACE);
  const [selectedWorkspace, setSelectedWorkspace] = (0, _react.useState)(null);
  const [showDropdown, setShowDropdown] = (0, _react.useState)(false);
  const global = (0, _react.useContext)(_contexts.FileSystemContext);
  const workspaceRenameInput = (0, _react.useRef)();
  const workspaceCreateInput = (0, _react.useRef)();
  const workspaceCreateTemplateInput = (0, _react.useRef)();
  const cloneUrlRef = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    setCurrentWorkspace(localStorage.getItem('currentWorkspace') ? localStorage.getItem('currentWorkspace') : '');
    resetFocus();
  }, []);
  (0, _react.useEffect)(() => {
    if (global.fs.mode === 'browser') {
      if (global.fs.browser.currentWorkspace) setCurrentWorkspace(global.fs.browser.currentWorkspace);else setCurrentWorkspace(NO_WORKSPACE);
      global.dispatchFetchWorkspaceDirectory(global.fs.browser.currentWorkspace);
    } else if (global.fs.mode === 'localhost') {
      global.dispatchFetchWorkspaceDirectory('/');
      setCurrentWorkspace(LOCALHOST);
    }
  }, [global.fs.browser.currentWorkspace, global.fs.localhost.sharedFolder, global.fs.mode]);
  (0, _react.useEffect)(() => {
    if (global.fs.browser.currentWorkspace && !global.fs.browser.workspaces.find(({
      name
    }) => name === global.fs.browser.currentWorkspace)) {
      if (global.fs.browser.workspaces.length > 0) {
        switchWorkspace(global.fs.browser.workspaces[global.fs.browser.workspaces.length - 1].name);
      } else {
        switchWorkspace(NO_WORKSPACE);
      }
    }
  }, [global.fs.browser.workspaces]);
  (0, _react.useEffect)(() => {
    const workspace = global.fs.browser.workspaces.find(workspace => workspace.name === currentWorkspace);
    setSelectedWorkspace(workspace);
  }, [currentWorkspace]);

  const renameCurrentWorkspace = () => {
    global.modal('Rename Current Workspace', renameModalMessage(), 'OK', onFinishRenameWorkspace, '');
  };

  const createWorkspace = () => {
    global.modal('Create Workspace', createModalMessage(), 'OK', onFinishCreateWorkspace, '');
  };

  const deleteCurrentWorkspace = () => {
    global.modal('Delete Current Workspace', 'Are you sure to delete the current workspace?', 'OK', onFinishDeleteWorkspace, '');
  };

  const cloneGitRepository = () => {
    global.modal('Clone Git Repository', cloneModalMessage(), 'OK', handleTypingUrl, '');
  };

  const downloadWorkspaces = async () => {
    try {
      await global.dispatchHandleDownloadFiles();
    } catch (e) {
      console.error(e);
    }
  };

  const restoreBackup = async () => {
    try {
      await global.dispatchHandleRestoreBackup();
    } catch (e) {
      console.error(e);
    }
  };

  const onFinishRenameWorkspace = async () => {
    if (workspaceRenameInput.current === undefined) return; // @ts-ignore: Object is possibly 'null'.

    const workspaceName = workspaceRenameInput.current.value;

    try {
      await global.dispatchRenameWorkspace(currentWorkspace, workspaceName);
    } catch (e) {
      global.modal('Rename Workspace', e.message, 'OK', () => {}, '');
      console.error(e);
    }
  };

  const onFinishCreateWorkspace = async () => {
    if (workspaceCreateInput.current === undefined) return; // @ts-ignore: Object is possibly 'null'.

    const workspaceName = workspaceCreateInput.current.value; // @ts-ignore: Object is possibly 'null'.

    const workspaceTemplateName = workspaceCreateTemplateInput.current.value || 'remixDefault';

    try {
      await global.dispatchCreateWorkspace(workspaceName, workspaceTemplateName);
    } catch (e) {
      global.modal('Create Workspace', e.message, 'OK', () => {}, '');
      console.error(e);
    }
  };

  const onFinishDeleteWorkspace = async () => {
    try {
      await global.dispatchDeleteWorkspace(global.fs.browser.currentWorkspace);
    } catch (e) {
      global.modal('Delete Workspace', e.message, 'OK', () => {}, '');
      console.error(e);
    }
  };
  /** ** ****/


  const resetFocus = () => {
    global.dispatchSetFocusElement([{
      key: '',
      type: 'folder'
    }]);
  };

  const switchWorkspace = async name => {
    try {
      await global.dispatchSwitchToWorkspace(name);
      global.dispatchHandleExpandPath([]);
    } catch (e) {
      global.modal('Switch To Workspace', e.message, 'OK', () => {}, '');
      console.error(e);
    }
  };

  const updateWsName = () => {
    // @ts-ignore
    workspaceCreateInput.current.value = `${workspaceCreateTemplateInput.current.value || 'remixDefault'}_${Date.now()}`;
  };

  const handleTypingUrl = () => {
    const url = cloneUrlRef.current.value;

    if (url) {
      global.dispatchCloneRepository(url);
    } else {
      global.modal('Clone Git Repository', 'Please provide a valid git repository url.', 'OK', () => {}, '');
    }
  };

  const toggleDropdown = isOpen => {
    setShowDropdown(isOpen);
  };

  const createModalMessage = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        id: "wsName",
        className: "form-check-label",
        children: "Workspace name"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        type: "text",
        "data-id": "modalDialogCustomPromptTextCreate",
        defaultValue: `remixDefault_${Date.now()}`,
        ref: workspaceCreateInput,
        className: "form-control"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("br", {}), /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
        id: "selectWsTemplate",
        className: "form-check-label",
        children: "Choose a template"
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("select", {
        name: "wstemplate",
        className: "form-control custom-select",
        id: "wstemplate",
        defaultValue: "remixDefault",
        ref: workspaceCreateTemplateInput,
        onChange: updateWsName,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          value: "remixDefault",
          children: "Default"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          value: "blank",
          children: "Blank"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          value: "ozerc20",
          children: "OpenZeppelin ERC20"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          value: "zeroxErc20",
          children: "0xProject ERC20"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("option", {
          value: "ozerc721",
          children: "OpenZeppelin ERC721"
        })]
      })]
    });
  };

  const renameModalMessage = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        type: "text",
        "data-id": "modalDialogCustomPromptTextRename",
        defaultValue: currentWorkspace,
        ref: workspaceRenameInput,
        className: "form-control"
      })
    });
  };

  const cloneModalMessage = () => {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
        type: "text",
        "data-id": "modalDialogCustomPromptTextClone",
        placeholder: "Enter git repository url",
        ref: cloneUrlRef,
        className: "form-control"
      })
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "px-2 remixui_container",
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "remixui_fileexplorer",
      "data-id": "remixUIWorkspaceExplorer",
      onClick: resetFocus,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("header", {
          children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: "mb-2",
            children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
              className: "pl-1 form-check-label",
              htmlFor: "workspacesSelect",
              children: "Workspaces"
            }), /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
              className: "remixui_menu",
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                hidden: currentWorkspace === LOCALHOST,
                id: "workspaceCreate",
                "data-id": "workspaceCreate",
                onClick: e => {
                  e.stopPropagation();
                  createWorkspace();
                },
                className: "far fa-plus-square remixui_menuicon",
                title: "Create"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                hidden: currentWorkspace === LOCALHOST || currentWorkspace === NO_WORKSPACE,
                id: "workspaceRename",
                "data-id": "workspaceRename",
                onClick: e => {
                  e.stopPropagation();
                  renameCurrentWorkspace();
                },
                className: "far fa-edit remixui_menuicon",
                title: "Rename"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                hidden: currentWorkspace === LOCALHOST || currentWorkspace === NO_WORKSPACE,
                id: "workspaceDelete",
                "data-id": "workspaceDelete",
                onClick: e => {
                  e.stopPropagation();
                  deleteCurrentWorkspace();
                },
                className: "fas fa-trash remixui_menuicon",
                title: "Delete"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                hidden: currentWorkspace === LOCALHOST || currentWorkspace === NO_WORKSPACE,
                id: "workspacesDownload",
                "data-id": "workspacesDownload",
                onClick: e => {
                  e.stopPropagation();
                  downloadWorkspaces();
                },
                className: "far fa-download remixui_menuicon",
                title: "Download Workspaces"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                hidden: currentWorkspace === LOCALHOST,
                id: "workspacesRestore",
                "data-id": "workspacesRestore",
                onClick: e => {
                  e.stopPropagation();
                  restoreBackup();
                },
                className: "far fa-upload remixui_menuicon",
                title: "Restore Workspaces Backup"
              }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                hidden: currentWorkspace === LOCALHOST,
                id: "cloneGitRepository",
                "data-id": "cloneGitRepository",
                onClick: e => {
                  e.stopPropagation();
                  cloneGitRepository();
                },
                className: "far fa-clone remixui_menuicon",
                title: "Clone Git Repository"
              })]
            }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactBootstrap.Dropdown, {
              id: "workspacesSelect",
              "data-id": "workspacesSelect",
              onToggle: toggleDropdown,
              show: showDropdown,
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Dropdown.Toggle, {
                as: _helper.CustomToggle,
                id: "dropdown-custom-components",
                className: "btn btn-light btn-block w-100 d-inline-block border border-dark form-control",
                icon: selectedWorkspace && selectedWorkspace.isGitRepo && !(currentWorkspace === LOCALHOST) ? 'far fa-code-branch' : null,
                children: selectedWorkspace ? selectedWorkspace.name : currentWorkspace === LOCALHOST ? 'localhost' : NO_WORKSPACE
              }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactBootstrap.Dropdown.Menu, {
                as: _helper.CustomMenu,
                className: "w-100 custom-dropdown-items",
                "data-id": "custom-dropdown-items",
                children: [global.fs.browser.workspaces.map(({
                  name,
                  isGitRepo
                }, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Dropdown.Item, {
                  onClick: () => {
                    switchWorkspace(name);
                  },
                  "data-id": `dropdown-item-${name}`,
                  children: isGitRepo ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
                    className: "d-flex justify-content-between",
                    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                      children: currentWorkspace === name ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                        children: ["\u2713 ", name, " "]
                      }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                        className: "pl-3",
                        children: name
                      })
                    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
                      className: "fas fa-code-branch pt-1"
                    })]
                  }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                    children: currentWorkspace === name ? /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                      children: ["\u2713 ", name, " "]
                    }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                      className: "pl-3",
                      children: name
                    })
                  })
                }, index)), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Dropdown.Item, {
                  onClick: () => {
                    switchWorkspace(LOCALHOST);
                  },
                  children: currentWorkspace === LOCALHOST ? /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                    children: "\u2713 localhost "
                  }) : /*#__PURE__*/(0, _jsxRuntime.jsxs)("span", {
                    className: "pl-3",
                    children: [" ", LOCALHOST, " "]
                  })
                }), (global.fs.browser.workspaces.length <= 0 || currentWorkspace === NO_WORKSPACE) && /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactBootstrap.Dropdown.Item, {
                  onClick: () => {
                    switchWorkspace(NO_WORKSPACE);
                  },
                  children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
                    className: "pl-3",
                    children: "NO_WORKSPACE"
                  })
                })]
              })]
            })]
          })
        })
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        className: "h-100 remixui_fileExplorerTree",
        onFocus: () => {
          toggleDropdown(false);
        },
        children: /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
          className: "h-100",
          children: [global.fs.browser.isRequestingWorkspace || global.fs.browser.isRequestingCloning ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "text-center py-5",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              className: "fas fa-spinner fa-pulse fa-2x"
            })
          }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "pl-2 remixui_treeview",
            "data-id": "filePanelFileExplorerTree",
            children: global.fs.mode === 'browser' && currentWorkspace !== NO_WORKSPACE && /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileExplorer.FileExplorer, {
              name: currentWorkspace,
              menuItems: ['createNewFile', 'createNewFolder', 'publishToGist', canUpload ? 'uploadFile' : ''],
              contextMenuItems: global.fs.browser.contextMenu.registeredMenuItems,
              removedContextMenuItems: global.fs.browser.contextMenu.removedMenuItems,
              files: global.fs.browser.files,
              expandPath: global.fs.browser.expandPath,
              focusEdit: global.fs.focusEdit,
              focusElement: global.fs.focusElement,
              dispatchCreateNewFile: global.dispatchCreateNewFile,
              modal: global.modal,
              dispatchCreateNewFolder: global.dispatchCreateNewFolder,
              readonly: global.fs.readonly,
              toast: global.toast,
              dispatchDeletePath: global.dispatchDeletePath,
              dispatchRenamePath: global.dispatchRenamePath,
              dispatchUploadFile: global.dispatchUploadFile,
              dispatchCopyFile: global.dispatchCopyFile,
              dispatchCopyFolder: global.dispatchCopyFolder,
              dispatchPublishToGist: global.dispatchPublishToGist,
              dispatchRunScript: global.dispatchRunScript,
              dispatchEmitContextMenuEvent: global.dispatchEmitContextMenuEvent,
              dispatchHandleClickFile: global.dispatchHandleClickFile,
              dispatchSetFocusElement: global.dispatchSetFocusElement,
              dispatchFetchDirectory: global.dispatchFetchDirectory,
              dispatchRemoveInputField: global.dispatchRemoveInputField,
              dispatchAddInputField: global.dispatchAddInputField,
              dispatchHandleExpandPath: global.dispatchHandleExpandPath
            })
          }), global.fs.localhost.isRequestingLocalhost ? /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "text-center py-5",
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
              className: "fas fa-spinner fa-pulse fa-2x"
            })
          }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
            className: "pl-2 filesystemexplorer remixui_treeview",
            children: global.fs.mode === 'localhost' && global.fs.localhost.isSuccessfulLocalhost && /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileExplorer.FileExplorer, {
              name: "localhost",
              menuItems: ['createNewFile', 'createNewFolder'],
              contextMenuItems: global.fs.localhost.contextMenu.registeredMenuItems,
              removedContextMenuItems: global.fs.localhost.contextMenu.removedMenuItems,
              files: global.fs.localhost.files,
              expandPath: global.fs.localhost.expandPath,
              focusEdit: global.fs.focusEdit,
              focusElement: global.fs.focusElement,
              dispatchCreateNewFile: global.dispatchCreateNewFile,
              modal: global.modal,
              dispatchCreateNewFolder: global.dispatchCreateNewFolder,
              readonly: global.fs.readonly,
              toast: global.toast,
              dispatchDeletePath: global.dispatchDeletePath,
              dispatchRenamePath: global.dispatchRenamePath,
              dispatchUploadFile: global.dispatchUploadFile,
              dispatchCopyFile: global.dispatchCopyFile,
              dispatchCopyFolder: global.dispatchCopyFolder,
              dispatchPublishToGist: global.dispatchPublishToGist,
              dispatchRunScript: global.dispatchRunScript,
              dispatchEmitContextMenuEvent: global.dispatchEmitContextMenuEvent,
              dispatchHandleClickFile: global.dispatchHandleClickFile,
              dispatchSetFocusElement: global.dispatchSetFocusElement,
              dispatchFetchDirectory: global.dispatchFetchDirectory,
              dispatchRemoveInputField: global.dispatchRemoveInputField,
              dispatchAddInputField: global.dispatchAddInputField,
              dispatchHandleExpandPath: global.dispatchHandleExpandPath
            })
          })]
        })
      })]
    })
  });
}

var _default = Workspace;
exports.default = _default;

/***/ }),
/* 2825 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileExplorer = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _treeView = __webpack_require__(1187);

var _fileExplorerMenu = __webpack_require__(2826);

var _fileExplorerContextMenu = __webpack_require__(2827);

var _utils = __webpack_require__(2830);

__webpack_require__(2831);

var _helper = __webpack_require__(1121);

var _fileRender = __webpack_require__(2833);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const FileExplorer = props => {
  const {
    name,
    contextMenuItems,
    removedContextMenuItems,
    files
  } = props;
  const [state, setState] = (0, _react.useState)({
    ctrlKey: false,
    newFileName: '',
    actions: _utils.contextMenuActions,
    focusContext: {
      element: null,
      x: null,
      y: null,
      type: ''
    },
    focusEdit: {
      element: null,
      type: '',
      isNew: false,
      lastEdit: ''
    },
    mouseOverElement: null,
    showContextMenu: false,
    reservedKeywords: [name, 'gist-'],
    copyElement: []
  });
  const [canPaste, setCanPaste] = (0, _react.useState)(false);
  const treeRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    if (contextMenuItems) {
      addMenuItems(contextMenuItems);
    }
  }, [contextMenuItems]);
  (0, _react.useEffect)(() => {
    if (removedContextMenuItems) {
      removeMenuItems(removedContextMenuItems);
    }
  }, [contextMenuItems]);
  (0, _react.useEffect)(() => {
    if (props.focusEdit) {
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          focusEdit: {
            element: props.focusEdit,
            type: 'file',
            isNew: true,
            lastEdit: null
          }
        });
      });
    }
  }, [props.focusEdit]);
  (0, _react.useEffect)(() => {
    if (treeRef.current) {
      const keyPressHandler = e => {
        if (e.shiftKey) {
          setState(prevState => {
            return _objectSpread(_objectSpread({}, prevState), {}, {
              ctrlKey: true
            });
          });
        }
      };

      const keyUpHandler = e => {
        if (!e.shiftKey) {
          setState(prevState => {
            return _objectSpread(_objectSpread({}, prevState), {}, {
              ctrlKey: false
            });
          });
        }
      };

      const targetDocument = treeRef.current;
      targetDocument.addEventListener('keydown', keyPressHandler);
      targetDocument.addEventListener('keyup', keyUpHandler);
      return () => {
        targetDocument.removeEventListener('keydown', keyPressHandler);
        targetDocument.removeEventListener('keyup', keyUpHandler);
      };
    }
  }, [treeRef.current]);
  (0, _react.useEffect)(() => {
    if (canPaste) {
      addMenuItems([{
        id: 'paste',
        name: 'Paste',
        type: ['folder', 'file'],
        path: [],
        extension: [],
        pattern: [],
        multiselect: false,
        label: ''
      }]);
    } else {
      removeMenuItems([{
        id: 'paste',
        name: 'Paste',
        type: ['folder', 'file'],
        path: [],
        extension: [],
        pattern: [],
        multiselect: false,
        label: ''
      }]);
    }
  }, [canPaste]);

  const addMenuItems = items => {
    setState(prevState => {
      // filter duplicate items
      const actions = items.filter(({
        name
      }) => prevState.actions.findIndex(action => action.name === name) === -1);
      return _objectSpread(_objectSpread({}, prevState), {}, {
        actions: [...prevState.actions, ...actions]
      });
    });
  };

  const removeMenuItems = items => {
    setState(prevState => {
      const actions = prevState.actions.filter(({
        id,
        name
      }) => items.findIndex(item => id === item.id && name === item.name) === -1);
      return _objectSpread(_objectSpread({}, prevState), {}, {
        actions
      });
    });
  };

  const hasReservedKeyword = content => {
    if (state.reservedKeywords.findIndex(value => content.startsWith(value)) !== -1) return true;else return false;
  };

  const getFocusedFolder = () => {
    if (props.focusElement[0]) {
      if (props.focusElement[0].type === 'folder' && props.focusElement[0].key) return props.focusElement[0].key;else if (props.focusElement[0].type === 'gist' && props.focusElement[0].key) return props.focusElement[0].key;else if (props.focusElement[0].type === 'file' && props.focusElement[0].key) return (0, _helper.extractParentFromKey)(props.focusElement[0].key) ? (0, _helper.extractParentFromKey)(props.focusElement[0].key) : name;else return name;
    }
  };

  const createNewFile = async newFilePath => {
    try {
      props.dispatchCreateNewFile(newFilePath, props.name);
    } catch (error) {
      return props.modal('File Creation Failed', typeof error === 'string' ? error : error.message, 'Close', async () => {});
    }
  };

  const createNewFolder = async newFolderPath => {
    try {
      props.dispatchCreateNewFolder(newFolderPath, props.name);
    } catch (e) {
      return props.modal('Folder Creation Failed', typeof e === 'string' ? e : e.message, 'Close', async () => {});
    }
  };

  const deletePath = async path => {
    if (props.readonly) return props.toast('cannot delete file. ' + name + ' is a read only explorer');
    if (!Array.isArray(path)) path = [path];
    props.modal(`Delete ${path.length > 1 ? 'items' : 'item'}`, deleteMessage(path), 'OK', () => {
      props.dispatchDeletePath(path);
    }, 'Cancel', () => {});
  };

  const renamePath = async (oldPath, newPath) => {
    try {
      props.dispatchRenamePath(oldPath, newPath);
    } catch (error) {
      props.modal('Rename File Failed', 'Unexpected error while renaming: ' + typeof error === 'string' ? error : error.message, 'Close', async () => {});
    }
  };

  const uploadFile = target => {
    let parentFolder = getFocusedFolder();
    const expandPath = [...new Set([...props.expandPath, parentFolder])];
    parentFolder = parentFolder === name ? '/' : parentFolder;
    props.dispatchHandleExpandPath(expandPath);
    props.dispatchUploadFile(target, parentFolder);
  };

  const copyFile = (src, dest) => {
    try {
      props.dispatchCopyFile(src, dest);
    } catch (error) {
      props.modal('Copy File Failed', 'Unexpected error while copying file: ' + src, 'Close', async () => {});
    }
  };

  const copyFolder = (src, dest) => {
    try {
      props.dispatchCopyFolder(src, dest);
    } catch (error) {
      props.modal('Copy Folder Failed', 'Unexpected error while copying folder: ' + src, 'Close', async () => {});
    }
  };

  const publishToGist = (path, type) => {
    props.modal('Create a public gist', `Are you sure you want to anonymously publish all your files in the ${name} workspace as a public gist on github.com?`, 'OK', () => toGist(path, type), 'Cancel', () => {});
  };

  const pushChangesToGist = (path, type) => {
    props.modal('Create a public gist', 'Are you sure you want to push changes to remote gist file on github.com?', 'OK', () => toGist(path, type), 'Cancel', () => {});
  };

  const publishFolderToGist = (path, type) => {
    props.modal('Create a public gist', `Are you sure you want to anonymously publish all your files in the ${path} folder as a public gist on github.com?`, 'OK', () => toGist(path, type), 'Cancel', () => {});
  };

  const publishFileToGist = (path, type) => {
    props.modal('Create a public gist', `Are you sure you want to anonymously publish ${path} file as a public gist on github.com?`, 'OK', () => toGist(path, type), 'Cancel', () => {});
  };

  const toGist = (path, type) => {
    props.dispatchPublishToGist(path, type);
  };

  const runScript = async path => {
    try {
      props.dispatchRunScript(path);
    } catch (error) {
      props.toast('Run script failed');
    }
  };

  const emitContextMenuEvent = cmd => {
    try {
      props.dispatchEmitContextMenuEvent(cmd);
    } catch (error) {
      props.toast(error);
    }
  };

  const handleClickFile = (path, type) => {
    path = path.indexOf(props.name + '/') === 0 ? path.replace(props.name + '/', '') : path;

    if (!state.ctrlKey) {
      props.dispatchHandleClickFile(path, type);
    } else {
      if (props.focusElement.findIndex(item => item.key === path) !== -1) {
        const focusElement = props.focusElement.filter(item => item.key !== path);
        props.dispatchSetFocusElement(focusElement);
      } else {
        const nonRootFocus = props.focusElement.filter(el => {
          return !(el.key === '' && el.type === 'folder');
        });
        nonRootFocus.push({
          key: path,
          type
        });
        props.dispatchSetFocusElement(nonRootFocus);
      }
    }
  };

  const handleClickFolder = async (path, type) => {
    if (state.ctrlKey) {
      if (props.focusElement.findIndex(item => item.key === path) !== -1) {
        const focusElement = props.focusElement.filter(item => item.key !== path);
        props.dispatchSetFocusElement(focusElement);
      } else {
        const nonRootFocus = props.focusElement.filter(el => {
          return !(el.key === '' && el.type === 'folder');
        });
        nonRootFocus.push({
          key: path,
          type
        });
        props.dispatchSetFocusElement(nonRootFocus);
      }
    } else {
      let expandPath = [];

      if (!props.expandPath.includes(path)) {
        expandPath = [...new Set([...props.expandPath, path])];
        props.dispatchFetchDirectory(path);
      } else {
        expandPath = [...new Set(props.expandPath.filter(key => key && typeof key === 'string' && !key.startsWith(path)))];
      }

      props.dispatchSetFocusElement([{
        key: path,
        type
      }]);
      props.dispatchHandleExpandPath(expandPath);
    }
  };

  const handleContextMenu = (pageX, pageY, path, content, type) => {
    if (!content) return;
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        focusContext: {
          element: path,
          x: pageX,
          y: pageY,
          type
        },
        focusEdit: _objectSpread(_objectSpread({}, prevState.focusEdit), {}, {
          lastEdit: content
        }),
        showContextMenu: prevState.focusEdit.element !== path
      });
    });
  };

  const hideContextMenu = () => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        focusContext: {
          element: null,
          x: 0,
          y: 0,
          type: ''
        },
        showContextMenu: false
      });
    });
  };

  const editModeOn = (path, type, isNew = false) => {
    if (props.readonly) return props.toast('Cannot write/modify file system in read only mode.');
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        focusEdit: _objectSpread(_objectSpread({}, prevState.focusEdit), {}, {
          element: path,
          isNew,
          type
        })
      });
    });
  };

  const editModeOff = async content => {
    if (typeof content === 'string') content = content.trim();
    const parentFolder = (0, _helper.extractParentFromKey)(state.focusEdit.element);

    if (!content || content.trim() === '') {
      if (state.focusEdit.isNew) {
        props.dispatchRemoveInputField(parentFolder);
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          });
        });
      } else {
        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          });
        });
      }
    } else {
      if (state.focusEdit.lastEdit === content) {
        return setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          });
        });
      }

      if ((0, _helper.checkSpecialChars)(content)) {
        props.modal('Validation Error', 'Special characters are not allowed', 'OK', () => {});
      } else {
        if (state.focusEdit.isNew) {
          if (hasReservedKeyword(content)) {
            props.dispatchRemoveInputField(parentFolder);
            props.modal('Reserved Keyword', `File name contains Remix reserved keywords. '${content}'`, 'Close', () => {});
          } else {
            state.focusEdit.type === 'file' ? createNewFile((0, _helper.joinPath)(parentFolder, content)) : createNewFolder((0, _helper.joinPath)(parentFolder, content));
            props.dispatchRemoveInputField(parentFolder);
          }
        } else {
          if (hasReservedKeyword(content)) {
            props.modal('Reserved Keyword', `File name contains Remix reserved keywords. '${content}'`, 'Close', () => {});
          } else {
            if (state.focusEdit.element) {
              const oldPath = state.focusEdit.element;
              const oldName = (0, _helper.extractNameFromKey)(oldPath);
              const newPath = oldPath.replace(oldName, content);
              renamePath(oldPath, newPath);
            }
          }
        }

        setState(prevState => {
          return _objectSpread(_objectSpread({}, prevState), {}, {
            focusEdit: {
              element: null,
              isNew: false,
              type: '',
              lastEdit: ''
            }
          });
        });
      }
    }
  };

  const handleNewFileInput = async parentFolder => {
    if (!parentFolder) parentFolder = getFocusedFolder();
    const expandPath = [...new Set([...props.expandPath, parentFolder])];
    await props.dispatchAddInputField(parentFolder, 'file');
    props.dispatchHandleExpandPath(expandPath);
    editModeOn(parentFolder + '/blank', 'file', true);
  };

  const handleNewFolderInput = async parentFolder => {
    if (!parentFolder) parentFolder = getFocusedFolder();else if (parentFolder.indexOf('.sol') !== -1 || parentFolder.indexOf('.js') !== -1) parentFolder = (0, _helper.extractParentFromKey)(parentFolder);
    const expandPath = [...new Set([...props.expandPath, parentFolder])];
    await props.dispatchAddInputField(parentFolder, 'folder');
    props.dispatchHandleExpandPath(expandPath);
    editModeOn(parentFolder + '/blank', 'folder', true);
  };

  const handleCopyClick = (path, type) => {
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        copyElement: [{
          key: path,
          type
        }]
      });
    });
    setCanPaste(true);
    props.toast(`Copied to clipboard ${path}`);
  };

  const handlePasteClick = (dest, destType) => {
    dest = destType === 'file' ? (0, _helper.extractParentFromKey)(dest) || props.name : dest;
    state.copyElement.map(({
      key,
      type
    }) => {
      type === 'file' ? copyFile(key, dest) : copyFolder(key, dest);
    });
  };

  const deleteMessage = path => {
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        children: ["Are you sure you want to delete ", path.length > 1 ? 'these items' : 'this item', "?"]
      }), path.map((item, i) => /*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
        children: item
      }, i))]
    });
  };

  const handleFileExplorerMenuClick = e => {
    e.stopPropagation();
    if (e && e.target.getAttribute('data-id') === 'fileExplorerUploadFileuploadFile') return; // we don't want to let propagate the input of type file

    if (e && e.target.getAttribute('data-id') === 'fileExplorerFileUpload') return; // we don't want to let propagate the input of type file

    let expandPath = [];

    if (!props.expandPath.includes(props.name)) {
      expandPath = [props.name, ...new Set([...props.expandPath])];
    } else {
      expandPath = [...new Set(props.expandPath.filter(key => key && typeof key === 'string' && !key.startsWith(props.name)))];
    }

    props.dispatchHandleExpandPath(expandPath);
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    ref: treeRef,
    tabIndex: 0,
    style: {
      outline: "none"
    },
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
      id: "treeView",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
        id: "treeViewItem",
        controlBehaviour: true,
        label: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          onClick: handleFileExplorerMenuClick,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileExplorerMenu.FileExplorerMenu, {
            title: '',
            menuItems: props.menuItems,
            createNewFile: handleNewFileInput,
            createNewFolder: handleNewFolderInput,
            publishToGist: publishToGist,
            uploadFile: uploadFile
          })
        }),
        expand: true,
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
          className: "pb-2",
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, {
            id: "treeViewMenu",
            children: files[props.name] && Object.keys(files[props.name]).map((key, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileRender.FileRender, {
              file: files[props.name][key],
              index: index,
              focusContext: state.focusContext,
              focusEdit: state.focusEdit,
              focusElement: props.focusElement,
              ctrlKey: state.ctrlKey,
              expandPath: props.expandPath,
              editModeOff: editModeOff,
              handleClickFile: handleClickFile,
              handleClickFolder: handleClickFolder,
              handleContextMenu: handleContextMenu
            }, index))
          })
        })
      })
    }), state.showContextMenu && /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileExplorerContextMenu.FileExplorerContextMenu, {
      actions: props.focusElement.length > 1 ? state.actions.filter(item => item.multiselect) : state.actions.filter(item => !item.multiselect),
      hideContextMenu: hideContextMenu,
      createNewFile: handleNewFileInput,
      createNewFolder: handleNewFolderInput,
      deletePath: deletePath,
      renamePath: editModeOn,
      runScript: runScript,
      copy: handleCopyClick,
      paste: handlePasteClick,
      emit: emitContextMenuEvent,
      pageX: state.focusContext.x,
      pageY: state.focusContext.y,
      path: state.focusContext.element,
      type: state.focusContext.type,
      focus: props.focusElement,
      pushChangesToGist: pushChangesToGist,
      publishFolderToGist: publishFolderToGist,
      publishFileToGist: publishFileToGist
    })]
  });
};

exports.FileExplorer = FileExplorer;
var _default = FileExplorer;
exports.default = _default;

/***/ }),
/* 2826 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileExplorerMenu = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const FileExplorerMenu = props => {
  const [state, setState] = (0, _react.useState)({
    menuItems: [{
      action: 'createNewFile',
      title: 'Create New File',
      icon: 'far fa-file'
    }, {
      action: 'createNewFolder',
      title: 'Create New Folder',
      icon: 'far fa-folder'
    }, {
      action: 'publishToGist',
      title: 'Publish all the current workspace files (only root) to a github gist',
      icon: 'fab fa-github'
    }, {
      action: 'uploadFile',
      title: 'Load a local file into current workspace',
      icon: 'fa fa-upload'
    }, {
      action: 'updateGist',
      title: 'Update the current [gist] explorer',
      icon: 'fab fa-github'
    }].filter(item => props.menuItems && props.menuItems.find(name => {
      return name === item.action;
    })),
    actions: {}
  });
  (0, _react.useEffect)(() => {
    const actions = {
      updateGist: () => {}
    };
    setState(prevState => {
      return _objectSpread(_objectSpread({}, prevState), {}, {
        actions
      });
    });
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      className: "remixui_label",
      title: props.title,
      "data-path": props.title,
      style: {
        fontWeight: 'bold'
      },
      children: props.title
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      className: "pl-2",
      children: state.menuItems.map(({
        action,
        title,
        icon
      }, index) => {
        if (action === 'uploadFile') {
          return /*#__PURE__*/(0, _jsxRuntime.jsx)("label", {
            id: action,
            "data-id": 'fileExplorerUploadFile' + action,
            className: icon + ' mb-0 remixui_newFile',
            title: title,
            children: /*#__PURE__*/(0, _jsxRuntime.jsx)("input", {
              id: "fileUpload",
              "data-id": "fileExplorerFileUpload",
              type: "file",
              onChange: e => {
                e.stopPropagation();
                props.uploadFile(e.target);
                e.target.value = null;
              },
              multiple: true
            })
          }, index);
        } else {
          return /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
            id: action,
            "data-id": 'fileExplorerNewFile' + action,
            onClick: e => {
              e.stopPropagation();

              if (action === 'createNewFile') {
                props.createNewFile();
              } else if (action === 'createNewFolder') {
                props.createNewFolder();
              } else if (action === 'publishToGist') {
                props.publishToGist();
              } else {
                state.actions[action]();
              }
            },
            className: 'newFile ' + icon + ' remixui_newFile',
            title: title
          }, index);
        }
      })
    })]
  });
};

exports.FileExplorerMenu = FileExplorerMenu;
var _default = FileExplorerMenu;
exports.default = _default;

/***/ }),
/* 2827 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FileExplorerContextMenu = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(1227));

var _react = _interopRequireWildcard(__webpack_require__(29));

__webpack_require__(2828);

var _jsxRuntime = __webpack_require__(46);

const _excluded = ["actions", "createNewFile", "createNewFolder", "deletePath", "renamePath", "hideContextMenu", "pushChangesToGist", "publishFileToGist", "publishFolderToGist", "copy", "paste", "runScript", "emit", "pageX", "pageY", "path", "type", "focus"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const _paq = window._paq = window._paq || []; //eslint-disable-line


const FileExplorerContextMenu = props => {
  const {
    actions,
    createNewFile,
    createNewFolder,
    deletePath,
    renamePath,
    hideContextMenu,
    pushChangesToGist,
    publishFileToGist,
    publishFolderToGist,
    copy,
    paste,
    runScript,
    emit,
    pageX,
    pageY,
    path,
    type,
    focus
  } = props,
        otherProps = (0, _objectWithoutProperties2.default)(props, _excluded);
  const contextMenuRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    contextMenuRef.current.focus();
  }, []);
  (0, _react.useEffect)(() => {
    const menuItemsContainer = contextMenuRef.current;
    const boundary = menuItemsContainer.getBoundingClientRect();

    if (boundary.bottom > (window.innerHeight || document.documentElement.clientHeight)) {
      menuItemsContainer.style.position = 'fixed';
      menuItemsContainer.style.bottom = '10px';
      menuItemsContainer.style.top = null;
    }
  }, [pageX, pageY]);

  const filterItem = item => {
    /**
     * if there are multiple elements focused we need to take this and all conditions must be met
     * for example : 'downloadAsZip' with type ['file','folder'] will work on files and folders when multiple are selected
    **/
    const nonRootFocus = focus.filter(el => {
      return !(el.key === '' && el.type === 'folder');
    });

    if (nonRootFocus.length > 1) {
      for (const element of nonRootFocus) {
        if (!itemMatchesCondition(item, element.type, element.key)) return false;
      }

      return true;
    } else {
      return itemMatchesCondition(item, type, path);
    }
  };

  const itemMatchesCondition = (item, itemType, itemPath) => {
    if (item.type && Array.isArray(item.type) && item.type.findIndex(name => name === itemType) !== -1) return true;else if (item.path && Array.isArray(item.path) && item.path.findIndex(key => key === itemPath) !== -1) return true;else if (item.extension && Array.isArray(item.extension) && item.extension.findIndex(ext => itemPath.endsWith(ext)) !== -1) return true;else if (item.pattern && Array.isArray(item.pattern) && item.pattern.filter(value => itemPath.match(new RegExp(value))).length > 0) return true;else return false;
  };

  const getPath = () => {
    if (focus.length > 1) {
      return focus.map(element => element.key);
    } else {
      return path;
    }
  };

  const menu = () => {
    return actions.filter(item => filterItem(item)).map((item, index) => {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("li", {
        id: `menuitem${item.name.toLowerCase()}`,
        className: "remixui_liitem",
        onClick: e => {
          e.stopPropagation();

          switch (item.name) {
            case 'New File':
              createNewFile(path);
              break;

            case 'New Folder':
              createNewFolder(path);
              break;

            case 'Rename':
              renamePath(path, type);
              break;

            case 'Delete':
              deletePath(getPath());
              break;

            case 'Push changes to gist':
              _paq.push(['trackEvent', 'fileExplorer', 'pushToChangesoGist']);

              pushChangesToGist(path, type);
              break;

            case 'Publish folder to gist':
              _paq.push(['trackEvent', 'fileExplorer', 'publishFolderToGist']);

              publishFolderToGist(path, type);
              break;

            case 'Publish file to gist':
              _paq.push(['trackEvent', 'fileExplorer', 'publishFileToGist']);

              publishFileToGist(path, type);
              break;

            case 'Run':
              _paq.push(['trackEvent', 'fileExplorer', 'runScript']);

              runScript(path);
              break;

            case 'Copy':
              copy(path, type);
              break;

            case 'Paste':
              paste(path, type);
              break;

            case 'Delete All':
              deletePath(getPath());
              break;

            default:
              _paq.push(['trackEvent', 'fileExplorer', 'customAction', `${item.id}/${item.name}`]);

              emit && emit(_objectSpread(_objectSpread({}, item), {}, {
                path: [path]
              }));
              break;
          }

          hideContextMenu();
        },
        children: item.label || item.name
      }, index);
    });
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread({
    id: "menuItemsContainer",
    className: "p-1 remixui_contextContainer bg-light shadow border",
    style: {
      left: pageX,
      top: pageY
    },
    ref: contextMenuRef,
    onBlur: hideContextMenu,
    tabIndex: 500
  }, otherProps), {}, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("ul", {
      id: "remixui_menuitems",
      children: menu()
    })
  }));
};

exports.FileExplorerContextMenu = FileExplorerContextMenu;
var _default = FileExplorerContextMenu;
exports.default = _default;

/***/ }),
/* 2828 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2829);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2829 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_contextContainer\n{\n  display: block;\n  position: fixed;\n  border-radius: 2px;\n  z-index: 1000;\n  box-shadow: 0 0 4px var(--dark);\n}\n.remixui_contextContainer:focus {\n    outline: none;\n}\n.remixui_liitem\n{\n  padding: 2px;\n  padding-left: 6px;\n  cursor: pointer;\n  color: var(--text-dark);\n  background-color: var(--light);\n}\n.remixui_liitem:hover\n{\n  background-color:  var(--secondary);\n}\n#remixui_menuitems\n{\n  list-style: none;\n  margin: 0px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGUtZXhwbG9yZXItY29udGV4dC1tZW51LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7RUFFRSxjQUFjO0VBQ2QsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQixhQUFhO0VBQ2IsK0JBQStCO0FBQ2pDO0FBQ0E7SUFDSSxhQUFhO0FBQ2pCO0FBQ0E7O0VBRUUsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixlQUFlO0VBQ2YsdUJBQXVCO0VBQ3ZCLDhCQUE4QjtBQUNoQztBQUNBOztFQUVFLG1DQUFtQztBQUNyQztBQUNBOztFQUVFLGdCQUFnQjtFQUNoQixXQUFXO0FBQ2IiLCJmaWxlIjoiZmlsZS1leHBsb3Jlci1jb250ZXh0LW1lbnUuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnJlbWl4dWlfY29udGV4dENvbnRhaW5lclxue1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGZpeGVkO1xuICBib3JkZXItcmFkaXVzOiAycHg7XG4gIHotaW5kZXg6IDEwMDA7XG4gIGJveC1zaGFkb3c6IDAgMCA0cHggdmFyKC0tZGFyayk7XG59XG4ucmVtaXh1aV9jb250ZXh0Q29udGFpbmVyOmZvY3VzIHtcbiAgICBvdXRsaW5lOiBub25lO1xufVxuLnJlbWl4dWlfbGlpdGVtXG57XG4gIHBhZGRpbmc6IDJweDtcbiAgcGFkZGluZy1sZWZ0OiA2cHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgY29sb3I6IHZhcigtLXRleHQtZGFyayk7XG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0KTtcbn1cbi5yZW1peHVpX2xpaXRlbTpob3Zlclxue1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAgdmFyKC0tc2Vjb25kYXJ5KTtcbn1cbiNyZW1peHVpX21lbnVpdGVtc1xue1xuICBsaXN0LXN0eWxlOiBub25lO1xuICBtYXJnaW46IDBweDtcbn0iXX0= */", '', '']]

/***/ }),
/* 2830 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contextMenuActions = void 0;
const contextMenuActions = [{
  id: 'newFile',
  name: 'New File',
  type: ['folder', 'gist'],
  multiselect: false,
  label: ''
}, {
  id: 'newFolder',
  name: 'New Folder',
  type: ['folder', 'gist'],
  multiselect: false,
  label: ''
}, {
  id: 'rename',
  name: 'Rename',
  type: ['file', 'folder'],
  multiselect: false,
  label: ''
}, {
  id: 'delete',
  name: 'Delete',
  type: ['file', 'folder', 'gist'],
  multiselect: false,
  label: ''
}, {
  id: 'run',
  name: 'Run',
  extension: ['.js', '.ts'],
  multiselect: false,
  label: ''
}, {
  id: 'pushChangesToGist',
  name: 'Push changes to gist',
  type: ['gist'],
  multiselect: false,
  label: ''
}, {
  id: 'publishFolderToGist',
  name: 'Publish folder to gist',
  type: ['folder'],
  multiselect: false,
  label: ''
}, {
  id: 'publishFileToGist',
  name: 'Publish file to gist',
  type: ['file'],
  multiselect: false,
  label: ''
}, {
  id: 'copy',
  name: 'Copy',
  type: ['folder', 'file'],
  multiselect: false,
  label: ''
}, {
  id: 'deleteAll',
  name: 'Delete All',
  type: ['folder', 'file'],
  multiselect: true,
  label: ''
}];
exports.contextMenuActions = contextMenuActions;

/***/ }),
/* 2831 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2832);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2832 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_label {\n    margin-top        : 4px;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n}\n.remixui_leaf {\n    overflow          : hidden;\n    text-overflow     : ellipsis;\n    width             : 90%;\n    margin-bottom     : 0px;\n}\n.remixui_fileexplorer       {\n    box-sizing        : border-box;\n    -webkit-user-select       : none;\n       -moz-user-select       : none;\n        -ms-user-select       : none;\n            user-select       : none;\n}\ninput[type=\"file\"] {\n    display: none;\n}\n.remixui_folder,\n.remixui_file               {\n    font-size         : 14px;\n    cursor            : pointer;\n}\n.remixui_file               {\n    padding           : 4px;\n}\n.remixui_newFile            {\n    padding-right     : 10px;\n}\n.remixui_newFile i          {\n    cursor            : pointer;\n}\n.remixui_newFile:hover    {\n    transform         : scale(1.3);\n}\n.remixui_menu               {\n    margin-left       : 20px;\n}\n.remixui_items              {\n    display           : inline\n}\n.remixui_remove             {\n    margin-left       : auto;\n    padding-left      : 5px;\n    padding-right     : 5px;\n}\n.remixui_activeMode         {\n    display           : flex;\n    width             : 100%;\n    margin-right      : 10px;\n    padding-right     : 19px;\n}\n.remixui_activeMode > div   {\n    min-width         : 10px;\n}\nul                  {\n    padding           : 0;\n}\n[contenteditable] {\n    -webkit-user-select: text;\n    -moz-user-select: text;\n     -ms-user-select: text;\n         user-select: text;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGUtZXhwbG9yZXIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksdUJBQXVCO0lBQ3ZCLHlCQUFpQjtPQUFqQixzQkFBaUI7UUFBakIscUJBQWlCO1lBQWpCLGlCQUFpQjtBQUNyQjtBQUNBO0lBQ0ksMEJBQTBCO0lBQzFCLDRCQUE0QjtJQUM1Qix1QkFBdUI7SUFDdkIsdUJBQXVCO0FBQzNCO0FBQ0E7SUFDSSw4QkFBOEI7SUFDOUIsZ0NBQXdCO09BQXhCLDZCQUF3QjtRQUF4Qiw0QkFBd0I7WUFBeEIsd0JBQXdCO0FBQzVCO0FBQ0E7SUFDSSxhQUFhO0FBQ2pCO0FBQ0E7O0lBRUksd0JBQXdCO0lBQ3hCLDJCQUEyQjtBQUMvQjtBQUNBO0lBQ0ksdUJBQXVCO0FBQzNCO0FBQ0E7SUFDSSx3QkFBd0I7QUFDNUI7QUFDQTtJQUNJLDJCQUEyQjtBQUMvQjtBQUNBO0lBQ0ksOEJBQThCO0FBQ2xDO0FBQ0E7SUFDSSx3QkFBd0I7QUFDNUI7QUFDQTtJQUNJO0FBQ0o7QUFDQTtJQUNJLHdCQUF3QjtJQUN4Qix1QkFBdUI7SUFDdkIsdUJBQXVCO0FBQzNCO0FBQ0E7SUFDSSx3QkFBd0I7SUFDeEIsd0JBQXdCO0lBQ3hCLHdCQUF3QjtJQUN4Qix3QkFBd0I7QUFDNUI7QUFDQTtJQUNJLHdCQUF3QjtBQUM1QjtBQUNBO0lBQ0kscUJBQXFCO0FBQ3pCO0FBRUE7SUFDSSx5QkFBeUI7SUFDekIsc0JBQWlCO0tBQWpCLHFCQUFpQjtTQUFqQixpQkFBaUI7QUFDckIiLCJmaWxlIjoiZmlsZS1leHBsb3Jlci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXh1aV9sYWJlbCB7XG4gICAgbWFyZ2luLXRvcCAgICAgICAgOiA0cHg7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG4ucmVtaXh1aV9sZWFmIHtcbiAgICBvdmVyZmxvdyAgICAgICAgICA6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93ICAgICA6IGVsbGlwc2lzO1xuICAgIHdpZHRoICAgICAgICAgICAgIDogOTAlO1xuICAgIG1hcmdpbi1ib3R0b20gICAgIDogMHB4O1xufVxuLnJlbWl4dWlfZmlsZWV4cGxvcmVyICAgICAgIHtcbiAgICBib3gtc2l6aW5nICAgICAgICA6IGJvcmRlci1ib3g7XG4gICAgdXNlci1zZWxlY3QgICAgICAgOiBub25lO1xufVxuaW5wdXRbdHlwZT1cImZpbGVcIl0ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG59XG4ucmVtaXh1aV9mb2xkZXIsXG4ucmVtaXh1aV9maWxlICAgICAgICAgICAgICAge1xuICAgIGZvbnQtc2l6ZSAgICAgICAgIDogMTRweDtcbiAgICBjdXJzb3IgICAgICAgICAgICA6IHBvaW50ZXI7XG59XG4ucmVtaXh1aV9maWxlICAgICAgICAgICAgICAge1xuICAgIHBhZGRpbmcgICAgICAgICAgIDogNHB4O1xufVxuLnJlbWl4dWlfbmV3RmlsZSAgICAgICAgICAgIHtcbiAgICBwYWRkaW5nLXJpZ2h0ICAgICA6IDEwcHg7XG59XG4ucmVtaXh1aV9uZXdGaWxlIGkgICAgICAgICAge1xuICAgIGN1cnNvciAgICAgICAgICAgIDogcG9pbnRlcjtcbn1cbi5yZW1peHVpX25ld0ZpbGU6aG92ZXIgICAge1xuICAgIHRyYW5zZm9ybSAgICAgICAgIDogc2NhbGUoMS4zKTtcbn1cbi5yZW1peHVpX21lbnUgICAgICAgICAgICAgICB7XG4gICAgbWFyZ2luLWxlZnQgICAgICAgOiAyMHB4O1xufVxuLnJlbWl4dWlfaXRlbXMgICAgICAgICAgICAgIHtcbiAgICBkaXNwbGF5ICAgICAgICAgICA6IGlubGluZVxufVxuLnJlbWl4dWlfcmVtb3ZlICAgICAgICAgICAgIHtcbiAgICBtYXJnaW4tbGVmdCAgICAgICA6IGF1dG87XG4gICAgcGFkZGluZy1sZWZ0ICAgICAgOiA1cHg7XG4gICAgcGFkZGluZy1yaWdodCAgICAgOiA1cHg7XG59XG4ucmVtaXh1aV9hY3RpdmVNb2RlICAgICAgICAge1xuICAgIGRpc3BsYXkgICAgICAgICAgIDogZmxleDtcbiAgICB3aWR0aCAgICAgICAgICAgICA6IDEwMCU7XG4gICAgbWFyZ2luLXJpZ2h0ICAgICAgOiAxMHB4O1xuICAgIHBhZGRpbmctcmlnaHQgICAgIDogMTlweDtcbn1cbi5yZW1peHVpX2FjdGl2ZU1vZGUgPiBkaXYgICB7XG4gICAgbWluLXdpZHRoICAgICAgICAgOiAxMHB4O1xufVxudWwgICAgICAgICAgICAgICAgICB7XG4gICAgcGFkZGluZyAgICAgICAgICAgOiAwO1xufVxuXG5bY29udGVudGVkaXRhYmxlXSB7XG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcbiAgICB1c2VyLXNlbGVjdDogdGV4dDtcbn0iXX0= */", '', '']]

/***/ }),
/* 2833 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileRender = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _treeView = __webpack_require__(1187);

var _helper = __webpack_require__(1121);

var _fileLabel = __webpack_require__(2834);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const FileRender = props => {
  const [file, setFile] = (0, _react.useState)({});
  const [hover, setHover] = (0, _react.useState)(false);
  const [icon, setIcon] = (0, _react.useState)('');
  (0, _react.useEffect)(() => {
    if (props.file && props.file.path && props.file.type) {
      setFile(props.file);
      setIcon((0, _helper.getPathIcon)(props.file.path));
    }
  }, [props.file]);
  const labelClass = props.focusEdit.element === file.path ? 'bg-light' : props.focusElement.findIndex(item => item.key === file.path) !== -1 ? 'bg-secondary' : hover ? 'bg-light border' : props.focusContext.element === file.path && props.focusEdit.element !== file.path ? 'bg-light border' : '';
  const spreadProps = {
    onClick: e => e.stopPropagation()
  };

  const handleFolderClick = event => {
    event.stopPropagation();
    if (props.focusEdit.element !== file.path) props.handleClickFolder(file.path, file.type);
  };

  const handleFileClick = event => {
    event.stopPropagation();
    if (props.focusEdit.element !== file.path) props.handleClickFile(file.path, file.type);
  };

  const handleContextMenu = event => {
    event.preventDefault();
    event.stopPropagation();
    props.handleContextMenu(event.pageX, event.pageY, file.path, event.target.textContent, file.type);
  };

  const handleMouseOut = event => {
    event.stopPropagation();
    setHover(false);
  };

  const handleMouseOver = event => {
    event.stopPropagation();
    setHover(true);
  };

  if (file.isDirectory) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
      id: `treeViewItem${file.path}`,
      iconX: "pr-3 fa fa-folder",
      iconY: "pr-3 fa fa-folder-open",
      label: /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileLabel.FileLabel, {
        file: file,
        focusEdit: props.focusEdit,
        editModeOff: props.editModeOff
      }),
      onClick: handleFolderClick,
      onContextMenu: handleContextMenu,
      labelClass: labelClass,
      controlBehaviour: props.ctrlKey,
      expand: props.expandPath.includes(file.path),
      onMouseOver: handleMouseOver,
      onMouseOut: handleMouseOut,
      children: file.child ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, _objectSpread(_objectSpread({
        id: `treeView${file.path}`
      }, spreadProps), {}, {
        children: Object.keys(file.child).map((key, index) => /*#__PURE__*/(0, _jsxRuntime.jsx)(FileRender, {
          file: file.child[key],
          index: index,
          focusContext: props.focusContext,
          focusEdit: props.focusEdit,
          focusElement: props.focusElement,
          ctrlKey: props.ctrlKey,
          editModeOff: props.editModeOff,
          handleClickFile: props.handleClickFile,
          handleClickFolder: props.handleClickFolder,
          handleContextMenu: props.handleContextMenu,
          expandPath: props.expandPath
        }, index))
      }), `treeView${file.path}`) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeView, _objectSpread({
        id: `treeView${file.path}`
      }, spreadProps), `treeView${file.path}`)
    }, `${file.path + props.index}`);
  } else {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_treeView.TreeViewItem, {
      id: `treeViewItem${file.path}`,
      label: /*#__PURE__*/(0, _jsxRuntime.jsx)(_fileLabel.FileLabel, {
        file: file,
        focusEdit: props.focusEdit,
        editModeOff: props.editModeOff
      }),
      onClick: handleFileClick,
      onContextMenu: handleContextMenu,
      icon: icon,
      labelClass: labelClass,
      onMouseOver: handleMouseOver,
      onMouseOut: handleMouseOut
    }, `treeView${file.path}`);
  }
};

exports.FileRender = FileRender;

/***/ }),
/* 2834 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileLabel = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-next-line no-use-before-define
const FileLabel = props => {
  const {
    file,
    focusEdit,
    editModeOff
  } = props;
  const [isEditable, setIsEditable] = (0, _react.useState)(false);
  const labelRef = (0, _react.useRef)(null);
  (0, _react.useEffect)(() => {
    if (focusEdit.element && file.path) {
      setIsEditable(focusEdit.element === file.path);
    }
  }, [file.path, focusEdit]);
  (0, _react.useEffect)(() => {
    if (labelRef.current) {
      setTimeout(() => {
        labelRef.current.focus();
      }, 0);
    }
  }, [isEditable]);

  const handleEditInput = event => {
    if (event.which === 13) {
      event.preventDefault();
      editModeOff(labelRef.current.innerText);
      labelRef.current.innerText = file.name;
    }
  };

  const handleEditBlur = event => {
    event.stopPropagation();
    editModeOff(labelRef.current.innerText);
    labelRef.current.innerText = file.name;
  };

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "remixui_items d-inline-block w-100 text-break",
    ref: isEditable ? labelRef : null,
    suppressContentEditableWarning: true,
    contentEditable: isEditable,
    onKeyDown: handleEditInput,
    onBlur: handleEditBlur,
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
      title: file.path,
      className: 'text-nowrap remixui_label ' + (file.isDirectory ? 'folder' : 'remixui_leaf'),
      "data-path": file.path,
      children: file.name
    })
  });
};

exports.FileLabel = FileLabel;

/***/ }),
/* 2835 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2836);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2836 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remixui_container {\n    display           : flex;\n    flex-direction    : row;\n    width             : 100%;\n    height            : 100%;\n    box-sizing        : border-box;\n  }\n  .remixui_fileexplorer       {\n    display           : flex;\n    flex-direction    : column;\n    position          : relative;\n    width             : 100%;\n    padding-left      : 6px;\n    padding-right     : 6px;\n    padding-top       : 6px;\n    overflow-y        : auto;\n  }\n  .remixui_fileExplorerTree   {\n    cursor            : default;\n  }\n  .remixui_gist            {\n    padding           : 10px;\n  }\n  .remixui_gist i          {\n    cursor            : pointer;\n  }\n  .remixui_gist i:hover    {\n    color             : orange;\n  }\n  .remixui_connectToLocalhost {\n    padding           : 10px;\n  }\n  .remixui_connectToLocalhost i {\n    cursor            : pointer;\n  }\n  .remixui_connectToLocalhost i:hover   {\n    color             : var(--secondary)\n  }\n  .remixui_uploadFile         {\n    padding           : 10px;\n  }\n  .remixui_uploadFile label:hover   {\n    color             : var(--secondary)\n  }\n  .remixui_uploadFile label   {\n    cursor            : pointer;\n  }\n  .remixui_treeview {\n    overflow-y        : auto;\n  }\n  .remixui_dialog {\n    display: flex;\n    flex-direction: column;\n  }\n  .remixui_dialogParagraph {\n    margin-bottom: 2em;\n    word-break: break-word;\n  }\n  .remixui_menuicon {\n    padding-right   : 10px;\n  }\n  .remixui_menuicon:hover {\n    transform: scale(1.3);\n  }\n  .remixui_cloneContainer {\n    display: flex;\n    align-items: center;\n    height: 32px;\n  }\n  .remixui_cloneContainer input {\n    height: 32px;\n    border-top-left-radius: 0 !important;\n    border-bottom-left-radius: 0 !important;\n    width: 250px;\n    font-size: 10px !important;\n    padding: .25rem;\n  }\n  .remixui_menuicon .bs-popover-auto[x-placement^=\"bottom\"] .popover-header::before, .bs-popover-bottom .popover-header::before {\n    border-bottom-color: var(--dark) !important\n  }\n  .remixui_menuicon .bs-popover-auto[x-placement^=\"bottom\"] > .arrow::after, .bs-popover-bottom > .arrow::after {\n    border-bottom-color: var(--dark) !important\n  }\n  .custom-dropdown-items {\n    padding: 0.25rem 0.25rem;\n    border-radius: .25rem;\n    background: var(--custom-select);\n  }\n  .custom-dropdown-items a {\n    border-radius: .25rem;\n    text-transform: none;\n    text-decoration: none;\n    font-weight: normal;\n    font-size: 0.875rem;\n    padding: 0.25rem 0.25rem;\n    width: auto;\n    color: var(--text);\n  }\n  \n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLXdvcmtzcGFjZS5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7SUFDSSx3QkFBd0I7SUFDeEIsdUJBQXVCO0lBQ3ZCLHdCQUF3QjtJQUN4Qix3QkFBd0I7SUFDeEIsOEJBQThCO0VBQ2hDO0VBQ0E7SUFDRSx3QkFBd0I7SUFDeEIsMEJBQTBCO0lBQzFCLDRCQUE0QjtJQUM1Qix3QkFBd0I7SUFDeEIsdUJBQXVCO0lBQ3ZCLHVCQUF1QjtJQUN2Qix1QkFBdUI7SUFDdkIsd0JBQXdCO0VBQzFCO0VBQ0E7SUFDRSwyQkFBMkI7RUFDN0I7RUFDQTtJQUNFLHdCQUF3QjtFQUMxQjtFQUNBO0lBQ0UsMkJBQTJCO0VBQzdCO0VBQ0E7SUFDRSwwQkFBMEI7RUFDNUI7RUFDQTtJQUNFLHdCQUF3QjtFQUMxQjtFQUNBO0lBQ0UsMkJBQTJCO0VBQzdCO0VBQ0E7SUFDRTtFQUNGO0VBQ0E7SUFDRSx3QkFBd0I7RUFDMUI7RUFDQTtJQUNFO0VBQ0Y7RUFDQTtJQUNFLDJCQUEyQjtFQUM3QjtFQUNBO0lBQ0Usd0JBQXdCO0VBQzFCO0VBQ0E7SUFDRSxhQUFhO0lBQ2Isc0JBQXNCO0VBQ3hCO0VBQ0E7SUFDRSxrQkFBa0I7SUFDbEIsc0JBQXNCO0VBQ3hCO0VBQ0E7SUFDRSxzQkFBc0I7RUFDeEI7RUFDQTtJQUNFLHFCQUFxQjtFQUN2QjtFQUNBO0lBQ0UsYUFBYTtJQUNiLG1CQUFtQjtJQUNuQixZQUFZO0VBQ2Q7RUFFQTtJQUNFLFlBQVk7SUFDWixvQ0FBb0M7SUFDcEMsdUNBQXVDO0lBQ3ZDLFlBQVk7SUFDWiwwQkFBMEI7SUFDMUIsZUFBZTtFQUNqQjtFQUVBO0lBQ0U7RUFDRjtFQUVBO0lBQ0U7RUFDRjtFQUVBO0lBQ0Usd0JBQXdCO0lBQ3hCLHFCQUFxQjtJQUNyQixnQ0FBZ0M7RUFDbEM7RUFDQTtJQUNFLHFCQUFxQjtJQUNyQixvQkFBb0I7SUFDcEIscUJBQXFCO0lBQ3JCLG1CQUFtQjtJQUNuQixtQkFBbUI7SUFDbkIsd0JBQXdCO0lBQ3hCLFdBQVc7SUFDWCxrQkFBa0I7RUFDcEIiLCJmaWxlIjoicmVtaXgtdWktd29ya3NwYWNlLmNzcyIsInNvdXJjZXNDb250ZW50IjpbIi5yZW1peHVpX2NvbnRhaW5lciB7XG4gICAgZGlzcGxheSAgICAgICAgICAgOiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uICAgIDogcm93O1xuICAgIHdpZHRoICAgICAgICAgICAgIDogMTAwJTtcbiAgICBoZWlnaHQgICAgICAgICAgICA6IDEwMCU7XG4gICAgYm94LXNpemluZyAgICAgICAgOiBib3JkZXItYm94O1xuICB9XG4gIC5yZW1peHVpX2ZpbGVleHBsb3JlciAgICAgICB7XG4gICAgZGlzcGxheSAgICAgICAgICAgOiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uICAgIDogY29sdW1uO1xuICAgIHBvc2l0aW9uICAgICAgICAgIDogcmVsYXRpdmU7XG4gICAgd2lkdGggICAgICAgICAgICAgOiAxMDAlO1xuICAgIHBhZGRpbmctbGVmdCAgICAgIDogNnB4O1xuICAgIHBhZGRpbmctcmlnaHQgICAgIDogNnB4O1xuICAgIHBhZGRpbmctdG9wICAgICAgIDogNnB4O1xuICAgIG92ZXJmbG93LXkgICAgICAgIDogYXV0bztcbiAgfVxuICAucmVtaXh1aV9maWxlRXhwbG9yZXJUcmVlICAge1xuICAgIGN1cnNvciAgICAgICAgICAgIDogZGVmYXVsdDtcbiAgfVxuICAucmVtaXh1aV9naXN0ICAgICAgICAgICAge1xuICAgIHBhZGRpbmcgICAgICAgICAgIDogMTBweDtcbiAgfVxuICAucmVtaXh1aV9naXN0IGkgICAgICAgICAge1xuICAgIGN1cnNvciAgICAgICAgICAgIDogcG9pbnRlcjtcbiAgfVxuICAucmVtaXh1aV9naXN0IGk6aG92ZXIgICAge1xuICAgIGNvbG9yICAgICAgICAgICAgIDogb3JhbmdlO1xuICB9XG4gIC5yZW1peHVpX2Nvbm5lY3RUb0xvY2FsaG9zdCB7XG4gICAgcGFkZGluZyAgICAgICAgICAgOiAxMHB4O1xuICB9XG4gIC5yZW1peHVpX2Nvbm5lY3RUb0xvY2FsaG9zdCBpIHtcbiAgICBjdXJzb3IgICAgICAgICAgICA6IHBvaW50ZXI7XG4gIH1cbiAgLnJlbWl4dWlfY29ubmVjdFRvTG9jYWxob3N0IGk6aG92ZXIgICB7XG4gICAgY29sb3IgICAgICAgICAgICAgOiB2YXIoLS1zZWNvbmRhcnkpXG4gIH1cbiAgLnJlbWl4dWlfdXBsb2FkRmlsZSAgICAgICAgIHtcbiAgICBwYWRkaW5nICAgICAgICAgICA6IDEwcHg7XG4gIH1cbiAgLnJlbWl4dWlfdXBsb2FkRmlsZSBsYWJlbDpob3ZlciAgIHtcbiAgICBjb2xvciAgICAgICAgICAgICA6IHZhcigtLXNlY29uZGFyeSlcbiAgfVxuICAucmVtaXh1aV91cGxvYWRGaWxlIGxhYmVsICAge1xuICAgIGN1cnNvciAgICAgICAgICAgIDogcG9pbnRlcjtcbiAgfVxuICAucmVtaXh1aV90cmVldmlldyB7XG4gICAgb3ZlcmZsb3cteSAgICAgICAgOiBhdXRvO1xuICB9ICBcbiAgLnJlbWl4dWlfZGlhbG9nIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIH1cbiAgLnJlbWl4dWlfZGlhbG9nUGFyYWdyYXBoIHtcbiAgICBtYXJnaW4tYm90dG9tOiAyZW07XG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcbiAgfVxuICAucmVtaXh1aV9tZW51aWNvbiB7XG4gICAgcGFkZGluZy1yaWdodCAgIDogMTBweDtcbiAgfVxuICAucmVtaXh1aV9tZW51aWNvbjpob3ZlciB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjMpO1xuICB9XG4gIC5yZW1peHVpX2Nsb25lQ29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgaGVpZ2h0OiAzMnB4O1xuICB9XG4gIFxuICAucmVtaXh1aV9jbG9uZUNvbnRhaW5lciBpbnB1dCB7XG4gICAgaGVpZ2h0OiAzMnB4O1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDAgIWltcG9ydGFudDtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7XG4gICAgd2lkdGg6IDI1MHB4O1xuICAgIGZvbnQtc2l6ZTogMTBweCAhaW1wb3J0YW50O1xuICAgIHBhZGRpbmc6IC4yNXJlbTtcbiAgfVxuXG4gIC5yZW1peHVpX21lbnVpY29uIC5icy1wb3BvdmVyLWF1dG9beC1wbGFjZW1lbnRePVwiYm90dG9tXCJdIC5wb3BvdmVyLWhlYWRlcjo6YmVmb3JlLCAuYnMtcG9wb3Zlci1ib3R0b20gLnBvcG92ZXItaGVhZGVyOjpiZWZvcmUge1xuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHZhcigtLWRhcmspICFpbXBvcnRhbnRcbiAgfVxuXG4gIC5yZW1peHVpX21lbnVpY29uIC5icy1wb3BvdmVyLWF1dG9beC1wbGFjZW1lbnRePVwiYm90dG9tXCJdID4gLmFycm93OjphZnRlciwgLmJzLXBvcG92ZXItYm90dG9tID4gLmFycm93OjphZnRlciB7XG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdmFyKC0tZGFyaykgIWltcG9ydGFudFxuICB9XG4gIFxuICAuY3VzdG9tLWRyb3Bkb3duLWl0ZW1zIHtcbiAgICBwYWRkaW5nOiAwLjI1cmVtIDAuMjVyZW07XG4gICAgYm9yZGVyLXJhZGl1czogLjI1cmVtO1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWN1c3RvbS1zZWxlY3QpO1xuICB9XG4gIC5jdXN0b20tZHJvcGRvd24taXRlbXMgYSB7XG4gICAgYm9yZGVyLXJhZGl1czogLjI1cmVtO1xuICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIGZvbnQtc2l6ZTogMC44NzVyZW07XG4gICAgcGFkZGluZzogMC4yNXJlbSAwLjI1cmVtO1xuICAgIHdpZHRoOiBhdXRvO1xuICAgIGNvbG9yOiB2YXIoLS10ZXh0KTtcbiAgfVxuICAiXX0= */", '', '']]

/***/ }),
/* 2837 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixdHandle = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _get2 = _interopRequireDefault(__webpack_require__(1197));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(111));

var _react = _interopRequireDefault(__webpack_require__(29));

var _isElectron = _interopRequireDefault(__webpack_require__(1300));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _package2 = __webpack_require__(2838);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var LOCALHOST = ' - connect to localhost - ';
var profile = {
  name: 'remixd',
  displayName: 'RemixD',
  url: 'ws://127.0.0.1:65520',
  methods: ['folderIsReadOnly', 'resolveDirectory', 'get', 'exists', 'isFile', 'set', 'rename', 'remove', 'isDirectory', 'list', 'createDir'],
  events: [],
  description: 'Using Remixd daemon, allow to access file system',
  kind: 'other',
  version: packageJson.version
};
var State;

(function (State) {
  State[State["ok"] = 0] = "ok";
  State[State["cancel"] = 1] = "cancel";
  State[State["new"] = 2] = "new";
})(State || (State = {}));

var RemixdHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  (0, _inherits2["default"])(RemixdHandle, _WebsocketPlugin);

  var _super = _createSuper(RemixdHandle);

  function RemixdHandle(localhostProvider, appManager) {
    var _this;

    (0, _classCallCheck2["default"])(this, RemixdHandle);
    _this = _super.call(this, profile);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "localhostProvider", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "appManager", void 0);
    _this.localhostProvider = localhostProvider;
    _this.appManager = appManager;
    return _this;
  }

  (0, _createClass2["default"])(RemixdHandle, [{
    key: "deactivate",
    value: function () {
      var _deactivate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if ((0, _get2["default"])((0, _getPrototypeOf2["default"])(RemixdHandle.prototype), "socket", this)) (0, _get2["default"])((0, _getPrototypeOf2["default"])(RemixdHandle.prototype), "deactivate", this).call(this); // this.appManager.deactivatePlugin('git') // plugin call doesn't work.. see issue https://github.com/ethereum/remix-plugin/issues/342

                if (this.appManager.isActive('hardhat')) this.appManager.deactivatePlugin('hardhat');
                if (this.appManager.isActive('truffle')) this.appManager.deactivatePlugin('truffle');
                if (this.appManager.isActive('slither')) this.appManager.deactivatePlugin('slither');
                this.localhostProvider.close(function (error) {
                  if (error) console.log(error);
                });

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function deactivate() {
        return _deactivate.apply(this, arguments);
      }

      return deactivate;
    }()
  }, {
    key: "activate",
    value: function () {
      var _activate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.connectToLocalhost();
                return _context2.abrupt("return", true);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function activate() {
        return _activate.apply(this, arguments);
      }

      return activate;
    }()
  }, {
    key: "canceled",
    value: function () {
      var _canceled = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.appManager.deactivatePlugin('remixd');

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function canceled() {
        return _canceled.apply(this, arguments);
      }

      return canceled;
    }()
    /**
      * connect to localhost if no connection and render the explorer
      * disconnect from localhost if connected and remove the explorer
      *
      * @param {String} txHash - hash of the transaction
      */

  }, {
    key: "connectToLocalhost",
    value: function () {
      var _connectToLocalhost = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var _this2 = this;

        var connection, mod, result;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                connection = function connection(error) {
                  if (error) {
                    console.log(error);
                    var alert = {
                      id: 'connectionAlert',
                      message: 'Cannot connect to the remixd daemon. Please make sure you have the remixd running in the background.'
                    };

                    _this2.call('notification', 'alert', alert);

                    _this2.canceled();
                  } else {
                    var intervalId = setInterval(function () {
                      if (!_this2.socket || _this2.socket && _this2.socket.readyState === 3) {
                        // 3 means connection closed
                        clearInterval(intervalId);
                        var _alert = {
                          id: 'connectionAlert',
                          message: 'Connection to remixd terminated. Please make sure remixd is still running in the background.'
                        };

                        _this2.call('notification', 'alert', _alert);

                        _this2.canceled();
                      }
                    }, 3000);

                    _this2.localhostProvider.init(function () {
                      _this2.call('filePanel', 'setWorkspace', {
                        name: LOCALHOST,
                        isLocalhost: true
                      }, true);
                    });

                    _this2.call('manager', 'activatePlugin', 'hardhat');

                    _this2.call('manager', 'activatePlugin', 'truffle');

                    _this2.call('manager', 'activatePlugin', 'slither');
                  }
                };

                if (!this.localhostProvider.isConnected()) {
                  _context4.next = 5;
                  break;
                }

                this.deactivate();
                _context4.next = 19;
                break;

              case 5:
                if ((0, _isElectron["default"])()) {
                  _context4.next = 18;
                  break;
                }

                // warn the user only if he/she is in the browser context
                mod = {
                  id: 'remixdConnect',
                  title: 'Connect to localhost',
                  message: remixdDialog(),
                  okLabel: 'Connect',
                  cancelLabel: 'Cancel'
                };
                _context4.next = 9;
                return this.call('notification', 'modal', mod);

              case 9:
                result = _context4.sent;

                if (!result) {
                  _context4.next = 14;
                  break;
                }

                try {
                  this.localhostProvider.preInit();
                  (0, _get2["default"])((0, _getPrototypeOf2["default"])(RemixdHandle.prototype), "activate", this).call(this);
                  setTimeout(function () {
                    if (!_this2.socket || _this2.socket && _this2.socket.readyState === 3) {
                      // 3 means connection closed
                      connection(new Error('Connection with daemon failed.'));
                    } else {
                      connection();
                    }
                  }, 3000);
                } catch (error) {
                  connection(error);
                }

                _context4.next = 16;
                break;

              case 14:
                _context4.next = 16;
                return this.canceled();

              case 16:
                _context4.next = 19;
                break;

              case 18:
                try {
                  (0, _get2["default"])((0, _getPrototypeOf2["default"])(RemixdHandle.prototype), "activate", this).call(this);
                  setTimeout(function () {
                    connection();
                  }, 2000);
                } catch (error) {
                  connection(error);
                }

              case 19:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function connectToLocalhost() {
        return _connectToLocalhost.apply(this, arguments);
      }

      return connectToLocalhost;
    }()
  }]);
  return RemixdHandle;
}(_engineWeb.WebsocketPlugin);

exports.RemixdHandle = RemixdHandle;

function remixdDialog() {
  var commandText = 'remixd';
  var fullCommandText = 'remixd -s <path-to-the-shared-folder> -u <remix-ide-instance-URL>';
  return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, /*#__PURE__*/_react["default"].createElement("div", {
    className: ""
  }, /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "Access your local file system from Remix IDE using ", /*#__PURE__*/_react["default"].createElement("a", {
    target: "_blank",
    href: "https://www.npmjs.com/package/@remix-project/remixd"
  }, "Remixd NPM package"), "."), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "Remixd ", /*#__PURE__*/_react["default"].createElement("a", {
    target: "_blank",
    href: "https://remix-ide.readthedocs.io/en/latest/remixd.html"
  }, "documentation"), "."), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "The remixd command is:", /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("b", null, commandText)), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "The remixd command without options uses the terminal's current directory as the shared directory and the shared Remix domain can only be https://remix.ethereum.org, https://remix-alpha.ethereum.org, or https://remix-beta.ethereum.org"), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "Example command with flags: ", /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("b", null, fullCommandText)), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "For info about ports, see ", /*#__PURE__*/_react["default"].createElement("a", {
    target: "_blank",
    href: "https://remix-ide.readthedocs.io/en/latest/remixd.html#ports-usage"
  }, "Remixd ports usage")), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, "This feature is still in Alpha. We recommend to keep a backup of the shared folder."), /*#__PURE__*/_react["default"].createElement("div", {
    className: "mb-2 text-break"
  }, /*#__PURE__*/_react["default"].createElement("h6", {
    className: "text-danger"
  }, "Before using, make sure remixd version is latest i.e. ", /*#__PURE__*/_react["default"].createElement("b", null, "v", _package2.version), /*#__PURE__*/_react["default"].createElement("br", null), /*#__PURE__*/_react["default"].createElement("a", {
    target: "_blank",
    href: "https://remix-ide.readthedocs.io/en/latest/remixd.html#update-to-the-latest-remixd"
  }, "Read here how to update it")))));
}

/***/ }),
/* 2838 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@remix-project/remixd\",\"version\":\"0.6.5\",\"description\":\"remix server: allow accessing file system from remix.ethereum.org and start a dev environment (see help section)\",\"main\":\"index.js\",\"types\":\"./index.d.ts\",\"bin\":{\"remixd\":\"./src/bin/remixd.js\"},\"scripts\":{\"test\":\"echo \\\"Error: no test specified\\\"\",\"start\":\"./src/bin/remixd.js\",\"npip\":\"npip\",\"lint\":\"eslint ./src --ext .ts\",\"build\":\"tsc -p ./ && chmod +x ./src/bin/remixd.js\",\"dev\":\"nodemon\",\"postinstall\":\"node src/scripts/installSlither.js\"},\"publishConfig\":{\"access\":\"public\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/ethereum/remix-project.git\"},\"keywords\":[\"remix\",\"ide\",\"ethereum\",\"solidity\"],\"author\":\"Remix Team\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/ethereum/remix-project/issues\"},\"homepage\":\"https://github.com/ethereum/remix-project#readme\",\"dependencies\":{\"@remixproject/plugin\":\"^0.3.11\",\"@remixproject/plugin-api\":\"^0.3.11\",\"@remixproject/plugin-utils\":\"^0.3.11\",\"@remixproject/plugin-ws\":\"^0.3.11\",\"axios\":\">=0.21.1\",\"chokidar\":\"^2.1.8\",\"commander\":\"^2.20.3\",\"fs-extra\":\"^3.0.1\",\"isbinaryfile\":\"^3.0.2\",\"ws\":\"^7.3.0\",\"latest-version\":\"^5.1.0\",\"semver\":\"^6.3.0\"},\"python\":{\"execPath\":\"python3\",\"dependencies\":{\"vyper\":\">=0.1.0b3\"}},\"devDependencies\":{\"@types/axios\":\"^0.14.0\",\"@types/fs-extra\":\"^9.0.1\",\"@types/node\":\"^14.0.5\",\"@types/ws\":\"^7.2.4\",\"@typescript-eslint/eslint-plugin\":\"^3.2.0\",\"@typescript-eslint/parser\":\"^3.2.0\",\"eslint\":\"6.8.0\",\"eslint-config-standard\":\"14.1.1\",\"eslint-plugin-import\":\"2.20.2\",\"eslint-plugin-node\":\"11.1.0\",\"eslint-plugin-promise\":\"4.2.1\",\"eslint-plugin-standard\":\"4.0.1\",\"nodemon\":\"^2.0.4\",\"ts-node\":\"^8.10.1\",\"typescript\":\"^3.9.3\"},\"typings\":\"index.d.ts\",\"gitHead\":\"ba6b2b226349d035146bd6deb120fef3d499ed16\"}");

/***/ }),
/* 2839 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GitHandle = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'git',
  displayName: 'Git',
  url: 'ws://127.0.0.1:65521',
  methods: ['execute'],
  description: 'Using Remixd daemon, allow to access git API',
  kind: 'other',
  version: packageJson.version
};

var GitHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  (0, _inherits2["default"])(GitHandle, _WebsocketPlugin);

  var _super = _createSuper(GitHandle);

  function GitHandle() {
    (0, _classCallCheck2["default"])(this, GitHandle);
    return _super.call(this, profile);
  }

  return GitHandle;
}(_engineWeb.WebsocketPlugin);

exports.GitHandle = GitHandle;

/***/ }),
/* 2840 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HardhatHandle = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'hardhat',
  displayName: 'Hardhat',
  url: 'ws://127.0.0.1:65522',
  methods: ['compile'],
  description: 'Using Remixd daemon, allow to access hardhat API',
  kind: 'other',
  version: packageJson.version
};

var HardhatHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  (0, _inherits2["default"])(HardhatHandle, _WebsocketPlugin);

  var _super = _createSuper(HardhatHandle);

  function HardhatHandle() {
    (0, _classCallCheck2["default"])(this, HardhatHandle);
    return _super.call(this, profile);
  }

  return HardhatHandle;
}(_engineWeb.WebsocketPlugin);

exports.HardhatHandle = HardhatHandle;

/***/ }),
/* 2841 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TruffleHandle = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'truffle',
  displayName: 'truffle',
  url: 'ws://127.0.0.1:65524',
  methods: ['compile'],
  description: 'Using Remixd daemon, allow to access truffle API',
  kind: 'other',
  version: packageJson.version
};

var TruffleHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  (0, _inherits2["default"])(TruffleHandle, _WebsocketPlugin);

  var _super = _createSuper(TruffleHandle);

  function TruffleHandle() {
    (0, _classCallCheck2["default"])(this, TruffleHandle);
    return _super.call(this, profile);
  }

  return TruffleHandle;
}(_engineWeb.WebsocketPlugin);

exports.TruffleHandle = TruffleHandle;

/***/ }),
/* 2842 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlitherHandle = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _engineWeb = __webpack_require__(1133);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var profile = {
  name: 'slither',
  displayName: 'Slither',
  url: 'ws://127.0.0.1:65523',
  methods: ['analyse'],
  description: 'Using Remixd daemon, run slither static analysis',
  kind: 'other',
  version: packageJson.version,
  documentation: 'https://remix-ide.readthedocs.io/en/latest/slither.html'
};

var SlitherHandle = /*#__PURE__*/function (_WebsocketPlugin) {
  (0, _inherits2["default"])(SlitherHandle, _WebsocketPlugin);

  var _super = _createSuper(SlitherHandle);

  function SlitherHandle() {
    (0, _classCallCheck2["default"])(this, SlitherHandle);
    return _super.call(this, profile);
  }

  return SlitherHandle;
}(_engineWeb.WebsocketPlugin);

exports.SlitherHandle = SlitherHandle;

/***/ }),
/* 2843 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _path = __webpack_require__(1124);

var _editor = __webpack_require__(2844);

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _helper = __webpack_require__(1121);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var EventManager = __webpack_require__(1196);

var profile = {
  displayName: 'Editor',
  name: 'editor',
  description: 'service - editor',
  version: packageJson.version,
  methods: ['highlight', 'discardHighlight', 'clearAnnotations', 'addAnnotation', 'gotoLine', 'revealRange', 'getCursorPosition']
};

var Editor = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(Editor, _Plugin);

  var _super = _createSuper(Editor);

  function Editor() {
    var _this;

    (0, _classCallCheck2["default"])(this, Editor);
    _this = _super.call(this, profile);
    _this._themes = {
      light: 'light',
      dark: 'vs-dark',
      remixDark: 'remix-dark'
    };
    _this.registeredDecorations = {
      sourceAnnotationsPerFile: {},
      markerPerFile: {}
    };
    _this.currentDecorations = {
      sourceAnnotationsPerFile: {},
      markerPerFile: {}
    }; // Init

    _this.event = new EventManager();
    _this.sessions = {};
    _this.readOnlySessions = {};
    _this.previousInput = '';
    _this.saveTimeout = null;
    _this.emptySession = null;
    _this.modes = {
      sol: 'sol',
      yul: 'sol',
      mvir: 'move',
      js: 'javascript',
      py: 'python',
      vy: 'python',
      zok: 'zokrates',
      lex: 'lexon',
      txt: 'text',
      json: 'json',
      abi: 'json',
      rs: 'rust',
      cairo: 'cairo',
      ts: 'typescript'
    };
    _this.activated = false;
    _this.events = {
      onBreakPointAdded: function onBreakPointAdded(file, line) {
        return _this.triggerEvent('breakpointAdded', [file, line]);
      },
      onBreakPointCleared: function onBreakPointCleared(file, line) {
        return _this.triggerEvent('breakpointCleared', [file, line]);
      },
      onDidChangeContent: function onDidChangeContent(file) {
        return _this._onChange(file);
      },
      onEditorMounted: function onEditorMounted() {
        return _this.triggerEvent('editorMounted', []);
      }
    }; // to be implemented by the react component

    _this.api = {};
    _this.dispatch = null;
    _this.ref = null;
    return _this;
  }

  (0, _createClass2["default"])(Editor, [{
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_editor.EditorUI, {
        editorAPI: state.api,
        themeType: state.currentThemeType,
        currentFile: state.currentFile,
        events: state.events,
        plugin: state.plugin
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      /*     if (this.el) return this.el
      
          this.el = document.createElement('div')
          this.el.setAttribute('id', 'editorView')
          this.el.currentContent = () => this.currentContent() // used by e2e test
          this.el.setCurrentContent = (value) => {
            if (this.sessions[this.currentFile]) {
              this.sessions[this.currentFile].setValue(value)
              this._onChange(this.currentFile)
            }
          }
          this.el.gotoLine = (line, column) => this.gotoLine(line, column || 0)
          this.el.getCursorPosition = () => this.getCursorPosition() */
      return /*#__PURE__*/_react["default"].createElement("div", {
        ref: function ref(element) {
          _this2.ref = element;

          _this2.ref.currentContent = function () {
            return _this2.currentContent();
          }; // used by e2e test


          _this2.ref.setCurrentContent = function (value) {
            if (_this2.sessions[_this2.currentFile]) {
              _this2.sessions[_this2.currentFile].setValue(value);

              _this2._onChange(_this2.currentFile);
            }
          };

          _this2.ref.gotoLine = function (line, column) {
            return _this2.gotoLine(line, column || 0);
          };

          _this2.ref.getCursorPosition = function () {
            return _this2.getCursorPosition();
          };

          _this2.ref.addDecoration = function (marker, filePath, typeOfDecoration) {
            return _this2.addDecoration(marker, filePath, typeOfDecoration);
          };

          _this2.ref.clearDecorationsByPlugin = function (filePath, plugin, typeOfDecoration) {
            return _this2.clearDecorationsByPlugin(filePath, plugin, typeOfDecoration);
          };

          _this2.ref.keepDecorationsFor = function (name, typeOfDecoration) {
            return _this2.keepDecorationsFor(name, typeOfDecoration);
          };
        },
        id: "editorView"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      this.dispatch({
        api: this.api,
        currentThemeType: this.currentThemeType,
        currentFile: this.currentFile,
        events: this.events,
        plugin: this
      });
    }
  }, {
    key: "triggerEvent",
    value: function triggerEvent(name, params) {
      this.event.trigger(name, params); // internal stack

      this.emit.apply(this, [name].concat((0, _toConsumableArray2["default"])(params))); // plugin stack
    }
  }, {
    key: "onActivation",
    value: function () {
      var _onActivation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        var _this3 = this;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.activated = true;
                this.on('sidePanel', 'focusChanged', function (name) {
                  _this3.keepDecorationsFor(name, 'sourceAnnotationsPerFile');

                  _this3.keepDecorationsFor(name, 'markerPerFile');
                });
                this.on('sidePanel', 'pluginDisabled', function (name) {
                  _this3.clearAllDecorationsFor(name);
                });
                this.on('theme', 'themeLoaded', function (theme) {
                  _this3.currentThemeType = theme.quality;

                  _this3.renderComponent();
                });
                this.on('fileManager', 'currentFileChanged', /*#__PURE__*/function () {
                  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(name) {
                    var content, paths, fromPath, _iterator, _step, match, path;

                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!name.endsWith('.ts')) {
                              _context.next = 33;
                              break;
                            }

                            _context.next = 3;
                            return _this3.call('fileManager', 'readFile', name);

                          case 3:
                            content = _context.sent;
                            paths = name.split('/');
                            paths.pop();
                            fromPath = paths.join('/'); // get current execution context path

                            _iterator = _createForOfIteratorHelper(content.matchAll(/import\s+.*\s+from\s+(?:"(.*?)"|'(.*?)')/g));
                            _context.prev = 8;

                            _iterator.s();

                          case 10:
                            if ((_step = _iterator.n()).done) {
                              _context.next = 25;
                              break;
                            }

                            match = _step.value;
                            path = match[2];
                            if (path.startsWith('./') || path.startsWith('../')) path = (0, _path.resolve)(fromPath, path);
                            if (path.startsWith('/')) path = path.substring(1);
                            if (!path.endsWith('.ts')) path = path + '.ts';
                            _context.next = 18;
                            return _this3.call('fileManager', 'exists', path);

                          case 18:
                            if (!_context.sent) {
                              _context.next = 23;
                              break;
                            }

                            _context.next = 21;
                            return _this3.call('fileManager', 'readFile', path);

                          case 21:
                            content = _context.sent;

                            _this3.emit('addModel', content, 'typescript', path, false);

                          case 23:
                            _context.next = 10;
                            break;

                          case 25:
                            _context.next = 30;
                            break;

                          case 27:
                            _context.prev = 27;
                            _context.t0 = _context["catch"](8);

                            _iterator.e(_context.t0);

                          case 30:
                            _context.prev = 30;

                            _iterator.f();

                            return _context.finish(30);

                          case 33:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, null, [[8, 27, 30, 33]]);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }());
                this.on('fileManager', 'noFileSelected', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
                  return _regenerator["default"].wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _this3.currentFile = null;

                          _this3.renderComponent();

                        case 2:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })));
                this.on('fileManager', 'currentFileChanged', /*#__PURE__*/function () {
                  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(name) {
                    var content, paths, fromPath, _iterator2, _step2, match, path;

                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (!name.endsWith('.ts')) {
                              _context3.next = 33;
                              break;
                            }

                            _context3.next = 3;
                            return _this3.call('fileManager', 'readFile', name);

                          case 3:
                            content = _context3.sent;
                            paths = name.split('/');
                            paths.pop();
                            fromPath = paths.join('/'); // get current execution context path

                            _iterator2 = _createForOfIteratorHelper(content.matchAll(/import\s+.*\s+from\s+(?:"(.*?)"|'(.*?)')/g));
                            _context3.prev = 8;

                            _iterator2.s();

                          case 10:
                            if ((_step2 = _iterator2.n()).done) {
                              _context3.next = 25;
                              break;
                            }

                            match = _step2.value;
                            path = match[2];
                            if (path.startsWith('./') || path.startsWith('../')) path = (0, _path.resolve)(fromPath, path);
                            if (path.startsWith('/')) path = path.substring(1);
                            if (!path.endsWith('.ts')) path = path + '.ts';
                            _context3.next = 18;
                            return _this3.call('fileManager', 'exists', path);

                          case 18:
                            if (!_context3.sent) {
                              _context3.next = 23;
                              break;
                            }

                            _context3.next = 21;
                            return _this3.call('fileManager', 'readFile', path);

                          case 21:
                            content = _context3.sent;

                            _this3.emit('addModel', content, 'typescript', path, false);

                          case 23:
                            _context3.next = 10;
                            break;

                          case 25:
                            _context3.next = 30;
                            break;

                          case 27:
                            _context3.prev = 27;
                            _context3.t0 = _context3["catch"](8);

                            _iterator2.e(_context3.t0);

                          case 30:
                            _context3.prev = 30;

                            _iterator2.f();

                            return _context3.finish(30);

                          case 33:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3, null, [[8, 27, 30, 33]]);
                  }));

                  return function (_x2) {
                    return _ref3.apply(this, arguments);
                  };
                }());
                this.on('fileManager', 'noFileSelected', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
                  return _regenerator["default"].wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _this3.currentFile = null;

                          _this3.renderComponent();

                        case 2:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                })));
                _context5.prev = 8;
                _context5.next = 11;
                return this.call('theme', 'currentTheme');

              case 11:
                this.currentThemeType = _context5.sent.quality;
                _context5.next = 17;
                break;

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](8);
                console.log('unable to select the theme ' + _context5.t0.message);

              case 17:
                this.renderComponent();

              case 18:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[8, 14]]);
      }));

      function onActivation() {
        return _onActivation.apply(this, arguments);
      }

      return onActivation;
    }()
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      this.off('sidePanel', 'focusChanged');
      this.off('sidePanel', 'pluginDisabled');
    }
  }, {
    key: "_onChange",
    value: function () {
      var _onChange2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(file) {
        var _this4 = this;

        var currentFile, input;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.call('fileManager', 'file');

              case 2:
                currentFile = _context6.sent;

                if (currentFile) {
                  _context6.next = 5;
                  break;
                }

                return _context6.abrupt("return");

              case 5:
                if (!(currentFile !== file)) {
                  _context6.next = 7;
                  break;
                }

                return _context6.abrupt("return");

              case 7:
                input = this.get(currentFile);

                if (input) {
                  _context6.next = 10;
                  break;
                }

                return _context6.abrupt("return");

              case 10:
                if (!(input === this.previousInput)) {
                  _context6.next = 12;
                  break;
                }

                return _context6.abrupt("return");

              case 12:
                this.previousInput = input; // fire storage update
                // NOTE: save at most once per 5 seconds

                if (this.saveTimeout) {
                  window.clearTimeout(this.saveTimeout);
                }

                this.saveTimeout = window.setTimeout(function () {
                  _this4.triggerEvent('contentChanged', []);

                  _this4.triggerEvent('requiringToSaveCurrentfile', []);
                }, 500);

              case 15:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _onChange(_x3) {
        return _onChange2.apply(this, arguments);
      }

      return _onChange;
    }()
  }, {
    key: "_switchSession",
    value: function _switchSession(path) {
      if (path === this.currentFile) return;
      this.triggerEvent('sessionSwitched', []);
      this.currentFile = path;
      this.renderComponent();
    }
    /**
     * Get Ace mode base of the extension of the session file
     * @param {string} path Path of the file
     */

  }, {
    key: "_getMode",
    value: function _getMode(path) {
      if (!path) return this.modes.txt;
      var root = path.split('#')[0].split('?')[0];
      var ext = root.indexOf('.') !== -1 ? /[^.]+$/.exec(root) : null;
      if (ext) ext = ext[0];else ext = 'txt';
      return ext && this.modes[ext] ? this.modes[ext] : this.modes.txt;
    }
    /**
     * Create an editor session
     * @param {string} path path of the file
     * @param {string} content Content of the file to open
     * @param {string} mode Mode for this file [Default is `text`]
     */

  }, {
    key: "_createSession",
    value: function _createSession(path, content, mode) {
      var _this5 = this;

      if (!this.activated) return;
      this.emit('addModel', content, mode, path, false);
      return {
        path: path,
        language: mode,
        setValue: function setValue(content) {
          _this5.emit('setValue', path, content);
        },
        getValue: function getValue() {
          return _this5.api.getValue(path, content);
        },
        dispose: function dispose() {
          _this5.emit('disposeModel', path);
        }
      };
    }
    /**
     * Attempts to find the string in the current document
     * @param {string} string
     */

  }, {
    key: "find",
    value: function find(string) {
      return this.api.findMatches(this.currentFile, string);
    }
    /**
     * Display an Empty read-only session
     */

  }, {
    key: "displayEmptyReadOnlySession",
    value: function displayEmptyReadOnlySession() {
      if (!this.activated) return;
      this.currentFile = null;
      this.emit('addModel', '', 'text', '_blank', true);
    }
    /**
     * Set the text in the current session, if any.
     * @param {string} text New text to be place.
     */

  }, {
    key: "setText",
    value: function setText(text) {
      if (this.currentFile && this.sessions[this.currentFile]) {
        this.sessions[this.currentFile].setValue(text);
      }
    }
    /**
     * Upsert and open a session.
     * @param {string} path Path of the session to open.
     * @param {string} content Content of the document or update.
     */

  }, {
    key: "open",
    value: function open(path, content) {
      /*
        we have the following cases:
         - URL prepended with "localhost"
         - URL prepended with "browser"
         - URL not prepended with the file explorer. We assume (as it is in the whole app, that this is a "browser" URL
      */
      if (!this.sessions[path]) {
        var session = this._createSession(path, content, this._getMode(path));

        this.sessions[path] = session;
        this.readOnlySessions[path] = false;
      } else if (this.sessions[path].getValue() !== content) {
        this.sessions[path].setValue(content);
      }

      this._switchSession(path);
    }
    /**
     * Upsert and Open a session and set it as Read-only.
     * @param {string} path Path of the session to open.
     * @param {string} content Content of the document or update.
     */

  }, {
    key: "openReadOnly",
    value: function openReadOnly(path, content) {
      if (!this.sessions[path]) {
        var session = this._createSession(path, content, this._getMode(path));

        this.sessions[path] = session;
        this.readOnlySessions[path] = true;
      }

      this._switchSession(path);
    }
    /**
     * Content of the current session
     * @return {String} content of the file referenced by @arg path
     */

  }, {
    key: "currentContent",
    value: function currentContent() {
      return this.get(this.current());
    }
    /**
     * Content of the session targeted by @arg path
     * if @arg path is null, the content of the current session is returned
     * @param {string} path Path of the session to get.
     * @return {String} content of the file referenced by @arg path
     */

  }, {
    key: "get",
    value: function get(path) {
      if (!path || this.currentFile === path) {
        return this.api.getValue(path);
      } else if (this.sessions[path]) {
        return this.sessions[path].getValue();
      }
    }
    /**
     * Path of the currently editing file
     * returns `undefined` if no session is being editer
     * @return {String} path of the current session
     */

  }, {
    key: "current",
    value: function current() {
      return this.currentFile;
    }
    /**
     * The position of the cursor
     */

  }, {
    key: "getCursorPosition",
    value: function getCursorPosition() {
      return this.api.getCursorPosition();
    }
    /**
     * Remove the current session from the list of sessions.
     */

  }, {
    key: "discardCurrentSession",
    value: function discardCurrentSession() {
      if (this.sessions[this.currentFile]) {
        delete this.sessions[this.currentFile];
        this.currentFile = null;
      }
    }
    /**
     * Remove a session based on its path.
     * @param {string} path
     */

  }, {
    key: "discard",
    value: function discard(path) {
      if (this.sessions[path]) {
        this.sessions[path].dispose();
        delete this.sessions[path];
      }

      if (this.currentFile === path) this.currentFile = null;
    }
    /**
     * Increment the font size (in pixels) for the editor text.
     * @param {number} incr The amount of pixels to add to the font.
     */

  }, {
    key: "editorFontSize",
    value: function editorFontSize(incr) {
      if (!this.activated) return;
      var newSize = this.api.getFontSize() + incr;

      if (newSize >= 6) {
        this.emit('setFontSize', newSize);
      }
    }
    /**
     * Resize the editor, and sets whether or not line wrapping is enabled.
     * @param {boolean} useWrapMode Enable (or disable) wrap mode
     */

  }, {
    key: "resize",
    value: function resize(useWrapMode) {
      if (!this.activated) return;
      this.emit('setWordWrap', useWrapMode);
    }
    /**
     * Moves the cursor and focus to the specified line and column number
     * @param {number} line
     * @param {number} col
     */

  }, {
    key: "gotoLine",
    value: function gotoLine(line, col) {
      if (!this.activated) return;
      this.emit('focus');
      this.emit('revealLine', line + 1, col);
    }
    /**
     * Reveals the range in the editor.
     * @param {number} startLineNumber
     * @param {number} startColumn
     * @param {number} endLineNumber
     * @param {number} endColumn
     */

  }, {
    key: "revealRange",
    value: function revealRange(startLineNumber, startColumn, endLineNumber, endColumn) {
      if (!this.activated) return;
      this.emit('focus');
      console.log(startLineNumber, startColumn, endLineNumber, endColumn);
      this.emit('revealRange', startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * Scrolls to a line. If center is true, it puts the line in middle of screen (or attempts to).
     * @param {number} line The line to scroll to
     */

  }, {
    key: "scrollToLine",
    value: function scrollToLine(line) {
      if (!this.activated) return;
      this.emit('revealLine', line + 1, 0);
    }
    /**
     * Clears all the decorations for the given @arg filePath and @arg plugin, if none is given, the current sesssion is used.
     * An annotation has the following shape:
        column: -1
        row: -1
        text: "browser/Untitled1.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.↵"
        type: "warning"
     * @param {String} filePath
     * @param {String} plugin
     * @param {String} typeOfDecoration
     */

  }, {
    key: "clearDecorationsByPlugin",
    value: function clearDecorationsByPlugin(filePath, plugin, typeOfDecoration) {
      if (filePath && !this.sessions[filePath]) throw new Error('file not found' + filePath);
      var path = filePath || this.currentFile;

      var _this$api$clearDecora = this.api.clearDecorationsByPlugin(path, plugin, typeOfDecoration, this.registeredDecorations[typeOfDecoration][filePath] || [], this.currentDecorations[typeOfDecoration][filePath] || []),
          currentDecorations = _this$api$clearDecora.currentDecorations,
          registeredDecorations = _this$api$clearDecora.registeredDecorations;

      this.currentDecorations[typeOfDecoration][filePath] = currentDecorations;
      this.registeredDecorations[typeOfDecoration][filePath] = registeredDecorations;
    }
  }, {
    key: "keepDecorationsFor",
    value: function keepDecorationsFor(plugin, typeOfDecoration) {
      if (!this.currentFile) return;

      var _this$api$keepDecorat = this.api.keepDecorationsFor(this.currentFile, plugin, typeOfDecoration, this.registeredDecorations[typeOfDecoration][this.currentFile] || [], this.currentDecorations[typeOfDecoration][this.currentFile] || []),
          currentDecorations = _this$api$keepDecorat.currentDecorations;

      this.currentDecorations[typeOfDecoration][this.currentFile] = currentDecorations;
    }
    /**
     * Clears all the decorations and for all the sessions for the given @arg plugin
     * An annotation has the following shape:
        column: -1
        row: -1
        text: "browser/Untitled1.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.↵"
        type: "warning"
     * @param {String} filePath
     */

  }, {
    key: "clearAllDecorationsFor",
    value: function clearAllDecorationsFor(plugin) {
      for (var session in this.sessions) {
        this.clearDecorationsByPlugin(session, plugin, 'sourceAnnotationsPerFile');
        this.clearDecorationsByPlugin(session, plugin, 'markerPerFile');
      }
    }
    /**
     * Clears all the annotations for the given @arg filePath, the plugin name is retrieved from the context, if none is given, the current sesssion is used.
     * An annotation has the following shape:
        column: -1
        row: -1
        text: "browser/Untitled1.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.↵"
        type: "warning"
     * @param {String} filePath
     * @param {String} plugin
     */

  }, {
    key: "clearAnnotations",
    value: function clearAnnotations(filePath) {
      filePath = filePath || this.currentFile;
      var from = this.currentRequest.from;
      this.clearDecorationsByPlugin(filePath, from, 'sourceAnnotationsPerFile');
    }
  }, {
    key: "addDecoration",
    value: function () {
      var _addDecoration = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(decoration, filePath, typeOfDecoration) {
        var _this$registeredDecor, _this$currentDecorati;

        var path, from, _this$api$addDecorati, currentDecorations, registeredDecorations;

        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (filePath) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return");

              case 2:
                _context7.next = 4;
                return this.call('fileManager', 'getPathFromUrl', filePath);

              case 4:
                filePath = _context7.sent;
                filePath = filePath.file;

                if (this.sessions[filePath]) {
                  _context7.next = 8;
                  break;
                }

                return _context7.abrupt("return");

              case 8:
                path = filePath || this.currentFile;
                from = this.currentRequest.from;
                decoration.from = from;
                _this$api$addDecorati = this.api.addDecoration(decoration, path, typeOfDecoration), currentDecorations = _this$api$addDecorati.currentDecorations, registeredDecorations = _this$api$addDecorati.registeredDecorations;
                if (!this.registeredDecorations[typeOfDecoration][filePath]) this.registeredDecorations[typeOfDecoration][filePath] = [];

                (_this$registeredDecor = this.registeredDecorations[typeOfDecoration][filePath]).push.apply(_this$registeredDecor, (0, _toConsumableArray2["default"])(registeredDecorations));

                if (!this.currentDecorations[typeOfDecoration][filePath]) this.currentDecorations[typeOfDecoration][filePath] = [];

                (_this$currentDecorati = this.currentDecorations[typeOfDecoration][filePath]).push.apply(_this$currentDecorati, (0, _toConsumableArray2["default"])(currentDecorations));

              case 16:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function addDecoration(_x4, _x5, _x6) {
        return _addDecoration.apply(this, arguments);
      }

      return addDecoration;
    }()
    /**
     * Add an annotation to the current session.
     * An annotation has the following shape:
        column: -1
        row: -1
        text: "browser/Untitled1.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.↵"
        type: "warning"
     * @param {Object} annotation
     * @param {String} filePath
     */

  }, {
    key: "addAnnotation",
    value: function () {
      var _addAnnotation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(annotation, filePath) {
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                filePath = filePath || this.currentFile;
                _context8.next = 3;
                return this.addDecoration(annotation, filePath, 'sourceAnnotationsPerFile');

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function addAnnotation(_x7, _x8) {
        return _addAnnotation.apply(this, arguments);
      }

      return addAnnotation;
    }()
  }, {
    key: "highlight",
    value: function () {
      var _highlight = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(position, filePath, highlightColor) {
        var opt,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                opt = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : {
                  focus: true
                };
                filePath = filePath || this.currentFile;

                if (!opt.focus) {
                  _context9.next = 6;
                  break;
                }

                _context9.next = 5;
                return this.call('fileManager', 'open', filePath);

              case 5:
                this.scrollToLine(position.start.line);

              case 6:
                _context9.next = 8;
                return this.addDecoration({
                  position: position
                }, filePath, 'markerPerFile');

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function highlight(_x9, _x10, _x11) {
        return _highlight.apply(this, arguments);
      }

      return highlight;
    }()
  }, {
    key: "discardHighlight",
    value: function discardHighlight() {
      var from = this.currentRequest.from;

      for (var session in this.sessions) {
        this.clearDecorationsByPlugin(session, from, 'markerPerFile', this.registeredDecorations, this.currentDecorations);
      }
    }
  }]);
  return Editor;
}(_engine.Plugin);

module.exports = Editor;

/***/ }),
/* 2844 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiEditor = __webpack_require__(2845);

Object.keys(_remixUiEditor).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiEditor[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiEditor[key];
    }
  });
});

/***/ }),
/* 2845 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EditorUI = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _editorContextView = __webpack_require__(2846);

var _react2 = _interopRequireWildcard(__webpack_require__(2944));

var _editor = __webpack_require__(2850);

var _syntax = __webpack_require__(2851);

var _cairoSyntax = __webpack_require__(2852);

__webpack_require__(2853);

var _webTypes = __webpack_require__(2855);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
_react2.loader.config({
  paths: {
    vs: 'assets/js/monaco-editor/dev/vs'
  }
});

const EditorUI = props => {
  const [, setCurrentBreakpoints] = (0, _react.useState)({});
  const defaultEditorValue = `
  \t\t\t\t\t\t\t ____    _____   __  __   ___  __  __   ___   ____    _____ 
  \t\t\t\t\t\t\t|  _ \\  | ____| |  \\/  | |_ _| \\ \\/ /  |_ _| |  _ \\  | ____|
  \t\t\t\t\t\t\t| |_) | |  _|   | |\\/| |  | |   \\  /    | |  | | | | |  _|  
  \t\t\t\t\t\t\t|  _ <  | |___  | |  | |  | |   /  \\    | |  | |_| | | |___ 
  \t\t\t\t\t\t\t|_| \\_\\ |_____| |_|  |_| |___| /_/\\_\\  |___| |____/  |_____|\n\n
  \t\t\t\t\t\t\tKeyboard Shortcuts:\n
  \t\t\t\t\t\t\t\tCTRL + S: Compile the current contract\n
  \t\t\t\t\t\t\t\tCtrl + Shift + F : Open the File Explorer\n
  \t\t\t\t\t\t\t\tCtrl + Shift + A : Open the Plugin Manager\n
  \t\t\t\t\t\t\t\tCTRL + SHIFT + S: Compile the current contract & Run an associated script\n\n
  \t\t\t\t\t\t\tImportant Links:\n
  \t\t\t\t\t\t\t\tOfficial website about the Remix Project: https://remix-project.org/\n
  \t\t\t\t\t\t\t\tOfficial documentation: https://remix-ide.readthedocs.io/en/latest/\n
  \t\t\t\t\t\t\t\tGithub: https://github.com/ethereum/remix-project\n
  \t\t\t\t\t\t\t\tGitter: https://gitter.im/ethereum/remix\n
  \t\t\t\t\t\t\t\tMedium: https://medium.com/remix-ide\n
  \t\t\t\t\t\t\t\tTwitter: https://twitter.com/ethereumremix\n
  `;
  const editorRef = (0, _react.useRef)(null);
  const monacoRef = (0, _react.useRef)(null);
  const currentFileRef = (0, _react.useRef)(''); // const currentDecorations = useRef({ sourceAnnotationsPerFile: {}, markerPerFile: {} }) // decorations that are currently in use by the editor
  // const registeredDecorations = useRef({}) // registered decorations

  const [editorModelsState, dispatch] = (0, _react.useReducer)(_editor.reducerActions, _editor.initialState);

  const formatColor = name => {
    let color = window.getComputedStyle(document.documentElement).getPropertyValue(name).trim();

    if (color.length === 4) {
      color = color.concat(color.substr(1));
    }

    return color;
  };

  const defineAndSetTheme = monaco => {
    const themeType = props.themeType === 'dark' ? 'vs-dark' : 'vs';
    const themeName = props.themeType === 'dark' ? 'remix-dark' : 'remix-light'; // see https://microsoft.github.io/monaco-editor/playground.html#customizing-the-appearence-exposed-colors

    const lightColor = formatColor('--light');
    const infoColor = formatColor('--info');
    const darkColor = formatColor('--dark');
    const secondaryColor = formatColor('--secondary');
    const textColor = formatColor('--text') || darkColor;
    const textbackground = formatColor('--text-background') || lightColor;
    const blueColor = formatColor('--blue');
    const successColor = formatColor('--success');
    const warningColor = formatColor('--warning');
    const yellowColor = formatColor('--yellow');
    const pinkColor = formatColor('--pink');
    const locationColor = '#9e7e08'; // const purpleColor = formatColor('--purple')

    const dangerColor = formatColor('--danger');
    const greenColor = formatColor('--green');
    const orangeColor = formatColor('--orange');
    const grayColor = formatColor('--gray');
    monaco.editor.defineTheme(themeName, {
      base: themeType,
      inherit: true,
      // can also be false to completely replace the builtin rules
      rules: [{
        background: darkColor.replace('#', '')
      }, {
        foreground: textColor.replace('#', '')
      }, // global variables
      {
        token: 'keyword.abi',
        foreground: blueColor
      }, {
        token: 'keyword.block',
        foreground: blueColor
      }, {
        token: 'keyword.bytes',
        foreground: blueColor
      }, {
        token: 'keyword.msg',
        foreground: blueColor
      }, {
        token: 'keyword.tx',
        foreground: blueColor
      }, // global functions
      {
        token: 'keyword.assert',
        foreground: blueColor
      }, {
        token: 'keyword.require',
        foreground: blueColor
      }, {
        token: 'keyword.revert',
        foreground: blueColor
      }, {
        token: 'keyword.blockhash',
        foreground: blueColor
      }, {
        token: 'keyword.keccak256',
        foreground: blueColor
      }, {
        token: 'keyword.sha256',
        foreground: blueColor
      }, {
        token: 'keyword.ripemd160',
        foreground: blueColor
      }, {
        token: 'keyword.ecrecover',
        foreground: blueColor
      }, {
        token: 'keyword.addmod',
        foreground: blueColor
      }, {
        token: 'keyword.mulmod',
        foreground: blueColor
      }, {
        token: 'keyword.selfdestruct',
        foreground: blueColor
      }, {
        token: 'keyword.type ',
        foreground: blueColor
      }, {
        token: 'keyword.gasleft',
        foreground: blueColor
      }, // specials
      {
        token: 'keyword.super',
        foreground: infoColor
      }, {
        token: 'keyword.this',
        foreground: infoColor
      }, {
        token: 'keyword.virtual',
        foreground: infoColor
      }, // for state variables
      {
        token: 'keyword.constants',
        foreground: grayColor
      }, {
        token: 'keyword.override',
        foreground: grayColor
      }, {
        token: 'keyword.immutable',
        foreground: grayColor
      }, // data location
      {
        token: 'keyword.memory',
        foreground: locationColor
      }, {
        token: 'keyword.storage',
        foreground: locationColor
      }, {
        token: 'keyword.calldata',
        foreground: locationColor
      }, // for Events
      {
        token: 'keyword.indexed',
        foreground: yellowColor
      }, {
        token: 'keyword.anonymous',
        foreground: yellowColor
      }, // for functions
      {
        token: 'keyword.external',
        foreground: successColor
      }, {
        token: 'keyword.internal',
        foreground: successColor
      }, {
        token: 'keyword.private',
        foreground: successColor
      }, {
        token: 'keyword.public',
        foreground: successColor
      }, {
        token: 'keyword.view',
        foreground: successColor
      }, {
        token: 'keyword.pure',
        foreground: successColor
      }, {
        token: 'keyword.payable',
        foreground: successColor
      }, {
        token: 'keyword.nonpayable',
        foreground: successColor
      }, // Errors
      {
        token: 'keyword.Error',
        foreground: dangerColor
      }, {
        token: 'keyword.Panic',
        foreground: dangerColor
      }, // special functions
      {
        token: 'keyword.fallback',
        foreground: pinkColor
      }, {
        token: 'keyword.receive',
        foreground: pinkColor
      }, {
        token: 'keyword.constructor',
        foreground: pinkColor
      }, // identifiers
      {
        token: 'keyword.identifier',
        foreground: warningColor
      }, {
        token: 'keyword.for',
        foreground: warningColor
      }, {
        token: 'keyword.break',
        foreground: warningColor
      }, {
        token: 'keyword.continue',
        foreground: warningColor
      }, {
        token: 'keyword.while',
        foreground: warningColor
      }, {
        token: 'keyword.do',
        foreground: warningColor
      }, {
        token: 'keyword.if',
        foreground: yellowColor
      }, {
        token: 'keyword.else',
        foreground: yellowColor
      }, {
        token: 'keyword.throw',
        foreground: orangeColor
      }, {
        token: 'keyword.catch',
        foreground: orangeColor
      }, {
        token: 'keyword.try',
        foreground: orangeColor
      }, // returns
      {
        token: 'keyword.returns',
        foreground: greenColor
      }, {
        token: 'keyword.return',
        foreground: greenColor
      }],
      colors: {
        // see https://code.visualstudio.com/api/references/theme-color for more settings
        'editor.background': textbackground,
        'editorSuggestWidget.background': lightColor,
        'editorSuggestWidget.selectedBackground': lightColor,
        'editorSuggestWidget.highlightForeground': infoColor,
        'editor.lineHighlightBorder': secondaryColor,
        'editor.lineHighlightBackground': textbackground === darkColor ? lightColor : secondaryColor,
        'editorGutter.background': lightColor,
        //'editor.selectionHighlightBackground': secondaryColor,
        'minimap.background': lightColor,
        'menu.foreground': textColor,
        'menu.background': textbackground,
        'menu.selectionBackground': secondaryColor,
        'menu.selectionForeground': textColor,
        'menu.selectionBorder': secondaryColor
      }
    });
    monacoRef.current.editor.setTheme(themeName);
  };

  (0, _react.useEffect)(() => {
    if (!monacoRef.current) return;
    defineAndSetTheme(monacoRef.current);
  });
  (0, _react.useEffect)(() => {
    if (!editorRef.current || !props.currentFile) return;
    currentFileRef.current = props.currentFile;
    const file = editorModelsState[props.currentFile];
    editorRef.current.setModel(file.model);
    editorRef.current.updateOptions({
      readOnly: editorModelsState[props.currentFile].readOnly
    });

    if (file.language === 'sol') {
      monacoRef.current.editor.setModelLanguage(file.model, 'remix-solidity');
    } else if (file.language === 'cairo') {
      monacoRef.current.editor.setModelLanguage(file.model, 'remix-cairo');
    }
  }, [props.currentFile]);

  const convertToMonacoDecoration = (decoration, typeOfDecoration) => {
    if (typeOfDecoration === 'sourceAnnotationsPerFile') {
      decoration = decoration;
      return {
        type: typeOfDecoration,
        range: new monacoRef.current.Range(decoration.row + 1, 1, decoration.row + 1, 1),
        options: {
          isWholeLine: false,
          glyphMarginHoverMessage: {
            value: (decoration.from ? `from ${decoration.from}:\n` : '') + decoration.text
          },
          glyphMarginClassName: `fal fa-exclamation-square text-${decoration.type === 'error' ? 'danger' : decoration.type === 'warning' ? 'warning' : 'info'}`
        }
      };
    }

    if (typeOfDecoration === 'markerPerFile') {
      decoration = decoration;
      let isWholeLine = false;

      if (decoration.position.start.line === decoration.position.end.line && decoration.position.end.column - decoration.position.start.column < 2 || decoration.position.start.line !== decoration.position.end.line) {
        // in this case we force highlighting the whole line (doesn't make sense to highlight 2 chars)
        isWholeLine = true;
      }

      return {
        type: typeOfDecoration,
        range: new monacoRef.current.Range(decoration.position.start.line + 1, decoration.position.start.column + 1, decoration.position.end.line + 1, decoration.position.end.column + 1),
        options: {
          isWholeLine,
          inlineClassName: `${isWholeLine ? 'alert-info' : 'inline-class'}  border-0 highlightLine${decoration.position.start.line + 1}`
        }
      };
    }
  };

  props.editorAPI.clearDecorationsByPlugin = (filePath, plugin, typeOfDecoration, registeredDecorations, currentDecorations) => {
    var _editorModelsState$fi;

    const model = (_editorModelsState$fi = editorModelsState[filePath]) === null || _editorModelsState$fi === void 0 ? void 0 : _editorModelsState$fi.model;
    if (!model) return {
      currentDecorations: [],
      registeredDecorations: []
    };
    const decorations = [];
    const newRegisteredDecorations = [];

    if (registeredDecorations) {
      for (const decoration of registeredDecorations) {
        if (decoration.type === typeOfDecoration && decoration.value.from !== plugin) {
          decorations.push(convertToMonacoDecoration(decoration.value, typeOfDecoration));
          newRegisteredDecorations.push(decoration);
        }
      }
    }

    return {
      currentDecorations: model.deltaDecorations(currentDecorations, decorations),
      registeredDecorations: newRegisteredDecorations
    };
  };

  props.editorAPI.keepDecorationsFor = (filePath, plugin, typeOfDecoration, registeredDecorations, currentDecorations) => {
    var _editorModelsState$fi2;

    const model = (_editorModelsState$fi2 = editorModelsState[filePath]) === null || _editorModelsState$fi2 === void 0 ? void 0 : _editorModelsState$fi2.model;
    if (!model) return {
      currentDecorations: []
    };
    const decorations = [];

    if (registeredDecorations) {
      for (const decoration of registeredDecorations) {
        if (decoration.value.from === plugin) {
          decorations.push(convertToMonacoDecoration(decoration.value, typeOfDecoration));
        }
      }
    }

    return {
      currentDecorations: model.deltaDecorations(currentDecorations, decorations)
    };
  };

  const addDecoration = (decoration, filePath, typeOfDecoration) => {
    var _editorModelsState$fi3;

    const model = (_editorModelsState$fi3 = editorModelsState[filePath]) === null || _editorModelsState$fi3 === void 0 ? void 0 : _editorModelsState$fi3.model;
    if (!model) return {
      currentDecorations: []
    };
    const monacoDecoration = convertToMonacoDecoration(decoration, typeOfDecoration);
    return {
      currentDecorations: model.deltaDecorations([], [monacoDecoration]),
      registeredDecorations: [{
        value: decoration,
        type: typeOfDecoration
      }]
    };
  };

  props.editorAPI.addDecoration = (marker, filePath, typeOfDecoration) => {
    return addDecoration(marker, filePath, typeOfDecoration);
  };

  props.editorAPI.findMatches = (uri, value) => {
    var _editorModelsState$ur;

    if (!editorRef.current) return;
    const model = (_editorModelsState$ur = editorModelsState[uri]) === null || _editorModelsState$ur === void 0 ? void 0 : _editorModelsState$ur.model;
    if (model) return model.findMatches(value);
  };

  props.editorAPI.getValue = uri => {
    var _editorModelsState$ur2;

    if (!editorRef.current) return;
    const model = (_editorModelsState$ur2 = editorModelsState[uri]) === null || _editorModelsState$ur2 === void 0 ? void 0 : _editorModelsState$ur2.model;

    if (model) {
      return model.getValue();
    }
  };

  props.editorAPI.getCursorPosition = () => {
    var _editorModelsState$cu;

    if (!monacoRef.current) return;
    const model = (_editorModelsState$cu = editorModelsState[currentFileRef.current]) === null || _editorModelsState$cu === void 0 ? void 0 : _editorModelsState$cu.model;

    if (model) {
      return model.getOffsetAt(editorRef.current.getPosition());
    }
  };

  props.editorAPI.getFontSize = () => {
    if (!editorRef.current) return;
    return editorRef.current.getOption(43).fontSize;
  };

  window.addRemixBreakpoint = position => {
    // make it available from e2e testing...
    const model = editorRef.current.getModel();

    if (model) {
      setCurrentBreakpoints(prevState => {
        const currentFile = currentFileRef.current;
        if (!prevState[currentFile]) prevState[currentFile] = {};
        const decoration = Object.keys(prevState[currentFile]).filter(line => parseInt(line) === position.lineNumber);

        if (decoration.length) {
          props.events.onBreakPointCleared(currentFile, position.lineNumber);
          model.deltaDecorations([prevState[currentFile][position.lineNumber]], []);
          delete prevState[currentFile][position.lineNumber];
        } else {
          props.events.onBreakPointAdded(currentFile, position.lineNumber);
          const decorationIds = model.deltaDecorations([], [{
            range: new monacoRef.current.Range(position.lineNumber, 1, position.lineNumber, 1),
            options: {
              isWholeLine: false,
              glyphMarginClassName: 'fas fa-circle text-info'
            }
          }]);
          prevState[currentFile][position.lineNumber] = decorationIds[0];
        }

        return prevState;
      });
    }
  };

  function handleEditorDidMount(editor) {
    editorRef.current = editor;
    defineAndSetTheme(monacoRef.current);
    (0, _editor.reducerListener)(props.plugin, dispatch, monacoRef.current, editorRef.current, props.events);
    props.events.onEditorMounted();
    editor.onMouseUp(e => {
      if (e && e.target && e.target.toString().startsWith('GUTTER')) {
        window.addRemixBreakpoint(e.target.position);
      }
    });
    editor.addCommand(monacoRef.current.KeyMod.CtrlCmd | monacoRef.current.KeyCode.US_EQUAL, () => {
      editor.updateOptions({
        fontSize: editor.getOption(43).fontSize + 1
      });
    });
    editor.addCommand(monacoRef.current.KeyMod.CtrlCmd | monacoRef.current.KeyCode.US_MINUS, () => {
      editor.updateOptions({
        fontSize: editor.getOption(43).fontSize - 1
      });
    });
    const editorService = editor._codeEditorService;
    const openEditorBase = editorService.openCodeEditor.bind(editorService);

    editorService.openCodeEditor = async (input, source) => {
      const result = await openEditorBase(input, source);

      if (input && input.resource && input.resource.path) {
        try {
          await props.plugin.call('fileManager', 'open', input.resource.path);
        } catch (e) {
          console.log(e);
        }
      }

      return result;
    };
  }

  function handleEditorWillMount(monaco) {
    monacoRef.current = monaco; // Register a new language

    monacoRef.current.languages.register({
      id: 'remix-solidity'
    });
    monacoRef.current.languages.register({
      id: 'remix-cairo'
    }); // Register a tokens provider for the language

    monacoRef.current.languages.setMonarchTokensProvider('remix-solidity', _syntax.language);
    monacoRef.current.languages.setLanguageConfiguration('remix-solidity', _syntax.conf);
    monacoRef.current.languages.setMonarchTokensProvider('remix-cairo', _cairoSyntax.cairoLang);
    monacoRef.current.languages.setLanguageConfiguration('remix-cairo', _cairoSyntax.cairoConf);
    (0, _webTypes.loadTypes)(monacoRef.current);
  }

  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "w-100 h-100 d-flex flex-column-reverse",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_react2.default, {
      width: "100%",
      path: props.currentFile,
      language: editorModelsState[props.currentFile] ? editorModelsState[props.currentFile].language : 'text',
      onMount: handleEditorDidMount,
      beforeMount: handleEditorWillMount,
      options: {
        glyphMargin: true,
        readOnly: true
      },
      defaultValue: defaultEditorValue
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
      className: "contextview",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_editorContextView.RemixUiEditorContextView, {
        hide: false,
        gotoLine: (line, column) => props.plugin.call('editor', 'gotoLine', line, column),
        openFile: file => props.plugin.call('fileManager', 'switchFile', file),
        getLastCompilationResult: () => {
          return props.plugin.call('compilerArtefacts', 'getLastCompilationResult');
        },
        offsetToLineColumn: (position, file, sources, asts) => {
          return props.plugin.call('offsetToLineColumnConverter', 'offsetToLineColumn', position, file, sources, asts);
        },
        getCurrentFileName: () => {
          return props.plugin.call('fileManager', 'file');
        },
        onContextListenerChanged: listener => {
          props.plugin.on('contextualListener', 'contextChanged', listener);
        },
        onCurrentFileChanged: listener => {
          props.plugin.on('fileManager', 'currentFileChanged', listener);
        },
        referencesOf: node => {
          return props.plugin.call('contextualListener', 'referencesOf', node);
        },
        getActiveHighlights: () => {
          return props.plugin.call('contextualListener', 'getActiveHighlights');
        },
        gasEstimation: node => {
          return props.plugin.call('contextualListener', 'gasEstimation', node);
        },
        declarationOf: node => {
          return props.plugin.call('contextualListener', 'declarationOf', node);
        }
      })
    })]
  });
};

exports.EditorUI = EditorUI;
var _default = EditorUI;
exports.default = _default;

/***/ }),
/* 2846 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiEditorContextView = __webpack_require__(2847);

Object.keys(_remixUiEditorContextView).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiEditorContextView[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiEditorContextView[key];
    }
  });
});

/***/ }),
/* 2847 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemixUiEditorContextView = RemixUiEditorContextView;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(138));

var _react = _interopRequireWildcard(__webpack_require__(29));

var _remixDebug = __webpack_require__(1217);

__webpack_require__(2848);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isDefinition(node) {
  return node.nodeType === 'ContractDefinition' || node.nodeType === 'FunctionDefinition' || node.nodeType === 'ModifierDefinition' || node.nodeType === 'VariableDeclaration' || node.nodeType === 'StructDefinition' || node.nodeType === 'EventDefinition';
}

function RemixUiEditorContextView(props) {
  const loopOverReferences = (0, _react.useRef)(0);
  const currentNodeDeclaration = (0, _react.useRef)(null);
  const [state, setState] = (0, _react.useState)({
    nodes: [],
    activeHighlights: [],
    gasEstimation: {
      executionCost: '',
      codeDepositCost: ''
    }
  });
  (0, _react.useEffect)(() => {
    props.onCurrentFileChanged(() => {
      currentNodeDeclaration.current = null;
      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          nodes: [],
          activeHighlights: []
        });
      });
    });
    props.onContextListenerChanged(async nodes => {
      let nextNodeDeclaration;
      let nextNode;

      if (!props.hide && nodes && nodes.length) {
        nextNode = nodes[nodes.length - 1];

        if (!isDefinition(nextNode)) {
          nextNodeDeclaration = await props.declarationOf(nextNode);
        } else {
          nextNodeDeclaration = nextNode;
        }
      }

      if (nextNodeDeclaration && currentNodeDeclaration.current && nextNodeDeclaration.id === currentNodeDeclaration.current.id) return;
      currentNodeDeclaration.current = nextNodeDeclaration;
      let gasEstimation;

      if (currentNodeDeclaration.current) {
        if (currentNodeDeclaration.current.nodeType === 'FunctionDefinition') {
          gasEstimation = await props.gasEstimation(currentNodeDeclaration.current);
        }
      }

      const activeHighlights = await props.getActiveHighlights();

      if (nextNode && activeHighlights && activeHighlights.length) {
        loopOverReferences.current = activeHighlights.findIndex(el => `${el.position.start}:${el.position.length}:${el.position.file}` === nextNode.src);
        loopOverReferences.current = loopOverReferences.current === -1 ? 0 : loopOverReferences.current;
      } else {
        loopOverReferences.current = 0;
      }

      setState(prevState => {
        return _objectSpread(_objectSpread({}, prevState), {}, {
          nodes,
          activeHighlights,
          gasEstimation
        });
      });
    });
  }, []);
  /*
   * show gas estimation
   */

  const gasEstimation = node => {
    if (node.nodeType === 'FunctionDefinition') {
      const result = state.gasEstimation;
      const executionCost = ' Execution cost: ' + result.executionCost + ' gas';
      const codeDepositCost = 'Code deposit cost: ' + result.codeDepositCost + ' gas';
      const estimatedGas = result.codeDepositCost ? `${codeDepositCost}, ${executionCost}` : `${executionCost}`;
      return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "gasEstimation",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "fas fa-gas-pump gasStationIcon",
          title: "Gas estimation"
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          children: estimatedGas
        })]
      });
    } else {
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    }
  };
  /*
   * onClick jump to ast node in the editor
   */


  const _jumpToInternal = async position => {
    const jumpToLine = async (fileName, lineColumn) => {
      if (fileName !== (await props.getCurrentFileName())) {
        await props.openFile(fileName);
      }

      if (lineColumn.start && lineColumn.start.line >= 0 && lineColumn.start.column >= 0) {
        props.gotoLine(lineColumn.start.line, lineColumn.end.column + 1);
      }
    };

    const lastCompilationResult = await props.getLastCompilationResult();

    if (lastCompilationResult && lastCompilationResult.languageversion.indexOf('soljson') === 0 && lastCompilationResult.data) {
      const lineColumn = await props.offsetToLineColumn(position, position.file, lastCompilationResult.getSourceCode().sources, lastCompilationResult.getAsts());
      const filename = lastCompilationResult.getSourceName(position.file); // TODO: refactor with rendererAPI.errorClick

      jumpToLine(filename, lineColumn);
    }
  };

  const _render = () => {
    const node = currentNodeDeclaration.current;
    if (!node) return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    const references = state.activeHighlights;
    const type = node.typeDescriptions && node.typeDescriptions.typeString ? node.typeDescriptions.typeString : node.nodeType;
    const referencesCount = `${references ? references.length : '0'} reference(s)`;
    const nodes = state.activeHighlights;

    const jumpTo = () => {
      if (node && node.src) {
        const position = _remixDebug.sourceMappingDecoder.decode(node.src);

        if (position) {
          _jumpToInternal(position);
        }
      }
    }; // JUMP BETWEEN REFERENCES


    const jump = e => {
      e.target.dataset.action === 'next' ? loopOverReferences.current++ : loopOverReferences.current--;
      if (loopOverReferences.current < 0) loopOverReferences.current = nodes.length - 1;
      if (loopOverReferences.current >= nodes.length) loopOverReferences.current = 0;

      _jumpToInternal(nodes[loopOverReferences.current].position);
    };

    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "line",
      children: [gasEstimation(node), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        title: type,
        className: "type",
        children: type
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        title: node.name,
        className: "name mr-2",
        children: node.name
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: "fas fa-share jump",
        "data-action": "gotoref",
        "aria-hidden": "true",
        onClick: jumpTo
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "referencesnb",
        children: referencesCount
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        "data-action": "previous",
        className: "fas fa-chevron-up jump",
        "aria-hidden": "true",
        onClick: jump
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        "data-action": "next",
        className: "fas fa-chevron-down jump",
        "aria-hidden": "true",
        onClick: jump
      })]
    });
  };

  return !props.hide && /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
    className: "container-context-view contextviewcontainer bg-light text-dark border-0 py-1",
    children: _render()
  });
}

var _default = RemixUiEditorContextView;
exports.default = _default;

/***/ }),
/* 2848 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2849);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2849 */
/***/ (function(module, exports) {

module.exports = [[module.i, "\n  .container-context-view {\n    padding             : 1px 15px;\n  }\n  .line {\n    display             : flex;\n    align-items         : center;\n    text-overflow       : ellipsis;\n    overflow            : hidden;\n    white-space         : nowrap;\n    font-size           : 13px;\n  }\n  .type {\n    font-style        : italic;\n    margin-right      : 5px;\n  }\n  .name  {\n    font-weight       : bold;\n  }\n  .jump {\n    cursor            : pointer;\n    margin            : 0 5px;\n  }\n  .jump:hover              {\n    color             : var(--secondary);\n  }\n  .referencesnb {\n    float             : right;\n    margin-left       : 15px;\n  }\n  .gasEstimation {\n    margin-right      : 15px;\n    display           : flex;\n    align-items       : center;\n  }\n  .gasStationIcon {\n    margin-right      : 5px;\n  }\n  .contextviewcontainer {\n    z-index           : 50;\n    border-radius     : 1px;\n    border            : 2px solid var(--secondary);\n  }\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLWVkaXRvci1jb250ZXh0LXZpZXcuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7RUFDRTtJQUNFLDhCQUE4QjtFQUNoQztFQUNBO0lBQ0UsMEJBQTBCO0lBQzFCLDRCQUE0QjtJQUM1Qiw4QkFBOEI7SUFDOUIsNEJBQTRCO0lBQzVCLDRCQUE0QjtJQUM1QiwwQkFBMEI7RUFDNUI7RUFDQTtJQUNFLDBCQUEwQjtJQUMxQix1QkFBdUI7RUFDekI7RUFDQTtJQUNFLHdCQUF3QjtFQUMxQjtFQUNBO0lBQ0UsMkJBQTJCO0lBQzNCLHlCQUF5QjtFQUMzQjtFQUNBO0lBQ0Usb0NBQW9DO0VBQ3RDO0VBQ0E7SUFDRSx5QkFBeUI7SUFDekIsd0JBQXdCO0VBQzFCO0VBQ0E7SUFDRSx3QkFBd0I7SUFDeEIsd0JBQXdCO0lBQ3hCLDBCQUEwQjtFQUM1QjtFQUNBO0lBQ0UsdUJBQXVCO0VBQ3pCO0VBQ0E7SUFDRSxzQkFBc0I7SUFDdEIsdUJBQXVCO0lBQ3ZCLDhDQUE4QztFQUNoRCIsImZpbGUiOiJyZW1peC11aS1lZGl0b3ItY29udGV4dC12aWV3LmNzcyIsInNvdXJjZXNDb250ZW50IjpbIlxuICAuY29udGFpbmVyLWNvbnRleHQtdmlldyB7XG4gICAgcGFkZGluZyAgICAgICAgICAgICA6IDFweCAxNXB4O1xuICB9XG4gIC5saW5lIHtcbiAgICBkaXNwbGF5ICAgICAgICAgICAgIDogZmxleDtcbiAgICBhbGlnbi1pdGVtcyAgICAgICAgIDogY2VudGVyO1xuICAgIHRleHQtb3ZlcmZsb3cgICAgICAgOiBlbGxpcHNpcztcbiAgICBvdmVyZmxvdyAgICAgICAgICAgIDogaGlkZGVuO1xuICAgIHdoaXRlLXNwYWNlICAgICAgICAgOiBub3dyYXA7XG4gICAgZm9udC1zaXplICAgICAgICAgICA6IDEzcHg7XG4gIH1cbiAgLnR5cGUge1xuICAgIGZvbnQtc3R5bGUgICAgICAgIDogaXRhbGljO1xuICAgIG1hcmdpbi1yaWdodCAgICAgIDogNXB4O1xuICB9XG4gIC5uYW1lICB7XG4gICAgZm9udC13ZWlnaHQgICAgICAgOiBib2xkO1xuICB9XG4gIC5qdW1wIHtcbiAgICBjdXJzb3IgICAgICAgICAgICA6IHBvaW50ZXI7XG4gICAgbWFyZ2luICAgICAgICAgICAgOiAwIDVweDtcbiAgfVxuICAuanVtcDpob3ZlciAgICAgICAgICAgICAge1xuICAgIGNvbG9yICAgICAgICAgICAgIDogdmFyKC0tc2Vjb25kYXJ5KTtcbiAgfVxuICAucmVmZXJlbmNlc25iIHtcbiAgICBmbG9hdCAgICAgICAgICAgICA6IHJpZ2h0O1xuICAgIG1hcmdpbi1sZWZ0ICAgICAgIDogMTVweDtcbiAgfVxuICAuZ2FzRXN0aW1hdGlvbiB7XG4gICAgbWFyZ2luLXJpZ2h0ICAgICAgOiAxNXB4O1xuICAgIGRpc3BsYXkgICAgICAgICAgIDogZmxleDtcbiAgICBhbGlnbi1pdGVtcyAgICAgICA6IGNlbnRlcjtcbiAgfVxuICAuZ2FzU3RhdGlvbkljb24ge1xuICAgIG1hcmdpbi1yaWdodCAgICAgIDogNXB4O1xuICB9XG4gIC5jb250ZXh0dmlld2NvbnRhaW5lciB7XG4gICAgei1pbmRleCAgICAgICAgICAgOiA1MDtcbiAgICBib3JkZXItcmFkaXVzICAgICA6IDFweDtcbiAgICBib3JkZXIgICAgICAgICAgICA6IDJweCBzb2xpZCB2YXIoLS1zZWNvbmRhcnkpO1xuICB9Il19 */", '', '']]

/***/ }),
/* 2850 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducerListener = exports.reducerActions = exports.initialState = void 0;
const initialState = {};
exports.initialState = initialState;

const reducerActions = (models = initialState, action) => {
  const monaco = action.monaco;
  const editor = action.editor;

  switch (action.type) {
    case 'ADD_MODEL':
      {
        if (!editor) return models;
        const uri = action.payload.uri;
        const value = action.payload.value;
        const language = action.payload.language;
        const readOnly = action.payload.readOnly;
        if (models[uri]) return models; // already existing

        models[uri] = {
          language,
          uri,
          readOnly
        };
        const model = monaco.editor.createModel(value, language, monaco.Uri.parse(uri));
        models[uri].model = model;
        model.onDidChangeContent(() => action.payload.events.onDidChangeContent(uri));
        return models;
      }

    case 'DISPOSE_MODEL':
      {
        var _models$uri;

        const uri = action.payload.uri;
        const model = (_models$uri = models[uri]) === null || _models$uri === void 0 ? void 0 : _models$uri.model;
        if (model) model.dispose();
        delete models[uri];
        return models;
      }

    case 'SET_VALUE':
      {
        var _models$uri2;

        if (!editor) return models;
        const uri = action.payload.uri;
        const value = action.payload.value;
        const model = (_models$uri2 = models[uri]) === null || _models$uri2 === void 0 ? void 0 : _models$uri2.model;

        if (model) {
          model.setValue(value);
        }

        return models;
      }

    case 'REVEAL_LINE':
      {
        if (!editor) return models;
        const line = action.payload.line;
        const column = action.payload.column;
        editor.revealLine(line);
        editor.setPosition({
          column,
          lineNumber: line
        });
        return models;
      }

    case 'REVEAL_RANGE':
      {
        if (!editor) return models;
        const range = {
          startLineNumber: action.payload.startLineNumber + 1,
          startColumn: action.payload.startColumn,
          endLineNumber: action.payload.endLineNumber + 1,
          endColumn: action.payload.endColumn
        }; // reset to start of line

        if (action.payload.startColumn < 100) {
          editor.revealRange({
            startLineNumber: range.startLineNumber,
            startColumn: 1,
            endLineNumber: range.endLineNumber,
            endColumn: 1
          });
        } else {
          editor.revealRangeInCenter(range);
        }

        return models;
      }

    case 'FOCUS':
      {
        if (!editor) return models;
        editor.focus();
        return models;
      }

    case 'SET_FONTSIZE':
      {
        if (!editor) return models;
        const size = action.payload.size;
        editor.updateOptions({
          fontSize: size
        });
        return models;
      }

    case 'SET_WORDWRAP':
      {
        if (!editor) return models;
        const wrap = action.payload.wrap;
        editor.updateOptions({
          wordWrap: wrap ? 'on' : 'off'
        });
        return models;
      }
  }
};

exports.reducerActions = reducerActions;

const reducerListener = (plugin, dispatch, monaco, editor, events) => {
  plugin.on('editor', 'addModel', (value, language, uri, readOnly) => {
    dispatch({
      type: 'ADD_MODEL',
      payload: {
        uri,
        value,
        language,
        readOnly,
        events
      },
      monaco,
      editor
    });
  });
  plugin.on('editor', 'disposeModel', uri => {
    dispatch({
      type: 'DISPOSE_MODEL',
      payload: {
        uri
      },
      monaco,
      editor
    });
  });
  plugin.on('editor', 'setValue', (uri, value) => {
    dispatch({
      type: 'SET_VALUE',
      payload: {
        uri,
        value
      },
      monaco,
      editor
    });
  });
  plugin.on('editor', 'revealLine', (line, column) => {
    dispatch({
      type: 'REVEAL_LINE',
      payload: {
        line,
        column
      },
      monaco,
      editor
    });
  });
  plugin.on('editor', 'revealRange', (startLineNumber, startColumn, endLineNumber, endColumn) => {
    dispatch({
      type: 'REVEAL_RANGE',
      payload: {
        startLineNumber,
        startColumn,
        endLineNumber,
        endColumn
      },
      monaco,
      editor
    });
  });
  plugin.on('editor', 'focus', () => {
    dispatch({
      type: 'FOCUS',
      payload: {},
      monaco,
      editor
    });
  });
  plugin.on('editor', 'setFontSize', size => {
    dispatch({
      type: 'SET_FONTSIZE',
      payload: {
        size
      },
      monaco,
      editor
    });
  });
  plugin.on('editor', 'setWordWrap', wrap => {
    dispatch({
      type: 'SET_WORDWRAP',
      payload: {
        wrap
      },
      monaco,
      editor
    });
  });
};

exports.reducerListener = reducerListener;

/***/ }),
/* 2851 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.language = exports.conf = void 0;

/* eslint-disable */
const conf = {
  comments: {
    lineComment: '//',
    blockComment: ['/*', '*/']
  },
  brackets: [['{', '}'], ['[', ']'], ['(', ')'], ['<', '>']],
  autoClosingPairs: [{
    open: '"',
    close: '"',
    notIn: ['string', 'comment']
  }, {
    open: "'",
    close: "'",
    notIn: ['string', 'comment']
  }, {
    open: '{',
    close: '}',
    notIn: ['string', 'comment']
  }, {
    open: '[',
    close: ']',
    notIn: ['string', 'comment']
  }, {
    open: '(',
    close: ')',
    notIn: ['string', 'comment']
  }]
};
exports.conf = conf;
const language = {
  defaultToken: '',
  tokenPostfix: '.sol',
  brackets: [{
    token: 'delimiter.curly',
    open: '{',
    close: '}'
  }, {
    token: 'delimiter.parenthesis',
    open: '(',
    close: ')'
  }, {
    token: 'delimiter.square',
    open: '[',
    close: ']'
  }, {
    token: 'delimiter.angle',
    open: '<',
    close: '>'
  }],
  keywords: [// Main keywords
  'pragma', 'solidity', 'contract', 'library', 'using', 'struct', 'function', 'modifier', 'constructor', // Built-in types
  'address', 'string', 'bool', // Other types
  'Int', 'Uint', 'Byte', 'Fixed', 'Ufixed', // All int
  'int', 'int8', 'int16', 'int24', 'int32', 'int40', 'int48', 'int56', 'int64', 'int72', 'int80', 'int88', 'int96', 'int104', 'int112', 'int120', 'int128', 'int136', 'int144', 'int152', 'int160', 'int168', 'int176', 'int184', 'int192', 'int200', 'int208', 'int216', 'int224', 'int232', 'int240', 'int248', 'int256', // All uint
  'uint', 'uint8', 'uint16', 'uint24', 'uint32', 'uint40', 'uint48', 'uint56', 'uint64', 'uint72', 'uint80', 'uint88', 'uint96', 'uint104', 'uint112', 'uint120', 'uint128', 'uint136', 'uint144', 'uint152', 'uint160', 'uint168', 'uint176', 'uint184', 'uint192', 'uint200', 'uint208', 'uint216', 'uint224', 'uint232', 'uint240', 'uint248', 'uint256', // All Byte
  'byte', 'bytes', 'bytes1', 'bytes2', 'bytes3', 'bytes4', 'bytes5', 'bytes6', 'bytes7', 'bytes8', 'bytes9', 'bytes10', 'bytes11', 'bytes12', 'bytes13', 'bytes14', 'bytes15', 'bytes16', 'bytes17', 'bytes18', 'bytes19', 'bytes20', 'bytes21', 'bytes22', 'bytes23', 'bytes24', 'bytes25', 'bytes26', 'bytes27', 'bytes28', 'bytes29', 'bytes30', 'bytes31', 'bytes32', // All fixed
  'fixed', 'fixed0x8', 'fixed0x16', 'fixed0x24', 'fixed0x32', 'fixed0x40', 'fixed0x48', 'fixed0x56', 'fixed0x64', 'fixed0x72', 'fixed0x80', 'fixed0x88', 'fixed0x96', 'fixed0x104', 'fixed0x112', 'fixed0x120', 'fixed0x128', 'fixed0x136', 'fixed0x144', 'fixed0x152', 'fixed0x160', 'fixed0x168', 'fixed0x176', 'fixed0x184', 'fixed0x192', 'fixed0x200', 'fixed0x208', 'fixed0x216', 'fixed0x224', 'fixed0x232', 'fixed0x240', 'fixed0x248', 'fixed0x256', 'fixed8x8', 'fixed8x16', 'fixed8x24', 'fixed8x32', 'fixed8x40', 'fixed8x48', 'fixed8x56', 'fixed8x64', 'fixed8x72', 'fixed8x80', 'fixed8x88', 'fixed8x96', 'fixed8x104', 'fixed8x112', 'fixed8x120', 'fixed8x128', 'fixed8x136', 'fixed8x144', 'fixed8x152', 'fixed8x160', 'fixed8x168', 'fixed8x176', 'fixed8x184', 'fixed8x192', 'fixed8x200', 'fixed8x208', 'fixed8x216', 'fixed8x224', 'fixed8x232', 'fixed8x240', 'fixed8x248', 'fixed16x8', 'fixed16x16', 'fixed16x24', 'fixed16x32', 'fixed16x40', 'fixed16x48', 'fixed16x56', 'fixed16x64', 'fixed16x72', 'fixed16x80', 'fixed16x88', 'fixed16x96', 'fixed16x104', 'fixed16x112', 'fixed16x120', 'fixed16x128', 'fixed16x136', 'fixed16x144', 'fixed16x152', 'fixed16x160', 'fixed16x168', 'fixed16x176', 'fixed16x184', 'fixed16x192', 'fixed16x200', 'fixed16x208', 'fixed16x216', 'fixed16x224', 'fixed16x232', 'fixed16x240', 'fixed24x8', 'fixed24x16', 'fixed24x24', 'fixed24x32', 'fixed24x40', 'fixed24x48', 'fixed24x56', 'fixed24x64', 'fixed24x72', 'fixed24x80', 'fixed24x88', 'fixed24x96', 'fixed24x104', 'fixed24x112', 'fixed24x120', 'fixed24x128', 'fixed24x136', 'fixed24x144', 'fixed24x152', 'fixed24x160', 'fixed24x168', 'fixed24x176', 'fixed24x184', 'fixed24x192', 'fixed24x200', 'fixed24x208', 'fixed24x216', 'fixed24x224', 'fixed24x232', 'fixed32x8', 'fixed32x16', 'fixed32x24', 'fixed32x32', 'fixed32x40', 'fixed32x48', 'fixed32x56', 'fixed32x64', 'fixed32x72', 'fixed32x80', 'fixed32x88', 'fixed32x96', 'fixed32x104', 'fixed32x112', 'fixed32x120', 'fixed32x128', 'fixed32x136', 'fixed32x144', 'fixed32x152', 'fixed32x160', 'fixed32x168', 'fixed32x176', 'fixed32x184', 'fixed32x192', 'fixed32x200', 'fixed32x208', 'fixed32x216', 'fixed32x224', 'fixed40x8', 'fixed40x16', 'fixed40x24', 'fixed40x32', 'fixed40x40', 'fixed40x48', 'fixed40x56', 'fixed40x64', 'fixed40x72', 'fixed40x80', 'fixed40x88', 'fixed40x96', 'fixed40x104', 'fixed40x112', 'fixed40x120', 'fixed40x128', 'fixed40x136', 'fixed40x144', 'fixed40x152', 'fixed40x160', 'fixed40x168', 'fixed40x176', 'fixed40x184', 'fixed40x192', 'fixed40x200', 'fixed40x208', 'fixed40x216', 'fixed48x8', 'fixed48x16', 'fixed48x24', 'fixed48x32', 'fixed48x40', 'fixed48x48', 'fixed48x56', 'fixed48x64', 'fixed48x72', 'fixed48x80', 'fixed48x88', 'fixed48x96', 'fixed48x104', 'fixed48x112', 'fixed48x120', 'fixed48x128', 'fixed48x136', 'fixed48x144', 'fixed48x152', 'fixed48x160', 'fixed48x168', 'fixed48x176', 'fixed48x184', 'fixed48x192', 'fixed48x200', 'fixed48x208', 'fixed56x8', 'fixed56x16', 'fixed56x24', 'fixed56x32', 'fixed56x40', 'fixed56x48', 'fixed56x56', 'fixed56x64', 'fixed56x72', 'fixed56x80', 'fixed56x88', 'fixed56x96', 'fixed56x104', 'fixed56x112', 'fixed56x120', 'fixed56x128', 'fixed56x136', 'fixed56x144', 'fixed56x152', 'fixed56x160', 'fixed56x168', 'fixed56x176', 'fixed56x184', 'fixed56x192', 'fixed56x200', 'fixed64x8', 'fixed64x16', 'fixed64x24', 'fixed64x32', 'fixed64x40', 'fixed64x48', 'fixed64x56', 'fixed64x64', 'fixed64x72', 'fixed64x80', 'fixed64x88', 'fixed64x96', 'fixed64x104', 'fixed64x112', 'fixed64x120', 'fixed64x128', 'fixed64x136', 'fixed64x144', 'fixed64x152', 'fixed64x160', 'fixed64x168', 'fixed64x176', 'fixed64x184', 'fixed64x192', 'fixed72x8', 'fixed72x16', 'fixed72x24', 'fixed72x32', 'fixed72x40', 'fixed72x48', 'fixed72x56', 'fixed72x64', 'fixed72x72', 'fixed72x80', 'fixed72x88', 'fixed72x96', 'fixed72x104', 'fixed72x112', 'fixed72x120', 'fixed72x128', 'fixed72x136', 'fixed72x144', 'fixed72x152', 'fixed72x160', 'fixed72x168', 'fixed72x176', 'fixed72x184', 'fixed80x8', 'fixed80x16', 'fixed80x24', 'fixed80x32', 'fixed80x40', 'fixed80x48', 'fixed80x56', 'fixed80x64', 'fixed80x72', 'fixed80x80', 'fixed80x88', 'fixed80x96', 'fixed80x104', 'fixed80x112', 'fixed80x120', 'fixed80x128', 'fixed80x136', 'fixed80x144', 'fixed80x152', 'fixed80x160', 'fixed80x168', 'fixed80x176', 'fixed88x8', 'fixed88x16', 'fixed88x24', 'fixed88x32', 'fixed88x40', 'fixed88x48', 'fixed88x56', 'fixed88x64', 'fixed88x72', 'fixed88x80', 'fixed88x88', 'fixed88x96', 'fixed88x104', 'fixed88x112', 'fixed88x120', 'fixed88x128', 'fixed88x136', 'fixed88x144', 'fixed88x152', 'fixed88x160', 'fixed88x168', 'fixed96x8', 'fixed96x16', 'fixed96x24', 'fixed96x32', 'fixed96x40', 'fixed96x48', 'fixed96x56', 'fixed96x64', 'fixed96x72', 'fixed96x80', 'fixed96x88', 'fixed96x96', 'fixed96x104', 'fixed96x112', 'fixed96x120', 'fixed96x128', 'fixed96x136', 'fixed96x144', 'fixed96x152', 'fixed96x160', 'fixed104x8', 'fixed104x16', 'fixed104x24', 'fixed104x32', 'fixed104x40', 'fixed104x48', 'fixed104x56', 'fixed104x64', 'fixed104x72', 'fixed104x80', 'fixed104x88', 'fixed104x96', 'fixed104x104', 'fixed104x112', 'fixed104x120', 'fixed104x128', 'fixed104x136', 'fixed104x144', 'fixed104x152', 'fixed112x8', 'fixed112x16', 'fixed112x24', 'fixed112x32', 'fixed112x40', 'fixed112x48', 'fixed112x56', 'fixed112x64', 'fixed112x72', 'fixed112x80', 'fixed112x88', 'fixed112x96', 'fixed112x104', 'fixed112x112', 'fixed112x120', 'fixed112x128', 'fixed112x136', 'fixed112x144', 'fixed120x8', 'fixed120x16', 'fixed120x24', 'fixed120x32', 'fixed120x40', 'fixed120x48', 'fixed120x56', 'fixed120x64', 'fixed120x72', 'fixed120x80', 'fixed120x88', 'fixed120x96', 'fixed120x104', 'fixed120x112', 'fixed120x120', 'fixed120x128', 'fixed120x136', 'fixed128x8', 'fixed128x16', 'fixed128x24', 'fixed128x32', 'fixed128x40', 'fixed128x48', 'fixed128x56', 'fixed128x64', 'fixed128x72', 'fixed128x80', 'fixed128x88', 'fixed128x96', 'fixed128x104', 'fixed128x112', 'fixed128x120', 'fixed128x128', 'fixed136x8', 'fixed136x16', 'fixed136x24', 'fixed136x32', 'fixed136x40', 'fixed136x48', 'fixed136x56', 'fixed136x64', 'fixed136x72', 'fixed136x80', 'fixed136x88', 'fixed136x96', 'fixed136x104', 'fixed136x112', 'fixed136x120', 'fixed144x8', 'fixed144x16', 'fixed144x24', 'fixed144x32', 'fixed144x40', 'fixed144x48', 'fixed144x56', 'fixed144x64', 'fixed144x72', 'fixed144x80', 'fixed144x88', 'fixed144x96', 'fixed144x104', 'fixed144x112', 'fixed152x8', 'fixed152x16', 'fixed152x24', 'fixed152x32', 'fixed152x40', 'fixed152x48', 'fixed152x56', 'fixed152x64', 'fixed152x72', 'fixed152x80', 'fixed152x88', 'fixed152x96', 'fixed152x104', 'fixed160x8', 'fixed160x16', 'fixed160x24', 'fixed160x32', 'fixed160x40', 'fixed160x48', 'fixed160x56', 'fixed160x64', 'fixed160x72', 'fixed160x80', 'fixed160x88', 'fixed160x96', 'fixed168x8', 'fixed168x16', 'fixed168x24', 'fixed168x32', 'fixed168x40', 'fixed168x48', 'fixed168x56', 'fixed168x64', 'fixed168x72', 'fixed168x80', 'fixed168x88', 'fixed176x8', 'fixed176x16', 'fixed176x24', 'fixed176x32', 'fixed176x40', 'fixed176x48', 'fixed176x56', 'fixed176x64', 'fixed176x72', 'fixed176x80', 'fixed184x8', 'fixed184x16', 'fixed184x24', 'fixed184x32', 'fixed184x40', 'fixed184x48', 'fixed184x56', 'fixed184x64', 'fixed184x72', 'fixed192x8', 'fixed192x16', 'fixed192x24', 'fixed192x32', 'fixed192x40', 'fixed192x48', 'fixed192x56', 'fixed192x64', 'fixed200x8', 'fixed200x16', 'fixed200x24', 'fixed200x32', 'fixed200x40', 'fixed200x48', 'fixed200x56', 'fixed208x8', 'fixed208x16', 'fixed208x24', 'fixed208x32', 'fixed208x40', 'fixed208x48', 'fixed216x8', 'fixed216x16', 'fixed216x24', 'fixed216x32', 'fixed216x40', 'fixed224x8', 'fixed224x16', 'fixed224x24', 'fixed224x32', 'fixed232x8', 'fixed232x16', 'fixed232x24', 'fixed240x8', 'fixed240x16', 'fixed248x8', // All ufixed
  'ufixed', 'ufixed0x8', 'ufixed0x16', 'ufixed0x24', 'ufixed0x32', 'ufixed0x40', 'ufixed0x48', 'ufixed0x56', 'ufixed0x64', 'ufixed0x72', 'ufixed0x80', 'ufixed0x88', 'ufixed0x96', 'ufixed0x104', 'ufixed0x112', 'ufixed0x120', 'ufixed0x128', 'ufixed0x136', 'ufixed0x144', 'ufixed0x152', 'ufixed0x160', 'ufixed0x168', 'ufixed0x176', 'ufixed0x184', 'ufixed0x192', 'ufixed0x200', 'ufixed0x208', 'ufixed0x216', 'ufixed0x224', 'ufixed0x232', 'ufixed0x240', 'ufixed0x248', 'ufixed0x256', 'ufixed8x8', 'ufixed8x16', 'ufixed8x24', 'ufixed8x32', 'ufixed8x40', 'ufixed8x48', 'ufixed8x56', 'ufixed8x64', 'ufixed8x72', 'ufixed8x80', 'ufixed8x88', 'ufixed8x96', 'ufixed8x104', 'ufixed8x112', 'ufixed8x120', 'ufixed8x128', 'ufixed8x136', 'ufixed8x144', 'ufixed8x152', 'ufixed8x160', 'ufixed8x168', 'ufixed8x176', 'ufixed8x184', 'ufixed8x192', 'ufixed8x200', 'ufixed8x208', 'ufixed8x216', 'ufixed8x224', 'ufixed8x232', 'ufixed8x240', 'ufixed8x248', 'ufixed16x8', 'ufixed16x16', 'ufixed16x24', 'ufixed16x32', 'ufixed16x40', 'ufixed16x48', 'ufixed16x56', 'ufixed16x64', 'ufixed16x72', 'ufixed16x80', 'ufixed16x88', 'ufixed16x96', 'ufixed16x104', 'ufixed16x112', 'ufixed16x120', 'ufixed16x128', 'ufixed16x136', 'ufixed16x144', 'ufixed16x152', 'ufixed16x160', 'ufixed16x168', 'ufixed16x176', 'ufixed16x184', 'ufixed16x192', 'ufixed16x200', 'ufixed16x208', 'ufixed16x216', 'ufixed16x224', 'ufixed16x232', 'ufixed16x240', 'ufixed24x8', 'ufixed24x16', 'ufixed24x24', 'ufixed24x32', 'ufixed24x40', 'ufixed24x48', 'ufixed24x56', 'ufixed24x64', 'ufixed24x72', 'ufixed24x80', 'ufixed24x88', 'ufixed24x96', 'ufixed24x104', 'ufixed24x112', 'ufixed24x120', 'ufixed24x128', 'ufixed24x136', 'ufixed24x144', 'ufixed24x152', 'ufixed24x160', 'ufixed24x168', 'ufixed24x176', 'ufixed24x184', 'ufixed24x192', 'ufixed24x200', 'ufixed24x208', 'ufixed24x216', 'ufixed24x224', 'ufixed24x232', 'ufixed32x8', 'ufixed32x16', 'ufixed32x24', 'ufixed32x32', 'ufixed32x40', 'ufixed32x48', 'ufixed32x56', 'ufixed32x64', 'ufixed32x72', 'ufixed32x80', 'ufixed32x88', 'ufixed32x96', 'ufixed32x104', 'ufixed32x112', 'ufixed32x120', 'ufixed32x128', 'ufixed32x136', 'ufixed32x144', 'ufixed32x152', 'ufixed32x160', 'ufixed32x168', 'ufixed32x176', 'ufixed32x184', 'ufixed32x192', 'ufixed32x200', 'ufixed32x208', 'ufixed32x216', 'ufixed32x224', 'ufixed40x8', 'ufixed40x16', 'ufixed40x24', 'ufixed40x32', 'ufixed40x40', 'ufixed40x48', 'ufixed40x56', 'ufixed40x64', 'ufixed40x72', 'ufixed40x80', 'ufixed40x88', 'ufixed40x96', 'ufixed40x104', 'ufixed40x112', 'ufixed40x120', 'ufixed40x128', 'ufixed40x136', 'ufixed40x144', 'ufixed40x152', 'ufixed40x160', 'ufixed40x168', 'ufixed40x176', 'ufixed40x184', 'ufixed40x192', 'ufixed40x200', 'ufixed40x208', 'ufixed40x216', 'ufixed48x8', 'ufixed48x16', 'ufixed48x24', 'ufixed48x32', 'ufixed48x40', 'ufixed48x48', 'ufixed48x56', 'ufixed48x64', 'ufixed48x72', 'ufixed48x80', 'ufixed48x88', 'ufixed48x96', 'ufixed48x104', 'ufixed48x112', 'ufixed48x120', 'ufixed48x128', 'ufixed48x136', 'ufixed48x144', 'ufixed48x152', 'ufixed48x160', 'ufixed48x168', 'ufixed48x176', 'ufixed48x184', 'ufixed48x192', 'ufixed48x200', 'ufixed48x208', 'ufixed56x8', 'ufixed56x16', 'ufixed56x24', 'ufixed56x32', 'ufixed56x40', 'ufixed56x48', 'ufixed56x56', 'ufixed56x64', 'ufixed56x72', 'ufixed56x80', 'ufixed56x88', 'ufixed56x96', 'ufixed56x104', 'ufixed56x112', 'ufixed56x120', 'ufixed56x128', 'ufixed56x136', 'ufixed56x144', 'ufixed56x152', 'ufixed56x160', 'ufixed56x168', 'ufixed56x176', 'ufixed56x184', 'ufixed56x192', 'ufixed56x200', 'ufixed64x8', 'ufixed64x16', 'ufixed64x24', 'ufixed64x32', 'ufixed64x40', 'ufixed64x48', 'ufixed64x56', 'ufixed64x64', 'ufixed64x72', 'ufixed64x80', 'ufixed64x88', 'ufixed64x96', 'ufixed64x104', 'ufixed64x112', 'ufixed64x120', 'ufixed64x128', 'ufixed64x136', 'ufixed64x144', 'ufixed64x152', 'ufixed64x160', 'ufixed64x168', 'ufixed64x176', 'ufixed64x184', 'ufixed64x192', 'ufixed72x8', 'ufixed72x16', 'ufixed72x24', 'ufixed72x32', 'ufixed72x40', 'ufixed72x48', 'ufixed72x56', 'ufixed72x64', 'ufixed72x72', 'ufixed72x80', 'ufixed72x88', 'ufixed72x96', 'ufixed72x104', 'ufixed72x112', 'ufixed72x120', 'ufixed72x128', 'ufixed72x136', 'ufixed72x144', 'ufixed72x152', 'ufixed72x160', 'ufixed72x168', 'ufixed72x176', 'ufixed72x184', 'ufixed80x8', 'ufixed80x16', 'ufixed80x24', 'ufixed80x32', 'ufixed80x40', 'ufixed80x48', 'ufixed80x56', 'ufixed80x64', 'ufixed80x72', 'ufixed80x80', 'ufixed80x88', 'ufixed80x96', 'ufixed80x104', 'ufixed80x112', 'ufixed80x120', 'ufixed80x128', 'ufixed80x136', 'ufixed80x144', 'ufixed80x152', 'ufixed80x160', 'ufixed80x168', 'ufixed80x176', 'ufixed88x8', 'ufixed88x16', 'ufixed88x24', 'ufixed88x32', 'ufixed88x40', 'ufixed88x48', 'ufixed88x56', 'ufixed88x64', 'ufixed88x72', 'ufixed88x80', 'ufixed88x88', 'ufixed88x96', 'ufixed88x104', 'ufixed88x112', 'ufixed88x120', 'ufixed88x128', 'ufixed88x136', 'ufixed88x144', 'ufixed88x152', 'ufixed88x160', 'ufixed88x168', 'ufixed96x8', 'ufixed96x16', 'ufixed96x24', 'ufixed96x32', 'ufixed96x40', 'ufixed96x48', 'ufixed96x56', 'ufixed96x64', 'ufixed96x72', 'ufixed96x80', 'ufixed96x88', 'ufixed96x96', 'ufixed96x104', 'ufixed96x112', 'ufixed96x120', 'ufixed96x128', 'ufixed96x136', 'ufixed96x144', 'ufixed96x152', 'ufixed96x160', 'ufixed104x8', 'ufixed104x16', 'ufixed104x24', 'ufixed104x32', 'ufixed104x40', 'ufixed104x48', 'ufixed104x56', 'ufixed104x64', 'ufixed104x72', 'ufixed104x80', 'ufixed104x88', 'ufixed104x96', 'ufixed104x104', 'ufixed104x112', 'ufixed104x120', 'ufixed104x128', 'ufixed104x136', 'ufixed104x144', 'ufixed104x152', 'ufixed112x8', 'ufixed112x16', 'ufixed112x24', 'ufixed112x32', 'ufixed112x40', 'ufixed112x48', 'ufixed112x56', 'ufixed112x64', 'ufixed112x72', 'ufixed112x80', 'ufixed112x88', 'ufixed112x96', 'ufixed112x104', 'ufixed112x112', 'ufixed112x120', 'ufixed112x128', 'ufixed112x136', 'ufixed112x144', 'ufixed120x8', 'ufixed120x16', 'ufixed120x24', 'ufixed120x32', 'ufixed120x40', 'ufixed120x48', 'ufixed120x56', 'ufixed120x64', 'ufixed120x72', 'ufixed120x80', 'ufixed120x88', 'ufixed120x96', 'ufixed120x104', 'ufixed120x112', 'ufixed120x120', 'ufixed120x128', 'ufixed120x136', 'ufixed128x8', 'ufixed128x16', 'ufixed128x24', 'ufixed128x32', 'ufixed128x40', 'ufixed128x48', 'ufixed128x56', 'ufixed128x64', 'ufixed128x72', 'ufixed128x80', 'ufixed128x88', 'ufixed128x96', 'ufixed128x104', 'ufixed128x112', 'ufixed128x120', 'ufixed128x128', 'ufixed136x8', 'ufixed136x16', 'ufixed136x24', 'ufixed136x32', 'ufixed136x40', 'ufixed136x48', 'ufixed136x56', 'ufixed136x64', 'ufixed136x72', 'ufixed136x80', 'ufixed136x88', 'ufixed136x96', 'ufixed136x104', 'ufixed136x112', 'ufixed136x120', 'ufixed144x8', 'ufixed144x16', 'ufixed144x24', 'ufixed144x32', 'ufixed144x40', 'ufixed144x48', 'ufixed144x56', 'ufixed144x64', 'ufixed144x72', 'ufixed144x80', 'ufixed144x88', 'ufixed144x96', 'ufixed144x104', 'ufixed144x112', 'ufixed152x8', 'ufixed152x16', 'ufixed152x24', 'ufixed152x32', 'ufixed152x40', 'ufixed152x48', 'ufixed152x56', 'ufixed152x64', 'ufixed152x72', 'ufixed152x80', 'ufixed152x88', 'ufixed152x96', 'ufixed152x104', 'ufixed160x8', 'ufixed160x16', 'ufixed160x24', 'ufixed160x32', 'ufixed160x40', 'ufixed160x48', 'ufixed160x56', 'ufixed160x64', 'ufixed160x72', 'ufixed160x80', 'ufixed160x88', 'ufixed160x96', 'ufixed168x8', 'ufixed168x16', 'ufixed168x24', 'ufixed168x32', 'ufixed168x40', 'ufixed168x48', 'ufixed168x56', 'ufixed168x64', 'ufixed168x72', 'ufixed168x80', 'ufixed168x88', 'ufixed176x8', 'ufixed176x16', 'ufixed176x24', 'ufixed176x32', 'ufixed176x40', 'ufixed176x48', 'ufixed176x56', 'ufixed176x64', 'ufixed176x72', 'ufixed176x80', 'ufixed184x8', 'ufixed184x16', 'ufixed184x24', 'ufixed184x32', 'ufixed184x40', 'ufixed184x48', 'ufixed184x56', 'ufixed184x64', 'ufixed184x72', 'ufixed192x8', 'ufixed192x16', 'ufixed192x24', 'ufixed192x32', 'ufixed192x40', 'ufixed192x48', 'ufixed192x56', 'ufixed192x64', 'ufixed200x8', 'ufixed200x16', 'ufixed200x24', 'ufixed200x32', 'ufixed200x40', 'ufixed200x48', 'ufixed200x56', 'ufixed208x8', 'ufixed208x16', 'ufixed208x24', 'ufixed208x32', 'ufixed208x40', 'ufixed208x48', 'ufixed216x8', 'ufixed216x16', 'ufixed216x24', 'ufixed216x32', 'ufixed216x40', 'ufixed224x8', 'ufixed224x16', 'ufixed224x24', 'ufixed224x32', 'ufixed232x8', 'ufixed232x16', 'ufixed232x24', 'ufixed240x8', 'ufixed240x16', 'ufixed248x8', 'event', 'emit', 'enum', 'let', 'mapping', 'private', 'public', 'external', 'internal', 'indexed', 'anonymous', 'view', 'pure', 'inherited', 'storage', 'memory', 'virtual', 'calldata', 'override', 'abstract', 'payable', 'nonpayable', 'constants', 'immutable', 'assert', 'require', 'revert', 'blockhash', 'keccak256', 'sha256', 'ripemd160', 'ecrecover', 'addmod', 'mulmod', 'selfdestruct', 'type', 'gasleft', 'abi', 'block', 'bytes', 'msg', 'tx', 'Error', 'Panic', 'exceptions', 'true', 'false', 'var', 'import', 'constant', 'fallback', 'receive', 'if', 'else', 'for', 'while', 'do', 'break', 'continue', 'throw', 'returns', 'return', 'suicide', 'new', 'is', 'this', 'super', 'try', 'catch'],
  operators: ['=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=', '&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%', '<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=', '%=', '<<=', '>>=', '>>>='],
  // we include these common regular expressions
  symbols: /[=><!~?:&|+\-*\/\^%]+/,
  escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
  integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,
  floatsuffix: /[fFlL]?/,
  // The main tokenizer for our languages
  tokenizer: {
    root: [// identifiers and keywords
    [/[a-zA-Z_]\w*/, {
      cases: {
        '@keywords': {
          token: 'keyword.$0'
        },
        '@default': 'identifier'
      }
    }], // whitespace
    {
      include: '@whitespace'
    }, // [[ attributes ]].
    [/\[\[.*\]\]/, 'annotation'], // Preprocessor directive
    [/^\s*#\w+/, 'keyword'], // DataTypes
    [/int\d*/, 'keyword'], // delimiters and operators
    [/[{}()\[\]]/, '@brackets'], [/[<>](?!@symbols)/, '@brackets'], [/@symbols/, {
      cases: {
        '@operators': 'delimiter',
        '@default': ''
      }
    }], // numbers
    [/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/, 'number.float'], [/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/, 'number.float'], [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, 'number.hex'], [/0[0-7']*[0-7](@integersuffix)/, 'number.octal'], [/0[bB][0-1']*[0-1](@integersuffix)/, 'number.binary'], [/\d[\d']*\d(@integersuffix)/, 'number'], [/\d(@integersuffix)/, 'number'], // delimiter: after number because of .\d floats
    [/[;,.]/, 'delimiter'], // strings
    [/"([^"\\]|\\.)*$/, 'string.invalid'], // non-teminated string
    [/"/, 'string', '@string'], // characters
    [/'[^\\']'/, 'string'], [/(')(@escapes)(')/, ['string', 'string.escape', 'string']], [/'/, 'string.invalid']],
    whitespace: [[/[ \t\r\n]+/, ''], [/\/\*\*(?!\/)/, 'comment.doc', '@doccomment'], [/\/\*/, 'comment', '@comment'], [/\/\/.*$/, 'comment']],
    comment: [[/[^\/*]+/, 'comment'], [/\*\//, 'comment', '@pop'], [/[\/*]/, 'comment']],
    // Identical copy of comment above, except for the addition of .doc
    doccomment: [[/[^\/*]+/, 'comment.doc'], [/\*\//, 'comment.doc', '@pop'], [/[\/*]/, 'comment.doc']],
    string: [[/[^\\"]+/, 'string'], [/@escapes/, 'string.escape'], [/\\./, 'string.escape.invalid'], [/"/, 'string', '@pop']]
  }
};
exports.language = language;

/***/ }),
/* 2852 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cairoLang = exports.cairoConf = void 0;

/* eslint-disable */
const cairoConf = {
  comments: {
    lineComment: '#'
  },
  brackets: [['{', '}'], ['[', ']'], ['(', ')'], ['%{', '%}']],
  autoClosingPairs: [{
    open: '{',
    close: '}'
  }, {
    open: '[',
    close: ']'
  }, {
    open: '(',
    close: ')'
  }, {
    open: '%{',
    close: '%}'
  }, {
    open: "'",
    close: "'",
    notIn: ['string', 'comment']
  }],
  surroundingPairs: [{
    open: '{',
    close: '}'
  }, {
    open: '[',
    close: ']'
  }, {
    open: '(',
    close: ')'
  }, {
    open: '%{',
    close: '%}'
  }, {
    open: "'",
    close: "'"
  }]
};
exports.cairoConf = cairoConf;
const cairoLang = {
  defaultToken: '',
  tokenPostfix: '.cairo',
  brackets: [{
    token: 'delimiter.curly',
    open: '{',
    close: '}'
  }, {
    token: 'delimiter.parenthesis',
    open: '(',
    close: ')'
  }, {
    token: 'delimiter.square',
    open: '[',
    close: ']'
  }, {
    token: 'delimiter.curly',
    open: '%{',
    close: '%}'
  }],
  keywords: [// control
  'if', 'else', 'end', // meta
  'alloc_locals', 'as', 'assert', 'cast', 'const', 'dw', 'felt', 'from', 'func', 'import', 'let', 'local', 'member', 'nondet', 'return', 'static_assert', 'struct', 'tempvar', 'with_attr', 'with', // register
  'ap', 'fp', // opcode
  'call', 'jmp', 'ret', 'abs', 'rel'],
  operators: ['=', ':', '==', '++', '+', '-', '*', '**', '/', '&', '%', '_'],
  // we include these common regular expressions
  symbols: /[=><!~?:&|+\-*\/\^%]+/,
  numberDecimal: /[+-]?[0-9]+/,
  numberHex: /[+-]?0x[0-9a-fA-F]+/,
  // The main tokenizer for our languages
  tokenizer: {
    root: [// identifiers and keywords
    [/[a-zA-Z_]\w*/, {
      cases: {
        '@keywords': {
          token: 'keyword.$0'
        },
        '@default': 'identifier'
      }
    }], // whitespace
    {
      include: '@whitespace'
    }, // directives
    [/^%[a-zA-Z]\w*/, 'tag'], // delimiters and operators
    [/[{}()\[\]]/, '@brackets'], [/[<>](?!@symbols)/, '@brackets'], [/@symbols/, {
      cases: {
        '@operators': 'delimiter',
        '@default': ''
      }
    }], // numbers
    [/(@numberHex)/, 'number.hex'], [/(@numberDecimal)/, 'number'], // strings
    [/'[^']*'/, 'string']],
    whitespace: [[/\s+/, 'white'], [/(^#.*$)/, 'comment']]
  }
};
exports.cairoLang = cairoLang;

/***/ }),
/* 2853 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2854);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2854 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".hover-row {\n    white-space: pre;\n    margin-left : 10px;\n    background : var(--light);    \n    font-weight : bold;\n    font-family : monospace;\n    padding : 10px;\n    border-radius : 10px;\n    height: auto;\n    width: auto;\n}\n\n.monaco-hover .markdown-hover > .hover-contents:not(.code-hover-contents) {\n    max-width: none !important;\n    word-wrap: break-word;\n}\n\n.contextview {\n    opacity: 1;\n    position: absolute;\n}\n\n.inline-class {\n    background: var(--info) !important;\n    color: var(--white) !important;\n    filter: opacity(0.5);\n    font-weight: bolder;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLWVkaXRvci5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7SUFDSSxnQkFBZ0I7SUFDaEIsa0JBQWtCO0lBQ2xCLHlCQUF5QjtJQUN6QixrQkFBa0I7SUFDbEIsdUJBQXVCO0lBQ3ZCLGNBQWM7SUFDZCxvQkFBb0I7SUFDcEIsWUFBWTtJQUNaLFdBQVc7QUFDZjs7QUFFQTtJQUNJLDBCQUEwQjtJQUMxQixxQkFBcUI7QUFDekI7O0FBRUE7SUFDSSxVQUFVO0lBQ1Ysa0JBQWtCO0FBQ3RCOztBQUVBO0lBQ0ksa0NBQWtDO0lBQ2xDLDhCQUE4QjtJQUM5QixvQkFBb0I7SUFDcEIsbUJBQW1CO0FBQ3ZCIiwiZmlsZSI6InJlbWl4LXVpLWVkaXRvci5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuaG92ZXItcm93IHtcbiAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgIG1hcmdpbi1sZWZ0IDogMTBweDtcbiAgICBiYWNrZ3JvdW5kIDogdmFyKC0tbGlnaHQpOyAgICBcbiAgICBmb250LXdlaWdodCA6IGJvbGQ7XG4gICAgZm9udC1mYW1pbHkgOiBtb25vc3BhY2U7XG4gICAgcGFkZGluZyA6IDEwcHg7XG4gICAgYm9yZGVyLXJhZGl1cyA6IDEwcHg7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIHdpZHRoOiBhdXRvO1xufVxuXG4ubW9uYWNvLWhvdmVyIC5tYXJrZG93bi1ob3ZlciA+IC5ob3Zlci1jb250ZW50czpub3QoLmNvZGUtaG92ZXItY29udGVudHMpIHtcbiAgICBtYXgtd2lkdGg6IG5vbmUgIWltcG9ydGFudDtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG59XG5cbi5jb250ZXh0dmlldyB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XG5cbi5pbmxpbmUtY2xhc3Mge1xuICAgIGJhY2tncm91bmQ6IHZhcigtLWluZm8pICFpbXBvcnRhbnQ7XG4gICAgY29sb3I6IHZhcigtLXdoaXRlKSAhaW1wb3J0YW50O1xuICAgIGZpbHRlcjogb3BhY2l0eSgwLjUpO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG59Il19 */", '', '']]

/***/ }),
/* 2855 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadTypes = void 0;

var _remixPluginTypes = __webpack_require__(2856);

const loadTypes = async monaco => {
  // ethers.js
  // @ts-ignore
  const ethersAbi = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-abi-lib-index-d-ts */ 3).then(__webpack_require__.bind(null, 2901));
  ethersAbi.default = ethersAbi.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersAbi.default, `file:///node_modules/@types/@ethersproject_abi/index.d.ts`); // @ts-ignore

  const ethersAbstract = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-abstract-provider-lib-index-d-ts */ 4).then(__webpack_require__.bind(null, 2902));
  ethersAbstract.default = ethersAbstract.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersAbstract.default, `file:///node_modules/@types/@ethersproject_abstract-provider/index.d.ts`); // @ts-ignore

  const ethersSigner = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-abstract-signer-lib-index-d-ts */ 5).then(__webpack_require__.bind(null, 2903));
  ethersSigner.default = ethersSigner.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersSigner.default, `file:///node_modules/@types/@ethersproject_abstract-signer/index.d.ts`); // @ts-ignore

  const ethersAddress = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-address-lib-index-d-ts */ 6).then(__webpack_require__.bind(null, 2904));
  ethersAddress.default = ethersAddress.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersAddress.default, `file:///node_modules/@types/@ethersproject_address/index.d.ts`); // @ts-ignore

  const ethersBase64 = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-base64-lib-index-d-ts */ 7).then(__webpack_require__.bind(null, 2905));
  ethersBase64.default = ethersBase64.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersBase64.default, `file:///node_modules/@types/@ethersproject_base64/index.d.ts`); // @ts-ignore

  const ethersBasex = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-basex-lib-index-d-ts */ 8).then(__webpack_require__.bind(null, 2906));
  ethersBasex.default = ethersBasex.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersBasex.default, `file:///node_modules/@types/@ethersproject_basex/index.d.ts`); // @ts-ignore

  const ethersBignumber = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-bignumber-lib-index-d-ts */ 9).then(__webpack_require__.bind(null, 2907));
  ethersBignumber.default = ethersBignumber.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersBignumber.default, `file:///node_modules/@types/@ethersproject_bignumber/index.d.ts`); // @ts-ignore

  const ethersBytes = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-bytes-lib-index-d-ts */ 10).then(__webpack_require__.bind(null, 2908));
  ethersBytes.default = ethersBytes.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersBytes.default, `file:///node_modules/@types/@ethersproject_bytes/index.d.ts`); // @ts-ignore

  const ethersConstants = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-constants-lib-index-d-ts */ 11).then(__webpack_require__.bind(null, 2909));
  ethersConstants.default = ethersConstants.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersConstants.default, `file:///node_modules/@types/@ethersproject_constants/index.d.ts`); // @ts-ignore

  const ethersContracts = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-contracts-lib-index-d-ts */ 12).then(__webpack_require__.bind(null, 2910));
  ethersContracts.default = ethersContracts.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersContracts.default, `file:///node_modules/@types/@ethersproject_contracts/index.d.ts`); // @ts-ignore

  const ethersHash = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-hash-lib-index-d-ts */ 13).then(__webpack_require__.bind(null, 2911));
  ethersHash.default = ethersHash.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersHash.default, `file:///node_modules/@types/@ethersproject_hash/index.d.ts`); // @ts-ignore

  const ethersHdnode = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-hdnode-lib-index-d-ts */ 14).then(__webpack_require__.bind(null, 2912));
  ethersHdnode.default = ethersHdnode.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersHdnode.default, `file:///node_modules/@types/@ethersproject_hdnode/index.d.ts`); // @ts-ignore

  const ethersJsonWallets = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-json-wallets-lib-index-d-ts */ 15).then(__webpack_require__.bind(null, 2913));
  ethersJsonWallets.default = ethersJsonWallets.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersJsonWallets.default, `file:///node_modules/@types/@ethersproject_json-wallets/index.d.ts`); // @ts-ignore

  const ethersKeccak256 = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-keccak256-lib-index-d-ts */ 16).then(__webpack_require__.bind(null, 2914));
  ethersKeccak256.default = ethersKeccak256.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersKeccak256.default, `file:///node_modules/@types/@ethersproject_keccak256/index.d.ts`); // @ts-ignore

  const ethersLogger = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-logger-lib-index-d-ts */ 17).then(__webpack_require__.bind(null, 2915));
  ethersLogger.default = ethersLogger.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersLogger.default, `file:///node_modules/@types/@ethersproject_logger/index.d.ts`); // @ts-ignore

  const ethersNetworks = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-networks-lib-index-d-ts */ 18).then(__webpack_require__.bind(null, 2916));
  ethersNetworks.default = ethersNetworks.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersNetworks.default, `file:///node_modules/@types/@ethersproject_networks/index.d.ts`); // @ts-ignore

  const ethersPbkdf2 = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-pbkdf2-lib-index-d-ts */ 19).then(__webpack_require__.bind(null, 2917));
  ethersPbkdf2.default = ethersPbkdf2.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersPbkdf2.default, `file:///node_modules/@types/@ethersproject_pbkdf2/index.d.ts`); // @ts-ignore

  const ethersProperties = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-properties-lib-index-d-ts */ 20).then(__webpack_require__.bind(null, 2918));
  ethersProperties.default = ethersProperties.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersProperties.default, `file:///node_modules/@types/@ethersproject_properties/index.d.ts`); // @ts-ignore

  const ethersProviders = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-providers-lib-index-d-ts */ 21).then(__webpack_require__.bind(null, 2919));
  ethersProviders.default = ethersProviders.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersProviders.default, `file:///node_modules/@types/@ethersproject_providers/index.d.ts`); // @ts-ignore

  const ethersRandom = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-random-lib-index-d-ts */ 22).then(__webpack_require__.bind(null, 2920));
  ethersRandom.default = ethersRandom.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersRandom.default, `file:///node_modules/@types/@ethersproject_random/index.d.ts`); // @ts-ignore

  const ethersRlp = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-rlp-lib-index-d-ts */ 23).then(__webpack_require__.bind(null, 2921));
  ethersRlp.default = ethersRlp.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersRlp.default, `file:///node_modules/@types/@ethersproject_rlp/index.d.ts`); // @ts-ignore

  const ethersSha2 = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-sha2-lib-index-d-ts */ 24).then(__webpack_require__.bind(null, 2922));
  ethersSha2.default = ethersSha2.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersSha2.default, `file:///node_modules/@types/@ethersproject_sha2/index.d.ts`); // @ts-ignore

  const ethersSingningkey = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-signing-key-lib-index-d-ts */ 25).then(__webpack_require__.bind(null, 2923));
  ethersSingningkey.default = ethersSingningkey.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersSingningkey.default, `file:///node_modules/@types/@ethersproject_signing-key/index.d.ts`); // @ts-ignore

  const ethersSolidity = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-solidity-lib-index-d-ts */ 26).then(__webpack_require__.bind(null, 2924));
  ethersSolidity.default = ethersSolidity.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersSolidity.default, `file:///node_modules/@types/@ethersproject_solidity/index.d.ts`); // @ts-ignore

  const ethersStrings = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-strings-lib-index-d-ts */ 27).then(__webpack_require__.bind(null, 2925));
  ethersStrings.default = ethersStrings.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersStrings.default, `file:///node_modules/@types/@ethersproject_strings/index.d.ts`); // @ts-ignore

  const ethersTransactions = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-transactions-lib-index-d-ts */ 28).then(__webpack_require__.bind(null, 2926));
  ethersTransactions.default = ethersTransactions.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersTransactions.default, `file:///node_modules/@types/@ethersproject_transactions/index.d.ts`); // @ts-ignore

  const ethersUnits = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-units-lib-index-d-ts */ 29).then(__webpack_require__.bind(null, 2927));
  ethersUnits.default = ethersUnits.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersUnits.default, `file:///node_modules/@types/@ethersproject_units/index.d.ts`); // @ts-ignore

  const ethersWallet = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-wallet-lib-index-d-ts */ 30).then(__webpack_require__.bind(null, 2928));
  ethersWallet.default = ethersWallet.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersWallet.default, `file:///node_modules/@types/@ethersproject_wallet/index.d.ts`); // @ts-ignore

  const ethersWeb = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-web-lib-index-d-ts */ 31).then(__webpack_require__.bind(null, 2929));
  ethersWeb.default = ethersWeb.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersWeb.default, `file:///node_modules/@types/@ethersproject_web/index.d.ts`); // @ts-ignore

  const ethersWordlists = await __webpack_require__.e(/* import() | raw-loader!-ethersproject-wordlists-lib-index-d-ts */ 32).then(__webpack_require__.bind(null, 2930));
  ethersWordlists.default = ethersWordlists.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethersWordlists.default, `file:///node_modules/@types/@ethersproject_wordlists/index.d.ts`); // @ts-ignore

  const versionEthers = await __webpack_require__.e(/* import() | raw-loader!ethers-lib-_version-d-ts */ 33).then(__webpack_require__.bind(null, 2931));
  versionEthers.default = versionEthers.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(versionEthers.default, `file:///node_modules/@types/_version-ethers-lib/index.d.ts`); // @ts-ignore

  const utilEthers = await __webpack_require__.e(/* import() | raw-loader!ethers-lib-utils-d-ts */ 36).then(__webpack_require__.bind(null, 2932));
  utilEthers.default = utilEthers.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(utilEthers.default, `file:///node_modules/@types/utils-ethers-lib/index.d.ts`); // @ts-ignore

  const ethers = await __webpack_require__.e(/* import() | raw-loader!ethers-lib-ethers-d-ts */ 34).then(__webpack_require__.bind(null, 2933));
  ethers.default = ethers.default.replace(/.\/utils/g, 'utils-ethers-lib');
  ethers.default = ethers.default.replace(/.\/_version/g, '_version-ethers-lib');
  ethers.default = ethers.default.replace(/.\/ethers/g, 'ethers-lib');
  ethers.default = ethers.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(ethers.default, `file:///node_modules/@types/ethers-lib/index.d.ts`); // @ts-ignore

  const indexEthers = await __webpack_require__.e(/* import() | raw-loader!ethers-lib-index-d-ts */ 35).then(__webpack_require__.bind(null, 2934));
  indexEthers.default = indexEthers.default.replace(/.\/ethers/g, 'ethers-lib');
  indexEthers.default = indexEthers.default.replace(/@ethersproject\//g, '@ethersproject_');
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexEthers.default, `file:///node_modules/@types/ethers/index.d.ts`); // Web3
  // @ts-ignore

  const indexWeb3 = await __webpack_require__.e(/* import() | raw-loader!web3-types-index-d-ts */ 44).then(__webpack_require__.bind(null, 2935));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3.default, `file:///node_modules/@types/web3/index.d.ts`); // @ts-ignore

  const indexWeb3Bzz = await __webpack_require__.e(/* import() | raw-loader!web3-bzz-types-index-d-ts */ 37).then(__webpack_require__.bind(null, 2936));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Bzz.default, `file:///node_modules/@types/web3-bzz/index.d.ts`); // @ts-ignore

  const indexWeb3Core = await __webpack_require__.e(/* import() | raw-loader!web3-core-types-index-d-ts */ 38).then(__webpack_require__.bind(null, 2937));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Core.default, `file:///node_modules/@types/web3-core/index.d.ts`); // @ts-ignore

  const indexWeb3Eth = await __webpack_require__.e(/* import() | raw-loader!web3-eth-types-index-d-ts */ 41).then(__webpack_require__.bind(null, 2938));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Eth.default, `file:///node_modules/@types/web3-eth/index.d.ts`); // @ts-ignore

  const indexWeb3Personal = await __webpack_require__.e(/* import() | raw-loader!web3-eth-personal-types-index-d-ts */ 40).then(__webpack_require__.bind(null, 2939));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Personal.default, `file:///node_modules/@types/web3-eth-personal/index.d.ts`); // @ts-ignore

  const indexWeb3Contract = await __webpack_require__.e(/* import() | raw-loader!web3-eth-contract-types-index-d-ts */ 39).then(__webpack_require__.bind(null, 2940));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Contract.default, `file:///node_modules/@types/web3-eth-contract/index.d.ts`); // @ts-ignore

  const indexWeb3Net = await __webpack_require__.e(/* import() | raw-loader!web3-net-types-index-d-ts */ 42).then(__webpack_require__.bind(null, 2941));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Net.default, `file:///node_modules/@types/web3-net/index.d.ts`); // @ts-ignore

  const indexWeb3Shh = await __webpack_require__.e(/* import() | raw-loader!web3-shh-types-index-d-ts */ 43).then(__webpack_require__.bind(null, 2942));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Shh.default, `file:///node_modules/@types/web3-shh/index.d.ts`); // @ts-ignore

  const indexWeb3Util = await __webpack_require__.e(/* import() | raw-loader!web3-utils-types-index-d-ts */ 45).then(__webpack_require__.bind(null, 2943));
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexWeb3Util.default, `file:///node_modules/@types/web3-utils/index.d.ts`); // remix

  const indexRemixApi = _remixPluginTypes.remixTypes + `\n
    declare global {
        const remix: PluginClient;
        const web3Provider;
    }
    `;
  monaco.languages.typescript.typescriptDefaults.addExtraLib(indexRemixApi);
  console.log('loaded monaco types');
};

exports.loadTypes = loadTypes;

/***/ }),
/* 2856 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remixTypes = void 0;
const remixTypes = `
/// <reference types="node" />

import { EventEmitter } from 'events';

declare type ABIDescription = FunctionDescription | EventDescription

declare interface ABIParameter {
    /** The name of the parameter */
    name: string
    /** The canonical type of the parameter */
    type: ABITypeParameter
    /** Used for tuple types */
    components?: ABIParameter[]
}

declare type ABITypeParameter =
| 'uint'
| 'uint[]' // TODO : add <M>
| 'int'
| 'int[]' // TODO : add <M>
| 'address'
| 'address[]'
| 'bool'
| 'bool[]'
| 'fixed'
| 'fixed[]' // TODO : add <M>
| 'ufixed'
| 'ufixed[]' // TODO : add <M>
| 'bytes'
| 'bytes[]' // TODO : add <M>
| 'function'
| 'function[]'
| 'tuple'
| 'tuple[]'
| string

declare interface Annotation {
    row: number;
    column: number;
    text: string;
    type: "error" | "warning" | "info";
}

declare interface Api {
    events: {
        [key: string]: (...args: any[]) => void
    } & StatusEvents
    methods: {
        [key: string]: (...args: any[]) => void
    }
}

/** A map of Api used to describe all the plugin's api in the project */
declare type ApiMap = Readonly<Record<string, Api>>

declare interface AstNode {
    absolutePath?: string
    exportedSymbols?: Object
    id: number
    nodeType: string
    nodes?: Array<AstNode>
    src: string
    literals?: Array<string>
    file?: string
    scope?: number
    sourceUnit?: number
    symbolAliases?: Array<string>
    [x: string]: any
}

declare interface AstNodeAtt {
    operator?: string
    string?: null
    type?: string
    value?: string
    constant?: boolean
    name?: string
    public?: boolean
    exportedSymbols?: Object
    argumentTypes?: null
    absolutePath?: string
    [x: string]: any
}

declare interface AstNodeLegacy {
    id: number
    name: string
    src: string
    children?: Array<AstNodeLegacy>
    attributes?: AstNodeAtt
}

declare interface BytecodeObject {
    /** The bytecode as a hex string. */
    object: string
    /** Opcodes list */
    opcodes: string
    /** The source mapping as a string. See the source mapping definition. */
    sourceMap: string
    /** If given, this is an unlinked object. */
    linkReferences?: {
        [contractName: string]: {
            /** Byte offsets into the bytecode. */
            [library: string]: { start: number; length: number }[]
        }
    }
}

declare interface CompilationError {
    /** Location within the source file */
    sourceLocation?: {
        file: string
        start: number
        end: number
    }
    /** Error type */
    type: CompilationErrorType
    /** Component where the error originated, such as "general", "ewasm", etc. */
    component: 'general' | 'ewasm' | string
    severity: 'error' | 'warning'
    message: string
    /** the message formatted with source location */
    formattedMessage?: string
}

declare type CompilationErrorType =
| 'JSONError'
| 'IOError'
| 'ParserError'
| 'DocstringParsingError'
| 'SyntaxError'
| 'DeclarationError'
| 'TypeError'
| 'UnimplementedFeatureError'
| 'InternalCompilerError'
| 'Exception'
| 'CompilerError'
| 'FatalError'
| 'Warning'

declare interface CompilationFileSources {
    [fileName: string]:
        {
        // Optional: keccak256 hash of the source file
        keccak256?: string,
        // Required (unless "urls" is used): literal contents of the source file
        content: string,
        urls?: string[]
    }
}

declare interface CompilationResult {
    /** not present if no errors/warnings were encountered */
    errors?: CompilationError[]
    /** This contains the file-level outputs. In can be limited/filtered by the outputSelection settings */
    sources: {
        [contractName: string]: CompilationSource
    }
    /** This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings */
    contracts: {
        /** If the language used has no contract names, this field should equal to an empty string. */
        [fileName: string]: {
            [contract: string]: CompiledContract
        }
    }
}

declare interface CompilationSource {
    /** Identifier of the source (used in source maps) */
    id: number
    /** The AST object */
    ast: AstNode
    /** The legacy AST object */
    legacyAST: AstNodeLegacy
}

declare interface CompiledContract {
    /** The Ethereum Contract ABI. If empty, it is represented as an empty array. */
    abi: ABIDescription[]
    // See the Metadata Output documentation (serialised JSON string)
    metadata: string
    /** User documentation (natural specification) */
    userdoc: UserDocumentation
    /** Developer documentation (natural specification) */
    devdoc: DeveloperDocumentation
    /** Intermediate representation (string) */
    ir: string
    /** EVM-related outputs */
    evm: {
        assembly: string
        legacyAssembly: {}
        /** Bytecode and related details. */
        bytecode: BytecodeObject
        deployedBytecode: BytecodeObject
        /** The list of function hashes */
        methodIdentifiers: {
            [functionIdentifier: string]: string
        }
        // Function gas estimates
        gasEstimates: {
            creation: {
                codeDepositCost: string
                executionCost: 'infinite' | string
                totalCost: 'infinite' | string
            }
            external: {
                [functionIdentifier: string]: string
            }
            internal: {
                [functionIdentifier: string]: 'infinite' | string
            }
        }
    }
    /** eWASM related outputs */
    ewasm: {
        /** S-expressions format */
        wast: string
        /** Binary format (hex string) */
        wasm: string
    }
}

declare interface CondensedCompilationInput {
    language: 'Solidity' | 'Vyper' | 'lll' | 'assembly' | 'yul'
    optimize: boolean
    /** e.g: 0.6.8+commit.0bbfe453 */
    version: string
    evmVersion?: 'berlin' | 'istanbul' | 'petersburg' | 'constantinople' | 'byzantium' | 'spuriousDragon' | 'tangerineWhistle' | 'homestead'
}

declare interface ContentImport {
    content: any
    cleanUrl: string
    type: 'github' | 'http' | 'https' | 'swarm' | 'ipfs'
    url: string
}

declare interface customAction {
    id: string,
    name: string,
    type: customActionType[],
    path: string[],
    extension: string[],
    pattern: string[],
    sticky?: boolean,
    label?: string
}

declare type customActionType = 'file' | 'folder'

/** @deprecated: current version in Remix IDE. To improve to match standard JSON RPC methods */
declare interface CustomNetwork {
    id?: string
    name: string
    url: string
}

export declare const defaultOptions: Partial<PluginOptions<any>>;

declare interface DeveloperDocumentation {
    author: string
    title: string
    details: string
    methods: DevMethodList
}

declare interface DevMethodDoc {
    author: string
    details: string
    return: string
    returns: {
        [param: string]: string
    }
    params: {
        [param: string]: string
    }
}

declare interface DevMethodList {
    [functionIdentifier: string]: DevMethodDoc
}

declare type EventCallback<T extends Api, K extends EventKey<T>> = T extends Api
? T['events'][K]
: (...payload: any[]) => void

declare interface EventDescription {
    type: 'event'
    name: string
    inputs: ABIParameter &
        {
        /** true if the field is part of the log’s topics, false if it one of the log’s data segment. */
        indexed: boolean
    }[]
    /** true if the event was declared as anonymous. */
    anonymous: boolean
}

declare type EventKey<T extends Api> = Extract<keyof T['events'], string>

declare type EventParams<T extends Api, K extends EventKey<T>> = T extends Api
? Parameters<T['events'][K]>
: any[]

declare interface Folder {
    [path: string]: {
        isDirectory: boolean
    }
}

declare interface FunctionDescription {
    /** Type of the method. default is 'function' */
    type?: 'function' | 'constructor' | 'fallback'
    /** The name of the function. Constructor and fallback functions never have a name */
    name?: string
    /** List of parameters of the method. Fallback functions don’t have inputs. */
    inputs?: ABIParameter[]
    /** List of the output parameters for the method, if any */
    outputs?: ABIParameter[]
    /** State mutability of the method */
    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable'
    /** true if function accepts Ether, false otherwise. Default is false */
    payable?: boolean
    /** true if function is either pure or view, false otherwise. Default is false  */
    constant?: boolean
}

declare type GetPluginService<S extends Record<string, any>> = S extends IPluginService<infer I> ? S : IPluginService<S>

/** Throw an error if client try to send a message before connection */
export declare function handleConnectionError(devMode?: Partial<PluginDevMode>): void;

declare interface HighLightOptions {
    focus: boolean
}

declare interface HighlightPosition {
    start: {
        line: number
        column: number
    }
    end: {
        line: number
        column: number
    }
}

declare interface ICompiler extends Api {
    events: {
        compilationFinished: (
        fileName: string,
        source: CompilationFileSources,
        languageVersion: string,
        data: CompilationResult
        ) => void
    } & StatusEvents
    methods: {
        getCompilationResult(): lastCompilationResult
        compile(fileName: string): void
        setCompilerConfig(settings: CondensedCompilationInput): void
        compileWithParameters(targets: SourcesInput, settings: CondensedCompilationInput): lastCompilationResult
    }
}

declare interface IContentImport {
    events: {} & StatusEvents
    methods: {
        resolve(path: string): ContentImport
        resolveAndSave (url:string, targetPath: string): string
    }
}

declare interface IDgitSystem {
    events: StatusEvents
    methods: {
        init(): void;
        add(cmd: any): string;
        commit(cmd: any): string;
        status(cmd: any): any[];
        rm(cmd: any): string;
        log(cmd: any): any[];
        lsfiles(cmd: any): any[];
        readblob(cmd: any): { oid: string, blob: Uint8Array }
        resolveref(cmd: any): string
        branch(cmd: any): void
        checkout(cmd: any): void
        branches(): string[]
        currentbranch(): string
        push(cmd: any): string
        pull(cmd: any): void
        setIpfsConfig(config:any): boolean
        zip():void
        setItem(name:string, content:string):void
        getItem(name: string): string
        import(cmd: any): void
        export(cmd: any): void
        remotes(): any[]
        addremote(cmd: any): void
        delremote(cmd: any): void
        clone(cmd: any): void
        localStorageUsed(): any
    };
}

declare interface IEditor {
    events: StatusEvents
    methods: {
        highlight(
        position: HighlightPosition,
        filePath: string,
        hexColor: string,
        opt?: HighLightOptions
        ): void
        discardHighlight(): void
        discardHighlightAt(line: number, filePath: string): void
        addAnnotation(annotation: Annotation): void
        clearAnnotations(): void
        gotoLine(line:number, col:number): void
    }

}

declare interface IFilePanel {
    events: {
        setWorkspace: (workspace:any) => void
        workspaceRenamed: (workspace:any) => void
        workspaceDeleted: (workspace:any) => void
        workspaceCreated: (workspace:any) => void
        customAction: (cmd: customAction) => void
    } & StatusEvents
    methods: {
        getCurrentWorkspace(): { name: string, isLocalhost: boolean, absolutePath: string }
        getWorkspaces(): string[]
        deleteWorkspace(name:string): void
        createWorkspace(name:string, isEmpty:boolean): void
        renameWorkspace(oldName:string, newName:string): void
        registerContextMenuItem(cmd: customAction): void
    }
}

declare interface IFileSystem {
    events: {
        currentFileChanged: (file: string) => void
        fileSaved: (file: string) => void
        fileAdded: (file: string) => void
        folderAdded: (file: string) => void
        fileRemoved: (file: string) => void
        fileClosed: (file: string) => void
        noFileSelected: ()=> void
        fileRenamed: (oldName: string, newName:string, isFolder: boolean) => void
    } & StatusEvents
    methods: {
        /** Open the content of the file in the context (eg: Editor) */
        open(path: string): void
        /** Set the content of a specific file */
        writeFile(path: string, data: string): void
        /** Return the content of a specific file */
        readFile(path: string): string
        /** Change the path of a file */
        rename(oldPath: string, newPath: string): void
        /** Upsert a file with the content of the source file */
        copyFile(src: string, dest: string): void
        /** Create a directory */
        mkdir(path: string): void
        /** Get the list of files in the directory */
        readdir(path: string): string[]
        /** Removes a file or directory recursively */
        remove(path: string): void
        /** Get the name of the file currently focused if any */
        getCurrentFile(): string
        /** close all files */
        closeAllFiles(): void
        /** close a file */
        closeFile(): void
        // Old API
        /** @deprecated Use readdir */
        getFolder(path: string): Folder
        /** @deprecated Use readFile */
        getFile(path: string): string
        /** @deprecated Use writeFile */
        setFile(path: string, content: string): void
        /** @deprecated Use open */
        switchFile(path: string): void
    }
}

/** @deprecated: current version in Remix IDE. To improve to match standard JSON RPC methods */
declare interface INetwork {
    events: {
        providerChanged: (provider: NetworkProvider) => void
    } & StatusEvents
    methods: {
        getNetworkProvider(): NetworkProvider
        detectNetwork(): Network | Partial<CustomNetwork>
        getEndpoint(): string
        addNetwork(network: CustomNetwork): void
        removeNetwork(name: string): void
    }
}

declare interface IPluginManager {
    events: {
        profileUpdated(profile: Profile): void
        profileAdded(profile: Profile): void
        pluginDeactivated(profile: Profile): void
        pluginActivated(profile: Profile): void
    } & StatusEvents
    methods: {
        getProfile(name: string): Promise<Profile>
        updateProfile(profile: Partial<Profile>): any
        activatePlugin(name: string): any
        deactivatePlugin(name: string): any
        isActive(name: string): boolean
        canCall(from: string, to: string, method: string, message?: string): any
    }
}

declare type IPluginService<T extends Record<string, any> = any> = {
    methods: string[]
    readonly path: string
} & T

declare interface IRemixApi {
    manager: IPluginManager,
    solidity: ICompiler
    fileManager: IFileSystem
    filePanel: IFilePanel
    dGitProvider: IDgitSystem
    solidityUnitTesting: IUnitTesting
    editor: IEditor
    network: INetwork
    udapp: IUdapp
    contentImport: IContentImport
    settings: ISettings
    theme: ITheme
    vscodeExtAPI: IVScodeExtAPI
    terminal: ITerminal
}

declare interface ISettings {
    events: {} & StatusEvents
    methods: {
        getGithubAccessToken(): string
    }
}

declare interface ITerminal {
    events: {   
    } & StatusEvents
    methods: {
        log(message: TerminalMessage): void
    }
}

declare interface ITheme {
    events: {
        themeChanged: (theme: Theme) => void
    } & StatusEvents
    methods: {
        currentTheme(): Theme
    }
}

declare interface IUdapp {
    events: {
        newTransaction: (transaction: RemixTxEvent) => void
    } & StatusEvents
    methods: {
        sendTransaction(tx: RemixTx): RemixTxReceipt
        getAccounts(): string[]
        createVMAccount(vmAccount: VMAccount): string
        getSettings(): UdappSettings
        setEnvironmentMode(env: 'vm' | 'injected' | 'web3'): void
    }
}

declare interface IUnitTesting {
    events: {} & StatusEvents
    methods: {
        testFromPath(path: string): UnitTestResult
        testFromSource(sourceCode: string): UnitTestResult
    }
}

declare interface IVScodeExtAPI {
    events: {
    } & StatusEvents
    methods: {
        executeCommand(extension: string, command: string, payload?: any[]): any
    }
}

declare interface lastCompilationResult {
    data: CompilationResult | null
    source: SourceWithTarget | null | undefined
}

declare type MethodKey<T extends Api> = Extract<keyof T['methods'], string>

declare type MethodParams<T extends Api, K extends MethodKey<T>> = T extends Api
? Parameters<T['methods'][K]>
: any[]

declare type Network =
| { id: '1', name: 'Main' }
| { id: '2', name: 'Morden (deprecated)' }
| { id: '3', name: 'Ropsten' }
| { id: '4', name: 'Rinkeby' }
| { id: '5', name: 'Goerli' }
| { id: '42', name: 'Kovan' }

/** @deprecated: current version in Remix IDE. To improve to match standard JSON RPC methods */
declare type NetworkProvider = 'vm' | 'injected' | 'web3'

declare interface PluginBase<T extends Api = any, App extends ApiMap = any> {
    methods: string[],
    activateService: Record<string, () => Promise<IPluginService>>
    /** Listen on an event from another plugin */
    on<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(
    name: Name,
    key: Key,
    cb: EventCallback<App[Name], Key>,
    ): void

    /** Listen one time on an event from another plugin, then remove event listener */
    once<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(
    name: Name,
    key: Key,
    cb: EventCallback<App[Name], Key>,
    ): void

    /** Stop listening on an event from another plugin */
    off<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(
    name: Name,
    key: Key,
    ): void

    /** Call a method of another plugin */
    call<Name extends Extract<keyof App, string>, Key extends MethodKey<App[Name]>>(
    name: Name,
    key: Key,
    ...payload: MethodParams<App[Name], Key>
    ): Promise<any>

    /** Clear calls in queue of a plugin called by plugin */
    cancel<Name extends Extract<keyof App, string>, Key extends MethodKey<App[Name]>>(
    name: Name,
    key: Key,
    ): void

    /** Emit an event */
    emit<Key extends EventKey<T>>(key: Key, ...payload: EventParams<T, Key>): void
}

export declare class PluginClient<T extends Api = any, App extends ApiMap = RemixApi> implements PluginBase<T, App> {
    private id;
    isLoaded: boolean;
    events: EventEmitter;
    currentRequest: PluginRequest;
    options: PluginOptions<App>;
    name: string;
    methods: string[];
    activateService: Record<string, () => Promise<any>>;
    onActivation?(): void;
    constructor(options?: Partial<PluginOptions<App>>);
    onload(cb?: () => void): Promise<void>;
    /**
     * Ask the plugin manager if current request can call a specific method
     * @param method The method to call
     * @param message An optional message to show to the user
     */
    askUserPermission(method: MethodKey<T>, message?: string): Promise<boolean>;
    /**
     * Called before deactivating the plugin
     * @param from profile of plugin asking to deactivate
     * @note PluginManager will always be able to deactivate
     */
    canDeactivate(from: Profile): boolean;
    /** Make a call to another plugin */
    call<Name extends Extract<keyof App, string>, Key extends MethodKey<App[Name]>>(name: Name, key: Key, ...payload: MethodParams<App[Name], Key>): Promise<ReturnType<App[Name]['methods'][Key]>>;
    /** Listen on event from another plugin */
    on<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(name: Name, key: Key, cb: EventCallback<App[Name], Key>): void;
    /** Listen once on event from another plugin */
    once<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(name: Name, key: Key, cb: EventCallback<App[Name], Key>): void;
    /** Remove all listeners on an event from an external plugin */
    off<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(name: Name, key: Key): void;
    /** Expose an event for the IDE */
    emit<Key extends EventKey<T>>(key: Key, ...payload: EventParams<T, Key>): void;
    /**
     * Create a service under the client node
     * @param name The name of the service
     * @param service The service
     */
    createService<S extends Record<string, any>, Service extends IPluginService<S>>(name: string, service: Service): Promise<GetPluginService<Service>>;
    /**
     * Prepare a service to be lazy loaded
     * @param name The name of the subservice inside this service
     * @param factory A function to create the service on demand
     */
    prepareService<S extends Record<string, any>>(name: string, factory: () => S): () => Promise<IPluginService<S>>;
}

export declare interface PluginDevMode {
    /** Port for localhost */
    port: number | string;
    origins: string | string[];
}

/** Options of the plugin client */
export declare interface PluginOptions<T extends ApiMap> {
    customTheme: boolean;
    /** define a set of custom apis to implements on the client  */
    customApi: ProfileMap<T>;
    /**
     * Allow a set of origins
     * You can either a list of origin or a url with a link of origins
     */
    allowOrigins: string | string[];
    /**
     * options only available for dev mode
     * @deprecated use allowOrigins instead if you want to limit the parent origin
     */
    devMode: Partial<PluginDevMode>;
}

declare interface PluginRequest {
    /** The name of the plugin making the request */
    from: string,
    /** @deprecated Will be remove in the next version */
    isFromNative?: boolean,
    /**
     * The path to access the request inside the plugin
     * @example 'remixd.cmd.git'
     */
    path?: string
}

/** Describe a plugin */
declare interface Profile<T extends Api = any> {
    name: string
    displayName?: string
    methods?: MethodKey<T>[]
    events?: EventKey<T>[]
    permission?: boolean
    hash?: string
    description?: string
    documentation?: string
    version?: string
    kind?: string,
    canActivate?: string[],
    icon?: string
}

/** A map of profile */
declare type ProfileMap<T extends ApiMap> = Partial<{
    [name in keyof T]: Profile<T[name]>
}>

declare type RemixApi = Readonly<IRemixApi>

declare interface RemixTx {
    data: string
    from: string
    to?: string
    timestamp?: string
    gasLimit: string
    value: string
    useCall: boolean
}

declare type RemixTxEvent = {
    contractAddress: string
    data: string
    envMode: 'vm'
    executionCost: string
    from: string
    gas: string
    hash: string
    input: string
    logs: any[]
    returnValue: Uint8Array
    status: '0x01' | '0x00'
    transactionCost: string
    transactionHash: string
    value: string
} | {
    blockHash: string
    blockNumber: number
    envMod: 'injected' | 'web3'
    from: string
    gas: number
    gasPrice: { c: number[], e: number, s: number }
    hash: string
    input: string
    none: number
    r: string
    s: string
    v: string
    status: '0x01' | '0x00'
    to: string
    transactionCost: string
    transactionIndex: number
    value: { c: number[], e: number, s: number }
}

declare interface RemixTxReceipt {
    transactionHash: string
    status: 0 | 1
    gasUsed: string
    error: string
    return: string
    createdAddress?: string
}

declare interface SourceInputContent {
    /** Hash of the source file. */
    keccak256?: string
    /** Literal contents of the source file */
    content: string
}

declare interface SourceInputUrls {
    /** Hash of the source file. It is used to verify the retrieved content imported via URLs */
    keccak256?: string
    /**
     * URL(s) to the source file.
     * URL(s) should be imported in this order and the result checked against the
     * keccak256 hash (if available). If the hash doesn't match or none of the
     * URL(s) result in success, an error should be raised.
     */
    urls: string[]
}

declare interface SourcesInput {
    [contractName: string]: SourceInputContent | SourceInputUrls
}

declare interface SourceWithTarget {
    sources?: CompilationFileSources,
    target?: string | null | undefined
}

declare interface Status {
    /** Display an icon or number */
    key: number | 'edited' | 'succeed' | 'loading' | 'failed' | 'none'
    /** Bootstrap css color */
    type?: 'success' | 'info' | 'warning' | 'error'
    /** Describe the status on mouseover */
    title?: string
}

declare type StatusEvents = {
    statusChanged: (status: Status) => void
}

declare type TerminalMessage = {
    value: any,
    type: 'html' | 'log' | 'info' | 'warn' | 'error'
}

declare interface Theme {
    url?: string
    /** @deprecated Use brightness instead */
    quality?: 'dark' | 'light'
    brightness: 'dark' | 'light'
    colors: {
        surface: string
        background: string
        foreground: string
        primary: string
        primaryContrast: string
        secondary?: string
        secondaryContrast?: string
        success?: string
        successContrast?: string
        warn: string
        warnContrast: string
        error: string
        errorContrast: string
        disabled: string
    }
    breakpoints: {
        xs: number
        sm: number
        md: number
        lg: number
        xl: number
    }
    fontFamily: string
    /** A unit to multiply for margin & padding */
    space: number
}

declare interface UdappSettings {
    selectedAccount:string
    selectedEnvMode: 'vm' | 'injected' | 'web3'
    networkEnvironment: string
}

declare interface UnitTestError {
    context: string
    value: string
    message: string
}

declare interface UnitTestResult {
    totalFailing: number
    totalPassing: number
    totalTime: number
    errors: UnitTestError[]
}

declare interface UserDocumentation {
    methods: UserMethodList
    notice: string
}

declare interface UserMethodDoc {
    notice: string
}

declare type UserMethodList = {
    [functionIdentifier: string]: UserMethodDoc
} & {
    'constructor'?: string
}

declare interface VMAccount {
    privateKey: string
    balance: string
}

export { }
`;
exports.remixTypes = remixTypes;

/***/ }),
/* 2857 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

var _typeof = __webpack_require__(219);

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(220));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _terminal = __webpack_require__(2858);

var _engine = __webpack_require__(477);

var packageJson = _interopRequireWildcard(__webpack_require__(312));

var _registry = _interopRequireDefault(__webpack_require__(315));

var _helper = __webpack_require__(1121);

var _corePlugin = __webpack_require__(1253);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var vm = __webpack_require__(1634);

var EventManager = __webpack_require__(1196);

// eslint-disable-line
var KONSOLES = [];

function register(api) {
  KONSOLES.push(api);
}

var profile = {
  displayName: 'Terminal',
  name: 'terminal',
  methods: ['log', 'logHtml'],
  events: [],
  description: 'Remix IDE terminal',
  version: packageJson.version
};

var Terminal = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(Terminal, _Plugin);

  var _super = _createSuper(Terminal);

  function Terminal(opts, api) {
    var _this;

    (0, _classCallCheck2["default"])(this, Terminal);
    _this = _super.call(this, profile);
    _this.fileImport = new _corePlugin.CompilerImports();
    _this.event = new EventManager();
    _this.globalRegistry = _registry["default"].getInstance();
    _this.element = document.createElement('div');

    _this.element.setAttribute('class', 'panel');

    _this.element.setAttribute('id', 'terminal-view');

    _this.element.setAttribute('data-id', 'terminalContainer-view');

    _this.eventsDecoder = _this.globalRegistry.get('eventsDecoder').api;
    _this.txListener = _this.globalRegistry.get('txlistener').api;
    _this._deps = {
      fileManager: _this.globalRegistry.get('filemanager').api,
      editor: _this.globalRegistry.get('editor').api,
      compilersArtefacts: _this.globalRegistry.get('compilersartefacts').api,
      offsetToLineColumnConverter: _this.globalRegistry.get('offsettolinecolumnconverter').api
    };
    _this.commandHelp = {
      'remix.loadgist(id)': 'Load a gist in the file explorer.',
      'remix.loadurl(url)': 'Load the given url in the file explorer. The url can be of type github, swarm, ipfs or raw http',
      'remix.execute(filepath)': 'Run the script specified by file path. If filepath is empty, script currently displayed in the editor is executed.',
      'remix.exeCurrent()': 'Run the script currently displayed in the editor',
      'remix.help()': 'Display this help message'
    };
    _this.blockchain = opts.blockchain;
    _this.vm = vm;
    _this._api = api;
    _this._opts = opts;
    _this.config = _this.globalRegistry.get('config').api;
    _this.version = packageJson.version;
    _this.data = {
      lineLength: opts.lineLength || 80,
      // ????
      session: [],
      activeFilters: {
        commands: {},
        input: ''
      },
      filterFns: {}
    };
    _this._view = {
      el: null,
      bar: null,
      input: null,
      term: null,
      journal: null,
      cli: null
    };
    _this._components = {};
    _this._commands = {};
    _this.commands = {};
    _this._JOURNAL = [];
    _this._jobs = [];
    _this._INDEX = {};
    _this._INDEX.all = [];
    _this._INDEX.allMain = [];
    _this._INDEX.commands = {};
    _this._INDEX.commandsMain = {};
    if (opts.shell) _this._shell = opts.shell; // ???

    register((0, _assertThisInitialized2["default"])(_this));

    _this.event.register('debuggingRequested', /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(hash) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this._opts.appManager.isActive('debugger');

              case 2:
                if (_context.sent) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return _this._opts.appManager.activatePlugin('debugger');

              case 5:
                _this.call('menuicons', 'select', 'debugger');

                _this.call('debugger', 'debug', hash);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    _this.dispatch = null;
    return _this;
  }

  (0, _createClass2["default"])(Terminal, [{
    key: "onActivation",
    value: function onActivation() {
      this.renderComponent();
    }
  }, {
    key: "onDeactivation",
    value: function onDeactivation() {
      this.off('scriptRunner', 'log');
      this.off('scriptRunner', 'info');
      this.off('scriptRunner', 'warn');
      this.off('scriptRunner', 'error');
    }
  }, {
    key: "logHtml",
    value: function logHtml(html) {
      this.terminalApi.logHtml(html);
    }
  }, {
    key: "log",
    value: function log(message) {
      this.terminalApi.log(message);
    }
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/_react["default"].createElement("div", {
        id: "terminal-view",
        className: "panel",
        "data-id": "terminalContainer-view"
      }, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_terminal.RemixUiTerminal, {
        plugin: state.plugin,
        onReady: state.onReady
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      var _this2 = this;

      var onReady = function onReady(api) {
        _this2.terminalApi = api;
      };

      this.dispatch({
        plugin: this,
        onReady: onReady
      });
    }
  }, {
    key: "scroll2bottom",
    value: function scroll2bottom() {
      setTimeout(function () {// do nothing.
      }, 0);
    }
  }]);
  return Terminal;
}(_engine.Plugin);

module.exports = Terminal;

/***/ }),
/* 2858 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiTerminal = __webpack_require__(2859);

Object.keys(_remixUiTerminal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiTerminal[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiTerminal[key];
    }
  });
});

/***/ }),
/* 2859 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RemixUiTerminal = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _terminalAction = __webpack_require__(2860);

var _terminalReducer = __webpack_require__(2861);

var _utils = __webpack_require__(2862);

var _commands = __webpack_require__(2863);

var _terminalWelcome = _interopRequireDefault(__webpack_require__(2864));

var _toaster = __webpack_require__(479);

var _modalDialog = __webpack_require__(316);

__webpack_require__(2865);

var _vm = _interopRequireDefault(__webpack_require__(1634));

var _javascriptSerialize = _interopRequireDefault(__webpack_require__(2867));

var _jsBeautify = _interopRequireDefault(__webpack_require__(2877));

var _RenderUnknownTransactions = _interopRequireDefault(__webpack_require__(2879));

var _RenderCall = _interopRequireDefault(__webpack_require__(2880));

var _RenderKnownTransactions = _interopRequireDefault(__webpack_require__(2881));

var _htmlReactParser = _interopRequireDefault(__webpack_require__(2882));

var _terminalTypes = __webpack_require__(1392);

var _wrapScript = __webpack_require__(2895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable @typescript-eslint/no-unused-vars */
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const RemixUiTerminal = props => {
  const {
    call,
    _deps,
    on,
    config,
    event,
    version
  } = props.plugin;
  const [_cmdIndex, setCmdIndex] = (0, _react.useState)(-1);
  const [_cmdTemp, setCmdTemp] = (0, _react.useState)('');
  const [isOpen, setIsOpen] = (0, _react.useState)(true);
  const [newstate, dispatch] = (0, _react.useReducer)(_terminalReducer.registerCommandReducer, _terminalReducer.initialState);
  const [cmdHistory, cmdHistoryDispatch] = (0, _react.useReducer)(_terminalReducer.addCommandHistoryReducer, _terminalReducer.initialState);
  const [, scriptRunnerDispatch] = (0, _react.useReducer)(_terminalReducer.registerScriptRunnerReducer, _terminalReducer.initialState);
  const [toaster, setToaster] = (0, _react.useState)(false);
  const [toastProvider, setToastProvider] = (0, _react.useState)({
    show: false,
    fileName: ''
  });
  const [modalState, setModalState] = (0, _react.useState)({
    message: '',
    title: '',
    okLabel: '',
    cancelLabel: '',
    hide: true,
    cancelFn: () => {},
    handleHide: () => {}
  });
  const [clearConsole, setClearConsole] = (0, _react.useState)(false);
  const [paste, setPaste] = (0, _react.useState)(false);
  const [storage, setStorage] = (0, _react.useState)(null);
  const [autoCompletState, setAutoCompleteState] = (0, _react.useState)({
    activeSuggestion: 0,
    data: {
      _options: []
    },
    _startingElement: 0,
    autoCompleteSelectedItem: {},
    _elementToShow: 4,
    _selectedElement: 0,
    filteredCommands: [],
    filteredPrograms: [],
    showSuggestions: false,
    text: '',
    userInput: '',
    extraCommands: [],
    commandHistoryIndex: 0
  });
  const [searchInput, setSearchInput] = (0, _react.useState)('');
  const [showTableHash, setShowTableHash] = (0, _react.useState)([]); // terminal inputRef

  const inputEl = (0, _react.useRef)(null);
  const messagesEndRef = (0, _react.useRef)(null); // terminal dragable

  const panelRef = (0, _react.useRef)(null);
  const terminalMenu = (0, _react.useRef)(null);

  const scrollToBottom = () => {
    messagesEndRef.current.scrollIntoView({
      behavior: 'smooth'
    });
  };

  (0, _react.useEffect)(() => {
    props.onReady({
      logHtml: html => {
        scriptRunnerDispatch({
          type: 'html',
          payload: {
            message: [html ? html.innerText ? html.innerText : html : null]
          }
        });
      },
      log: message => {
        scriptRunnerDispatch({
          type: 'log',
          payload: {
            message: [message]
          }
        });
      }
    });
  }, []); // events

  (0, _react.useEffect)(() => {
    (0, _terminalAction.initListeningOnNetwork)(props.plugin, scriptRunnerDispatch);
    (0, _terminalAction.registerLogScriptRunnerAction)(on, 'log', newstate.commands, scriptRunnerDispatch);
    (0, _terminalAction.registerInfoScriptRunnerAction)(on, 'info', newstate.commands, scriptRunnerDispatch);
    (0, _terminalAction.registerWarnScriptRunnerAction)(on, 'warn', newstate.commands, scriptRunnerDispatch);
    (0, _terminalAction.registerErrorScriptRunnerAction)(on, 'error', newstate.commands, scriptRunnerDispatch);
    (0, _terminalAction.registerCommandAction)('html', _blocksRenderer('html'), {
      activate: true
    }, dispatch);
    (0, _terminalAction.registerCommandAction)('log', _blocksRenderer('log'), {
      activate: true
    }, dispatch);
    (0, _terminalAction.registerCommandAction)('info', _blocksRenderer('info'), {
      activate: true
    }, dispatch);
    (0, _terminalAction.registerCommandAction)('warn', _blocksRenderer('warn'), {
      activate: true
    }, dispatch);
    (0, _terminalAction.registerCommandAction)('error', _blocksRenderer('error'), {
      activate: true
    }, dispatch);
    (0, _terminalAction.registerCommandAction)('script', function execute(args, scopedCommands) {
      const script = String(args[0]);

      _shell(script, scopedCommands, function (error, output) {
        if (error) scriptRunnerDispatch({
          type: 'error',
          payload: {
            message: error
          }
        });
        if (output) scriptRunnerDispatch({
          type: 'script',
          payload: {
            message: '5'
          }
        });
      });
    }, {
      activate: true
    }, dispatch);
  }, [autoCompletState.text]);
  (0, _react.useEffect)(() => {
    scrollToBottom();
  }, [newstate.journalBlocks.length, toaster]);

  function execute(file, cb) {
    function _execute(content, cb) {
      if (!content) {
        setToaster(true);
        if (cb) cb();
        return;
      }

      newstate.commands.script(content);
    }

    if (typeof file === 'undefined') {
      const content = _deps.editor.currentContent();

      _execute(content, cb);

      return;
    }

    const provider = _deps.fileManager.fileProviderOf(file);

    console.log({
      provider
    });

    if (!provider) {
      // toolTip(`provider for path ${file} not found`)
      setToastProvider({
        show: true,
        fileName: file
      });
      if (cb) cb();
      return;
    }

    provider.get(file, (error, content) => {
      console.log({
        content
      });

      if (error) {
        // toolTip(error)
        // TODO: pop up
        if (cb) cb();
        return;
      }

      _execute(content, cb);
    });
  }

  function loadgist(id, cb) {
    props.plugin.call('gistHandler', 'load', id);
    if (cb) cb();
  }

  const _shell = async (script, scopedCommands, done) => {
    // default shell
    if (script.indexOf('remix:') === 0) {
      return done(null, 'This type of command has been deprecated and is not functionning anymore. Please run remix.help() to list available commands.');
    }

    if (script.indexOf('remix.') === 0) {
      // we keep the old feature. This will basically only be called when the command is querying the "remix" object.
      // for all the other case, we use the Code Executor plugin
      const context = {
        remix: {
          exeCurrent: script => {
            return execute(undefined, script);
          },
          loadgist: id => {
            return loadgist(id, () => {});
          },
          execute: (fileName, callback) => {
            return execute(fileName, callback);
          }
        }
      };

      try {
        const cmds = _vm.default.createContext(context);

        const result = _vm.default.runInContext(script, cmds); // eslint-disable-line


        console.log({
          result
        });
        return done(null, result);
      } catch (error) {
        return done(error.message);
      }
    }

    try {
      if (script.trim().startsWith('git')) {// await this.call('git', 'execute', script) code might be used in the future
      } else {
        await call('scriptRunner', 'execute', script);
      }

      done();
    } catch (error) {
      done(error.message || error);
    }
  };

  const focusinput = () => {
    inputEl.current.focus();
  };

  const handleKeyDown = event => {
    const suggestionCount = autoCompletState.activeSuggestion;

    if (autoCompletState.userInput !== '' && (event.which === 27 || event.which === 8 || event.which === 46)) {
      // backspace or any key that should remove the autocompletion
      setAutoCompleteState(prevState => ({ ...prevState,
        showSuggestions: false
      }));
    }

    if (autoCompletState.showSuggestions && (event.which === 13 || event.which === 9)) {
      if (autoCompletState.userInput.length === 1) {
        setAutoCompleteState(prevState => ({ ...prevState,
          activeSuggestion: 0,
          showSuggestions: false,
          userInput: Object.keys(autoCompletState.data._options[0]).toString()
        }));
      } else {
        if (autoCompletState.showSuggestions && (event.which === 13 || event.which === 9)) {
          setAutoCompleteState(prevState => ({ ...prevState,
            activeSuggestion: 0,
            showSuggestions: false,
            userInput: autoCompletState.data._options[autoCompletState.activeSuggestion] ? Object.keys(autoCompletState.data._options[autoCompletState.activeSuggestion]).toString() : inputEl.current.value
          }));
        } else {
          setAutoCompleteState(prevState => ({ ...prevState,
            activeSuggestion: 0,
            showSuggestions: false,
            userInput: autoCompletState.data._options.length === 1 ? Object.keys(autoCompletState.data._options[0]).toString() : inputEl.current.value
          }));
        }
      }
    }

    if (event.which === 13 && !autoCompletState.showSuggestions) {
      if (event.ctrlKey) {
        // <ctrl+enter>
        // on enter, append the value in the cli input to the journal
        inputEl.current.focus();
      } else {
        // <enter>
        event.preventDefault();
        setCmdIndex(-1);
        setCmdTemp('');
        const script = autoCompletState.userInput.trim(); // inputEl.current.innerText.trim()

        if (script.length) {
          cmdHistoryDispatch({
            type: 'cmdHistory',
            payload: {
              script
            }
          });
          newstate.commands.script((0, _wrapScript.wrapScript)(script));
        }

        setAutoCompleteState(prevState => ({ ...prevState,
          userInput: ''
        }));
        inputEl.current.innerText = '';
        inputEl.current.focus();
        setAutoCompleteState(prevState => ({ ...prevState,
          showSuggestions: false
        }));
      }
    } else if (newstate._commandHistory.length && event.which === 38 && !autoCompletState.showSuggestions && autoCompletState.userInput === '') {
      event.preventDefault();
      setAutoCompleteState(prevState => ({ ...prevState,
        userInput: newstate._commandHistory[0]
      }));
    } else if (event.which === 38 && autoCompletState.showSuggestions) {
      event.preventDefault();

      if (autoCompletState.activeSuggestion === 0) {
        return;
      }

      setAutoCompleteState(prevState => ({ ...prevState,
        activeSuggestion: suggestionCount - 1,
        userInput: Object.keys(autoCompletState.data._options[autoCompletState.activeSuggestion]).toString()
      }));
    } else if (event.which === 38 && !autoCompletState.showSuggestions) {
      // <arrowUp>
      if (cmdHistory.length - 1 > _cmdIndex) {
        setCmdIndex(prevState => prevState++);
      }

      inputEl.current.innerText = cmdHistory[_cmdIndex];
      inputEl.current.focus();
    } else if (event.which === 40 && autoCompletState.showSuggestions) {
      event.preventDefault();

      if (autoCompletState.activeSuggestion + 1 === autoCompletState.data._options.length) {
        return;
      }

      setAutoCompleteState(prevState => ({ ...prevState,
        activeSuggestion: suggestionCount + 1,
        userInput: Object.keys(autoCompletState.data._options[autoCompletState.activeSuggestion + 1]).toString()
      }));
    } else if (event.which === 40 && !autoCompletState.showSuggestions) {
      if (_cmdIndex > -1) {
        setCmdIndex(prevState => prevState--);
      }

      inputEl.current.innerText = _cmdIndex >= 0 ? cmdHistory[_cmdIndex] : _cmdTemp;
      inputEl.current.focus();
    } else {
      setCmdTemp(inputEl.current.innerText);
    }
  };
  /* block contents that gets rendered from scriptRunner */


  const _blocksRenderer = mode => {
    if (mode === 'html') {
      return function logger(args) {
        if (args.length) {
          return args[0];
        }
      };
    }

    mode = {
      log: 'text-log',
      info: 'text-log',
      warn: 'text-warning',
      error: 'text-danger'
    }[mode]; // defaults

    if (mode) {
      const filterUndefined = el => el !== undefined && el !== null;

      return function logger(args) {
        const types = args.filter(filterUndefined).map(type => type);

        const values = _javascriptSerialize.default.apply(null, args.filter(filterUndefined)).map(function (val, idx) {
          // eslint-disable-line
          if (typeof args[idx] === 'string') {
            const el = document.createElement('div');
            el.innerHTML = args[idx].replace(/(\r\n|\n|\r)/gm, '<br>');
            val = el.children.length === 0 ? el.firstChild : el;
          }

          if (types[idx] === 'element') val = _jsBeautify.default.html(val);
          return val;
        });

        if (values.length) {
          return values;
        }
      };
    } else {
      throw new Error('mode is not supported');
    }
  };
  /* end of block content that gets rendered from script Runner */


  const handleClearConsole = () => {
    setClearConsole(true);
    dispatch({
      type: 'clearconsole',
      payload: []
    });
    inputEl.current.focus();
  };
  /* start of autoComplete */


  const listenOnNetwork = e => {
    const isListening = e.target.checked;
    (0, _terminalAction.listenOnNetworkAction)(props.plugin, isListening);
  };

  const onChange = event => {
    event.preventDefault();
    const inputString = event.target.value;

    if ((0, _utils.matched)(_commands.allPrograms, inputString) || inputString.includes('.')) {
      if (paste) {
        setPaste(false);
        setAutoCompleteState(prevState => ({ ...prevState,
          showSuggestions: false,
          userInput: inputString
        }));
      } else {
        setAutoCompleteState(prevState => ({ ...prevState,
          showSuggestions: true,
          userInput: inputString
        }));
      }

      const textList = inputString.split('.');

      if (textList.length === 1) {
        setAutoCompleteState(prevState => ({ ...prevState,
          data: {
            _options: []
          }
        }));
        const result = (0, _utils.Objectfilter)(_commands.allPrograms, autoCompletState.userInput);
        setAutoCompleteState(prevState => ({ ...prevState,
          data: {
            _options: result
          }
        }));
      } else {
        setAutoCompleteState(prevState => ({ ...prevState,
          data: {
            _options: []
          }
        }));
        const result = (0, _utils.Objectfilter)(_commands.allCommands, autoCompletState.userInput);
        setAutoCompleteState(prevState => ({ ...prevState,
          data: {
            _options: result
          }
        }));
      }
    } else {
      setAutoCompleteState(prevState => ({ ...prevState,
        showSuggestions: false,
        userInput: inputString
      }));
    }
  };

  const handleClickSelect = item => {
    const result = (0, _utils.getKeyOf)(item) || (0, _utils.getValueOf)(item);
    setAutoCompleteState(prevState => ({ ...prevState,
      showSuggestions: false,
      userInput: result
    }));
    inputEl.current.focus();
  };

  const handleSelect = event => {
    const suggestionCount = autoCompletState.activeSuggestion;

    if (event.keyCode === 38) {
      if (autoCompletState.activeSuggestion === 0) {
        return;
      }

      setAutoCompleteState(prevState => ({ ...prevState,
        activeSuggestion: suggestionCount - 1
      }));
    } else if (event.keyCode === 40) {
      if (autoCompletState.activeSuggestion - 1 === autoCompletState.data._options.length) {
        return;
      }

      setAutoCompleteState(prevState => ({ ...prevState,
        activeSuggestion: suggestionCount + 1
      }));
    }
  };

  const modal = (title, message, okLabel, hide, okFn, cancelLabel, cancelFn) => {
    setModalState(prevState => ({ ...prevState,
      message,
      okLabel,
      okFn,
      cancelLabel,
      cancelFn,
      hide
    }));
  };

  const handleHideModal = () => {
    setModalState(prevState => ({ ...prevState,
      hide: true
    }));
  };

  const txDetails = (event, tx) => {
    if (showTableHash.includes(tx.hash)) {
      const index = showTableHash.indexOf(tx.hash);

      if (index > -1) {
        setShowTableHash(prevState => prevState.filter(x => x !== tx.hash));
      }
    } else {
      setShowTableHash(prevState => [...prevState, tx.hash]);
    }

    scrollToBottom();
  };

  const handleAutoComplete = () => /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_popup bg-light ml-4 p-2 position-absolute text-left ",
    style: {
      display: autoCompletState.showSuggestions && autoCompletState.userInput !== '' && autoCompletState.userInput.length > 0 && autoCompletState.data._options.length > 0 ? 'block' : 'none'
    }
  }, /*#__PURE__*/_react.default.createElement("div", null, autoCompletState.data._options.map((item, index) => {
    return /*#__PURE__*/_react.default.createElement("div", {
      key: index,
      "data-id": "autoCompletePopUpAutoCompleteItem",
      className: `remix_ui_terminal_autoCompleteItem item ${autoCompletState.data._options[autoCompletState.activeSuggestion] === item ? 'border border-primary ' : ''}`,
      onKeyDown: handleSelect,
      onClick: () => handleClickSelect(item)
    }, /*#__PURE__*/_react.default.createElement("div", null, (0, _utils.getKeyOf)(item)), /*#__PURE__*/_react.default.createElement("div", null, (0, _utils.getValueOf)(item)));
  })));
  /* end of autoComplete */


  const handlePaste = () => {
    setPaste(true);
    setAutoCompleteState(prevState => ({ ...prevState,
      activeSuggestion: 0,
      showSuggestions: false
    }));
  };

  const handleToggleTerminal = () => {
    setIsOpen(!isOpen);
    props.plugin.call('layout', 'minimize', props.plugin.profile.name, isOpen);
  };

  (0, _react.useEffect)(() => {
    (async () => {
      const storage = await props.plugin.call('storage', 'formatString', await props.plugin.call('storage', 'getStorage'));
      setStorage(storage);
    })();

    props.plugin.on('layout', 'change', panels => {
      setIsOpen(!panels.terminal.minimized);
    });
    return () => {
      props.plugin.off('layout', 'change');
    };
  }, []);
  const classNameBlock = 'remix_ui_terminal_block px-4 py-1 text-break';
  return /*#__PURE__*/_react.default.createElement("div", {
    style: {
      flexGrow: 1
    },
    className: "remix_ui_terminal_panel",
    ref: panelRef
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_bar d-flex"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_menu d-flex w-100 align-items-center position-relative border-top border-dark bg-light",
    ref: terminalMenu,
    "data-id": "terminalToggleMenu"
  }, /*#__PURE__*/_react.default.createElement("i", {
    className: `mx-2 remix_ui_terminal_toggleTerminal fas ${isOpen ? 'fa-angle-double-down' : 'fa-angle-double-up'}`,
    "data-id": "terminalToggleIcon",
    onClick: handleToggleTerminal
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "mx-2 remix_ui_terminal_console",
    id: "clearConsole",
    "data-id": "terminalClearConsole",
    onClick: handleClearConsole
  }, /*#__PURE__*/_react.default.createElement("i", {
    className: "fas fa-ban",
    "aria-hidden": "true",
    title: "Clear console"
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "mx-2",
    title: "Pending Transactions"
  }, "0"), /*#__PURE__*/_react.default.createElement("div", {
    className: "pt-1 h-80 mx-3 align-items-center remix_ui_terminal_listenOnNetwork custom-control custom-checkbox"
  }, /*#__PURE__*/_react.default.createElement("input", {
    className: "custom-control-input",
    id: "listenNetworkCheck",
    onChange: listenOnNetwork,
    type: "checkbox",
    title: "If checked Remix will listen on all transactions mined in the current environment and not only transactions created by you"
  }), /*#__PURE__*/_react.default.createElement("label", {
    className: "pt-1 form-check-label custom-control-label text-nowrap",
    title: "If checked Remix will listen on all transactions mined in the current environment and not only transactions created by you",
    htmlFor: "listenNetworkCheck"
  }, "listen on all transactions")), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_search d-flex align-items-center h-100"
  }, /*#__PURE__*/_react.default.createElement("i", {
    className: "remix_ui_terminal_searchIcon d-flex align-items-center justify-content-center fas fa-search bg-light",
    "aria-hidden": "true"
  }), /*#__PURE__*/_react.default.createElement("input", {
    onChange: event => setSearchInput(event.target.value.trim()),
    type: "text",
    className: "remix_ui_terminal_filter border form-control",
    id: "searchInput",
    placeholder: "Search with transaction hash or address",
    "data-id": "terminalInputSearch"
  })))), /*#__PURE__*/_react.default.createElement("div", {
    tabIndex: -1,
    className: "remix_ui_terminal_container d-flex h-100 m-0 flex-column",
    "data-id": "terminalContainer"
  }, handleAutoComplete(), /*#__PURE__*/_react.default.createElement("div", {
    className: "position-relative d-flex flex-column-reverse h-100"
  }, /*#__PURE__*/_react.default.createElement("div", {
    id: "journal",
    className: "remix_ui_terminal_journal d-flex flex-column pt-3 pb-4 px-2 mx-2 mr-0",
    "data-id": "terminalJournal"
  }, !clearConsole && /*#__PURE__*/_react.default.createElement(_terminalWelcome.default, {
    storage: storage,
    packageJson: version
  }), newstate.journalBlocks && newstate.journalBlocks.map((x, index) => {
    if (x.name === _terminalTypes.EMPTY_BLOCK) {
      return /*#__PURE__*/_react.default.createElement("div", {
        className: classNameBlock,
        "data-id": "block",
        key: index
      }, /*#__PURE__*/_react.default.createElement("span", {
        className: "remix_ui_terminal_tx"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "remix_ui_terminal_txItem"
      }, "[", /*#__PURE__*/_react.default.createElement("span", {
        className: "remix_ui_terminal_txItemTitle"
      }, "block:", x.message, " - "), " 0 ", 'transactions', " ]")));
    } else if (x.name === _terminalTypes.UNKNOWN_TRANSACTION) {
      return x.message.filter(x => x.tx.hash.includes(searchInput) || x.tx.from.includes(searchInput) || x.tx.to.includes(searchInput)).map(trans => {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: classNameBlock,
          "data-id": `block_tx${trans.tx.hash}`,
          key: index
        }, " ", /*#__PURE__*/_react.default.createElement(_RenderUnknownTransactions.default, {
          tx: trans.tx,
          receipt: trans.receipt,
          index: index,
          plugin: props.plugin,
          showTableHash: showTableHash,
          txDetails: txDetails,
          modal: modal,
          provider: x.provider
        }));
      });
    } else if (x.name === _terminalTypes.KNOWN_TRANSACTION) {
      return x.message.map(trans => {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: classNameBlock,
          "data-id": `block_tx${trans.tx.hash}`,
          key: index
        }, trans.tx.isCall ? /*#__PURE__*/_react.default.createElement(_RenderCall.default, {
          tx: trans.tx,
          resolvedData: trans.resolvedData,
          logs: trans.logs,
          index: index,
          plugin: props.plugin,
          showTableHash: showTableHash,
          txDetails: txDetails,
          modal: modal
        }) : /*#__PURE__*/_react.default.createElement(_RenderKnownTransactions.default, {
          tx: trans.tx,
          receipt: trans.receipt,
          resolvedData: trans.resolvedData,
          logs: trans.logs,
          index: index,
          plugin: props.plugin,
          showTableHash: showTableHash,
          txDetails: txDetails,
          modal: modal,
          provider: x.provider
        }));
      });
    } else if (Array.isArray(x.message)) {
      return x.message.map((msg, i) => {
        if (!msg) msg = 'null';

        if (_react.default.isValidElement(msg)) {
          return /*#__PURE__*/_react.default.createElement("div", {
            className: "px-4 block",
            "data-id": "block",
            key: i
          }, /*#__PURE__*/_react.default.createElement("span", {
            className: x.style
          }, msg));
        } else if (typeof msg === 'object') {
          if (msg.value && isHtml(msg.value)) {
            return /*#__PURE__*/_react.default.createElement("div", {
              className: classNameBlock,
              "data-id": "block",
              key: i
            }, /*#__PURE__*/_react.default.createElement("span", {
              className: x.style
            }, (0, _htmlReactParser.default)(msg.value), " "));
          }

          let stringified;

          try {
            stringified = JSON.stringify(msg);
          } catch (e) {
            console.error(e);
            stringified = '< value not displayable >';
          }

          return /*#__PURE__*/_react.default.createElement("div", {
            className: classNameBlock,
            "data-id": "block",
            key: i
          }, /*#__PURE__*/_react.default.createElement("span", {
            className: x.style
          }, stringified, " "));
        } else {
          return /*#__PURE__*/_react.default.createElement("div", {
            className: classNameBlock,
            "data-id": "block",
            key: i
          }, /*#__PURE__*/_react.default.createElement("span", {
            className: x.style
          }, msg ? msg.toString() : null));
        }
      });
    } else {
      if (typeof x.message !== 'function') {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: classNameBlock,
          "data-id": "block",
          key: index
        }, " ", /*#__PURE__*/_react.default.createElement("span", {
          className: x.style
        }, " ", x.message));
      }
    }
  }), /*#__PURE__*/_react.default.createElement("div", {
    ref: messagesEndRef
  })), isOpen && /*#__PURE__*/_react.default.createElement("div", {
    id: "terminalCli",
    "data-id": "terminalCli",
    className: "remix_ui_terminal_cli position-absolute w-100",
    onClick: focusinput
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "remix_ui_terminal_prompt blink mx-1 font-weight-bold text-dark"
  }, '>'), /*#__PURE__*/_react.default.createElement("input", {
    className: "remix_ui_terminal_input ml-1 text-dark text-break border-0",
    ref: inputEl,
    spellCheck: "false",
    contentEditable: "true",
    id: "terminalCliInput",
    "data-id": "terminalCliInput",
    onChange: event => onChange(event),
    onKeyDown: event => handleKeyDown(event),
    value: autoCompletState.userInput,
    onPaste: handlePaste
  })))), /*#__PURE__*/_react.default.createElement(_modalDialog.ModalDialog, {
    id: "terminal",
    title: modalState.title,
    message: modalState.message,
    hide: modalState.hide,
    okLabel: modalState.okLabel,
    cancelLabel: modalState.cancelLabel,
    cancelFn: modalState.cancelFn,
    handleHide: handleHideModal
  }), toaster && /*#__PURE__*/_react.default.createElement(_toaster.Toaster, {
    message: "no content to execute"
  }), toastProvider.show && /*#__PURE__*/_react.default.createElement(_toaster.Toaster, {
    message: `provider for path ${toastProvider.fileName} not found`
  }));
};

exports.RemixUiTerminal = RemixUiTerminal;

function isHtml(value) {
  if (!value.indexOf) return false;
  return value.indexOf('<div') !== -1 || value.indexOf('<span') !== -1 || value.indexOf('<p') !== -1 || value.indexOf('<label') !== -1 || value.indexOf('<b') !== -1;
}

var _default = RemixUiTerminal;
exports.default = _default;

/***/ }),
/* 2860 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerWarnScriptRunnerAction = exports.registerLogScriptRunnerAction = exports.registerInfoScriptRunnerAction = exports.registerErrorScriptRunnerAction = exports.registerCommandAction = exports.listenOnNetworkAction = exports.initListeningOnNetwork = exports.filterFnAction = void 0;

var _terminalTypes = __webpack_require__(1392);

const registerCommandAction = (name, command, activate, dispatch) => {
  const commands = {};
  const _commands = {};
  _commands[name] = command;
  const data = {
    session: [],
    activeFilters: {
      commands: {},
      input: ''
    },
    filterFns: {}
  };
  const _INDEX = {
    all: [],
    allMain: [],
    commands: {},
    commandsMain: {}
  };

  const registerFilter = (commandName, filterFn) => {
    data.filterFns[commandName] = filterFn;
  };

  commands[name] = function () {
    const args = [...arguments]; // eslint-disable-line

    const steps = [];
    const root = {
      steps,
      cmd: name,
      gidx: 0,
      idx: 0
    };
    const ITEM = {
      root,
      cmd: name
    };
    root.gidx = _INDEX.allMain.push(ITEM) - 1;
    let item;

    function append(cmd, params, el) {
      if (cmd) {
        // subcommand
        item = {
          el,
          cmd,
          root
        };
      } else {
        // command
        item = ITEM;
        item.el = el;
        cmd = name;
      }

      item.gidx = _INDEX.all.push(item) - 1;
      item.idx = _INDEX.commands[cmd].push(item) - 1;
      item.step = steps.push(item) - 1;
      item.args = params;
    }

    const scopedCommands = _scopeCommands(append);

    command(args, scopedCommands, el => append(null, args, el));
  };

  const help = typeof command.help === 'string' ? command.help : ['// no help available for:', `terminal.command.${name}`].join('\n');

  commands[name].toString = () => {
    return help;
  };

  commands[name].help = help;
  data.activeFilters.commands[name] = activate && activate.activate;

  if (activate.filterFn) {
    registerFilter(name, activate.filterFn);
  }

  if (name !== (_terminalTypes.KNOWN_TRANSACTION || _terminalTypes.UNKNOWN_TRANSACTION || _terminalTypes.EMPTY_BLOCK)) {
    dispatch({
      type: name,
      payload: {
        commands: commands,
        _commands: _commands,
        data: data
      }
    });
  }

  const _scopeCommands = append => {
    const scopedCommands = {};
    Object.keys(commands).forEach(function makeScopedCommand(cmd) {
      const command = _commands[cmd];

      scopedCommands[cmd] = function _command() {
        const args = [...arguments]; // eslint-disable-line

        command(args, scopedCommands, el => append(cmd, args, el));
      };
    });
    return scopedCommands;
  };
};

exports.registerCommandAction = registerCommandAction;

const filterFnAction = (name, filterFn, dispatch) => {
  const data = {
    filterFns: {}
  };
  data.filterFns[name] = filterFn;
  dispatch({
    type: name,
    payload: {
      data: data
    }
  });
};

exports.filterFnAction = filterFnAction;

const registerLogScriptRunnerAction = (on, commandName, commandFn, dispatch) => {
  on('scriptRunner', commandName, msg => {
    commandFn.log.apply(commandFn, msg.data); // eslint-disable-line

    dispatch({
      type: commandName,
      payload: {
        commandFn,
        message: msg.data
      }
    });
  });
};

exports.registerLogScriptRunnerAction = registerLogScriptRunnerAction;

const registerInfoScriptRunnerAction = (on, commandName, commandFn, dispatch) => {
  on('scriptRunner', commandName, msg => {
    commandFn.info.apply(commandFn, msg.data); // eslint-disable-line

    dispatch({
      type: commandName,
      payload: {
        commandFn,
        message: msg.data
      }
    });
  });
};

exports.registerInfoScriptRunnerAction = registerInfoScriptRunnerAction;

const registerWarnScriptRunnerAction = (on, commandName, commandFn, dispatch) => {
  on('scriptRunner', commandName, msg => {
    commandFn.warn.apply(commandFn, msg.data); // eslint-disable-line

    dispatch({
      type: commandName,
      payload: {
        commandFn,
        message: msg.data
      }
    });
  });
};

exports.registerWarnScriptRunnerAction = registerWarnScriptRunnerAction;

const registerErrorScriptRunnerAction = (on, commandName, commandFn, dispatch) => {
  on('scriptRunner', commandName, msg => {
    commandFn.error.apply(commandFn, msg.data); // eslint-disable-line

    dispatch({
      type: commandName,
      payload: {
        commandFn,
        message: msg.data
      }
    });
  });
};

exports.registerErrorScriptRunnerAction = registerErrorScriptRunnerAction;

const listenOnNetworkAction = async (plugins, isListening) => {
  plugins.txListener.setListenOnNetwork(isListening);
};

exports.listenOnNetworkAction = listenOnNetworkAction;

const initListeningOnNetwork = (plugins, dispatch) => {
  const provider = plugins.blockchain.getProvider();
  plugins.txListener.event.register(_terminalTypes.NEW_BLOCK, block => {
    if (!block.transactions || block.transactions && !block.transactions.length) {
      dispatch({
        type: _terminalTypes.EMPTY_BLOCK,
        payload: {
          message: 0,
          provider
        }
      });
    }
  });
  plugins.txListener.event.register(_terminalTypes.KNOWN_TRANSACTION, () => {});
  plugins.txListener.event.register(_terminalTypes.NEW_CALL, (tx, receipt) => {
    log(plugins, tx, receipt, dispatch); // log(this, tx, null)
  });
  plugins.txListener.event.register(_terminalTypes.NEW_TRANSACTION, (tx, receipt) => {
    log(plugins, tx, receipt, dispatch);
  });

  const log = async (plugins, tx, receipt, dispatch) => {
    const resolvedTransaction = await plugins.txListener.resolvedTransaction(tx.hash);
    const provider = plugins.blockchain.getProvider();

    if (resolvedTransaction) {
      let compiledContracts = null;

      if (plugins._deps.compilersArtefacts.__last) {
        compiledContracts = await plugins._deps.compilersArtefacts.__last.getContracts();
      }

      await plugins.eventsDecoder.parseLogs(tx, resolvedTransaction.contractName, compiledContracts, async (error, logs) => {
        if (!error) {
          await dispatch({
            type: _terminalTypes.KNOWN_TRANSACTION,
            payload: {
              message: [{
                tx: tx,
                receipt: receipt,
                resolvedData: resolvedTransaction,
                logs: logs
              }],
              provider
            }
          });
        }
      });
    } else {
      await dispatch({
        type: _terminalTypes.UNKNOWN_TRANSACTION,
        payload: {
          message: [{
            tx: tx,
            receipt: receipt
          }],
          provider
        }
      });
    }
  };

  plugins.txListener.event.register('debuggingRequested', async hash => {
    // TODO should probably be in the run module
    if (!(await plugins.options.appManager.isActive('debugger'))) await plugins.options.appManager.activatePlugin('debugger');
    plugins.call('menuicons', 'select', 'debugger');
    plugins.call('debugger', 'debug', hash);
  });
};

exports.initListeningOnNetwork = initListeningOnNetwork;

/***/ }),
/* 2861 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remixWelcomeTextReducer = exports.registerScriptRunnerReducer = exports.registerFilterReducer = exports.registerCommandReducer = exports.initialState = exports.addCommandHistoryReducer = void 0;

var _terminalTypes = __webpack_require__(1392);

const initialState = {
  journalBlocks: [],
  data: {
    // lineLength: props.options.lineLength || 80,
    session: [],
    activeFilters: {
      commands: {},
      input: ''
    },
    filterFns: {}
  },
  _commandHistory: [],
  _commands: {},
  commands: {},
  _JOURNAL: [],
  _jobs: [],
  _INDEX: {},
  _INDEXall: [],
  _INDEXallMain: [],
  _INDEXcommands: {},
  _INDEXcommandsMain: {},
  message: []
};
exports.initialState = initialState;

const registerCommandReducer = (state, action) => {
  switch (action.type) {
    case _terminalTypes.HTML:
      return { ...state,
        _commands: Object.assign(initialState._commands, action.payload._commands),
        commands: Object.assign(initialState.commands, action.payload.commands),
        data: Object.assign(initialState.data, { ...action.payload.data
        })
      };

    case _terminalTypes.LOG:
      return { ...state,
        _commands: Object.assign(initialState._commands, action.payload._commands),
        commands: Object.assign(initialState.commands, action.payload.commands),
        data: Object.assign(initialState.data, { ...action.payload.data
        })
      };

    case _terminalTypes.INFO:
      return { ...state,
        _commands: Object.assign(initialState._commands, action.payload._commands),
        commands: Object.assign(initialState.commands, action.payload.commands),
        data: Object.assign(initialState.data, action.payload.data)
      };

    case _terminalTypes.WARN:
      return { ...state,
        _commands: Object.assign(initialState._commands, action.payload._commands),
        commands: Object.assign(initialState.commands, action.payload.commands),
        data: Object.assign(initialState.data, action.payload.data)
      };

    case _terminalTypes.ERROR:
      return { ...state,
        _commands: Object.assign(initialState._commands, action.payload._commands),
        commands: Object.assign(initialState.commands, action.payload.commands),
        data: Object.assign(initialState.data, action.payload.data)
      };

    case _terminalTypes.SCRIPT:
      return { ...state,
        _commands: Object.assign(initialState._commands, action.payload._commands),
        commands: Object.assign(initialState.commands, action.payload.commands),
        data: Object.assign(initialState.data, action.payload.data)
      };

    case _terminalTypes.CLEAR_CONSOLE:
      return { ...state,
        ...state.journalBlocks.splice(0)
      };

    case _terminalTypes.LISTEN_ON_NETWORK:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-log'
        })
      };

    default:
      return {
        state
      };
  }
};

exports.registerCommandReducer = registerCommandReducer;

const registerFilterReducer = (state, action) => {
  switch (action.type) {
    case _terminalTypes.LOG:
      return { ...state,
        data: Object.assign(initialState.data.filterFns, action.payload.data.filterFns)
      };

    case _terminalTypes.INFO:
      return { ...state,
        data: Object.assign(initialState.data.filterFns, action.payload.data.filterFns)
      };

    case _terminalTypes.WARN:
      return { ...state,
        data: Object.assign(initialState.data.filterFns, action.payload.data.filterFns)
      };

    case _terminalTypes.ERROR:
      return { ...state,
        data: Object.assign(initialState.data.filterFns, action.payload.data.filterFns)
      };

    case _terminalTypes.SCRIPT:
      return { ...state,
        data: Object.assign(initialState.data.filterFns, action.payload.data.filterFns)
      };

    default:
      return {
        state
      };
  }
};

exports.registerFilterReducer = registerFilterReducer;

const addCommandHistoryReducer = (state, action) => {
  switch (action.type) {
    case _terminalTypes.CMD_HISTORY:
      return { ...state,
        _commandHistory: initialState._commandHistory.unshift(action.payload.script)
      };

    default:
      return {
        state
      };
  }
};

exports.addCommandHistoryReducer = addCommandHistoryReducer;

const remixWelcomeTextReducer = (state, action) => {
  switch (action.type) {
    case 'welcomeText':
      return { ...state,
        journalBlocks: initialState.journalBlocks.push(action.payload.welcomeText)
      };
  }
};

exports.remixWelcomeTextReducer = remixWelcomeTextReducer;

const registerScriptRunnerReducer = (state, action) => {
  switch (action.type) {
    case _terminalTypes.HTML:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-log',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.LOG:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-log',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.INFO:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-success',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.WARN:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-warning',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.ERROR:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-danger',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.SCRIPT:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: 'text-log',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.KNOWN_TRANSACTION:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: '',
          name: 'knownTransaction',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.UNKNOWN_TRANSACTION:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: '',
          name: 'unknownTransaction',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.EMPTY_BLOCK:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: '',
          name: 'emptyBlock',
          provider: action.payload.provider
        })
      };

    case _terminalTypes.NEW_TRANSACTION:
      return { ...state,
        journalBlocks: initialState.journalBlocks.push({
          message: action.payload.message,
          style: '',
          provider: action.payload.provider
        })
      };
  }
};

exports.registerScriptRunnerReducer = registerScriptRunnerReducer;

/***/ }),
/* 2862 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matched = exports.getValueOf = exports.getKeyOf = exports.find = exports.Objectfilter = void 0;

const getKeyOf = item => {
  return Object.keys(item)[0];
};

exports.getKeyOf = getKeyOf;

const getValueOf = item => {
  return Object.values(item)[0];
};

exports.getValueOf = getValueOf;

const Objectfilter = (obj, filterValue) => obj.filter(item => Object.keys(item)[0].indexOf(filterValue) > -1);

exports.Objectfilter = Objectfilter;

const matched = (arr, value) => arr.map(x => Object.keys(x).some(x => x.startsWith(value))).some(x => x === true);

exports.matched = matched;

const findDeep = (object, fn, found = {
  break: false,
  value: undefined
}) => {
  if (typeof object !== 'object' || object === null) return;

  for (const i in object) {
    if (found.break) break;
    let el = object[i];
    if (el && el.innerText !== undefined && el.innerText !== null) el = el.innerText;

    if (fn(el, i, object)) {
      found.value = el;
      found.break = true;
      break;
    } else {
      findDeep(el, fn, found);
    }
  }

  return found.value;
};

const find = (args, query) => {
  query = query.trim();
  const isMatch = !!findDeep(args, function check(value) {
    if (value === undefined || value === null) return false;
    if (typeof value === 'function') return false;
    if (typeof value === 'object') return false;
    const contains = String(value).indexOf(query.trim()) !== -1;
    return contains;
  });
  return isMatch;
};

exports.find = find;

/***/ }),
/* 2863 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allPrograms = exports.allCommands = void 0;
const allPrograms = [{
  ethers: 'The ethers.js library is a compact and complete JavaScript library for Ethereum.'
}, {
  remix: 'Ethereum IDE and tools for the web.'
}, {
  web3: 'The web3.js library is a collection of modules which contain specific functionality for the ethereum ecosystem.'
} // { swarmgw: 'This library can be used to upload/download files to Swarm via https://swarm-gateways.net/.' }
];
exports.allPrograms = allPrograms;
const allCommands = [{
  'remix.execute(filepath)': 'Run the script specified by file path. If filepath is empty, script currently displayed in the editor is executed.'
}, {
  'remix.exeCurrent()': 'Run the script currently displayed in the editor.'
}, {
  'remix.loadgist(id)': 'Load a gist in the file explorer.'
}, // { 'remix.loadurl(url)': 'Load the given url in the file explorer. The url can be of type github, swarm or ipfs.' },
// { 'swarmgw.get(url, cb)': 'Download files from Swarm via https://swarm-gateways.net/' },
// { 'swarmgw.put(content, cb)': 'Upload files to Swarm via https://swarm-gateways.net/' },
{
  'ethers.Contract': 'This API provides a graceful connection to a contract deployed on the blockchain, simplifying calling and querying its functions and handling all the binary protocol and conversion as necessarily.'
}, // { 'ethers.HDNode': 'A Hierarchical Deterministic Wallet represents a large tree of private keys which can reliably be reproduced from an initial seed.' },
// { 'ethers.Interface': 'The Interface Object is a meta-class that accepts a Solidity (or compatible) Application Binary Interface (ABI) and populates functions to deal with encoding and decoding the parameters to pass in and results returned.' },
{
  'ethers.providers': 'A Provider abstracts a connection to the Ethereum blockchain, for issuing queries and sending state changing transactions.'
}, // { 'ethers.SigningKey': 'The SigningKey interface provides an abstraction around the secp256k1 elliptic curve cryptography library.' },
// { 'ethers.utils': 'The utility functions exposed in both the ethers umbrella package and the ethers-utils.' },
// { 'ethers.utils.AbiCoder': 'Create a new ABI Coder object' },
// { 'ethers.utils.RLP': 'This encoding method is used internally for several aspects of Ethereum, such as encoding transactions and determining contract addresses.' },
{
  'ethers.Wallet': 'A wallet manages a private/public key pair which is used to cryptographically sign transactions and prove ownership on the Ethereum network.'
}, {
  'ethers.version': 'Contains the version of the ethers container object.'
}, {
  'web3.eth': 'Eth module for interacting with the Ethereum network.'
}, {
  'web3.eth.accounts': 'The web3.eth.accounts contains functions to generate Ethereum accounts and sign transactions and data.'
}, // TODO: need to break down the object return from abi response
// { 'web3.eth.abi': 'The web3.eth.abi functions let you de- and encode parameters to ABI (Application Binary Interface) for function calls to the EVM (Ethereum Virtual Machine).' },
{
  'web3.eth.ens': 'The web3.eth.ens functions let you interacting with ENS.'
}, {
  'web3.eth.Iban': 'The web3.eth.Iban function lets convert Ethereum addresses from and to IBAN and BBAN.'
}, {
  'web3.eth.net': 'Net module for interacting with network properties.'
}, {
  'web3.eth.personal': 'Personal module for interacting with the Ethereum accounts.'
}, {
  'web3.eth.subscribe': 'The web3.eth.subscribe function lets you subscribe to specific events in the blockchain.'
}, {
  'web3.givenProvider': 'When using web3.js in an Ethereum compatible browser, it will set with the current native provider by that browser. Will return the given provider by the (browser) environment, otherwise null.'
}, // { 'web3.modules': 'Contains the version of the web3 container object.' },
{
  'web3.providers': 'Contains the current available providers.'
}, {
  'web3.shh': 'Shh module for interacting with the whisper protocol'
}, {
  'web3.utils': 'This package provides utility functions for Ethereum dapps and other web3.js packages.'
}, {
  'web3.version': 'Contains the version of the web3 container object.'
}, {
  'web3.eth.clearSubscriptions();': 'Resets subscriptions.'
} //   { 'web3.eth.Contract(jsonInterface[, address][, options])': 'The web3.eth.Contract object makes it easy to interact with smart contracts on the ethereum blockchain.' },
//   { 'web3.eth.accounts.create([entropy]);': 'The web3.eth.accounts contains functions to generate Ethereum accounts and sign transactions and data.' },
//   { 'web3.eth.getAccounts();': 'Retrieve the list of accounts' },
//   { 'web3.eth.accounts.privateKeyToAccount(privateKey [, ignoreLength ]);': 'Get the account from the private key' },
//   { 'web3.eth.accounts.signTransaction(tx, privateKey [, callback]);': 'Sign Transaction' },
//   { 'web3.eth.accounts.recoverTransaction(rawTransaction);': 'Sign Transaction' },
//   { 'web3.eth.accounts.hashMessage(message);': 'Hash message' }
];
exports.allCommands = allCommands;

/***/ }),
/* 2864 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
const TerminalWelcomeMessage = ({
  packageJson,
  storage
}) => {
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_block px-4 ",
    "data-id": "block_null"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_welcome"
  }, " Welcome to Remix ", packageJson, " "), /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("div", {
    className: ""
  }, "Your files are stored in ", window.remixFileSystem.name, ", ", storage, " used"), /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("div", null, "You can use this terminal to: "), /*#__PURE__*/_react.default.createElement("ul", {
    className: "ml-0 mr-4"
  }, /*#__PURE__*/_react.default.createElement("li", null, "Check transactions details and start debugging."), /*#__PURE__*/_react.default.createElement("li", null, "Execute JavaScript scripts:", /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("i", null, " - Input a script directly in the command line interface "), /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("i", null, " - Select a Javascript file in the file explorer and then run \\`remix.execute()\\` or \\`remix.exeCurrent()\\`  in the command line interface  "), /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("i", null, " - Right click on a JavaScript file in the file explorer and then click \\`Run\\` "))), /*#__PURE__*/_react.default.createElement("div", null, "The following libraries are accessible:"), /*#__PURE__*/_react.default.createElement("ul", {
    className: "ml-0 mr-4"
  }, /*#__PURE__*/_react.default.createElement("li", null, /*#__PURE__*/_react.default.createElement("a", {
    target: "_blank",
    href: "https://web3js.readthedocs.io/en/1.0/"
  }, "web3 version 1.5.2")), /*#__PURE__*/_react.default.createElement("li", null, /*#__PURE__*/_react.default.createElement("a", {
    target: "_blank",
    href: "https://docs.ethers.io"
  }, "ethers.js"), " "), /*#__PURE__*/_react.default.createElement("li", null, "remix")), /*#__PURE__*/_react.default.createElement("div", null, "Type the library name to see available commands."));
};

var _default = TerminalWelcomeMessage;
exports.default = _default;

/***/ }),
/* 2865 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2866);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2866 */
/***/ (function(module, exports) {

module.exports = [[module.i, "\nelement.style {\n height: 323px !important;\n}\n#terminalCliInput{\n  width: 97%;\n  font-weight: 800;\n  background: var(--body-bg)\n}\n#terminalCliInput:focus {\n  outline: none;\n}\n.remix_ui_terminal_panel {\n  position          : relative;\n  display           : flex;\n  flex-direction    : column;\n  font-size         : 12px;\n  min-height        : 3em;\n}\n.remix_ui_terminal_bar {\n  z-index           : 2;\n}\n.remix_ui_terminal_menu {\n  max-height           : 35px;\n  min-height           : 35px;\n}\n.remix_ui_terminal_toggleTerminal {\n  cursor            : pointer;\n}\n.remix_ui_terminal_toggleTerminal:hover {\n  color             : var(--secondary);\n}\n.remix_ui_terminal_container {\n  overflow-y          : auto;\n  font-family         : monospace;\n  background-repeat   : no-repeat;\n  background-position : center 15%;\n  background-size     : auto calc(75% -  1.7em);\n}\n.remix_ui_terminal_journal {\n  margin-top        : auto;\n  margin-bottom     : 2rem;\n  font-family       : monospace;\n  overflow-y        : scroll;\n}\n.remix_ui_terminal_block {\n  white-space       : pre-wrap;\n  font-family       : monospace;\n  line-height       : 2ch;\n}\n.remix_ui_terminal_block > pre {\n  max-height        : 200px;\n}\n.remix_ui_terminal_welcome {\n  font-weight: bold;\n}\n.remix_ui_terminal_cli {\n  white-space       : nowrap;\n  line-height       : 1.7em;\n  font-family       : monospace;\n  padding           : .4em;\n  color             : var(--primary);\n}\n.remix_ui_terminal_prompt {\n  font-family       : monospace;\n}\n.remix_ui_terminal_input {\n  outline           : none;\n  font-family       : monospace;\n}\n.remix_ui_terminal_search {\n  width             : 330px;\n  padding-left      : 20px;\n  padding-top       : 1px;\n  padding-bottom    : 1px;\n}\n.remix_ui_terminal_filter {\n  height                      : 80%;\n  white-space                 : nowrap;\n  overflow                    : hidden;\n  text-overflow               : ellipsis;\n}\n.remix_ui_terminal_searchIcon {\n  width                       : 25px;\n  border-top-left-radius      : 3px;\n  border-bottom-left-radius   : 3px;\n  margin-right                : 5px;\n}\n.remix_ui_terminal_console {\n  cursor           : pointer;\n}\n.remix_ui_terminal_listenOnNetwork {\n  min-height: auto;\n}\n.remix_ui_terminal_popup {\n  width            : 95%;\n  font-family      : monospace;\n  background-color : var(--secondary);\n  overflow         : auto;\n  z-index          : 80;\n  bottom           : 2.2em;\n  border-width     : 4px;\n  overflow-y       : scroll;\n  box-shadow       : 0px 0px 13px -8px;\n}\n.remix_ui_terminal_autoCompleteItem {\n  padding          : 4px;\n  border-radius    : 2px;\n}\n.remix_ui_terminal_popup a {\n  cursor           : pointer;\n}\n.call {\n  font-size: 7px;\n  border-radius: 50%;\n  min-width: 20px;\n  min-height: 20px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: var(--text-info);\n  text-transform: uppercase;\n  font-weight: bold;\n}\n.remix_ui_terminal_txItem {\n  color: var(--text-info);\n  margin-right: 5px;\n  float: left;\n}\n.remix_ui_terminal_txItemTitle {\n  font-weight: bold;\n}\n/* tx logger css*/\n.remix_ui_terminal_log {\n  display: flex;\n  cursor: pointer;\n  align-items: center;\n  cursor: pointer;\n  padding-top: 0.5rem;\n}\n.remix_ui_terminal_log:hover {\n  opacity: 0.8;\n}\n.remix_ui_terminal_txStatus {\n  display: flex;\n  font-size: 20px;\n  margin-right: 20px;\n  float: left;\n}\n.remix_ui_terminal_succeeded {\n  color: var(--success);\n}\n.remix_ui_terminal_failed {\n  color: var(--danger);\n}\n.remix_ui_terminal_arrow {\n  color: var(--text-info);\n  font-size: 20px;\n  cursor: pointer;\n  display: flex;\n  margin-left: 10px;\n}\n.remix_ui_terminal_arrow:hover {\n  color: var(--secondary);\n}\n.remix_ui_terminal_call {\n  font-size: 7px;\n  border-radius: 50%;\n  min-width: 20px;\n  min-height: 20px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: var(--text-info);\n  text-transform: uppercase;\n  font-weight: bold;\n}\n.remix_ui_terminal_tx {\n  color: var(--text-info);\n  font-weight: bold;\n  float: left;\n  margin-right: 10px;\n}\n.remix_ui_terminal_tr,\n.remix_ui_terminal_td {\n  border-collapse: collapse;\n  font-size: 10px;\n  color: var(--text-info);\n  border: 1px solid var(--text-info);\n  transition: max-height 0.3s, padding 0.3s;\n}\ntable .active {\n  transition: max-height 0.6s, padding 0.6s;\n}\n.remix_ui_terminal_tr, .remix_ui_terminal_td {\n  padding: 4px;\n  vertical-align: baseline;\n}\n.remix_ui_terminal_td:first-child {\n  min-width: 30%;\n  width: 30%;\n  align-items: baseline;\n  font-weight: bold;\n}\n.remix_ui_terminal_tableTitle {\n  width: 25%;\n}\n.remix_ui_terminal_buttons {\n  display: flex;\n  margin-left: auto;\n}\n.remix_ui_terminal_debug {\n  white-space: nowrap;\n}\n.remix_ui_terminal_debug:hover {\n  opacity: 0.8;\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLXRlcm1pbmFsLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7Q0FDQyx3QkFBd0I7QUFDekI7QUFDQTtFQUNFLFVBQVU7RUFDVixnQkFBZ0I7RUFDaEI7QUFDRjtBQUNBO0VBQ0UsYUFBYTtBQUNmO0FBRUE7RUFDRSw0QkFBNEI7RUFDNUIsd0JBQXdCO0VBQ3hCLDBCQUEwQjtFQUMxQix3QkFBd0I7RUFDeEIsdUJBQXVCO0FBQ3pCO0FBQ0E7RUFDRSxxQkFBcUI7QUFDdkI7QUFDQTtFQUNFLDJCQUEyQjtFQUMzQiwyQkFBMkI7QUFDN0I7QUFDQTtFQUNFLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0Usb0NBQW9DO0FBQ3RDO0FBQ0E7RUFDRSwwQkFBMEI7RUFDMUIsK0JBQStCO0VBQy9CLCtCQUErQjtFQUMvQixnQ0FBZ0M7RUFDaEMsNkNBQTZDO0FBQy9DO0FBRUE7RUFDRSx3QkFBd0I7RUFDeEIsd0JBQXdCO0VBQ3hCLDZCQUE2QjtFQUM3QiwwQkFBMEI7QUFDNUI7QUFDQTtFQUNFLDRCQUE0QjtFQUM1Qiw2QkFBNkI7RUFDN0IsdUJBQXVCO0FBQ3pCO0FBQ0E7RUFDRSx5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsMEJBQTBCO0VBQzFCLHlCQUF5QjtFQUN6Qiw2QkFBNkI7RUFDN0Isd0JBQXdCO0VBQ3hCLGtDQUFrQztBQUNwQztBQUNBO0VBQ0UsNkJBQTZCO0FBQy9CO0FBQ0E7RUFDRSx3QkFBd0I7RUFDeEIsNkJBQTZCO0FBQy9CO0FBQ0E7RUFDRSx5QkFBeUI7RUFDekIsd0JBQXdCO0VBQ3hCLHVCQUF1QjtFQUN2Qix1QkFBdUI7QUFDekI7QUFDQTtFQUNFLGlDQUFpQztFQUNqQyxvQ0FBb0M7RUFDcEMsb0NBQW9DO0VBQ3BDLHNDQUFzQztBQUN4QztBQUNBO0VBQ0Usa0NBQWtDO0VBQ2xDLGlDQUFpQztFQUNqQyxpQ0FBaUM7RUFDakMsaUNBQWlDO0FBQ25DO0FBRUE7RUFDRSwwQkFBMEI7QUFDNUI7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0Usc0JBQXNCO0VBQ3RCLDRCQUE0QjtFQUM1QixtQ0FBbUM7RUFDbkMsdUJBQXVCO0VBQ3ZCLHFCQUFxQjtFQUNyQix3QkFBd0I7RUFDeEIsc0JBQXNCO0VBQ3RCLHlCQUF5QjtFQUN6QixvQ0FBb0M7QUFDdEM7QUFFQTtFQUNFLHNCQUFzQjtFQUN0QixzQkFBc0I7QUFDeEI7QUFFQTtFQUNFLDBCQUEwQjtBQUM1QjtBQUVBO0VBQ0UsY0FBYztFQUNkLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLGFBQWE7RUFDYix1QkFBdUI7RUFDdkIsbUJBQW1CO0VBQ25CLHVCQUF1QjtFQUN2Qix5QkFBeUI7RUFDekIsaUJBQWlCO0FBQ25CO0FBRUE7RUFDRSx1QkFBdUI7RUFDdkIsaUJBQWlCO0VBQ2pCLFdBQVc7QUFDYjtBQUVBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBRUEsaUJBQWlCO0FBRWpCO0VBQ0UsYUFBYTtFQUNiLGVBQWU7RUFDZixtQkFBbUI7RUFDbkIsZUFBZTtFQUNmLG1CQUFtQjtBQUNyQjtBQUNBO0VBQ0UsWUFBWTtBQUNkO0FBRUE7RUFDRSxhQUFhO0VBQ2IsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQixXQUFXO0FBQ2I7QUFDQTtFQUNFLHFCQUFxQjtBQUN2QjtBQUNBO0VBQ0Usb0JBQW9CO0FBQ3RCO0FBRUE7RUFDRSx1QkFBdUI7RUFDdkIsZUFBZTtFQUNmLGVBQWU7RUFDZixhQUFhO0VBQ2IsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSx1QkFBdUI7QUFDekI7QUFDQTtFQUNFLGNBQWM7RUFDZCxrQkFBa0I7RUFDbEIsZUFBZTtFQUNmLGdCQUFnQjtFQUNoQixhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtFQUNuQix1QkFBdUI7RUFDdkIseUJBQXlCO0VBQ3pCLGlCQUFpQjtBQUNuQjtBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCLGlCQUFpQjtFQUNqQixXQUFXO0VBQ1gsa0JBQWtCO0FBQ3BCO0FBRUE7O0VBRUUseUJBQXlCO0VBQ3pCLGVBQWU7RUFDZix1QkFBdUI7RUFDdkIsa0NBQWtDO0VBQ2xDLHlDQUF5QztBQUMzQztBQUNBO0VBQ0UseUNBQXlDO0FBQzNDO0FBQ0E7RUFDRSxZQUFZO0VBQ1osd0JBQXdCO0FBQzFCO0FBQ0E7RUFDRSxjQUFjO0VBQ2QsVUFBVTtFQUNWLHFCQUFxQjtFQUNyQixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLFVBQVU7QUFDWjtBQUNBO0VBQ0UsYUFBYTtFQUNiLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsbUJBQW1CO0FBQ3JCO0FBQ0E7RUFDRSxZQUFZO0FBQ2QiLCJmaWxlIjoicmVtaXgtdWktdGVybWluYWwuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiXG5lbGVtZW50LnN0eWxlIHtcbiBoZWlnaHQ6IDMyM3B4ICFpbXBvcnRhbnQ7XG59XG4jdGVybWluYWxDbGlJbnB1dHtcbiAgd2lkdGg6IDk3JTtcbiAgZm9udC13ZWlnaHQ6IDgwMDtcbiAgYmFja2dyb3VuZDogdmFyKC0tYm9keS1iZylcbn1cbiN0ZXJtaW5hbENsaUlucHV0OmZvY3VzIHtcbiAgb3V0bGluZTogbm9uZTtcbn1cblxuLnJlbWl4X3VpX3Rlcm1pbmFsX3BhbmVsIHtcbiAgcG9zaXRpb24gICAgICAgICAgOiByZWxhdGl2ZTtcbiAgZGlzcGxheSAgICAgICAgICAgOiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbiAgICA6IGNvbHVtbjtcbiAgZm9udC1zaXplICAgICAgICAgOiAxMnB4O1xuICBtaW4taGVpZ2h0ICAgICAgICA6IDNlbTtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9iYXIge1xuICB6LWluZGV4ICAgICAgICAgICA6IDI7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfbWVudSB7XG4gIG1heC1oZWlnaHQgICAgICAgICAgIDogMzVweDtcbiAgbWluLWhlaWdodCAgICAgICAgICAgOiAzNXB4O1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX3RvZ2dsZVRlcm1pbmFsIHtcbiAgY3Vyc29yICAgICAgICAgICAgOiBwb2ludGVyO1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX3RvZ2dsZVRlcm1pbmFsOmhvdmVyIHtcbiAgY29sb3IgICAgICAgICAgICAgOiB2YXIoLS1zZWNvbmRhcnkpO1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX2NvbnRhaW5lciB7XG4gIG92ZXJmbG93LXkgICAgICAgICAgOiBhdXRvO1xuICBmb250LWZhbWlseSAgICAgICAgIDogbW9ub3NwYWNlO1xuICBiYWNrZ3JvdW5kLXJlcGVhdCAgIDogbm8tcmVwZWF0O1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uIDogY2VudGVyIDE1JTtcbiAgYmFja2dyb3VuZC1zaXplICAgICA6IGF1dG8gY2FsYyg3NSUgLSAgMS43ZW0pO1xufVxuXG4ucmVtaXhfdWlfdGVybWluYWxfam91cm5hbCB7XG4gIG1hcmdpbi10b3AgICAgICAgIDogYXV0bztcbiAgbWFyZ2luLWJvdHRvbSAgICAgOiAycmVtO1xuICBmb250LWZhbWlseSAgICAgICA6IG1vbm9zcGFjZTtcbiAgb3ZlcmZsb3cteSAgICAgICAgOiBzY3JvbGw7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfYmxvY2sge1xuICB3aGl0ZS1zcGFjZSAgICAgICA6IHByZS13cmFwO1xuICBmb250LWZhbWlseSAgICAgICA6IG1vbm9zcGFjZTtcbiAgbGluZS1oZWlnaHQgICAgICAgOiAyY2g7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfYmxvY2sgPiBwcmUge1xuICBtYXgtaGVpZ2h0ICAgICAgICA6IDIwMHB4O1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX3dlbGNvbWUge1xuICBmb250LXdlaWdodDogYm9sZDtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9jbGkge1xuICB3aGl0ZS1zcGFjZSAgICAgICA6IG5vd3JhcDtcbiAgbGluZS1oZWlnaHQgICAgICAgOiAxLjdlbTtcbiAgZm9udC1mYW1pbHkgICAgICAgOiBtb25vc3BhY2U7XG4gIHBhZGRpbmcgICAgICAgICAgIDogLjRlbTtcbiAgY29sb3IgICAgICAgICAgICAgOiB2YXIoLS1wcmltYXJ5KTtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9wcm9tcHQge1xuICBmb250LWZhbWlseSAgICAgICA6IG1vbm9zcGFjZTtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9pbnB1dCB7XG4gIG91dGxpbmUgICAgICAgICAgIDogbm9uZTtcbiAgZm9udC1mYW1pbHkgICAgICAgOiBtb25vc3BhY2U7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfc2VhcmNoIHtcbiAgd2lkdGggICAgICAgICAgICAgOiAzMzBweDtcbiAgcGFkZGluZy1sZWZ0ICAgICAgOiAyMHB4O1xuICBwYWRkaW5nLXRvcCAgICAgICA6IDFweDtcbiAgcGFkZGluZy1ib3R0b20gICAgOiAxcHg7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfZmlsdGVyIHtcbiAgaGVpZ2h0ICAgICAgICAgICAgICAgICAgICAgIDogODAlO1xuICB3aGl0ZS1zcGFjZSAgICAgICAgICAgICAgICAgOiBub3dyYXA7XG4gIG92ZXJmbG93ICAgICAgICAgICAgICAgICAgICA6IGhpZGRlbjtcbiAgdGV4dC1vdmVyZmxvdyAgICAgICAgICAgICAgIDogZWxsaXBzaXM7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfc2VhcmNoSWNvbiB7XG4gIHdpZHRoICAgICAgICAgICAgICAgICAgICAgICA6IDI1cHg7XG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXMgICAgICA6IDNweDtcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyAgIDogM3B4O1xuICBtYXJnaW4tcmlnaHQgICAgICAgICAgICAgICAgOiA1cHg7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF9jb25zb2xlIHtcbiAgY3Vyc29yICAgICAgICAgICA6IHBvaW50ZXI7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF9saXN0ZW5Pbk5ldHdvcmsge1xuICBtaW4taGVpZ2h0OiBhdXRvO1xufVxuXG4ucmVtaXhfdWlfdGVybWluYWxfcG9wdXAge1xuICB3aWR0aCAgICAgICAgICAgIDogOTUlO1xuICBmb250LWZhbWlseSAgICAgIDogbW9ub3NwYWNlO1xuICBiYWNrZ3JvdW5kLWNvbG9yIDogdmFyKC0tc2Vjb25kYXJ5KTtcbiAgb3ZlcmZsb3cgICAgICAgICA6IGF1dG87XG4gIHotaW5kZXggICAgICAgICAgOiA4MDtcbiAgYm90dG9tICAgICAgICAgICA6IDIuMmVtO1xuICBib3JkZXItd2lkdGggICAgIDogNHB4O1xuICBvdmVyZmxvdy15ICAgICAgIDogc2Nyb2xsO1xuICBib3gtc2hhZG93ICAgICAgIDogMHB4IDBweCAxM3B4IC04cHg7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF9hdXRvQ29tcGxldGVJdGVtIHtcbiAgcGFkZGluZyAgICAgICAgICA6IDRweDtcbiAgYm9yZGVyLXJhZGl1cyAgICA6IDJweDtcbn1cblxuLnJlbWl4X3VpX3Rlcm1pbmFsX3BvcHVwIGEge1xuICBjdXJzb3IgICAgICAgICAgIDogcG9pbnRlcjtcbn1cblxuLmNhbGwge1xuICBmb250LXNpemU6IDdweDtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBtaW4td2lkdGg6IDIwcHg7XG4gIG1pbi1oZWlnaHQ6IDIwcHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBjb2xvcjogdmFyKC0tdGV4dC1pbmZvKTtcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF90eEl0ZW0ge1xuICBjb2xvcjogdmFyKC0tdGV4dC1pbmZvKTtcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XG4gIGZsb2F0OiBsZWZ0O1xufVxuXG4ucmVtaXhfdWlfdGVybWluYWxfdHhJdGVtVGl0bGUge1xuICBmb250LXdlaWdodDogYm9sZDtcbn1cblxuLyogdHggbG9nZ2VyIGNzcyovXG5cbi5yZW1peF91aV90ZXJtaW5hbF9sb2cge1xuICBkaXNwbGF5OiBmbGV4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9sb2c6aG92ZXIge1xuICBvcGFjaXR5OiAwLjg7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF90eFN0YXR1cyB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZvbnQtc2l6ZTogMjBweDtcbiAgbWFyZ2luLXJpZ2h0OiAyMHB4O1xuICBmbG9hdDogbGVmdDtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9zdWNjZWVkZWQge1xuICBjb2xvcjogdmFyKC0tc3VjY2Vzcyk7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfZmFpbGVkIHtcbiAgY29sb3I6IHZhcigtLWRhbmdlcik7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF9hcnJvdyB7XG4gIGNvbG9yOiB2YXIoLS10ZXh0LWluZm8pO1xuICBmb250LXNpemU6IDIwcHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogZmxleDtcbiAgbWFyZ2luLWxlZnQ6IDEwcHg7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfYXJyb3c6aG92ZXIge1xuICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5KTtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9jYWxsIHtcbiAgZm9udC1zaXplOiA3cHg7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgbWluLXdpZHRoOiAyMHB4O1xuICBtaW4taGVpZ2h0OiAyMHB4O1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgY29sb3I6IHZhcigtLXRleHQtaW5mbyk7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuXG4ucmVtaXhfdWlfdGVybWluYWxfdHgge1xuICBjb2xvcjogdmFyKC0tdGV4dC1pbmZvKTtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIGZsb2F0OiBsZWZ0O1xuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG59XG5cbi5yZW1peF91aV90ZXJtaW5hbF90cixcbi5yZW1peF91aV90ZXJtaW5hbF90ZCB7XG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG4gIGZvbnQtc2l6ZTogMTBweDtcbiAgY29sb3I6IHZhcigtLXRleHQtaW5mbyk7XG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRleHQtaW5mbyk7XG4gIHRyYW5zaXRpb246IG1heC1oZWlnaHQgMC4zcywgcGFkZGluZyAwLjNzO1xufVxudGFibGUgLmFjdGl2ZSB7XG4gIHRyYW5zaXRpb246IG1heC1oZWlnaHQgMC42cywgcGFkZGluZyAwLjZzO1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX3RyLCAucmVtaXhfdWlfdGVybWluYWxfdGQge1xuICBwYWRkaW5nOiA0cHg7XG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbn1cbi5yZW1peF91aV90ZXJtaW5hbF90ZDpmaXJzdC1jaGlsZCB7XG4gIG1pbi13aWR0aDogMzAlO1xuICB3aWR0aDogMzAlO1xuICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX3RhYmxlVGl0bGUge1xuICB3aWR0aDogMjUlO1xufVxuLnJlbWl4X3VpX3Rlcm1pbmFsX2J1dHRvbnMge1xuICBkaXNwbGF5OiBmbGV4O1xuICBtYXJnaW4tbGVmdDogYXV0bztcbn1cbi5yZW1peF91aV90ZXJtaW5hbF9kZWJ1ZyB7XG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XG59XG4ucmVtaXhfdWlfdGVybWluYWxfZGVidWc6aG92ZXIge1xuICBvcGFjaXR5OiAwLjg7XG59XG4iXX0= */", '', '']]

/***/ }),
/* 2867 */,
/* 2868 */,
/* 2869 */,
/* 2870 */,
/* 2871 */,
/* 2872 */,
/* 2873 */,
/* 2874 */,
/* 2875 */,
/* 2876 */,
/* 2877 */,
/* 2878 */,
/* 2879 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _ChechTxStatus = _interopRequireDefault(__webpack_require__(1395));

var _Context = _interopRequireDefault(__webpack_require__(1635));

var _Table = _interopRequireDefault(__webpack_require__(1396));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const RenderUnKnownTransactions = ({
  tx,
  receipt,
  index,
  plugin,
  showTableHash,
  txDetails,
  modal,
  provider
}) => {
  const debug = (event, tx) => {
    event.stopPropagation();

    if (tx.isCall && tx.envMode !== 'vm') {
      modal('VM mode', 'Cannot debug this call. Debugging calls is only possible in Remix VM mode.', 'Ok', true, () => {}, 'Cancel', () => {});
    } else {
      plugin.event.trigger('debuggingRequested', [tx.hash]);
    }
  };

  const from = tx.from;
  const to = tx.to;
  const txType = 'unknown' + (tx.isCall ? 'Call' : 'Tx');
  const options = {
    from,
    to,
    tx
  };
  return /*#__PURE__*/_react.default.createElement("span", {
    id: `tx${tx.hash}`,
    key: index
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_log",
    onClick: event => txDetails(event, tx)
  }, /*#__PURE__*/_react.default.createElement(_ChechTxStatus.default, {
    tx: receipt || tx,
    type: txType
  }), /*#__PURE__*/_react.default.createElement(_Context.default, {
    opts: options,
    provider: provider
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_buttons"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_debug btn btn-primary btn-sm",
    "data-shared": "txLoggerDebugButton",
    "data-id": `txLoggerDebugButton${tx.hash}`,
    onClick: event => debug(event, tx)
  }, "Debug")), /*#__PURE__*/_react.default.createElement("i", {
    className: `remix_ui_terminal_arrow fas ${showTableHash.includes(tx.hash) ? 'fa-angle-up' : 'fa-angle-down'}`
  })), showTableHash.includes(tx.hash) ? (0, _Table.default)({
    hash: tx.hash,
    status: receipt ? receipt.status : null,
    isCall: tx.isCall,
    contractAddress: tx.contractAddress,
    data: tx,
    from,
    to,
    gas: tx.gas,
    input: tx.input,
    'decoded output': ' - ',
    val: tx.value,
    transactionCost: tx.transactionCost,
    executionCost: tx.executionCost
  }, showTableHash) : null);
};

var _default = RenderUnKnownTransactions;
exports.default = _default;

/***/ }),
/* 2880 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _helper = __webpack_require__(1121);

var _ChechTxStatus = _interopRequireDefault(__webpack_require__(1395));

var _Table = _interopRequireDefault(__webpack_require__(1396));

var _remixLib = __webpack_require__(311);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
const typeConversion = _remixLib.execution.typeConversion;

const RenderCall = ({
  tx,
  resolvedData,
  logs,
  index,
  plugin,
  showTableHash,
  txDetails,
  modal
}) => {
  const to = resolvedData.contractName + '.' + resolvedData.fn;
  const from = tx.from ? tx.from : ' - ';
  const input = tx.input ? (0, _helper.shortenHexData)(tx.input) : '';
  const txType = 'call';

  const debug = (event, tx) => {
    event.stopPropagation();

    if (tx.isCall && tx.envMode !== 'vm') {
      modal('VM mode', 'Cannot debug this call. Debugging calls is only possible in Remix VM mode.', 'Ok', true, () => {}, 'Cancel', () => {});
    } else {
      plugin.event.trigger('debuggingRequested', [tx.hash]);
    }
  };

  return /*#__PURE__*/_react.default.createElement("span", {
    id: `tx${tx.hash}`,
    key: index
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_log",
    onClick: event => txDetails(event, tx)
  }, /*#__PURE__*/_react.default.createElement(_ChechTxStatus.default, {
    tx: tx,
    type: txType
  }), /*#__PURE__*/_react.default.createElement("span", null, /*#__PURE__*/_react.default.createElement("span", {
    className: "remix_ui_terminal_tx"
  }, "[call]"), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_txItem"
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "remix_ui_terminal_txItemTitle"
  }, "from:"), " ", from), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_txItem"
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "remix_ui_terminal_txItemTitle"
  }, "to:"), " ", to), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_txItem"
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "remix_ui_terminal_txItemTitle"
  }, "data:"), " ", input)), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_buttons"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_debug btn btn-primary btn-sm",
    onClick: event => debug(event, tx)
  }, "Debug")), /*#__PURE__*/_react.default.createElement("i", {
    className: `remix_ui_terminal_arrow fas ${showTableHash.includes(tx.hash) ? 'fa-angle-up' : 'fa-angle-down'}`
  })), showTableHash.includes(tx.hash) ? (0, _Table.default)({
    hash: tx.hash,
    isCall: tx.isCall,
    contractAddress: tx.contractAddress,
    data: tx,
    from,
    to,
    gas: tx.gas,
    input: tx.input,
    'decoded input': resolvedData && resolvedData.params ? JSON.stringify(typeConversion.stringify(resolvedData.params), null, '\t') : ' - ',
    'decoded output': resolvedData && resolvedData.decodedReturnValue ? JSON.stringify(typeConversion.stringify(resolvedData.decodedReturnValue), null, '\t') : ' - ',
    val: tx.value,
    logs: logs,
    transactionCost: tx.transactionCost,
    executionCost: tx.executionCost
  }, showTableHash) : null);
};

var _default = RenderCall;
exports.default = _default;

/***/ }),
/* 2881 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(__webpack_require__(29));

var _ChechTxStatus = _interopRequireDefault(__webpack_require__(1395));

var _Context = _interopRequireDefault(__webpack_require__(1635));

var _Table = _interopRequireDefault(__webpack_require__(1396));

var _remixLib = __webpack_require__(311);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
// eslint-disable-line
// eslint-disable-line
const typeConversion = _remixLib.execution.typeConversion;

const RenderKnownTransactions = ({
  tx,
  receipt,
  resolvedData,
  logs,
  index,
  plugin,
  showTableHash,
  txDetails,
  modal,
  provider
}) => {
  const debug = (event, tx) => {
    event.stopPropagation();

    if (tx.isCall && tx.envMode !== 'vm') {
      modal('VM mode', 'Cannot debug this call. Debugging calls is only possible in Remix VM mode.', 'Ok', true, () => {}, 'Cancel', () => {});
    } else {
      plugin.event.trigger('debuggingRequested', [tx.hash]);
    }
  };

  const from = tx.from;
  const to = resolvedData.contractName + '.' + resolvedData.fn;
  const txType = 'knownTx';
  const options = {
    from,
    to,
    tx,
    logs
  };
  return /*#__PURE__*/_react.default.createElement("span", {
    id: `tx${tx.hash}`,
    key: index
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_log",
    onClick: event => txDetails(event, tx)
  }, /*#__PURE__*/_react.default.createElement(_ChechTxStatus.default, {
    tx: receipt,
    type: txType
  }), /*#__PURE__*/_react.default.createElement(_Context.default, {
    opts: options,
    provider: provider
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_buttons"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "remix_ui_terminal_debug btn btn-primary btn-sm",
    "data-shared": "txLoggerDebugButton",
    "data-id": `txLoggerDebugButton${tx.hash}`,
    onClick: event => debug(event, tx)
  }, "Debug")), /*#__PURE__*/_react.default.createElement("i", {
    className: `remix_ui_terminal_arrow fas ${showTableHash.includes(tx.hash) ? 'fa-angle-up' : 'fa-angle-down'}`
  })), showTableHash.includes(tx.hash) ? (0, _Table.default)({
    hash: tx.hash,
    status: receipt !== null ? receipt.status : null,
    isCall: tx.isCall,
    contractAddress: tx.contractAddress,
    data: tx,
    from,
    to,
    gas: tx.gas,
    input: tx.input,
    'decoded input': resolvedData && resolvedData.params ? JSON.stringify(typeConversion.stringify(resolvedData.params), null, '\t') : ' - ',
    'decoded output': resolvedData && resolvedData.decodedReturnValue ? JSON.stringify(typeConversion.stringify(resolvedData.decodedReturnValue), null, '\t') : ' - ',
    logs: logs,
    val: tx.value,
    transactionCost: tx.transactionCost,
    executionCost: tx.executionCost
  }, showTableHash) : null);
};

var _default = RenderKnownTransactions;
exports.default = _default;

/***/ }),
/* 2882 */,
/* 2883 */,
/* 2884 */,
/* 2885 */,
/* 2886 */,
/* 2887 */,
/* 2888 */,
/* 2889 */,
/* 2890 */,
/* 2891 */,
/* 2892 */,
/* 2893 */,
/* 2894 */,
/* 2895 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapScript = void 0;

const wrapScript = script => {
  const isKnownScript = ['remix.', 'git'].some(prefix => script.trim().startsWith(prefix));
  if (isKnownScript) return script;
  return `
        try {
          const ret = ${script};
          if (ret instanceof Promise) {
            ret.then((result) => { console.log(result) }).catch((error) => { console.log(error) })
          } else {
            console.log(ret)
          }   
        } catch (e) {
          console.log(e.message)
        }
        `;
};

exports.wrapScript = wrapScript;

/***/ }),
/* 2896 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(30);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabProxy = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(109));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(1176));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(110));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(107));

var _createClass2 = _interopRequireDefault(__webpack_require__(216));

var _inherits2 = _interopRequireDefault(__webpack_require__(217));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(218));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(215));

var _react = _interopRequireDefault(__webpack_require__(29));

var _engine = __webpack_require__(477);

var _tabs = __webpack_require__(2897);

var _helper = __webpack_require__(1121);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var EventEmitter = __webpack_require__(40);

var profile = {
  name: 'tabs',
  methods: ['focus'],
  kind: 'other'
};

var TabProxy = /*#__PURE__*/function (_Plugin) {
  (0, _inherits2["default"])(TabProxy, _Plugin);

  var _super = _createSuper(TabProxy);

  function TabProxy(fileManager, editor) {
    var _this;

    (0, _classCallCheck2["default"])(this, TabProxy);
    _this = _super.call(this, profile);
    _this.event = new EventEmitter();
    _this.fileManager = fileManager;
    _this.editor = editor;
    _this.data = {};
    _this._view = {};
    _this._handlers = {};
    _this.loadedTabs = [];
    _this.dispatch = null;
    _this.themeQuality = 'dark';
    return _this;
  }

  (0, _createClass2["default"])(TabProxy, [{
    key: "onActivation",
    value: function () {
      var _onActivation = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.on('theme', 'themeChanged', function (theme) {
                  _this2.themeQuality = theme.quality; // update invert for all icons

                  _this2.renderComponent();
                });
                this.on('fileManager', 'filesAllClosed', function () {
                  _this2.call('manager', 'activatePlugin', 'home');

                  _this2.tabsApi.activateTab('home');
                });
                this.on('fileManager', 'fileRemoved', function (name) {
                  var workspace = _this2.fileManager.currentWorkspace();

                  if (_this2.fileManager.mode === 'browser') {
                    name = name.startsWith(workspace + '/') ? name : workspace + '/' + name; // If deleted file is not current file and not an active tab in editor,
                    // ensure current file is active in the editor

                    if (_this2.fileManager.currentFile() && name !== _this2.fileManager.currentFile()) {
                      var currentFile = _this2.fileManager.currentFile();

                      var currentFileTabPath = currentFile.startsWith(workspace + '/') ? currentFile : workspace + '/' + currentFile;

                      _this2.removeTab(name, {
                        name: currentFileTabPath
                      });
                    } else _this2.removeTab(name);
                  } else {
                    name = name.startsWith(_this2.fileManager.mode + '/') ? name : _this2.fileManager.mode + '/' + name;

                    _this2.removeTab(name);
                  }
                });
                this.on('fileManager', 'fileClosed', function (name) {
                  var workspace = _this2.fileManager.currentWorkspace();

                  if (_this2.fileManager.mode === 'browser') {
                    name = name.startsWith(workspace + '/') ? name : workspace + '/' + name;

                    var tabIndex = _this2.loadedTabs.findIndex(function (tab) {
                      return tab.name === name;
                    }); // If tab doesn't exist, check if tab is opened because of abrupt disconnection with remixd


                    if (tabIndex === -1) {
                      var nameArray = name.split('/');
                      nameArray.shift();
                      name = 'localhost' + '/' + nameArray.join('/');
                      tabIndex = _this2.loadedTabs.findIndex(function (tab) {
                        return tab.name === name;
                      });
                      if (tabIndex !== -1) _this2.removeTab(name);
                    } else _this2.removeTab(name);
                  } else {
                    name = name.startsWith(_this2.fileManager.mode + '/') ? name : _this2.fileManager.mode + '/' + name;

                    _this2.removeTab(name);
                  }
                });
                this.on('fileManager', 'currentFileChanged', function (file) {
                  var workspace = _this2.fileManager.currentWorkspace();

                  if (_this2.fileManager.mode === 'browser') {
                    var workspacePath = workspace + '/' + file;

                    if (_this2._handlers[workspacePath]) {
                      _this2.tabsApi.activateTab(workspacePath);

                      return;
                    }

                    _this2.addTab(workspacePath, '', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
                      return _regenerator["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 2;
                              return _this2.fileManager.open(file);

                            case 2:
                              _this2.event.emit('openFile', file);

                              _this2.emit('openFile', file);

                            case 4:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    })), /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
                      return _regenerator["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return _this2.fileManager.closeFile(file);

                            case 2:
                              _this2.event.emit('closeFile', file);

                              _this2.emit('closeFile', file);

                            case 4:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    })));

                    _this2.tabsApi.activateTab(workspacePath);
                  } else {
                    var path = file.startsWith(_this2.fileManager.mode + '/') ? file : _this2.fileManager.mode + '/' + file;

                    if (_this2._handlers[path]) {
                      _this2.tabsApi.activateTab(path);

                      return;
                    }

                    _this2.addTab(path, '', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
                      return _regenerator["default"].wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              _context3.next = 2;
                              return _this2.fileManager.open(file);

                            case 2:
                              _this2.event.emit('openFile', file);

                              _this2.emit('openFile', file);

                            case 4:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3);
                    })), /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
                      return _regenerator["default"].wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.next = 2;
                              return _this2.fileManager.closeFile(file);

                            case 2:
                              _this2.event.emit('closeFile', file);

                              _this2.emit('closeFile', file);

                            case 4:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    })));

                    _this2.tabsApi.activateTab(path);
                  }
                });
                this.on('fileManager', 'fileRenamed', function (oldName, newName, isFolder) {
                  var workspace = _this2.fileManager.currentWorkspace();

                  if (_this2.fileManager.mode === 'browser') {
                    if (isFolder) {
                      var _iterator = _createForOfIteratorHelper(_this2.loadedTabs),
                          _step;

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          var tab = _step.value;

                          if (tab.name.indexOf(workspace + '/' + oldName + '/') === 0) {
                            var newTabName = workspace + '/' + newName + tab.name.slice(workspace + '/' + oldName.length, tab.name.length);

                            _this2.renameTab(tab.name, newTabName);
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      return;
                    } // should change the tab title too


                    _this2.renameTab(workspace + '/' + oldName, workspace + '/' + newName);
                  } else {
                    if (isFolder) {
                      var _iterator2 = _createForOfIteratorHelper(_this2.loadedTabs),
                          _step2;

                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          var _tab = _step2.value;

                          if (_tab.name.indexOf(_this2.fileManager.mode + '/' + oldName + '/') === 0) {
                            var _newTabName = _this2.fileManager.mode + '/' + newName + _tab.name.slice(_this2.fileManager.mode + '/' + oldName.length, _tab.name.length);

                            _this2.renameTab(_tab.name, _newTabName);
                          }
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }

                      return;
                    } // should change the tab title too


                    _this2.renameTab(_this2.fileManager.mode + '/' + oldName, _this2.fileManager.mode + '/' + newName);
                  }
                });
                this.on('manager', 'pluginActivated', function (_ref5) {
                  var name = _ref5.name,
                      location = _ref5.location,
                      displayName = _ref5.displayName,
                      icon = _ref5.icon;

                  if (location === 'mainPanel') {
                    _this2.addTab(name, displayName, function () {
                      return _this2.emit('switchApp', name);
                    }, function () {
                      if (name === 'home' && _this2.loadedTabs.length === 1 && _this2.loadedTabs[0].id === "home") {
                        var files = Object.keys(_this2.editor.sessions);
                        files.forEach(function (filepath) {
                          return _this2.editor.discard(filepath);
                        });
                      }

                      _this2.emit('closeApp', name);

                      _this2.call('manager', 'deactivatePlugin', name);
                    }, icon);

                    _this2.switchTab(name);
                  }
                });
                this.on('manager', 'pluginDeactivated', function (profile) {
                  _this2.removeTab(profile.name);
                });
                _context5.prev = 8;
                _context5.next = 11;
                return this.call('theme', 'currentTheme');

              case 11:
                this.themeQuality = _context5.sent.quality;
                _context5.next = 17;
                break;

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](8);
                console.log('theme plugin has an issue: ', _context5.t0);

              case 17:
                this.renderComponent();

              case 18:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[8, 14]]);
      }));

      function onActivation() {
        return _onActivation.apply(this, arguments);
      }

      return onActivation;
    }()
  }, {
    key: "focus",
    value: function focus(name) {
      this.emit('switchApp', name);
      this.tabsApi.activateTab(name);
    }
  }, {
    key: "switchTab",
    value: function switchTab(tabName) {
      if (this._handlers[tabName]) {
        this._handlers[tabName].switchTo();

        this.tabsApi.activateTab(tabName);
      }
    }
  }, {
    key: "switchNextTab",
    value: function switchNextTab() {
      var active = this.tabsApi.active();

      if (active && this._handlers[active]) {
        var handlers = Object.keys(this._handlers);
        var i = handlers.indexOf(active);

        if (i >= 0) {
          i = handlers[i + 1] ? i + 1 : 0;
          this.switchTab(handlers[i]);
        }
      }
    }
  }, {
    key: "switchPreviousTab",
    value: function switchPreviousTab() {
      var active = this.tabsApi.active();

      if (active && this._handlers[active]) {
        var handlers = Object.keys(this._handlers);
        var i = handlers.indexOf(active);

        if (i >= 0) {
          i = handlers[i - 1] ? i - 1 : handlers.length - 1;
          this.switchTab(handlers[i]);
        }
      }
    }
  }, {
    key: "renameTab",
    value: function renameTab(oldName, newName) {
      // The new tab is being added by FileManager
      this.removeTab(oldName);
    }
  }, {
    key: "addTab",
    value: function addTab(name, title, switchTo, close, icon) {
      var _this3 = this;

      if (this._handlers[name]) return this.renderComponent();
      var slash = name.split('/');
      var tabPath = slash.reverse();
      var tempTitle = [];

      if (!title) {
        var _loop = function _loop(i) {
          tempTitle.push(tabPath[i]);
          var formatPath = [].concat(tempTitle).reverse();

          var index = _this3.loadedTabs.findIndex(function (_ref6) {
            var title = _ref6.title;
            return title === formatPath.join('/');
          });

          if (index === -1) {
            title = formatPath.join('/');
            var titleLength = formatPath.length;

            _this3.loadedTabs.push({
              id: name,
              name: name,
              title: title,
              icon: icon,
              tooltip: name,
              iconClass: (0, _helper.getPathIcon)(name)
            });

            formatPath.shift();

            if (formatPath.length > 0) {
              var _index = _this3.loadedTabs.findIndex(function (_ref7) {
                var title = _ref7.title;
                return title === formatPath.join('/');
              });

              if (_index > -1) {
                var duplicateTabName = _this3.loadedTabs[_index].name;
                var duplicateTabPath = duplicateTabName.split('/');
                var duplicateTabFormatPath = (0, _toConsumableArray2["default"])(duplicateTabPath).reverse();
                var duplicateTabTitle = duplicateTabFormatPath.slice(0, titleLength).reverse().join('/');
                _this3.loadedTabs[_index] = {
                  id: duplicateTabName,
                  name: duplicateTabName,
                  title: duplicateTabTitle,
                  icon: icon,
                  tooltip: duplicateTabName,
                  iconClass: (0, _helper.getPathIcon)(duplicateTabName)
                };
              }
            }

            return "break";
          }
        };

        for (var i = 0; i < tabPath.length; i++) {
          var _ret = _loop(i);

          if (_ret === "break") break;
        }
      } else {
        this.loadedTabs.push({
          id: name,
          name: name,
          title: title,
          icon: icon,
          tooltip: name,
          iconClass: (0, _helper.getPathIcon)(name)
        });
      }

      this.renderComponent();
      this._handlers[name] = {
        switchTo: switchTo,
        close: close
      };
    }
  }, {
    key: "removeTab",
    value: function removeTab(name, currentFileTab) {
      var _this4 = this;

      delete this._handlers[name];
      var previous = currentFileTab;
      this.loadedTabs = this.loadedTabs.filter(function (tab, index) {
        if (!previous && tab.name === name) {
          if (index - 1 >= 0 && _this4.loadedTabs[index - 1]) previous = _this4.loadedTabs[index - 1];else if (index + 1 && _this4.loadedTabs[index + 1]) previous = _this4.loadedTabs[index + 1];
        }

        return tab.name !== name;
      });
      this.renderComponent();
      if (previous) this.switchTab(previous.name);
    }
  }, {
    key: "addHandler",
    value: function addHandler(type, fn) {
      this.handlers[type] = fn;
    }
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      this.dispatch = dispatch;
      this.renderComponent();
    }
  }, {
    key: "updateComponent",
    value: function updateComponent(state) {
      return /*#__PURE__*/_react["default"].createElement(_tabs.TabsUI, {
        tabs: state.loadedTabs,
        onSelect: state.onSelect,
        onClose: state.onClose,
        onZoomIn: state.onZoomIn,
        onZoomOut: state.onZoomOut,
        onReady: state.onReady,
        themeQuality: state.themeQuality
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent() {
      var _this5 = this;

      var onSelect = function onSelect(index) {
        if (_this5.loadedTabs[index]) {
          var name = _this5.loadedTabs[index].name;
          if (_this5._handlers[name]) _this5._handlers[name].switchTo();

          _this5.emit('tabCountChanged', _this5.loadedTabs.length);
        }
      };

      var onClose = function onClose(index) {
        if (_this5.loadedTabs[index]) {
          var name = _this5.loadedTabs[index].name;
          if (_this5._handlers[name]) _this5._handlers[name].close();

          _this5.emit('tabCountChanged', _this5.loadedTabs.length);
        }
      };

      var onZoomIn = function onZoomIn() {
        return _this5.editor.editorFontSize(1);
      };

      var onZoomOut = function onZoomOut() {
        return _this5.editor.editorFontSize(-1);
      };

      var onReady = function onReady(api) {
        _this5.tabsApi = api;
      };

      this.dispatch({
        loadedTabs: this.loadedTabs,
        onSelect: onSelect,
        onClose: onClose,
        onZoomIn: onZoomIn,
        onZoomOut: onZoomOut,
        onReady: onReady,
        themeQuality: this.themeQuality
      });
    }
  }, {
    key: "renderTabsbar",
    value: function renderTabsbar() {
      return /*#__PURE__*/_react["default"].createElement("div", null, /*#__PURE__*/_react["default"].createElement(_helper.PluginViewWrapper, {
        plugin: this
      }));
    }
  }]);
  return TabProxy;
}(_engine.Plugin);

exports.TabProxy = TabProxy;

/***/ }),
/* 2897 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _remixUiTabs = __webpack_require__(2898);

Object.keys(_remixUiTabs).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _remixUiTabs[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remixUiTabs[key];
    }
  });
});

/***/ }),
/* 2898 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TabsUI = void 0;

var _react = _interopRequireWildcard(__webpack_require__(29));

var _reactTabs = __webpack_require__(2947);

__webpack_require__(2899);

var _jsxRuntime = __webpack_require__(46);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// eslint-disable-line
const TabsUI = props => {
  const [selectedIndex, setSelectedIndex] = (0, _react.useState)(-1);
  const currentIndexRef = (0, _react.useRef)(-1);
  const tabsRef = (0, _react.useRef)({});
  const tabsElement = (0, _react.useRef)(null);
  const tabs = (0, _react.useRef)(props.tabs);
  tabs.current = props.tabs; // we do this to pass the tabs list to the onReady callbacks

  (0, _react.useEffect)(() => {
    if (props.tabs[selectedIndex]) {
      tabsRef.current[selectedIndex].scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });
    }
  }, [selectedIndex]);

  const renderTab = (tab, index) => {
    const classNameImg = 'my-1 mr-1 text-dark ' + tab.iconClass;
    const classNameTab = 'nav-item nav-link d-flex justify-content-center align-items-center px-2 py-1 tab' + (index === currentIndexRef.current ? ' active' : '');
    const invert = props.themeQuality === 'dark' ? 'invert(1)' : 'invert(0)';
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      ref: el => {
        tabsRef.current[index] = el;
      },
      className: classNameTab,
      "data-id": index === currentIndexRef.current ? 'tab-active' : '',
      title: tab.tooltip,
      children: [tab.icon ? /*#__PURE__*/(0, _jsxRuntime.jsx)("img", {
        className: "my-1 mr-1 iconImage",
        style: {
          filter: invert
        },
        src: tab.icon
      }) : /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
        className: classNameImg
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "title-tabs",
        children: tab.title
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
        className: "close-tabs",
        onClick: event => {
          props.onClose(index);
          event.stopPropagation();
        },
        children: /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
          className: "text-dark fas fa-times"
        })
      })]
    });
  };

  const active = () => {
    if (currentIndexRef.current < 0) return '';
    return tabs.current[currentIndexRef.current].name;
  };

  const activateTab = name => {
    const index = tabs.current.findIndex(tab => tab.name === name);
    currentIndexRef.current = index;
    setSelectedIndex(index);
  };

  const transformScroll = event => {
    if (!event.deltaY) {
      return;
    }

    event.currentTarget.scrollLeft += event.deltaY + event.deltaX;
    event.preventDefault();
  };

  (0, _react.useEffect)(() => {
    props.onReady({
      activateTab,
      active
    });
    return () => {
      tabsElement.current.removeEventListener('wheel', transformScroll);
    };
  }, []);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
    className: "remix-ui-tabs d-flex justify-content-between border-0 header nav-tabs",
    "data-id": "tabs-component",
    children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
      className: "d-flex flex-row",
      style: {
        maxWidth: 'fit-content',
        width: '97%'
      },
      children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
        className: "d-flex flex-row justify-content-center align-items-center m-1 mt-2",
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          "data-id": "tabProxyZoomOut",
          className: "btn btn-sm px-2 fas fa-search-minus text-dark",
          title: "Zoom out",
          onClick: () => props.onZoomOut()
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)("span", {
          "data-id": "tabProxyZoomIn",
          className: "btn btn-sm px-2 fas fa-search-plus text-dark",
          title: "Zoom in",
          onClick: () => props.onZoomIn()
        })]
      }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactTabs.Tabs, {
        className: "tab-scroll",
        selectedIndex: selectedIndex,
        domRef: domEl => {
          if (tabsElement.current) return;
          tabsElement.current = domEl;
          tabsElement.current.addEventListener('wheel', transformScroll);
        },
        onSelect: index => {
          props.onSelect(index);
          currentIndexRef.current = index;
          setSelectedIndex(index);
        },
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactTabs.TabList, {
          className: "d-flex flex-row align-items-center",
          children: props.tabs.map((tab, i) => /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactTabs.Tab, {
            className: "py-1",
            children: renderTab(tab, i)
          }, tab.name))
        }), props.tabs.map(tab => /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactTabs.TabPanel, {}, tab.name))]
      })]
    }), /*#__PURE__*/(0, _jsxRuntime.jsx)("i", {
      className: "mt-2 mr-2 fas fa-arrows-alt-h",
      title: "Scroll to see all tabs"
    })]
  });
};

exports.TabsUI = TabsUI;
var _default = TabsUI;
exports.default = _default;

/***/ }),
/* 2899 */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(2900);

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(68)(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),
/* 2900 */
/***/ (function(module, exports) {

module.exports = [[module.i, ".remix-ui-tabs {\n    display: -webkit-box; \n    max-height: 2.15rem;\n}\n.remix-ui-tabs li {\n    display: inline-block;\n}\n.title-tabs {\n    padding: inherit;\n    align-items: center;\n    padding-right: 8px;\n    padding-left: 2px;\n    cursor: default;\n    /*to make it unselectable*/\n    -webkit-touch-callout: none; /* iOS Safari */\n    -webkit-user-select: none;   /* Chrome/Safari/Opera */    /* Konqueror */\n    -moz-user-select: none;      /* Firefox */\n    -ms-user-select: none;       /* Internet Explorer/Edge */\n    user-select: none;           /* Non-prefixed version, currently supported by any browser but < IE9 */\n    vertical-align: middle;\n}\n.tab:hover .close-tabs{\n    visibility: visible\n}\n.active .close-tabs {\n    visibility: visible\n}\n.close-tabs {\n    visibility: hidden;\n    font-size: medium;\n}\n.iconImage {\n    width: 1rem;\n    height: 1rem;\n}\n.active {\n    border: 1px solid transparent;\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n}\n.tab-scroll {\n    overflow-x: auto;\n    overflow-y: hidden;\n    white-space: nowrap;\n}\n/* Hide scrollbar for Chrome, Safari and Opera */\n.tab-scroll::-webkit-scrollbar {\n    display: none;\n}\n/* Hide scrollbar for IE, Edge and Firefox */\n.tab-scroll {\n    -ms-overflow-style: none;  /* IE and Edge */\n    scrollbar-width: none;  /* Firefox */\n}\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlbWl4LXVpLXRhYnMuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksb0JBQW9CO0lBQ3BCLG1CQUFtQjtBQUN2QjtBQUNBO0lBQ0kscUJBQXFCO0FBQ3pCO0FBQ0E7SUFDSSxnQkFBZ0I7SUFDaEIsbUJBQW1CO0lBQ25CLGtCQUFrQjtJQUNsQixpQkFBaUI7SUFDakIsZUFBZTtJQUNmLDBCQUEwQjtJQUMxQiwyQkFBMkIsRUFBRSxlQUFlO0lBQzVDLHlCQUF5QixJQUFJLHdCQUF3QixLQUN4QixjQUFjO0lBQzNDLHNCQUFzQixPQUFPLFlBQVk7SUFDekMscUJBQXFCLFFBQVEsMkJBQTJCO0lBQ3hELGlCQUFpQixZQUFZLHVFQUF1RTtJQUNwRyxzQkFBc0I7QUFDMUI7QUFDQTtJQUNJO0FBQ0o7QUFDQTtJQUNJO0FBQ0o7QUFDQTtJQUNJLGtCQUFrQjtJQUNsQixpQkFBaUI7QUFDckI7QUFDQTtJQUNJLFdBQVc7SUFDWCxZQUFZO0FBQ2hCO0FBQ0E7SUFDSSw2QkFBNkI7SUFDN0IsMkJBQTJCO0lBQzNCLDRCQUE0QjtBQUNoQztBQUNBO0lBQ0ksZ0JBQWdCO0lBQ2hCLGtCQUFrQjtJQUNsQixtQkFBbUI7QUFDdkI7QUFFQSxnREFBZ0Q7QUFDaEQ7SUFDSSxhQUFhO0FBQ2pCO0FBRUUsNENBQTRDO0FBQzlDO0lBQ0ksd0JBQXdCLEdBQUcsZ0JBQWdCO0lBQzNDLHFCQUFxQixHQUFHLFlBQVk7QUFDeEMiLCJmaWxlIjoicmVtaXgtdWktdGFicy5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIucmVtaXgtdWktdGFicyB7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7IFxuICAgIG1heC1oZWlnaHQ6IDIuMTVyZW07XG59XG4ucmVtaXgtdWktdGFicyBsaSB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xufVxuLnRpdGxlLXRhYnMge1xuICAgIHBhZGRpbmc6IGluaGVyaXQ7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgIC8qdG8gbWFrZSBpdCB1bnNlbGVjdGFibGUqL1xuICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7ICAgLyogQ2hyb21lL1NhZmFyaS9PcGVyYSAqL1xuICAgIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTsgICAgLyogS29ucXVlcm9yICovXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgICAgICAvKiBGaXJlZm94ICovXG4gICAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAgICAgICAvKiBJbnRlcm5ldCBFeHBsb3Jlci9FZGdlICovXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7ICAgICAgICAgICAvKiBOb24tcHJlZml4ZWQgdmVyc2lvbiwgY3VycmVudGx5IHN1cHBvcnRlZCBieSBhbnkgYnJvd3NlciBidXQgPCBJRTkgKi9cbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xufVxuLnRhYjpob3ZlciAuY2xvc2UtdGFic3tcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlXG59XG4uYWN0aXZlIC5jbG9zZS10YWJzIHtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlXG59XG4uY2xvc2UtdGFicyB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAgIGZvbnQtc2l6ZTogbWVkaXVtO1xufVxuLmljb25JbWFnZSB7XG4gICAgd2lkdGg6IDFyZW07XG4gICAgaGVpZ2h0OiAxcmVtO1xufVxuLmFjdGl2ZSB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAycHg7XG59XG4udGFiLXNjcm9sbCB7XG4gICAgb3ZlcmZsb3cteDogYXV0bztcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbn1cblxuLyogSGlkZSBzY3JvbGxiYXIgZm9yIENocm9tZSwgU2FmYXJpIGFuZCBPcGVyYSAqL1xuLnRhYi1zY3JvbGw6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgICBkaXNwbGF5OiBub25lO1xufVxuICBcbiAgLyogSGlkZSBzY3JvbGxiYXIgZm9yIElFLCBFZGdlIGFuZCBGaXJlZm94ICovXG4udGFiLXNjcm9sbCB7XG4gICAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAgLyogSUUgYW5kIEVkZ2UgKi9cbiAgICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7ICAvKiBGaXJlZm94ICovXG59XG4iXX0= */", '', '']]

/***/ })
])]);
//# sourceMappingURL=app.0.25.3.1660689740068.js.map
//# sourceMappingURL=app.0.25.3.1660689740068.js.map