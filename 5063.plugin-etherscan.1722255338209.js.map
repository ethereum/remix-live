{"version":3,"file":"5063.plugin-etherscan.1722255338209.js","mappings":";;;;;;;;;;AAAA,iEAAe,qBAAqB,mDAAmD,6CAA6C,+CAA+C,oDAAoD,8CAA8C,wBAAwB,oCAAoC,uCAAuC,2BAA2B,6BAA6B,oCAAoC,oCAAoC,sBAAsB,WAAW,MAAM,kDAAkD,kNAAkN,uEAAuE,OAAO,oCAAoC,GAAG,yCAAyC,mCAAmC,+BAA+B,yBAAyB,gFAAgF,yEAAyE,uBAAuB,GAAG,CAAC","sources":["webpack:///../../libs/remix-ws-templates/src/templates/rln/circuits/utils.circom"],"sourcesContent":["export default \"pragma circom 2.1.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\ninclude \\\"circomlib/circuits/mux1.circom\\\";\\ninclude \\\"circomlib/circuits/bitify.circom\\\";\\ninclude \\\"circomlib/circuits/comparators.circom\\\";\\n\\ntemplate MerkleTreeInclusionProof(DEPTH) {\\n    signal input leaf;\\n    signal input pathIndex[DEPTH];\\n    signal input pathElements[DEPTH];\\n\\n    signal output root;\\n\\n    signal mux[DEPTH][2];\\n    signal levelHashes[DEPTH + 1];\\n    \\n    levelHashes[0] <== leaf;\\n    for (var i = 0; i < DEPTH; i++) {\\n        pathIndex[i] * (pathIndex[i] - 1) === 0;\\n\\n        mux[i] <== MultiMux1(2)(\\n            [\\n                [levelHashes[i], pathElements[i]], \\n                [pathElements[i], levelHashes[i]]\\n            ], \\n            pathIndex[i]\\n        );\\n\\n        levelHashes[i + 1] <== Poseidon(2)([mux[i][0], mux[i][1]]);\\n    }\\n\\n    root <== levelHashes[DEPTH];\\n}\\n\\ntemplate RangeCheck(LIMIT_BIT_SIZE) {\\n    assert(LIMIT_BIT_SIZE < 253);\\n\\n    signal input messageId;\\n    signal input limit;\\n\\n    signal bitCheck[LIMIT_BIT_SIZE] <== Num2Bits(LIMIT_BIT_SIZE)(messageId);\\n    signal rangeCheck <== LessThan(LIMIT_BIT_SIZE)([messageId, limit]);\\n    rangeCheck === 1;\\n}\";"],"names":[],"sourceRoot":""}