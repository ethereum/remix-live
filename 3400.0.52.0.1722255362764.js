"use strict";(self["webpackChunk"]=self["webpackChunk"]||[]).push([[3400],{53400:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__);__webpack_require__.d(__webpack_exports__,{default:()=>__WEBPACK_DEFAULT_EXPORT__});const __WEBPACK_DEFAULT_EXPORT__="import { ethers, BigNumber } from 'ethers'\nimport { IncrementalMerkleTree } from \"@zk-kit/incremental-merkle-tree\"\nimport { poseidon } from \"circomlibjs\" // v0.0.8\n\nimport { ZqField } from 'ffjavascript'\nconst SNARK_FIELD_SIZE = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617')\n\n// Creates the finite field\nconst Fq = new ZqField(SNARK_FIELD_SIZE)\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst snarkjs = require('snarkjs');\n\nconst logger = {\n  info: (...args) => console.log(...args),\n  debug: (...args) => console.log(...args),\n  error: (...args) => console.error(...args),\n}\n\n/**\n * Recovers secret from two shares\n * @param x1 signal hash of first message\n * @param x2 signal hash of second message\n * @param y1 yshare of first message\n * @param y2 yshare of second message\n * @returns identity secret\n */\nfunction shamirRecovery(x1: bigint, x2: bigint, y1: bigint, y2: bigint): bigint {\n  const slope = Fq.div(Fq.sub(y2, y1), Fq.sub(x2, x1))\n  const privateKey = Fq.sub(y1, Fq.mul(slope, x1))\n\n  return Fq.normalize(privateKey)\n}\n\nfunction hash(message: any): bigint {\n  message = BigNumber.from(message).toTwos(256).toHexString()\n  message = ethers.utils.zeroPad(message, 32)\n  return BigInt(ethers.utils.keccak256(message)) >> BigInt(8)\n}\n\nfunction hashNullifier(message: any): bigint {\n  return BigInt(ethers.utils.keccak256(message)) >> BigInt(8)\n}\n\nasync function prove (signals, wasm, wtns, r1cs, zkey_final, vKey) {\n  console.log('calculate')\n  await snarkjs.wtns.calculate(signals, wasm, wtns);\n\n  console.log('check')\n  await snarkjs.wtns.check(r1cs, wtns, logger);\n\n  console.log('prove')\n  const { proof, publicSignals } = await snarkjs.groth16.prove(zkey_final, wtns);\n\n  const verified = await snarkjs.groth16.verify(vKey, publicSignals, proof, logger);\n  console.log('zk proof validity', verified);\n\n  await remix.call('fileManager', 'writeFile', `scripts/groth16/zk/build/input-${Date.now()}.json`, JSON.stringify({\n    _pA: [proof.pi_a[0], proof.pi_a[1]],\n    _pB: [[proof.pi_b[0][1], proof.pi_b[0][0]], [proof.pi_b[1][1], proof.pi_b[1][0]]],\n    _pC: [proof.pi_c[0], proof.pi_c[1]],\n    _pubSignals: publicSignals,\n  }, null, 2))\n\n  console.log('proof done.')\n  return {\n    proof,\n    x: publicSignals[3],\n    y: publicSignals[0]\n  }\n}\n\n(async () => {\n  try {\n    // @ts-ignore\n    const r1csBuffer = await remix.call('fileManager', 'readFile', 'circuits/.bin/rln.r1cs', { encoding: null });\n    // @ts-ignore\n    const r1cs = new Uint8Array(r1csBuffer);\n    // @ts-ignore\n    await remix.call('circuit-compiler', 'compile', 'circuits/rln.circom');\n    // @ts-ignore\n    const wasmBuffer = await remix.call('fileManager', 'readFile', 'circuits/.bin/rln.wasm', { encoding: null });\n    // @ts-ignore\n    const wasm = new Uint8Array(wasmBuffer);\n\n    const zkey_final = {\n      type: \"mem\",\n      data: new Uint8Array(await remix.call('fileManager', 'readFile', 'scripts/groth16/zk/keys/zkey_final.txt', { encoding: null }))\n    }\n    const wtns = { type: \"mem\" };\n\n    const vKey = JSON.parse(await remix.call('fileManager', 'readFile', 'scripts/groth16/zk/keys/verification_key.json'))\n\n    // build list of identity commitments\n    const secrets = []\n    const identityCommitments = []\n    const rateCommitments = []\n    const userMessageLimit = 0x2\n    for (let k = 0; k < 2; k++) {\n      const identitySecret = BigInt(ethers.utils.hexlify(ethers.utils.randomBytes(32)))\n      secrets.push(identitySecret)\n\n      const identityCommitment = poseidon([identitySecret])\n      const rateCommitment = poseidon([identityCommitment, userMessageLimit])\n      identityCommitments.push(identityCommitment)\n      rateCommitments.push(rateCommitment)\n    }\n\n    let tree\n\n    try {\n      tree = new IncrementalMerkleTree(poseidon, 20, BigInt(0), 2, rateCommitments) // Binary tree.\n    } catch (e) {\n      console.error(e.message)\n      return\n    }\n\n    const merkleproof1 = tree.createProof(0)\n\n    const appId = 0xa\n    const epoch = 0x1\n\n    const signals1 = {\n      identitySecret: secrets[0],\n      userMessageLimit,\n      messageId: 0x0,\n      pathElements: merkleproof1.siblings,\n      identityPathIndex: merkleproof1.pathIndices,\n      x: 0xabcd, // hash(message)\n      externalNullifier: 0xa // hash(epoch, appId)\n    }\n    const proof1 = await prove(signals1, wasm, wtns, r1cs, zkey_final, vKey)\n\n    const signals2 = {\n      identitySecret: secrets[0],\n      userMessageLimit,\n      messageId: 0x0,\n      pathElements: merkleproof1.siblings,\n      identityPathIndex: merkleproof1.pathIndices,\n      x: 0xabce, // hash(message)\n      externalNullifier: 0xa // hash(epoch, appId)\n    }\n    const proof2 = await prove(signals2, wasm, wtns, r1cs, zkey_final, vKey)\n\n    const secret = shamirRecovery(BigInt(proof1.x), BigInt(proof2.x), BigInt(proof1.y), BigInt(proof2.y))\n\n    console.log(secret.toString(10))\n    console.log(Fq.normalize(secrets[0]))\n\n    const templates = {\n      groth16: await remix.call('fileManager', 'readFile', 'templates/groth16_verifier.sol.ejs')\n    }\n    const solidityContract = await snarkjs.zKey.exportSolidityVerifier(zkey_final, templates)\n\n    await remix.call('fileManager', 'writeFile', 'scripts/groth16/zk/build/zk_verifier.sol', solidityContract)\n  } catch (e) {\n    console.error(e.message)\n  }\n})()\n"}}]);
//# sourceMappingURL=3400.0.52.0.1722255362764.js.map